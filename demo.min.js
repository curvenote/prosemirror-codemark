/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/orderedmap/index.es.js":
/*!*********************************************!*\
  !*** ./node_modules/orderedmap/index.es.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap(content) {
  this.content = content;
}

OrderedMap.prototype = {
  constructor: OrderedMap,

  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i
    return -1
  },

  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found = this.find(key);
    return found == -1 ? undefined : this.content[found + 1]
  },

  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found = self.find(key), content = self.content.slice();
    if (found == -1) {
      content.push(newKey || key, value);
    } else {
      content[found + 1] = value;
      if (newKey) content[found] = newKey;
    }
    return new OrderedMap(content)
  },

  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found = this.find(key);
    if (found == -1) return this
    var content = this.content.slice();
    content.splice(found, 2);
    return new OrderedMap(content)
  },

  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content))
  },

  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content)
  },

  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found = without.find(place);
    content.splice(found == -1 ? content.length : found, 0, key, value);
    return new OrderedMap(content)
  },

  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(map.content.concat(this.subtract(map).content))
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(this.subtract(map).content.concat(map.content))
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i = 0; i < map.content.length; i += 2)
      result = result.remove(map.content[i]);
    return result
  },

  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1
  }
};

// :: (?union<Object, OrderedMap>) → OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content)
};

var orderedmap = OrderedMap;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (orderedmap);


/***/ }),

/***/ "./node_modules/prosemirror-commands/dist/index.es.js":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.es.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "baseKeymap": () => (/* binding */ baseKeymap),
/* harmony export */   "chainCommands": () => (/* binding */ chainCommands),
/* harmony export */   "exitCode": () => (/* binding */ exitCode),
/* harmony export */   "joinDown": () => (/* binding */ joinDown),
/* harmony export */   "joinUp": () => (/* binding */ joinUp),
/* harmony export */   "lift": () => (/* binding */ lift),
/* harmony export */   "selectParentNode": () => (/* binding */ selectParentNode),
/* harmony export */   "setBlockType": () => (/* binding */ setBlockType),
/* harmony export */   "toggleMark": () => (/* binding */ toggleMark),
/* harmony export */   "wrapIn": () => (/* binding */ wrapIn)
/* harmony export */ });
/* unused harmony exports autoJoin, createParagraphNear, deleteSelection, joinBackward, joinForward, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, splitBlock, splitBlockKeepMarks */
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");




// :: (EditorState, ?(tr: Transaction)) → bool
// Delete the selection, if there is one.
function deleteSelection(state, dispatch) {
  if (state.selection.empty) { return false }
  if (dispatch) { dispatch(state.tr.deleteSelection().scrollIntoView()); }
  return true
}

// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
// If the selection is empty and at the start of a textblock, try to
// reduce the distance between that block and the one before it—if
// there's a block directly before it that can be joined, join them.
// If not, try to move the selected block closer to the next one in
// the document structure by lifting it out of its parent or moving it
// into a parent of the previous block. Will use the view for accurate
// (bidi-aware) start-of-textblock detection if given.
function joinBackward(state, dispatch, view) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state)
                        : $cursor.parentOffset > 0))
    { return false }

  var $cut = findCutBefore($cursor);

  // If there is no node before this, try to lift
  if (!$cut) {
    var range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
    if (target == null) { return false }
    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
    return true
  }

  var before = $cut.nodeBefore;
  // Apply the joining algorithm
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
    { return true }

  // If the node below has no content and the node above is
  // selectable, delete the node below and select the one above.
  if ($cursor.parent.content.size == 0 &&
      (textblockAt(before, "end") || prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(before))) {
    if (dispatch) {
      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
      tr.setSelection(textblockAt(before, "end") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)
                      : prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
      dispatch(tr.scrollIntoView());
    }
    return true
  }

  // If the node before is an atom, delete it
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) { dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView()); }
    return true
  }

  return false
}

function textblockAt(node, side, only) {
  for (; node; node = (side == "start" ? node.firstChild : node.lastChild)) {
    if (node.isTextblock) { return true }
    if (only && node.childCount != 1) { return false }
  }
  return false
}

// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
// When the selection is empty and at the start of a textblock, select
// the node before that textblock, if possible. This is intended to be
// bound to keys like backspace, after
// [`joinBackward`](#commands.joinBackward) or other deleting
// commands, as a fall-back behavior when the schema doesn't allow
// deletion at the selected point.
function selectNodeBackward(state, dispatch, view) {
  var ref = state.selection;
  var $head = ref.$head;
  var empty = ref.empty;
  var $cut = $head;
  if (!empty) { return false }

  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) { return false }
    $cut = findCutBefore($head);
  }
  var node = $cut && $cut.nodeBefore;
  if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(node)) { return false }
  if (dispatch)
    { dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView()); }
  return true
}

function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {
    if ($pos.index(i) > 0) { return $pos.doc.resolve($pos.before(i + 1)) }
    if ($pos.node(i).type.spec.isolating) { break }
  } }
  return null
}

// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
// If the selection is empty and the cursor is at the end of a
// textblock, try to reduce or remove the boundary between that block
// and the one after it, either by joining them or by moving the other
// block closer to this one in the tree structure. Will use the view
// for accurate start-of-textblock detection if given.
function joinForward(state, dispatch, view) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state)
                        : $cursor.parentOffset < $cursor.parent.content.size))
    { return false }

  var $cut = findCutAfter($cursor);

  // If there is no node after this, there's nothing to do
  if (!$cut) { return false }

  var after = $cut.nodeAfter;
  // Try the joining algorithm
  if (deleteBarrier(state, $cut, dispatch)) { return true }

  // If the node above has no content and the node below is
  // selectable, delete the node above and select the one below.
  if ($cursor.parent.content.size == 0 &&
      (textblockAt(after, "start") || prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(after))) {
    if (dispatch) {
      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
      tr.setSelection(textblockAt(after, "start") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)
                      : prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
      dispatch(tr.scrollIntoView());
    }
    return true
  }

  // If the next node is an atom, delete it
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) { dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView()); }
    return true
  }

  return false
}

// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
// When the selection is empty and at the end of a textblock, select
// the node coming after that textblock, if possible. This is intended
// to be bound to keys like delete, after
// [`joinForward`](#commands.joinForward) and similar deleting
// commands, to provide a fall-back behavior when the schema doesn't
// allow deletion at the selected point.
function selectNodeForward(state, dispatch, view) {
  var ref = state.selection;
  var $head = ref.$head;
  var empty = ref.empty;
  var $cut = $head;
  if (!empty) { return false }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      { return false }
    $cut = findCutAfter($head);
  }
  var node = $cut && $cut.nodeAfter;
  if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(node)) { return false }
  if (dispatch)
    { dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView()); }
  return true
}

function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {
    var parent = $pos.node(i);
    if ($pos.index(i) + 1 < parent.childCount) { return $pos.doc.resolve($pos.after(i + 1)) }
    if (parent.type.spec.isolating) { break }
  } }
  return null
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Join the selected block or, if there is a text selection, the
// closest ancestor block of the selection that can be joined, with
// the sibling above it.
function joinUp(state, dispatch) {
  var sel = state.selection, nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from)) { return false }
    point = sel.from;
  } else {
    point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);
    if (point == null) { return false }
  }
  if (dispatch) {
    var tr = state.tr.join(point);
    if (nodeSel) { tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize)); }
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Join the selected block, or the closest ancestor of the selection
// that can be joined, with the sibling after it.
function joinDown(state, dispatch) {
  var sel = state.selection, point;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection) {
    if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to)) { return false }
    point = sel.to;
  } else {
    point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);
    if (point == null) { return false }
  }
  if (dispatch)
    { dispatch(state.tr.join(point).scrollIntoView()); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Lift the selected block, or the closest ancestor block of the
// selection that can be lifted, out of its parent node.
function lift(state, dispatch) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  var range = $from.blockRange($to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
  if (target == null) { return false }
  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// If the selection is in a node whose type has a truthy
// [`code`](#model.NodeSpec.code) property in its spec, replace the
// selection with a newline character.
function newlineInCode(state, dispatch) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }
  if (dispatch) { dispatch(state.tr.insertText("\n").scrollIntoView()); }
  return true
}

function defaultBlockAt(match) {
  for (var i = 0; i < match.edgeCount; i++) {
    var ref = match.edge(i);
    var type = ref.type;
    if (type.isTextblock && !type.hasRequiredAttrs()) { return type }
  }
  return null
}

// :: (EditorState, ?(tr: Transaction)) → bool
// When the selection is in a node with a truthy
// [`code`](#model.NodeSpec.code) property in its spec, create a
// default block after the code block, and move the cursor there.
function exitCode(state, dispatch) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }
  var above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!above.canReplaceWith(after, after, type)) { return false }
  if (dispatch) {
    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// If a block node is selected, create an empty paragraph before (if
// it is its parent's first child) or after it.
function createParagraphNear(state, dispatch) {
  var sel = state.selection;
  var $from = sel.$from;
  var $to = sel.$to;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) { return false }
  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock) { return false }
  if (dispatch) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// If the cursor is in an empty textblock that can be lifted, lift the
// block.
function liftEmptyBlock(state, dispatch) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || $cursor.parent.content.size) { return false }
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before = $cursor.before();
    if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {
      if (dispatch) { dispatch(state.tr.split(before).scrollIntoView()); }
      return true
    }
  }
  var range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
  if (target == null) { return false }
  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Split the parent block of the selection. If the selection is a text
// selection, also delete its content.
function splitBlock(state, dispatch) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection && state.selection.node.isBlock) {
    if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos)) { return false }
    if (dispatch) { dispatch(state.tr.split($from.pos).scrollIntoView()); }
    return true
  }

  if (!$from.parent.isBlock) { return false }

  if (dispatch) {
    var atEnd = $to.parentOffset == $to.parent.content.size;
    var tr = state.tr;
    if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.AllSelection) { tr.deleteSelection(); }
    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    var types = atEnd && deflt ? [{type: deflt}] : null;
    var can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {
      types = [{type: deflt}];
      can = true;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
        var first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
          { tr.setNodeMarkup(tr.mapping.map($from.before()), deflt); }
      }
    }
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Acts like [`splitBlock`](#commands.splitBlock), but without
// resetting the set of active marks at the cursor.
function splitBlockKeepMarks(state, dispatch) {
  return splitBlock(state, dispatch && (function (tr) {
    var marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());
    if (marks) { tr.ensureMarks(marks); }
    dispatch(tr);
  }))
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Move the selection to the node wrapping the current selection, if
// any. (Will not select the document node.)
function selectParentNode(state, dispatch) {
  var ref = state.selection;
  var $from = ref.$from;
  var to = ref.to;
  var pos;
  var same = $from.sharedDepth(to);
  if (same == 0) { return false }
  pos = $from.before(same);
  if (dispatch) { dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(state.doc, pos))); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Select the whole document.
function selectAll(state, dispatch) {
  if (dispatch) { dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.AllSelection(state.doc))); }
  return true
}

function joinMaybeClear(state, $pos, dispatch) {
  var before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type)) { return false }
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch) { dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView()); }
    return true
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos)))
    { return false }
  if (dispatch)
    { dispatch(state.tr
             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))
             .join($pos.pos)
             .scrollIntoView()); }
  return true
}

function deleteBarrier(state, $cut, dispatch) {
  var before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  if (before.type.spec.isolating || after.type.spec.isolating) { return false }
  if (joinMaybeClear(state, $cut, dispatch)) { return true }

  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter &&
      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&
      match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      var end = $cut.pos + after.nodeSize, wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;
      for (var i = conn.length - 1; i >= 0; i--)
        { wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(conn[i].create(null, wrap)); }
      wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(before.copy(wrap));
      var tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(wrap, 1, 0), conn.length, true));
      var joinAt = end + 2 * conn.length;
      if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinAt)) { tr.join(joinAt); }
      dispatch(tr.scrollIntoView());
    }
    return true
  }

  var selAfter = prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.findFrom($cut, 1);
  var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
    return true
  }

  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    var at = before, wrap$1 = [];
    for (;;) {
      wrap$1.push(at);
      if (at.isTextblock) { break }
      at = at.lastChild;
    }
    var afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild) { afterDepth++; }
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        var end$1 = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;
        for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) { end$1 = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(wrap$1[i$1].copy(end$1)); }
        var tr$1 = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - wrap$1.length, $cut.pos + after.nodeSize,
                                                     $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth,
                                                     new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(end$1, wrap$1.length, 0), 0, true));
        dispatch(tr$1.scrollIntoView());
      }
      return true
    }
  }

  return false
}

// Parameterized commands

// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Wrap the selection in a node of the given type with the given
// attributes.
function wrapIn(nodeType, attrs) {
  return function(state, dispatch) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);
    if (!wrapping) { return false }
    if (dispatch) { dispatch(state.tr.wrap(range, wrapping).scrollIntoView()); }
    return true
  }
}

// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command that tries to set the selected textblocks to the
// given node type with the given attributes.
function setBlockType(nodeType, attrs) {
  return function(state, dispatch) {
    var ref = state.selection;
    var from = ref.from;
    var to = ref.to;
    var applicable = false;
    state.doc.nodesBetween(from, to, function (node, pos) {
      if (applicable) { return false }
      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) { return }
      if (node.type == nodeType) {
        applicable = true;
      } else {
        var $pos = state.doc.resolve(pos), index = $pos.index();
        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
      }
    });
    if (!applicable) { return false }
    if (dispatch) { dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView()); }
    return true
  }
}

function markApplies(doc, ranges, type) {
  var loop = function ( i ) {
    var ref = ranges[i];
    var $from = ref.$from;
    var $to = ref.$to;
    var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;
    doc.nodesBetween($from.pos, $to.pos, function (node) {
      if (can) { return false }
      can = node.inlineContent && node.type.allowsMarkType(type);
    });
    if (can) { return { v: true } }
  };

  for (var i = 0; i < ranges.length; i++) {
    var returned = loop( i );

    if ( returned ) return returned.v;
  }
  return false
}

// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Create a command function that toggles the given mark with the
// given attributes. Will return `false` when the current selection
// doesn't support that mark. This will remove the mark if any marks
// of that type exist in the selection, or add it otherwise. If the
// selection is empty, this applies to the [stored
// marks](#state.EditorState.storedMarks) instead of a range of the
// document.
function toggleMark(markType, attrs) {
  return function(state, dispatch) {
    var ref = state.selection;
    var empty = ref.empty;
    var $cursor = ref.$cursor;
    var ranges = ref.ranges;
    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) { return false }
    if (dispatch) {
      if ($cursor) {
        if (markType.isInSet(state.storedMarks || $cursor.marks()))
          { dispatch(state.tr.removeStoredMark(markType)); }
        else
          { dispatch(state.tr.addStoredMark(markType.create(attrs))); }
      } else {
        var has = false, tr = state.tr;
        for (var i = 0; !has && i < ranges.length; i++) {
          var ref$1 = ranges[i];
          var $from = ref$1.$from;
          var $to = ref$1.$to;
          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
        }
        for (var i$1 = 0; i$1 < ranges.length; i$1++) {
          var ref$2 = ranges[i$1];
          var $from$1 = ref$2.$from;
          var $to$1 = ref$2.$to;
          if (has) {
            tr.removeMark($from$1.pos, $to$1.pos, markType);
          } else {
            var from = $from$1.pos, to = $to$1.pos, start = $from$1.nodeAfter, end = $to$1.nodeBefore;
            var spaceStart = start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
            var spaceEnd = end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;
            if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd; }
            tr.addMark(from, to, markType.create(attrs));
          }
        }
        dispatch(tr.scrollIntoView());
      }
    }
    return true
  }
}

function wrapDispatchForJoin(dispatch, isJoinable) {
  return function (tr) {
    if (!tr.isGeneric) { return dispatch(tr) }

    var ranges = [];
    for (var i = 0; i < tr.mapping.maps.length; i++) {
      var map = tr.mapping.maps[i];
      for (var j = 0; j < ranges.length; j++)
        { ranges[j] = map.map(ranges[j]); }
      map.forEach(function (_s, _e, from, to) { return ranges.push(from, to); });
    }

    // Figure out which joinable points exist inside those ranges,
    // by checking all node boundaries in their parent nodes.
    var joinable = [];
    for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {
      var from = ranges[i$1], to = ranges[i$1 + 1];
      var $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);
      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {
        var after = parent.maybeChild(index);
        if (!after) { break }
        if (index && joinable.indexOf(pos) == -1) {
          var before = parent.child(index - 1);
          if (before.type == after.type && isJoinable(before, after))
            { joinable.push(pos); }
        }
        pos += after.nodeSize;
      }
    }
    // Join the joinable points
    joinable.sort(function (a, b) { return a - b; });
    for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {
      if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[i$2])) { tr.join(joinable[i$2]); }
    }
    dispatch(tr);
  }
}

// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool
// Wrap a command so that, when it produces a transform that causes
// two joinable nodes to end up next to each other, those are joined.
// Nodes are considered joinable when they are of the same type and
// when the `isJoinable` predicate returns true for them or, if an
// array of strings was passed, if their node type name is in that
// array.
function autoJoin(command, isJoinable) {
  if (Array.isArray(isJoinable)) {
    var types = isJoinable;
    isJoinable = function (node) { return types.indexOf(node.type.name) > -1; };
  }
  return function (state, dispatch, view) { return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable), view); }
}

// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool
// Combine a number of command functions into a single function (which
// calls them one by one until one returns true).
function chainCommands() {
  var commands = [], len = arguments.length;
  while ( len-- ) commands[ len ] = arguments[ len ];

  return function(state, dispatch, view) {
    for (var i = 0; i < commands.length; i++)
      { if (commands[i](state, dispatch, view)) { return true } }
    return false
  }
}

var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);

// :: Object
// A basic keymap containing bindings not specific to any schema.
// Binds the following keys (when multiple commands are listed, they
// are chained with [`chainCommands`](#commands.chainCommands)):
//
// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`
// * **Mod-Enter** to `exitCode`
// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`
// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
// * **Mod-a** to `selectAll`
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};

// :: Object
// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,
// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and
// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like
// Ctrl-Delete.
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"]
};
for (var key in pcBaseKeymap) { macBaseKeymap[key] = pcBaseKeymap[key]; }

// declare global: os, navigator
var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
          : typeof os != "undefined" ? os.platform() == "darwin" : false;

// :: Object
// Depending on the detected platform, this will hold
// [`pcBasekeymap`](#commands.pcBaseKeymap) or
// [`macBaseKeymap`](#commands.macBaseKeymap).
var baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-dropcursor/dist/index.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/prosemirror-dropcursor/dist/index.es.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dropCursor": () => (/* binding */ dropCursor)
/* harmony export */ });
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");



// :: (options: ?Object) → Plugin
// Create a plugin that, when added to a ProseMirror instance,
// causes a decoration to show up at the drop position when something
// is dragged over the editor.
//
//   options::- These options are supported:
//
//     color:: ?string
//     The color of the cursor. Defaults to `black`.
//
//     width:: ?number
//     The precise width of the cursor in pixels. Defaults to 1.
//
//     class:: ?string
//     A CSS class name to add to the cursor element.
function dropCursor(options) {
  if ( options === void 0 ) options = {};

  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
    view: function view(editorView) { return new DropCursorView(editorView, options) }
  })
}

var DropCursorView = function DropCursorView(editorView, options) {
  var this$1 = this;

  this.editorView = editorView;
  this.width = options.width || 1;
  this.color = options.color || "black";
  this.class = options.class;
  this.cursorPos = null;
  this.element = null;
  this.timeout = null;

  this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(function (name) {
    var handler = function (e) { return this$1[name](e); };
    editorView.dom.addEventListener(name, handler);
    return {name: name, handler: handler}
  });
};

DropCursorView.prototype.destroy = function destroy () {
    var this$1 = this;

  this.handlers.forEach(function (ref) {
      var name = ref.name;
      var handler = ref.handler;

      return this$1.editorView.dom.removeEventListener(name, handler);
    });
};

DropCursorView.prototype.update = function update (editorView, prevState) {
  if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
    if (this.cursorPos > editorView.state.doc.content.size) { this.setCursor(null); }
    else { this.updateOverlay(); }
  }
};

DropCursorView.prototype.setCursor = function setCursor (pos) {
  if (pos == this.cursorPos) { return }
  this.cursorPos = pos;
  if (pos == null) {
    this.element.parentNode.removeChild(this.element);
    this.element = null;
  } else {
    this.updateOverlay();
  }
};

DropCursorView.prototype.updateOverlay = function updateOverlay () {
  var $pos = this.editorView.state.doc.resolve(this.cursorPos), rect;
  if (!$pos.parent.inlineContent) {
    var before = $pos.nodeBefore, after = $pos.nodeAfter;
    if (before || after) {
      var nodeRect = this.editorView.nodeDOM(this.cursorPos - (before ?before.nodeSize : 0)).getBoundingClientRect();
      var top = before ? nodeRect.bottom : nodeRect.top;
      if (before && after)
        { top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2; }
      rect = {left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2};
    }
  }
  if (!rect) {
    var coords = this.editorView.coordsAtPos(this.cursorPos);
    rect = {left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom};
  }

  var parent = this.editorView.dom.offsetParent;
  if (!this.element) {
    this.element = parent.appendChild(document.createElement("div"));
    if (this.class) { this.element.className = this.class; }
    this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none; background-color: " + this.color;
  }
  var parentLeft, parentTop;
  if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
    parentLeft = -pageXOffset;
    parentTop = -pageYOffset;
  } else {
    var rect$1 = parent.getBoundingClientRect();
    parentLeft = rect$1.left - parent.scrollLeft;
    parentTop = rect$1.top - parent.scrollTop;
  }
  this.element.style.left = (rect.left - parentLeft) + "px";
  this.element.style.top = (rect.top - parentTop) + "px";
  this.element.style.width = (rect.right - rect.left) + "px";
  this.element.style.height = (rect.bottom - rect.top) + "px";
};

DropCursorView.prototype.scheduleRemoval = function scheduleRemoval (timeout) {
    var this$1 = this;

  clearTimeout(this.timeout);
  this.timeout = setTimeout(function () { return this$1.setCursor(null); }, timeout);
};

DropCursorView.prototype.dragover = function dragover (event) {
  if (!this.editorView.editable) { return }
  var pos = this.editorView.posAtCoords({left: event.clientX, top: event.clientY});
  if (pos) {
    var target = pos.pos;
    if (this.editorView.dragging && this.editorView.dragging.slice) {
      target = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.dropPoint)(this.editorView.state.doc, target, this.editorView.dragging.slice);
      if (target == null) { return this.setCursor(null) }
    }
    this.setCursor(target);
    this.scheduleRemoval(5000);
  }
};

DropCursorView.prototype.dragend = function dragend () {
  this.scheduleRemoval(20);
};

DropCursorView.prototype.drop = function drop () {
  this.scheduleRemoval(20);
};

DropCursorView.prototype.dragleave = function dragleave (event) {
  if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
    { this.setCursor(null); }
};


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-example-setup/dist/index.es.js":
/*!*****************************************************************!*\
  !*** ./node_modules/prosemirror-example-setup/dist/index.es.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildInputRules": () => (/* binding */ buildInputRules),
/* harmony export */   "buildKeymap": () => (/* binding */ buildKeymap),
/* harmony export */   "buildMenuItems": () => (/* binding */ buildMenuItems),
/* harmony export */   "exampleSetup": () => (/* binding */ exampleSetup)
/* harmony export */ });
/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ "./node_modules/prosemirror-keymap/dist/index.es.js");
/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-history */ "./node_modules/prosemirror-history/dist/index.es.js");
/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-commands */ "./node_modules/prosemirror-commands/dist/index.es.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-dropcursor */ "./node_modules/prosemirror-dropcursor/dist/index.es.js");
/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prosemirror-gapcursor */ "./node_modules/prosemirror-gapcursor/dist/index.es.js");
/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-menu */ "./node_modules/prosemirror-menu/dist/index.es.js");
/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! prosemirror-schema-list */ "./node_modules/prosemirror-schema-list/dist/index.es.js");
/* harmony import */ var prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.es.js");










var prefix = "ProseMirror-prompt";

function openPrompt(options) {
  var wrapper = document.body.appendChild(document.createElement("div"));
  wrapper.className = prefix;

  var mouseOutside = function (e) { if (!wrapper.contains(e.target)) { close(); } };
  setTimeout(function () { return window.addEventListener("mousedown", mouseOutside); }, 50);
  var close = function () {
    window.removeEventListener("mousedown", mouseOutside);
    if (wrapper.parentNode) { wrapper.parentNode.removeChild(wrapper); }
  };

  var domFields = [];
  for (var name in options.fields) { domFields.push(options.fields[name].render()); }

  var submitButton = document.createElement("button");
  submitButton.type = "submit";
  submitButton.className = prefix + "-submit";
  submitButton.textContent = "OK";
  var cancelButton = document.createElement("button");
  cancelButton.type = "button";
  cancelButton.className = prefix + "-cancel";
  cancelButton.textContent = "Cancel";
  cancelButton.addEventListener("click", close);

  var form = wrapper.appendChild(document.createElement("form"));
  if (options.title) { form.appendChild(document.createElement("h5")).textContent = options.title; }
  domFields.forEach(function (field) {
    form.appendChild(document.createElement("div")).appendChild(field);
  });
  var buttons = form.appendChild(document.createElement("div"));
  buttons.className = prefix + "-buttons";
  buttons.appendChild(submitButton);
  buttons.appendChild(document.createTextNode(" "));
  buttons.appendChild(cancelButton);

  var box = wrapper.getBoundingClientRect();
  wrapper.style.top = ((window.innerHeight - box.height) / 2) + "px";
  wrapper.style.left = ((window.innerWidth - box.width) / 2) + "px";

  var submit = function () {
    var params = getValues(options.fields, domFields);
    if (params) {
      close();
      options.callback(params);
    }
  };

  form.addEventListener("submit", function (e) {
    e.preventDefault();
    submit();
  });

  form.addEventListener("keydown", function (e) {
    if (e.keyCode == 27) {
      e.preventDefault();
      close();
    } else if (e.keyCode == 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) {
      e.preventDefault();
      submit();
    } else if (e.keyCode == 9) {
      window.setTimeout(function () {
        if (!wrapper.contains(document.activeElement)) { close(); }
      }, 500);
    }
  });

  var input = form.elements[0];
  if (input) { input.focus(); }
}

function getValues(fields, domFields) {
  var result = Object.create(null), i = 0;
  for (var name in fields) {
    var field = fields[name], dom = domFields[i++];
    var value = field.read(dom), bad = field.validate(value);
    if (bad) {
      reportInvalid(dom, bad);
      return null
    }
    result[name] = field.clean(value);
  }
  return result
}

function reportInvalid(dom, message) {
  // FIXME this is awful and needs a lot more work
  var parent = dom.parentNode;
  var msg = parent.appendChild(document.createElement("div"));
  msg.style.left = (dom.offsetLeft + dom.offsetWidth + 2) + "px";
  msg.style.top = (dom.offsetTop - 5) + "px";
  msg.className = "ProseMirror-invalid";
  msg.textContent = message;
  setTimeout(function () { return parent.removeChild(msg); }, 1500);
}

// ::- The type of field that `FieldPrompt` expects to be passed to it.
var Field = function Field(options) { this.options = options; };

// render:: (state: EditorState, props: Object) → dom.Node
// Render the field to the DOM. Should be implemented by all subclasses.

// :: (dom.Node) → any
// Read the field's value from its DOM node.
Field.prototype.read = function read (dom) { return dom.value };

// :: (any) → ?string
// A field-type-specific validation function.
Field.prototype.validateType = function validateType (_value) {};

Field.prototype.validate = function validate (value) {
  if (!value && this.options.required)
    { return "Required field" }
  return this.validateType(value) || (this.options.validate && this.options.validate(value))
};

Field.prototype.clean = function clean (value) {
  return this.options.clean ? this.options.clean(value) : value
};

// ::- A field class for single-line text fields.
var TextField = /*@__PURE__*/(function (Field) {
  function TextField () {
    Field.apply(this, arguments);
  }

  if ( Field ) TextField.__proto__ = Field;
  TextField.prototype = Object.create( Field && Field.prototype );
  TextField.prototype.constructor = TextField;

  TextField.prototype.render = function render () {
    var input = document.createElement("input");
    input.type = "text";
    input.placeholder = this.options.label;
    input.value = this.options.value || "";
    input.autocomplete = "off";
    return input
  };

  return TextField;
}(Field));

// Helpers to create specific types of items

function canInsert(state, nodeType) {
  var $from = state.selection.$from;
  for (var d = $from.depth; d >= 0; d--) {
    var index = $from.index(d);
    if ($from.node(d).canReplaceWith(index, index, nodeType)) { return true }
  }
  return false
}

function insertImageItem(nodeType) {
  return new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.MenuItem({
    title: "Insert image",
    label: "Image",
    enable: function enable(state) { return canInsert(state, nodeType) },
    run: function run(state, _, view) {
      var ref = state.selection;
      var from = ref.from;
      var to = ref.to;
      var attrs = null;
      if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.NodeSelection && state.selection.node.type == nodeType)
        { attrs = state.selection.node.attrs; }
      openPrompt({
        title: "Insert image",
        fields: {
          src: new TextField({label: "Location", required: true, value: attrs && attrs.src}),
          title: new TextField({label: "Title", value: attrs && attrs.title}),
          alt: new TextField({label: "Description",
                              value: attrs ? attrs.alt : state.doc.textBetween(from, to, " ")})
        },
        callback: function callback(attrs) {
          view.dispatch(view.state.tr.replaceSelectionWith(nodeType.createAndFill(attrs)));
          view.focus();
        }
      });
    }
  })
}

function cmdItem(cmd, options) {
  var passedOptions = {
    label: options.title,
    run: cmd
  };
  for (var prop in options) { passedOptions[prop] = options[prop]; }
  if ((!options.enable || options.enable === true) && !options.select)
    { passedOptions[options.enable ? "enable" : "select"] = function (state) { return cmd(state); }; }

  return new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.MenuItem(passedOptions)
}

function markActive(state, type) {
  var ref = state.selection;
  var from = ref.from;
  var $from = ref.$from;
  var to = ref.to;
  var empty = ref.empty;
  if (empty) { return type.isInSet(state.storedMarks || $from.marks()) }
  else { return state.doc.rangeHasMark(from, to, type) }
}

function markItem(markType, options) {
  var passedOptions = {
    active: function active(state) { return markActive(state, markType) },
    enable: true
  };
  for (var prop in options) { passedOptions[prop] = options[prop]; }
  return cmdItem((0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(markType), passedOptions)
}

function linkItem(markType) {
  return new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.MenuItem({
    title: "Add or remove link",
    icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.link,
    active: function active(state) { return markActive(state, markType) },
    enable: function enable(state) { return !state.selection.empty },
    run: function run(state, dispatch, view) {
      if (markActive(state, markType)) {
        (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(markType)(state, dispatch);
        return true
      }
      openPrompt({
        title: "Create a link",
        fields: {
          href: new TextField({
            label: "Link target",
            required: true
          }),
          title: new TextField({label: "Title"})
        },
        callback: function callback(attrs) {
          (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(markType, attrs)(view.state, view.dispatch);
          view.focus();
        }
      });
    }
  })
}

function wrapListItem(nodeType, options) {
  return cmdItem((0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__.wrapInList)(nodeType, options.attrs), options)
}

// :: (Schema) → Object
// Given a schema, look for default mark and node types in it and
// return an object with relevant menu items relating to those marks:
//
// **`toggleStrong`**`: MenuItem`
//   : A menu item to toggle the [strong mark](#schema-basic.StrongMark).
//
// **`toggleEm`**`: MenuItem`
//   : A menu item to toggle the [emphasis mark](#schema-basic.EmMark).
//
// **`toggleCode`**`: MenuItem`
//   : A menu item to toggle the [code font mark](#schema-basic.CodeMark).
//
// **`toggleLink`**`: MenuItem`
//   : A menu item to toggle the [link mark](#schema-basic.LinkMark).
//
// **`insertImage`**`: MenuItem`
//   : A menu item to insert an [image](#schema-basic.Image).
//
// **`wrapBulletList`**`: MenuItem`
//   : A menu item to wrap the selection in a [bullet list](#schema-list.BulletList).
//
// **`wrapOrderedList`**`: MenuItem`
//   : A menu item to wrap the selection in an [ordered list](#schema-list.OrderedList).
//
// **`wrapBlockQuote`**`: MenuItem`
//   : A menu item to wrap the selection in a [block quote](#schema-basic.BlockQuote).
//
// **`makeParagraph`**`: MenuItem`
//   : A menu item to set the current textblock to be a normal
//     [paragraph](#schema-basic.Paragraph).
//
// **`makeCodeBlock`**`: MenuItem`
//   : A menu item to set the current textblock to be a
//     [code block](#schema-basic.CodeBlock).
//
// **`makeHead[N]`**`: MenuItem`
//   : Where _N_ is 1 to 6. Menu items to set the current textblock to
//     be a [heading](#schema-basic.Heading) of level _N_.
//
// **`insertHorizontalRule`**`: MenuItem`
//   : A menu item to insert a horizontal rule.
//
// The return value also contains some prefabricated menu elements and
// menus, that you can use instead of composing your own menu from
// scratch:
//
// **`insertMenu`**`: Dropdown`
//   : A dropdown containing the `insertImage` and
//     `insertHorizontalRule` items.
//
// **`typeMenu`**`: Dropdown`
//   : A dropdown containing the items for making the current
//     textblock a paragraph, code block, or heading.
//
// **`fullMenu`**`: [[MenuElement]]`
//   : An array of arrays of menu elements for use as the full menu
//     for, for example the [menu bar](https://github.com/prosemirror/prosemirror-menu#user-content-menubar).
function buildMenuItems(schema) {
  var r = {}, type;
  if (type = schema.marks.strong)
    { r.toggleStrong = markItem(type, {title: "Toggle strong style", icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.strong}); }
  if (type = schema.marks.em)
    { r.toggleEm = markItem(type, {title: "Toggle emphasis", icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.em}); }
  if (type = schema.marks.code)
    { r.toggleCode = markItem(type, {title: "Toggle code font", icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.code}); }
  if (type = schema.marks.link)
    { r.toggleLink = linkItem(type); }

  if (type = schema.nodes.image)
    { r.insertImage = insertImageItem(type); }
  if (type = schema.nodes.bullet_list)
    { r.wrapBulletList = wrapListItem(type, {
      title: "Wrap in bullet list",
      icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.bulletList
    }); }
  if (type = schema.nodes.ordered_list)
    { r.wrapOrderedList = wrapListItem(type, {
      title: "Wrap in ordered list",
      icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.orderedList
    }); }
  if (type = schema.nodes.blockquote)
    { r.wrapBlockQuote = (0,prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.wrapItem)(type, {
      title: "Wrap in block quote",
      icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.blockquote
    }); }
  if (type = schema.nodes.paragraph)
    { r.makeParagraph = (0,prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.blockTypeItem)(type, {
      title: "Change to paragraph",
      label: "Plain"
    }); }
  if (type = schema.nodes.code_block)
    { r.makeCodeBlock = (0,prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.blockTypeItem)(type, {
      title: "Change to code block",
      label: "Code"
    }); }
  if (type = schema.nodes.heading)
    { for (var i = 1; i <= 10; i++)
      { r["makeHead" + i] = (0,prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.blockTypeItem)(type, {
        title: "Change to heading " + i,
        label: "Level " + i,
        attrs: {level: i}
      }); } }
  if (type = schema.nodes.horizontal_rule) {
    var hr = type;
    r.insertHorizontalRule = new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.MenuItem({
      title: "Insert horizontal rule",
      label: "Horizontal rule",
      enable: function enable(state) { return canInsert(state, hr) },
      run: function run(state, dispatch) { dispatch(state.tr.replaceSelectionWith(hr.create())); }
    });
  }

  var cut = function (arr) { return arr.filter(function (x) { return x; }); };
  r.insertMenu = new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.Dropdown(cut([r.insertImage, r.insertHorizontalRule]), {label: "Insert"});
  r.typeMenu = new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.Dropdown(cut([r.makeParagraph, r.makeCodeBlock, r.makeHead1 && new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.DropdownSubmenu(cut([
    r.makeHead1, r.makeHead2, r.makeHead3, r.makeHead4, r.makeHead5, r.makeHead6
  ]), {label: "Heading"})]), {label: "Type..."});

  r.inlineMenu = [cut([r.toggleStrong, r.toggleEm, r.toggleCode, r.toggleLink])];
  r.blockMenu = [cut([r.wrapBulletList, r.wrapOrderedList, r.wrapBlockQuote, prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.joinUpItem,
                      prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.liftItem, prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.selectParentNodeItem])];
  r.fullMenu = r.inlineMenu.concat([[r.insertMenu, r.typeMenu]], [[prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.undoItem, prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.redoItem]], r.blockMenu);

  return r
}

var mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;

// :: (Schema, ?Object) → Object
// Inspect the given schema looking for marks and nodes from the
// basic schema, and if found, add key bindings related to them.
// This will add:
//
// * **Mod-b** for toggling [strong](#schema-basic.StrongMark)
// * **Mod-i** for toggling [emphasis](#schema-basic.EmMark)
// * **Mod-`** for toggling [code font](#schema-basic.CodeMark)
// * **Ctrl-Shift-0** for making the current textblock a paragraph
// * **Ctrl-Shift-1** to **Ctrl-Shift-Digit6** for making the current
//   textblock a heading of the corresponding level
// * **Ctrl-Shift-Backslash** to make the current textblock a code block
// * **Ctrl-Shift-8** to wrap the selection in an ordered list
// * **Ctrl-Shift-9** to wrap the selection in a bullet list
// * **Ctrl->** to wrap the selection in a block quote
// * **Enter** to split a non-empty textblock in a list item while at
//   the same time splitting the list item
// * **Mod-Enter** to insert a hard break
// * **Mod-_** to insert a horizontal rule
// * **Backspace** to undo an input rule
// * **Alt-ArrowUp** to `joinUp`
// * **Alt-ArrowDown** to `joinDown`
// * **Mod-BracketLeft** to `lift`
// * **Escape** to `selectParentNode`
//
// You can suppress or map these bindings by passing a `mapKeys`
// argument, which maps key names (say `"Mod-B"` to either `false`, to
// remove the binding, or a new key name string.
function buildKeymap(schema, mapKeys) {
  var keys = {}, type;
  function bind(key, cmd) {
    if (mapKeys) {
      var mapped = mapKeys[key];
      if (mapped === false) { return }
      if (mapped) { key = mapped; }
    }
    keys[key] = cmd;
  }


  bind("Mod-z", prosemirror_history__WEBPACK_IMPORTED_MODULE_1__.undo);
  bind("Shift-Mod-z", prosemirror_history__WEBPACK_IMPORTED_MODULE_1__.redo);
  bind("Backspace", prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.undoInputRule);
  if (!mac) { bind("Mod-y", prosemirror_history__WEBPACK_IMPORTED_MODULE_1__.redo); }

  bind("Alt-ArrowUp", prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.joinUp);
  bind("Alt-ArrowDown", prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.joinDown);
  bind("Mod-BracketLeft", prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.lift);
  bind("Escape", prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.selectParentNode);

  if (type = schema.marks.strong) {
    bind("Mod-b", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(type));
    bind("Mod-B", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(type));
  }
  if (type = schema.marks.em) {
    bind("Mod-i", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(type));
    bind("Mod-I", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(type));
  }
  if (type = schema.marks.code)
    { bind("Mod-`", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(type)); }

  if (type = schema.nodes.bullet_list)
    { bind("Shift-Ctrl-8", (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__.wrapInList)(type)); }
  if (type = schema.nodes.ordered_list)
    { bind("Shift-Ctrl-9", (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__.wrapInList)(type)); }
  if (type = schema.nodes.blockquote)
    { bind("Ctrl->", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.wrapIn)(type)); }
  if (type = schema.nodes.hard_break) {
    var br = type, cmd = (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.chainCommands)(prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.exitCode, function (state, dispatch) {
      dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());
      return true
    });
    bind("Mod-Enter", cmd);
    bind("Shift-Enter", cmd);
    if (mac) { bind("Ctrl-Enter", cmd); }
  }
  if (type = schema.nodes.list_item) {
    bind("Enter", (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__.splitListItem)(type));
    bind("Mod-[", (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__.liftListItem)(type));
    bind("Mod-]", (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__.sinkListItem)(type));
  }
  if (type = schema.nodes.paragraph)
    { bind("Shift-Ctrl-0", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(type)); }
  if (type = schema.nodes.code_block)
    { bind("Shift-Ctrl-\\", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(type)); }
  if (type = schema.nodes.heading)
    { for (var i = 1; i <= 6; i++) { bind("Shift-Ctrl-" + i, (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(type, {level: i})); } }
  if (type = schema.nodes.horizontal_rule) {
    var hr = type;
    bind("Mod-_", function (state, dispatch) {
      dispatch(state.tr.replaceSelectionWith(hr.create()).scrollIntoView());
      return true
    });
  }

  return keys
}

// : (NodeType) → InputRule
// Given a blockquote node type, returns an input rule that turns `"> "`
// at the start of a textblock into a blockquote.
function blockQuoteRule(nodeType) {
  return (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.wrappingInputRule)(/^\s*>\s$/, nodeType)
}

// : (NodeType) → InputRule
// Given a list node type, returns an input rule that turns a number
// followed by a dot at the start of a textblock into an ordered list.
function orderedListRule(nodeType) {
  return (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.wrappingInputRule)(/^(\d+)\.\s$/, nodeType, function (match) { return ({order: +match[1]}); },
                           function (match, node) { return node.childCount + node.attrs.order == +match[1]; })
}

// : (NodeType) → InputRule
// Given a list node type, returns an input rule that turns a bullet
// (dash, plush, or asterisk) at the start of a textblock into a
// bullet list.
function bulletListRule(nodeType) {
  return (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.wrappingInputRule)(/^\s*([-+*])\s$/, nodeType)
}

// : (NodeType) → InputRule
// Given a code block node type, returns an input rule that turns a
// textblock starting with three backticks into a code block.
function codeBlockRule(nodeType) {
  return (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.textblockTypeInputRule)(/^```$/, nodeType)
}

// : (NodeType, number) → InputRule
// Given a node type and a maximum level, creates an input rule that
// turns up to that number of `#` characters followed by a space at
// the start of a textblock into a heading whose level corresponds to
// the number of `#` signs.
function headingRule(nodeType, maxLevel) {
  return (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.textblockTypeInputRule)(new RegExp("^(#{1," + maxLevel + "})\\s$"),
                                nodeType, function (match) { return ({level: match[1].length}); })
}

// : (Schema) → Plugin
// A set of input rules for creating the basic block quotes, lists,
// code blocks, and heading.
function buildInputRules(schema) {
  var rules = prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.smartQuotes.concat(prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.ellipsis, prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.emDash), type;
  if (type = schema.nodes.blockquote) { rules.push(blockQuoteRule(type)); }
  if (type = schema.nodes.ordered_list) { rules.push(orderedListRule(type)); }
  if (type = schema.nodes.bullet_list) { rules.push(bulletListRule(type)); }
  if (type = schema.nodes.code_block) { rules.push(codeBlockRule(type)); }
  if (type = schema.nodes.heading) { rules.push(headingRule(type, 6)); }
  return (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.inputRules)({rules: rules})
}

// !! This module exports helper functions for deriving a set of basic
// menu items, input rules, or key bindings from a schema. These
// values need to know about the schema for two reasons—they need
// access to specific instances of node and mark types, and they need
// to know which of the node and mark types that they know about are
// actually present in the schema.
//
// The `exampleSetup` plugin ties these together into a plugin that
// will automatically enable this basic functionality in an editor.

// :: (Object) → [Plugin]
// A convenience plugin that bundles together a simple menu with basic
// key bindings, input rules, and styling for the example schema.
// Probably only useful for quickly setting up a passable
// editor—you'll need more control over your settings in most
// real-world situations.
//
//   options::- The following options are recognized:
//
//     schema:: Schema
//     The schema to generate key bindings and menu items for.
//
//     mapKeys:: ?Object
//     Can be used to [adjust](#example-setup.buildKeymap) the key bindings created.
//
//     menuBar:: ?bool
//     Set to false to disable the menu bar.
//
//     history:: ?bool
//     Set to false to disable the history plugin.
//
//     floatingMenu:: ?bool
//     Set to false to make the menu bar non-floating.
//
//     menuContent:: [[MenuItem]]
//     Can be used to override the menu content.
function exampleSetup(options) {
  var plugins = [
    buildInputRules(options.schema),
    (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)(buildKeymap(options.schema, options.mapKeys)),
    (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)(prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.baseKeymap),
    (0,prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_4__.dropCursor)(),
    (0,prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_5__.gapCursor)()
  ];
  if (options.menuBar !== false)
    { plugins.push((0,prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.menuBar)({floating: options.floatingMenu !== false,
                          content: options.menuContent || buildMenuItems(options.schema).fullMenu})); }
  if (options.history !== false)
    { plugins.push((0,prosemirror_history__WEBPACK_IMPORTED_MODULE_1__.history)()); }

  return plugins.concat(new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({
    props: {
      attributes: {class: "ProseMirror-example-setup-style"}
    }
  }))
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-gapcursor/dist/index.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/prosemirror-gapcursor/dist/index.es.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gapCursor": () => (/* binding */ gapCursor)
/* harmony export */ });
/* unused harmony export GapCursor */
/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ "./node_modules/prosemirror-keymap/dist/index.es.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.es.js");
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");





// ::- Gap cursor selections are represented using this class. Its
// `$anchor` and `$head` properties both point at the cursor position.
var GapCursor = /*@__PURE__*/(function (Selection) {
  function GapCursor($pos) {
    Selection.call(this, $pos, $pos);
  }

  if ( Selection ) GapCursor.__proto__ = Selection;
  GapCursor.prototype = Object.create( Selection && Selection.prototype );
  GapCursor.prototype.constructor = GapCursor;

  GapCursor.prototype.map = function map (doc, mapping) {
    var $pos = doc.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)
  };

  GapCursor.prototype.content = function content () { return prosemirror_model__WEBPACK_IMPORTED_MODULE_3__.Slice.empty };

  GapCursor.prototype.eq = function eq (other) {
    return other instanceof GapCursor && other.head == this.head
  };

  GapCursor.prototype.toJSON = function toJSON () {
    return {type: "gapcursor", pos: this.head}
  };

  GapCursor.fromJSON = function fromJSON (doc, json) {
    if (typeof json.pos != "number") { throw new RangeError("Invalid input for GapCursor.fromJSON") }
    return new GapCursor(doc.resolve(json.pos))
  };

  GapCursor.prototype.getBookmark = function getBookmark () { return new GapBookmark(this.anchor) };

  GapCursor.valid = function valid ($pos) {
    var parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) { return false }
    var override = parent.type.spec.allowGapCursor;
    if (override != null) { return override }
    var deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock
  };

  GapCursor.findFrom = function findFrom ($pos, dir, mustMove) {
    search: for (;;) {
      if (!mustMove && GapCursor.valid($pos)) { return $pos }
      var pos = $pos.pos, next = null;
      // Scan up from this position
      for (var d = $pos.depth;; d--) {
        var parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break
        } else if (d == 0) {
          return null
        }
        pos += dir;
        var $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur)) { return $cur }
      }

      // And then down into the next node
      for (;;) {
        var inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search
          }
          break
        }
        next = inside;
        pos += dir;
        var $cur$1 = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur$1)) { return $cur$1 }
      }

      return null
    }
  };

  return GapCursor;
}(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection));

GapCursor.prototype.visible = false;

prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.jsonID("gapcursor", GapCursor);

var GapBookmark = function GapBookmark(pos) {
  this.pos = pos;
};
GapBookmark.prototype.map = function map (mapping) {
  return new GapBookmark(mapping.map(this.pos))
};
GapBookmark.prototype.resolve = function resolve (doc) {
  var $pos = doc.resolve(this.pos);
  return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near($pos)
};

function closedBefore($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index = $pos.index(d);
    // At the start of this parent, look at next one
    if (index == 0) { continue }
    // See if the node before (or its first ancestor) is closed
    for (var before = $pos.node(d).child(index - 1);; before = before.lastChild) {
      if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating) { return true }
      if (before.inlineContent) { return false }
    }
  }
  // Hit start of document
  return true
}

function closedAfter($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) { continue }
    for (var after = parent.child(index);; after = after.firstChild) {
      if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating) { return true }
      if (after.inlineContent) { return false }
    }
  }
  return true
}

// :: () → Plugin
// Create a gap cursor plugin. When enabled, this will capture clicks
// near and arrow-key-motion past places that don't have a normally
// selectable position nearby, and create a gap cursor selection for
// them. The cursor is drawn as an element with class
// `ProseMirror-gapcursor`. You can either include
// `style/gapcursor.css` from the package's directory or add your own
// styles to make it visible.
var gapCursor = function() {
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({
    props: {
      decorations: drawGapCursor,

      createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {
        if ($anchor.pos == $head.pos && GapCursor.valid($head)) { return new GapCursor($head) }
      },

      handleClick: handleClick,
      handleKeyDown: handleKeyDown
    }
  })
};

var handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler)({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});

function arrow(axis, dir) {
  var dirStr = axis == "vert" ? (dir > 0 ? "down" : "up") : (dir > 0 ? "right" : "left");
  return function(state, dispatch, view) {
    var sel = state.selection;
    var $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0) { return false }
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    var $found = GapCursor.findFrom($start, dir, mustMove);
    if (!$found) { return false }
    if (dispatch) { dispatch(state.tr.setSelection(new GapCursor($found))); }
    return true
  }
}

function handleClick(view, pos, event) {
  if (!view.editable) { return false }
  var $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos)) { return false }
  var ref = view.posAtCoords({left: event.clientX, top: event.clientY});
  var inside = ref.inside;
  if (inside > -1 && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) { return false }
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true
}

function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor)) { return null }
  var node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, [prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget(state.selection.head, node, {key: "gapcursor"})])
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-history/dist/index.es.js":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-history/dist/index.es.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "history": () => (/* binding */ history),
/* harmony export */   "redo": () => (/* binding */ redo),
/* harmony export */   "undo": () => (/* binding */ undo)
/* harmony export */ });
/* unused harmony exports HistoryState, closeHistory, redoDepth, undoDepth */
/* harmony import */ var rope_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rope-sequence */ "./node_modules/rope-sequence/dist/index.es.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");




// ProseMirror's history isn't simply a way to roll back to a previous
// state, because ProseMirror supports applying changes without adding
// them to the history (for example during collaboration).
//
// To this end, each 'Branch' (one for the undo history and one for
// the redo history) keeps an array of 'Items', which can optionally
// hold a step (an actual undoable change), and always hold a position
// map (which is needed to move changes below them to apply to the
// current document).
//
// An item that has both a step and a selection bookmark is the start
// of an 'event' — a group of changes that will be undone or redone at
// once. (It stores only the bookmark, since that way we don't have to
// provide a document until the selection is actually applied, which
// is useful when compressing.)

// Used to schedule history compression
var max_empty_items = 500;

var Branch = function Branch(items, eventCount) {
  this.items = items;
  this.eventCount = eventCount;
};

// : (EditorState, bool) → ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}
// Pop the latest event off the branch's history and apply it
// to a document transform.
Branch.prototype.popEvent = function popEvent (state, preserveItems) {
    var this$1 = this;

  if (this.eventCount == 0) { return null }

  var end = this.items.length;
  for (;; end--) {
    var next = this.items.get(end - 1);
    if (next.selection) { --end; break }
  }

  var remap, mapFrom;
  if (preserveItems) {
    remap = this.remapping(end, this.items.length);
    mapFrom = remap.maps.length;
  }
  var transform = state.tr;
  var selection, remaining;
  var addAfter = [], addBefore = [];

  this.items.forEach(function (item, i) {
    if (!item.step) {
      if (!remap) {
        remap = this$1.remapping(end, i + 1);
        mapFrom = remap.maps.length;
      }
      mapFrom--;
      addBefore.push(item);
      return
    }

    if (remap) {
      addBefore.push(new Item(item.map));
      var step = item.step.map(remap.slice(mapFrom)), map;

      if (step && transform.maybeStep(step).doc) {
        map = transform.mapping.maps[transform.mapping.maps.length - 1];
        addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length));
      }
      mapFrom--;
      if (map) { remap.appendMap(map, mapFrom); }
    } else {
      transform.maybeStep(item.step);
    }

    if (item.selection) {
      selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
      remaining = new Branch(this$1.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1);
      return false
    }
  }, this.items.length, 0);

  return {remaining: remaining, transform: transform, selection: selection}
};

// : (Transform, ?SelectionBookmark, Object) → Branch
// Create a new branch with the given transform added.
Branch.prototype.addTransform = function addTransform (transform, selection, histOptions, preserveItems) {
  var newItems = [], eventCount = this.eventCount;
  var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;

  for (var i = 0; i < transform.steps.length; i++) {
    var step = transform.steps[i].invert(transform.docs[i]);
    var item = new Item(transform.mapping.maps[i], step, selection), merged = (void 0);
    if (merged = lastItem && lastItem.merge(item)) {
      item = merged;
      if (i) { newItems.pop(); }
      else { oldItems = oldItems.slice(0, oldItems.length - 1); }
    }
    newItems.push(item);
    if (selection) {
      eventCount++;
      selection = null;
    }
    if (!preserveItems) { lastItem = item; }
  }
  var overflow = eventCount - histOptions.depth;
  if (overflow > DEPTH_OVERFLOW) {
    oldItems = cutOffEvents(oldItems, overflow);
    eventCount -= overflow;
  }
  return new Branch(oldItems.append(newItems), eventCount)
};

Branch.prototype.remapping = function remapping (from, to) {
  var maps = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Mapping;
  this.items.forEach(function (item, i) {
    var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from
        ? maps.maps.length - item.mirrorOffset : null;
    maps.appendMap(item.map, mirrorPos);
  }, from, to);
  return maps
};

Branch.prototype.addMaps = function addMaps (array) {
  if (this.eventCount == 0) { return this }
  return new Branch(this.items.append(array.map(function (map) { return new Item(map); })), this.eventCount)
};

// : (Transform, number)
// When the collab module receives remote changes, the history has
// to know about those, so that it can adjust the steps that were
// rebased on top of the remote changes, and include the position
// maps for the remote changes in its array of items.
Branch.prototype.rebased = function rebased (rebasedTransform, rebasedCount) {
  if (!this.eventCount) { return this }

  var rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);

  var mapping = rebasedTransform.mapping;
  var newUntil = rebasedTransform.steps.length;
  var eventCount = this.eventCount;
  this.items.forEach(function (item) { if (item.selection) { eventCount--; } }, start);

  var iRebased = rebasedCount;
  this.items.forEach(function (item) {
    var pos = mapping.getMirror(--iRebased);
    if (pos == null) { return }
    newUntil = Math.min(newUntil, pos);
    var map = mapping.maps[pos];
    if (item.step) {
      var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
      var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
      if (selection) { eventCount++; }
      rebasedItems.push(new Item(map, step, selection));
    } else {
      rebasedItems.push(new Item(map));
    }
  }, start);

  var newMaps = [];
  for (var i = rebasedCount; i < newUntil; i++)
    { newMaps.push(new Item(mapping.maps[i])); }
  var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
  var branch = new Branch(items, eventCount);

  if (branch.emptyItemCount() > max_empty_items)
    { branch = branch.compress(this.items.length - rebasedItems.length); }
  return branch
};

Branch.prototype.emptyItemCount = function emptyItemCount () {
  var count = 0;
  this.items.forEach(function (item) { if (!item.step) { count++; } });
  return count
};

// Compressing a branch means rewriting it to push the air (map-only
// items) out. During collaboration, these naturally accumulate
// because each remote change adds one. The `upto` argument is used
// to ensure that only the items below a given level are compressed,
// because `rebased` relies on a clean, untouched set of items in
// order to associate old items with rebased steps.
Branch.prototype.compress = function compress (upto) {
    if ( upto === void 0 ) upto = this.items.length;

  var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
  var items = [], events = 0;
  this.items.forEach(function (item, i) {
    if (i >= upto) {
      items.push(item);
      if (item.selection) { events++; }
    } else if (item.step) {
      var step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();
      mapFrom--;
      if (map) { remap.appendMap(map, mapFrom); }
      if (step) {
        var selection = item.selection && item.selection.map(remap.slice(mapFrom));
        if (selection) { events++; }
        var newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;
        if (merged = items.length && items[last].merge(newItem))
          { items[last] = merged; }
        else
          { items.push(newItem); }
      }
    } else if (item.map) {
      mapFrom--;
    }
  }, this.items.length, 0);
  return new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__["default"].from(items.reverse()), events)
};

Branch.empty = new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__["default"].empty, 0);

function cutOffEvents(items, n) {
  var cutPoint;
  items.forEach(function (item, i) {
    if (item.selection && (n-- == 0)) {
      cutPoint = i;
      return false
    }
  });
  return items.slice(cutPoint)
}

var Item = function Item(map, step, selection, mirrorOffset) {
  // The (forward) step map for this item.
  this.map = map;
  // The inverted step
  this.step = step;
  // If this is non-null, this item is the start of a group, and
  // this selection is the starting selection for the group (the one
  // that was active before the first step was applied)
  this.selection = selection;
  // If this item is the inverse of a previous mapping on the stack,
  // this points at the inverse's offset
  this.mirrorOffset = mirrorOffset;
};

Item.prototype.merge = function merge (other) {
  if (this.step && other.step && !other.selection) {
    var step = other.step.merge(this.step);
    if (step) { return new Item(step.getMap().invert(), step, this.selection) }
  }
};

// The value of the state field that tracks undo/redo history for that
// state. Will be stored in the plugin state when the history plugin
// is active.
var HistoryState = function HistoryState(done, undone, prevRanges, prevTime) {
  this.done = done;
  this.undone = undone;
  this.prevRanges = prevRanges;
  this.prevTime = prevTime;
};

var DEPTH_OVERFLOW = 20;

// : (HistoryState, EditorState, Transaction, Object)
// Record a transformation in undo history.
function applyTransaction(history, state, tr, options) {
  var historyTr = tr.getMeta(historyKey), rebased;
  if (historyTr) { return historyTr.historyState }

  if (tr.getMeta(closeHistoryKey)) { history = new HistoryState(history.done, history.undone, null, 0); }

  var appended = tr.getMeta("appendedTransaction");

  if (tr.steps.length == 0) {
    return history
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      { return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)),
                              history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime) }
    else
      { return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)),
                              null, history.prevTime) }
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    // Group transforms that occur in quick succession into one event.
    var newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||
                                                          !isAdjacentTo(tr, history.prevRanges));
    var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null,
                                                      options, mustPreserveItems(state)),
                            Branch.empty, prevRanges, tr.time)
  } else if (rebased = tr.getMeta("rebased")) {
    // Used by the collab module to tell the history that some of its
    // content has been rebased.
    return new HistoryState(history.done.rebased(tr, rebased),
                            history.undone.rebased(tr, rebased),
                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)
  } else {
    return new HistoryState(history.done.addMaps(tr.mapping.maps),
                            history.undone.addMaps(tr.mapping.maps),
                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)
  }
}

function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges) { return false }
  if (!transform.docChanged) { return true }
  var adjacent = false;
  transform.mapping.maps[0].forEach(function (start, end) {
    for (var i = 0; i < prevRanges.length; i += 2)
      { if (start <= prevRanges[i + 1] && end >= prevRanges[i])
        { adjacent = true; } }
  });
  return adjacent
}

function rangesFor(map) {
  var result = [];
  map.forEach(function (_from, _to, from, to) { return result.push(from, to); });
  return result
}

function mapRanges(ranges, mapping) {
  if (!ranges) { return null }
  var result = [];
  for (var i = 0; i < ranges.length; i += 2) {
    var from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from <= to) { result.push(from, to); }
  }
  return result
}

// : (HistoryState, EditorState, (tr: Transaction), bool)
// Apply the latest event from one branch to the document and shift the event
// onto the other branch.
function histTransaction(history, state, dispatch, redo) {
  var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;
  var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);
  if (!pop) { return }

  var selection = pop.selection.resolve(pop.transform.doc);
  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),
                                                                  histOptions, preserveItems);

  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);
  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {redo: redo, historyState: newHist}).scrollIntoView());
}

var cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
// Check whether any plugin in the given state has a
// `historyPreserveItems` property in its spec, in which case we must
// preserve steps exactly as they came in, so that they can be
// rebased.
function mustPreserveItems(state) {
  var plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (var i = 0; i < plugins.length; i++) { if (plugins[i].spec.historyPreserveItems) {
      cachedPreserveItems = true;
      break
    } }
  }
  return cachedPreserveItems
}

// :: (Transaction) → Transaction
// Set a flag on the given transaction that will prevent further steps
// from being appended to an existing history event (so that they
// require a separate undo command to undo).
function closeHistory(tr) {
  return tr.setMeta(closeHistoryKey, true)
}

var historyKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey("history");
var closeHistoryKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey("closeHistory");

// :: (?Object) → Plugin
// Returns a plugin that enables the undo history for an editor. The
// plugin will track undo and redo stacks, which can be used with the
// [`undo`](#history.undo) and [`redo`](#history.redo) commands.
//
// You can set an `"addToHistory"` [metadata
// property](#state.Transaction.setMeta) of `false` on a transaction
// to prevent it from being rolled back by undo.
//
//   config::-
//   Supports the following configuration options:
//
//     depth:: ?number
//     The amount of history events that are collected before the
//     oldest events are discarded. Defaults to 100.
//
//     newGroupDelay:: ?number
//     The delay between changes after which a new group should be
//     started. Defaults to 500 (milliseconds). Note that when changes
//     aren't adjacent, a new group is always started.
function history(config) {
  config = {depth: config && config.depth || 100,
            newGroupDelay: config && config.newGroupDelay || 500};
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({
    key: historyKey,

    state: {
      init: function init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0)
      },
      apply: function apply(tr, hist, state) {
        return applyTransaction(hist, state, tr, config)
      }
    },

    config: config,

    props: {
      handleDOMEvents: {
        beforeinput: function beforeinput(view, e) {
          var handled = e.inputType == "historyUndo" ? undo(view.state, view.dispatch) :
              e.inputType == "historyRedo" ? redo(view.state, view.dispatch) : false;
          if (handled) { e.preventDefault(); }
          return handled
        }
      }
    }
  })
}

// :: (EditorState, ?(tr: Transaction)) → bool
// A command function that undoes the last change, if any.
function undo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0) { return false }
  if (dispatch) { histTransaction(hist, state, dispatch, false); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// A command function that redoes the last undone change, if any.
function redo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0) { return false }
  if (dispatch) { histTransaction(hist, state, dispatch, true); }
  return true
}

// :: (EditorState) → number
// The amount of undoable events available in a given state.
function undoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.done.eventCount : 0
}

// :: (EditorState) → number
// The amount of redoable events available in a given editor state.
function redoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.undone.eventCount : 0
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-inputrules/dist/index.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/prosemirror-inputrules/dist/index.es.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ellipsis": () => (/* binding */ ellipsis),
/* harmony export */   "emDash": () => (/* binding */ emDash),
/* harmony export */   "inputRules": () => (/* binding */ inputRules),
/* harmony export */   "smartQuotes": () => (/* binding */ smartQuotes),
/* harmony export */   "textblockTypeInputRule": () => (/* binding */ textblockTypeInputRule),
/* harmony export */   "undoInputRule": () => (/* binding */ undoInputRule),
/* harmony export */   "wrappingInputRule": () => (/* binding */ wrappingInputRule)
/* harmony export */ });
/* unused harmony exports InputRule, closeDoubleQuote, closeSingleQuote, openDoubleQuote, openSingleQuote */
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");



// ::- Input rules are regular expressions describing a piece of text
// that, when typed, causes something to happen. This might be
// changing two dashes into an emdash, wrapping a paragraph starting
// with `"> "` into a blockquote, or something entirely different.
var InputRule = function InputRule(match, handler) {
  this.match = match;
  this.handler = typeof handler == "string" ? stringHandler(handler) : handler;
};

function stringHandler(string) {
  return function(state, match, start, end) {
    var insert = string;
    if (match[1]) {
      var offset = match[0].lastIndexOf(match[1]);
      insert += match[0].slice(offset + match[1].length);
      start += offset;
      var cutOff = start - end;
      if (cutOff > 0) {
        insert = match[0].slice(offset - cutOff, offset) + insert;
        start = end;
      }
    }
    return state.tr.insertText(insert, start, end)
  }
}

var MAX_MATCH = 500;

// :: (config: {rules: [InputRule]}) → Plugin
// Create an input rules plugin. When enabled, it will cause text
// input that matches any of the given rules to trigger the rule's
// action.
function inputRules(ref) {
  var rules = ref.rules;

  var plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
    state: {
      init: function init() { return null },
      apply: function apply(tr, prev) {
        var stored = tr.getMeta(this);
        if (stored) { return stored }
        return tr.selectionSet || tr.docChanged ? null : prev
      }
    },

    props: {
      handleTextInput: function handleTextInput(view, from, to, text) {
        return run(view, from, to, text, rules, plugin)
      },
      handleDOMEvents: {
        compositionend: function (view) {
          setTimeout(function () {
            var ref = view.state.selection;
            var $cursor = ref.$cursor;
            if ($cursor) { run(view, $cursor.pos, $cursor.pos, "", rules, plugin); }
          });
        }
      }
    },

    isInputRules: true
  });
  return plugin
}

function run(view, from, to, text, rules, plugin) {
  if (view.composing) { return false }
  var state = view.state, $from = state.doc.resolve(from);
  if ($from.parent.type.spec.code) { return false }
  var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,
                                            null, "\ufffc") + text;
  for (var i = 0; i < rules.length; i++) {
    var match = rules[i].match.exec(textBefore);
    var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);
    if (!tr) { continue }
    view.dispatch(tr.setMeta(plugin, {transform: tr, from: from, to: to, text: text}));
    return true
  }
  return false
}

// :: (EditorState, ?(Transaction)) → bool
// This is a command that will undo an input rule, if applying such a
// rule was the last thing that the user did.
function undoInputRule(state, dispatch) {
  var plugins = state.plugins;
  for (var i = 0; i < plugins.length; i++) {
    var plugin = plugins[i], undoable = (void 0);
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        var tr = state.tr, toUndo = undoable.transform;
        for (var j = toUndo.steps.length - 1; j >= 0; j--)
          { tr.step(toUndo.steps[j].invert(toUndo.docs[j])); }
        if (undoable.text) {
          var marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
        dispatch(tr);
      }
      return true
    }
  }
  return false
}

// :: InputRule Converts double dashes to an emdash.
var emDash = new InputRule(/--$/, "—");
// :: InputRule Converts three dots to an ellipsis character.
var ellipsis = new InputRule(/\.\.\.$/, "…");
// :: InputRule “Smart” opening double quotes.
var openDoubleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“");
// :: InputRule “Smart” closing double quotes.
var closeDoubleQuote = new InputRule(/"$/, "”");
// :: InputRule “Smart” opening single quotes.
var openSingleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘");
// :: InputRule “Smart” closing single quotes.
var closeSingleQuote = new InputRule(/'$/, "’");

// :: [InputRule] Smart-quote related input rules.
var smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];

// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule
// Build an input rule for automatically wrapping a textblock when a
// given string is typed. The `regexp` argument is
// directly passed through to the `InputRule` constructor. You'll
// probably want the regexp to start with `^`, so that the pattern can
// only occur at the start of a textblock.
//
// `nodeType` is the type of node to wrap in. If it needs attributes,
// you can either pass them directly, or pass a function that will
// compute them from the regular expression match.
//
// By default, if there's a node with the same type above the newly
// wrapped node, the rule will try to [join](#transform.Transform.join) those
// two nodes. You can pass a join predicate, which takes a regular
// expression match and the node before the wrapped node, and can
// return a boolean to indicate whether a join should happen.
function wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {
  return new InputRule(regexp, function (state, match, start, end) {
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    var tr = state.tr.delete(start, end);
    var $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.findWrapping)(range, nodeType, attrs);
    if (!wrapping) { return null }
    tr.wrap(range, wrapping);
    var before = tr.doc.resolve(start - 1).nodeBefore;
    if (before && before.type == nodeType && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canJoin)(tr.doc, start - 1) &&
        (!joinPredicate || joinPredicate(match, before)))
      { tr.join(start - 1); }
    return tr
  })
}

// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule
// Build an input rule that changes the type of a textblock when the
// matched text is typed into it. You'll usually want to start your
// regexp with `^` to that it is only matched at the start of a
// textblock. The optional `getAttrs` parameter can be used to compute
// the new node's attributes, and works the same as in the
// `wrappingInputRule` function.
function textblockTypeInputRule(regexp, nodeType, getAttrs) {
  return new InputRule(regexp, function (state, match, start, end) {
    var $start = state.doc.resolve(start);
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) { return null }
    return state.tr
      .delete(start, end)
      .setBlockType(start, start, nodeType, attrs)
  })
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-keymap/dist/index.es.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-keymap/dist/index.es.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "keydownHandler": () => (/* binding */ keydownHandler),
/* harmony export */   "keymap": () => (/* binding */ keymap)
/* harmony export */ });
/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! w3c-keyname */ "./node_modules/w3c-keyname/index.es.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");



// declare global: navigator

var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;

function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space") { result = " "; }
  var alt, ctrl, shift, meta;
  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) { meta = true; }
    else if (/^a(lt)?$/i.test(mod)) { alt = true; }
    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
    else if (/^s(hift)?$/i.test(mod)) { shift = true; }
    else if (/^mod$/i.test(mod)) { if (mac) { meta = true; } else { ctrl = true; } }
    else { throw new Error("Unrecognized modifier name: " + mod) }
  }
  if (alt) { result = "Alt-" + result; }
  if (ctrl) { result = "Ctrl-" + result; }
  if (meta) { result = "Meta-" + result; }
  if (shift) { result = "Shift-" + result; }
  return result
}

function normalize(map) {
  var copy = Object.create(null);
  for (var prop in map) { copy[normalizeKeyName(prop)] = map[prop]; }
  return copy
}

function modifiers(name, event, shift) {
  if (event.altKey) { name = "Alt-" + name; }
  if (event.ctrlKey) { name = "Ctrl-" + name; }
  if (event.metaKey) { name = "Meta-" + name; }
  if (shift !== false && event.shiftKey) { name = "Shift-" + name; }
  return name
}

// :: (Object) → Plugin
// Create a keymap plugin for the given set of bindings.
//
// Bindings should map key names to [command](#commands)-style
// functions, which will be called with `(EditorState, dispatch,
// EditorView)` arguments, and should return true when they've handled
// the key. Note that the view argument isn't part of the command
// protocol, but can be used as an escape hatch if a binding needs to
// directly interact with the UI.
//
// Key names may be strings like `"Shift-Ctrl-Enter"`—a key
// identifier prefixed with zero or more modifiers. Key identifiers
// are based on the strings that can appear in
// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).
// Use lowercase letters to refer to letter keys (or uppercase letters
// if you want shift to be held). You may use `"Space"` as an alias
// for the `" "` name.
//
// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or
// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or
// `Meta-`) are recognized. For characters that are created by holding
// shift, the `Shift-` prefix is implied, and should not be added
// explicitly.
//
// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on
// other platforms.
//
// You can add multiple keymap plugins to an editor. The order in
// which they appear determines their precedence (the ones early in
// the array get to dispatch first).
function keymap(bindings) {
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({props: {handleKeyDown: keydownHandler(bindings)}})
}

// :: (Object) → (view: EditorView, event: dom.Event) → bool
// Given a set of bindings (using the same format as
// [`keymap`](#keymap.keymap)), return a [keydown
// handler](#view.EditorProps.handleKeyDown) that handles them.
function keydownHandler(bindings) {
  var map = normalize(bindings);
  return function(view, event) {
    var name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.keyName)(event), isChar = name.length == 1 && name != " ", baseName;
    var direct = map[modifiers(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view)) { return true }
    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&
        (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.base[event.keyCode]) && baseName != name) {
      // Try falling back to the keyCode when there's a modifier
      // active or the character produced isn't ASCII, and our table
      // produces a different name from the the keyCode. See #668,
      // #1060
      var fromCode = map[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view)) { return true }
    } else if (isChar && event.shiftKey) {
      // Otherwise, if shift is active, also try the binding with the
      // Shift- prefix enabled. See #997
      var withShift = map[modifiers(name, event, true)];
      if (withShift && withShift(view.state, view.dispatch, view)) { return true }
    }
    return false
  }
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-menu/dist/index.es.js":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-menu/dist/index.es.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dropdown": () => (/* binding */ Dropdown),
/* harmony export */   "DropdownSubmenu": () => (/* binding */ DropdownSubmenu),
/* harmony export */   "MenuItem": () => (/* binding */ MenuItem),
/* harmony export */   "blockTypeItem": () => (/* binding */ blockTypeItem),
/* harmony export */   "icons": () => (/* binding */ icons),
/* harmony export */   "joinUpItem": () => (/* binding */ joinUpItem),
/* harmony export */   "liftItem": () => (/* binding */ liftItem),
/* harmony export */   "menuBar": () => (/* binding */ menuBar),
/* harmony export */   "redoItem": () => (/* binding */ redoItem),
/* harmony export */   "selectParentNodeItem": () => (/* binding */ selectParentNodeItem),
/* harmony export */   "undoItem": () => (/* binding */ undoItem),
/* harmony export */   "wrapItem": () => (/* binding */ wrapItem)
/* harmony export */ });
/* unused harmony export renderGrouped */
/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ "./node_modules/crelt/index.es.js");
/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-commands */ "./node_modules/prosemirror-commands/dist/index.es.js");
/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-history */ "./node_modules/prosemirror-history/dist/index.es.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");





var SVG = "http://www.w3.org/2000/svg";
var XLINK = "http://www.w3.org/1999/xlink";

var prefix = "ProseMirror-icon";

function hashPath(path) {
  var hash = 0;
  for (var i = 0; i < path.length; i++)
    { hash = (((hash << 5) - hash) + path.charCodeAt(i)) | 0; }
  return hash
}

function getIcon(icon) {
  var node = document.createElement("div");
  node.className = prefix;
  if (icon.path) {
    var name = "pm-icon-" + hashPath(icon.path).toString(16);
    if (!document.getElementById(name)) { buildSVG(name, icon); }
    var svg = node.appendChild(document.createElementNS(SVG, "svg"));
    svg.style.width = (icon.width / icon.height) + "em";
    var use = svg.appendChild(document.createElementNS(SVG, "use"));
    use.setAttributeNS(XLINK, "href", /([^#]*)/.exec(document.location)[1] + "#" + name);
  } else if (icon.dom) {
    node.appendChild(icon.dom.cloneNode(true));
  } else {
    node.appendChild(document.createElement("span")).textContent = icon.text || '';
    if (icon.css) { node.firstChild.style.cssText = icon.css; }
  }
  return node
}

function buildSVG(name, data) {
  var collection = document.getElementById(prefix + "-collection");
  if (!collection) {
    collection = document.createElementNS(SVG, "svg");
    collection.id = prefix + "-collection";
    collection.style.display = "none";
    document.body.insertBefore(collection, document.body.firstChild);
  }
  var sym = document.createElementNS(SVG, "symbol");
  sym.id = name;
  sym.setAttribute("viewBox", "0 0 " + data.width + " " + data.height);
  var path = sym.appendChild(document.createElementNS(SVG, "path"));
  path.setAttribute("d", data.path);
  collection.appendChild(sym);
}

var prefix$1 = "ProseMirror-menu";

// ::- An icon or label that, when clicked, executes a command.
var MenuItem = function MenuItem(spec) {
  // :: MenuItemSpec
  // The spec used to create the menu item.
  this.spec = spec;
};

// :: (EditorView) → {dom: dom.Node, update: (EditorState) → bool}
// Renders the icon according to its [display
// spec](#menu.MenuItemSpec.display), and adds an event handler which
// executes the command when the representation is clicked.
MenuItem.prototype.render = function render (view) {
  var spec = this.spec;
  var dom = spec.render ? spec.render(view)
      : spec.icon ? getIcon(spec.icon)
      : spec.label ? (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", null, translate(view, spec.label))
      : null;
  if (!dom) { throw new RangeError("MenuItem without icon or label property") }
  if (spec.title) {
    var title = (typeof spec.title === "function" ? spec.title(view.state) : spec.title);
    dom.setAttribute("title", translate(view, title));
  }
  if (spec.class) { dom.classList.add(spec.class); }
  if (spec.css) { dom.style.cssText += spec.css; }

  dom.addEventListener("mousedown", function (e) {
    e.preventDefault();
    if (!dom.classList.contains(prefix$1 + "-disabled"))
      { spec.run(view.state, view.dispatch, view, e); }
  });

  function update(state) {
    if (spec.select) {
      var selected = spec.select(state);
      dom.style.display = selected ? "" : "none";
      if (!selected) { return false }
    }
    var enabled = true;
    if (spec.enable) {
      enabled = spec.enable(state) || false;
      setClass(dom, prefix$1 + "-disabled", !enabled);
    }
    if (spec.active) {
      var active = enabled && spec.active(state) || false;
      setClass(dom, prefix$1 + "-active", active);
    }
    return true
  }

  return {dom: dom, update: update}
};

function translate(view, text) {
  return view._props.translate ? view._props.translate(text) : text
}

// MenuItemSpec:: interface
// The configuration object passed to the `MenuItem` constructor.
//
//   run:: (EditorState, (Transaction), EditorView, dom.Event)
//   The function to execute when the menu item is activated.
//
//   select:: ?(EditorState) → bool
//   Optional function that is used to determine whether the item is
//   appropriate at the moment. Deselected items will be hidden.
//
//   enable:: ?(EditorState) → bool
//   Function that is used to determine if the item is enabled. If
//   given and returning false, the item will be given a disabled
//   styling.
//
//   active:: ?(EditorState) → bool
//   A predicate function to determine whether the item is 'active' (for
//   example, the item for toggling the strong mark might be active then
//   the cursor is in strong text).
//
//   render:: ?(EditorView) → dom.Node
//   A function that renders the item. You must provide either this,
//   [`icon`](#menu.MenuItemSpec.icon), or [`label`](#MenuItemSpec.label).
//
//   icon:: ?Object
//   Describes an icon to show for this item. The object may specify
//   an SVG icon, in which case its `path` property should be an [SVG
//   path
//   spec](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d),
//   and `width` and `height` should provide the viewbox in which that
//   path exists. Alternatively, it may have a `text` property
//   specifying a string of text that makes up the icon, with an
//   optional `css` property giving additional CSS styling for the
//   text. _Or_ it may contain `dom` property containing a DOM node.
//
//   label:: ?string
//   Makes the item show up as a text label. Mostly useful for items
//   wrapped in a [drop-down](#menu.Dropdown) or similar menu. The object
//   should have a `label` property providing the text to display.
//
//   title:: ?union<string, (EditorState) → string>
//   Defines DOM title (mouseover) text for the item.
//
//   class:: ?string
//   Optionally adds a CSS class to the item's DOM representation.
//
//   css:: ?string
//   Optionally adds a string of inline CSS to the item's DOM
//   representation.

var lastMenuEvent = {time: 0, node: null};
function markMenuEvent(e) {
  lastMenuEvent.time = Date.now();
  lastMenuEvent.node = e.target;
}
function isMenuEvent(wrapper) {
  return Date.now() - 100 < lastMenuEvent.time &&
    lastMenuEvent.node && wrapper.contains(lastMenuEvent.node)
}

// ::- A drop-down menu, displayed as a label with a downwards-pointing
// triangle to the right of it.
var Dropdown = function Dropdown(content, options) {
  this.options = options || {};
  this.content = Array.isArray(content) ? content : [content];
};

// :: (EditorView) → {dom: dom.Node, update: (EditorState)}
// Render the dropdown menu and sub-items.
Dropdown.prototype.render = function render (view) {
    var this$1 = this;

  var content = renderDropdownItems(this.content, view);

  var label = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-dropdown " + (this.options.class || ""),
                           style: this.options.css},
                   translate(view, this.options.label));
  if (this.options.title) { label.setAttribute("title", translate(view, this.options.title)); }
  var wrap = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-dropdown-wrap"}, label);
  var open = null, listeningOnClose = null;
  var close = function () {
    if (open && open.close()) {
      open = null;
      window.removeEventListener("mousedown", listeningOnClose);
    }
  };
  label.addEventListener("mousedown", function (e) {
    e.preventDefault();
    markMenuEvent(e);
    if (open) {
      close();
    } else {
      open = this$1.expand(wrap, content.dom);
      window.addEventListener("mousedown", listeningOnClose = function () {
        if (!isMenuEvent(wrap)) { close(); }
      });
    }
  });

  function update(state) {
    var inner = content.update(state);
    wrap.style.display = inner ? "" : "none";
    return inner
  }

  return {dom: wrap, update: update}
};

Dropdown.prototype.expand = function expand (dom, items) {
  var menuDOM = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-dropdown-menu " + (this.options.class || "")}, items);

  var done = false;
  function close() {
    if (done) { return }
    done = true;
    dom.removeChild(menuDOM);
    return true
  }
  dom.appendChild(menuDOM);
  return {close: close, node: menuDOM}
};

function renderDropdownItems(items, view) {
  var rendered = [], updates = [];
  for (var i = 0; i < items.length; i++) {
    var ref = items[i].render(view);
    var dom = ref.dom;
    var update = ref.update;
    rendered.push((0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-dropdown-item"}, dom));
    updates.push(update);
  }
  return {dom: rendered, update: combineUpdates(updates, rendered)}
}

function combineUpdates(updates, nodes) {
  return function (state) {
    var something = false;
    for (var i = 0; i < updates.length; i++) {
      var up = updates[i](state);
      nodes[i].style.display = up ? "" : "none";
      if (up) { something = true; }
    }
    return something
  }
}

// ::- Represents a submenu wrapping a group of elements that start
// hidden and expand to the right when hovered over or tapped.
var DropdownSubmenu = function DropdownSubmenu(content, options) {
  this.options = options || {};
  this.content = Array.isArray(content) ? content : [content];
};

// :: (EditorView) → {dom: dom.Node, update: (EditorState) → bool}
// Renders the submenu.
DropdownSubmenu.prototype.render = function render (view) {
  var items = renderDropdownItems(this.content, view);

  var label = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-submenu-label"}, translate(view, this.options.label));
  var wrap = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-submenu-wrap"}, label,
                 (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-submenu"}, items.dom));
  var listeningOnClose = null;
  label.addEventListener("mousedown", function (e) {
    e.preventDefault();
    markMenuEvent(e);
    setClass(wrap, prefix$1 + "-submenu-wrap-active");
    if (!listeningOnClose)
      { window.addEventListener("mousedown", listeningOnClose = function () {
        if (!isMenuEvent(wrap)) {
          wrap.classList.remove(prefix$1 + "-submenu-wrap-active");
          window.removeEventListener("mousedown", listeningOnClose);
          listeningOnClose = null;
        }
      }); }
  });

  function update(state) {
    var inner = items.update(state);
    wrap.style.display = inner ? "" : "none";
    return inner
  }
  return {dom: wrap, update: update}
};

// :: (EditorView, [union<MenuElement, [MenuElement]>]) → {dom: ?dom.DocumentFragment, update: (EditorState) → bool}
// Render the given, possibly nested, array of menu elements into a
// document fragment, placing separators between them (and ensuring no
// superfluous separators appear when some of the groups turn out to
// be empty).
function renderGrouped(view, content) {
  var result = document.createDocumentFragment();
  var updates = [], separators = [];
  for (var i = 0; i < content.length; i++) {
    var items = content[i], localUpdates = [], localNodes = [];
    for (var j = 0; j < items.length; j++) {
      var ref = items[j].render(view);
      var dom = ref.dom;
      var update$1 = ref.update;
      var span = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {class: prefix$1 + "item"}, dom);
      result.appendChild(span);
      localNodes.push(span);
      localUpdates.push(update$1);
    }
    if (localUpdates.length) {
      updates.push(combineUpdates(localUpdates, localNodes));
      if (i < content.length - 1)
        { separators.push(result.appendChild(separator())); }
    }
  }

  function update(state) {
    var something = false, needSep = false;
    for (var i = 0; i < updates.length; i++) {
      var hasContent = updates[i](state);
      if (i) { separators[i - 1].style.display = needSep && hasContent ? "" : "none"; }
      needSep = hasContent;
      if (hasContent) { something = true; }
    }
    return something
  }
  return {dom: result, update: update}
}

function separator() {
  return (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {class: prefix$1 + "separator"})
}

// :: Object
// A set of basic editor-related icons. Contains the properties
// `join`, `lift`, `selectParentNode`, `undo`, `redo`, `strong`, `em`,
// `code`, `link`, `bulletList`, `orderedList`, and `blockquote`, each
// holding an object that can be used as the `icon` option to
// `MenuItem`.
var icons = {
  join: {
    width: 800, height: 900,
    path: "M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z"
  },
  lift: {
    width: 1024, height: 1024,
    path: "M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z"
  },
  selectParentNode: {text: "\u2b1a", css: "font-weight: bold"},
  undo: {
    width: 1024, height: 1024,
    path: "M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z"
  },
  redo: {
    width: 1024, height: 1024,
    path: "M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z"
  },
  strong: {
    width: 805, height: 1024,
    path: "M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z"
  },
  em: {
    width: 585, height: 1024,
    path: "M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z"
  },
  code: {
    width: 896, height: 1024,
    path: "M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z"
  },
  link: {
    width: 951, height: 1024,
    path: "M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z"
  },
  bulletList: {
    width: 768, height: 896,
    path: "M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z"
  },
  orderedList: {
    width: 768, height: 896,
    path: "M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z"
  },
  blockquote: {
    width: 640, height: 896,
    path: "M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z"
  }
};

// :: MenuItem
// Menu item for the `joinUp` command.
var joinUpItem = new MenuItem({
  title: "Join with above block",
  run: prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.joinUp,
  select: function (state) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.joinUp)(state); },
  icon: icons.join
});

// :: MenuItem
// Menu item for the `lift` command.
var liftItem = new MenuItem({
  title: "Lift out of enclosing block",
  run: prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.lift,
  select: function (state) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.lift)(state); },
  icon: icons.lift
});

// :: MenuItem
// Menu item for the `selectParentNode` command.
var selectParentNodeItem = new MenuItem({
  title: "Select parent node",
  run: prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.selectParentNode,
  select: function (state) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.selectParentNode)(state); },
  icon: icons.selectParentNode
});

// :: MenuItem
// Menu item for the `undo` command.
var undoItem = new MenuItem({
  title: "Undo last change",
  run: prosemirror_history__WEBPACK_IMPORTED_MODULE_2__.undo,
  enable: function (state) { return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_2__.undo)(state); },
  icon: icons.undo
});

// :: MenuItem
// Menu item for the `redo` command.
var redoItem = new MenuItem({
  title: "Redo last undone change",
  run: prosemirror_history__WEBPACK_IMPORTED_MODULE_2__.redo,
  enable: function (state) { return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_2__.redo)(state); },
  icon: icons.redo
});

// :: (NodeType, Object) → MenuItem
// Build a menu item for wrapping the selection in a given node type.
// Adds `run` and `select` properties to the ones present in
// `options`. `options.attrs` may be an object or a function.
function wrapItem(nodeType, options) {
  var passedOptions = {
    run: function run(state, dispatch) {
      // FIXME if (options.attrs instanceof Function) options.attrs(state, attrs => wrapIn(nodeType, attrs)(state))
      return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.wrapIn)(nodeType, options.attrs)(state, dispatch)
    },
    select: function select(state) {
      return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.wrapIn)(nodeType, options.attrs instanceof Function ? null : options.attrs)(state)
    }
  };
  for (var prop in options) { passedOptions[prop] = options[prop]; }
  return new MenuItem(passedOptions)
}

// :: (NodeType, Object) → MenuItem
// Build a menu item for changing the type of the textblock around the
// selection to the given type. Provides `run`, `active`, and `select`
// properties. Others must be given in `options`. `options.attrs` may
// be an object to provide the attributes for the textblock node.
function blockTypeItem(nodeType, options) {
  var command = (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.setBlockType)(nodeType, options.attrs);
  var passedOptions = {
    run: command,
    enable: function enable(state) { return command(state) },
    active: function active(state) {
      var ref = state.selection;
      var $from = ref.$from;
      var to = ref.to;
      var node = ref.node;
      if (node) { return node.hasMarkup(nodeType, options.attrs) }
      return to <= $from.end() && $from.parent.hasMarkup(nodeType, options.attrs)
    }
  };
  for (var prop in options) { passedOptions[prop] = options[prop]; }
  return new MenuItem(passedOptions)
}

// Work around classList.toggle being broken in IE11
function setClass(dom, cls, on) {
  if (on) { dom.classList.add(cls); }
  else { dom.classList.remove(cls); }
}

var prefix$2 = "ProseMirror-menubar";

function isIOS() {
  if (typeof navigator == "undefined") { return false }
  var agent = navigator.userAgent;
  return !/Edge\/\d/.test(agent) && /AppleWebKit/.test(agent) && /Mobile\/\w+/.test(agent)
}

// :: (Object) → Plugin
// A plugin that will place a menu bar above the editor. Note that
// this involves wrapping the editor in an additional `<div>`.
//
//   options::-
//   Supports the following options:
//
//     content:: [[MenuElement]]
//     Provides the content of the menu, as a nested array to be
//     passed to `renderGrouped`.
//
//     floating:: ?bool
//     Determines whether the menu floats, i.e. whether it sticks to
//     the top of the viewport when the editor is partially scrolled
//     out of view.
function menuBar(options) {
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({
    view: function view(editorView) { return new MenuBarView(editorView, options) }
  })
}

var MenuBarView = function MenuBarView(editorView, options) {
  var this$1 = this;

  this.editorView = editorView;
  this.options = options;

  this.wrapper = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$2 + "-wrapper"});
  this.menu = this.wrapper.appendChild((0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$2}));
  this.menu.className = prefix$2;
  this.spacer = null;

  editorView.dom.parentNode.replaceChild(this.wrapper, editorView.dom);
  this.wrapper.appendChild(editorView.dom);

  this.maxHeight = 0;
  this.widthForMaxHeight = 0;
  this.floating = false;

  var ref = renderGrouped(this.editorView, this.options.content);
  var dom = ref.dom;
  var update = ref.update;
  this.contentUpdate = update;
  this.menu.appendChild(dom);
  this.update();

  if (options.floating && !isIOS()) {
    this.updateFloat();
    var potentialScrollers = getAllWrapping(this.wrapper);
    this.scrollFunc = function (e) {
      var root = this$1.editorView.root;
      if (!(root.body || root).contains(this$1.wrapper)) {
          potentialScrollers.forEach(function (el) { return el.removeEventListener("scroll", this$1.scrollFunc); });
      } else {
          this$1.updateFloat(e.target.getBoundingClientRect && e.target);
      }
    };
    potentialScrollers.forEach(function (el) { return el.addEventListener('scroll', this$1.scrollFunc); });
  }
};

MenuBarView.prototype.update = function update () {
  this.contentUpdate(this.editorView.state);

  if (this.floating) {
    this.updateScrollCursor();
  } else {
    if (this.menu.offsetWidth != this.widthForMaxHeight) {
      this.widthForMaxHeight = this.menu.offsetWidth;
      this.maxHeight = 0;
    }
    if (this.menu.offsetHeight > this.maxHeight) {
      this.maxHeight = this.menu.offsetHeight;
      this.menu.style.minHeight = this.maxHeight + "px";
    }
  }
};

MenuBarView.prototype.updateScrollCursor = function updateScrollCursor () {
  var selection = this.editorView.root.getSelection();
  if (!selection.focusNode) { return }
  var rects = selection.getRangeAt(0).getClientRects();
  var selRect = rects[selectionIsInverted(selection) ? 0 : rects.length - 1];
  if (!selRect) { return }
  var menuRect = this.menu.getBoundingClientRect();
  if (selRect.top < menuRect.bottom && selRect.bottom > menuRect.top) {
    var scrollable = findWrappingScrollable(this.wrapper);
    if (scrollable) { scrollable.scrollTop -= (menuRect.bottom - selRect.top); }
  }
};

MenuBarView.prototype.updateFloat = function updateFloat (scrollAncestor) {
  var parent = this.wrapper, editorRect = parent.getBoundingClientRect(),
      top = scrollAncestor ? Math.max(0, scrollAncestor.getBoundingClientRect().top) : 0;

  if (this.floating) {
    if (editorRect.top >= top || editorRect.bottom < this.menu.offsetHeight + 10) {
      this.floating = false;
      this.menu.style.position = this.menu.style.left = this.menu.style.top = this.menu.style.width = "";
      this.menu.style.display = "";
      this.spacer.parentNode.removeChild(this.spacer);
      this.spacer = null;
    } else {
      var border = (parent.offsetWidth - parent.clientWidth) / 2;
      this.menu.style.left = (editorRect.left + border) + "px";
      this.menu.style.display = (editorRect.top > window.innerHeight ? "none" : "");
      if (scrollAncestor) { this.menu.style.top = top + "px"; }
    }
  } else {
    if (editorRect.top < top && editorRect.bottom >= this.menu.offsetHeight + 10) {
      this.floating = true;
      var menuRect = this.menu.getBoundingClientRect();
      this.menu.style.left = menuRect.left + "px";
      this.menu.style.width = menuRect.width + "px";
      if (scrollAncestor) { this.menu.style.top = top + "px"; }
      this.menu.style.position = "fixed";
      this.spacer = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$2 + "-spacer", style: ("height: " + (menuRect.height) + "px")});
      parent.insertBefore(this.spacer, this.menu);
    }
  }
};

MenuBarView.prototype.destroy = function destroy () {
  if (this.wrapper.parentNode)
    { this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper); }
};

// Not precise, but close enough
function selectionIsInverted(selection) {
  if (selection.anchorNode == selection.focusNode) { return selection.anchorOffset > selection.focusOffset }
  return selection.anchorNode.compareDocumentPosition(selection.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING
}

function findWrappingScrollable(node) {
  for (var cur = node.parentNode; cur; cur = cur.parentNode)
    { if (cur.scrollHeight > cur.clientHeight) { return cur } }
}

function getAllWrapping(node) {
    var res = [window];
    for (var cur = node.parentNode; cur; cur = cur.parentNode)
        { res.push(cur); }
    return res
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-model/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-model/dist/index.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContentMatch": () => (/* binding */ ContentMatch),
/* harmony export */   "DOMParser": () => (/* binding */ DOMParser),
/* harmony export */   "DOMSerializer": () => (/* binding */ DOMSerializer),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "Mark": () => (/* binding */ Mark),
/* harmony export */   "MarkType": () => (/* binding */ MarkType),
/* harmony export */   "Node": () => (/* binding */ Node),
/* harmony export */   "NodeRange": () => (/* binding */ NodeRange),
/* harmony export */   "NodeType": () => (/* binding */ NodeType),
/* harmony export */   "ReplaceError": () => (/* binding */ ReplaceError),
/* harmony export */   "ResolvedPos": () => (/* binding */ ResolvedPos),
/* harmony export */   "Schema": () => (/* binding */ Schema),
/* harmony export */   "Slice": () => (/* binding */ Slice)
/* harmony export */ });
/* harmony import */ var orderedmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orderedmap */ "./node_modules/orderedmap/index.es.js");


function findDiffStart(a, b, pos) {
  for (var i = 0;; i++) {
    if (i == a.childCount || i == b.childCount)
      { return a.childCount == b.childCount ? null : pos }

    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) { pos += childA.nodeSize; continue }

    if (!childA.sameMarkup(childB)) { return pos }

    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++)
        { pos++; }
      return pos
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null) { return inner }
    }
    pos += childA.nodeSize;
  }
}

function findDiffEnd(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount;;) {
    if (iA == 0 || iB == 0)
      { return iA == iB ? null : {a: posA, b: posB} }

    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size; posB -= size;
      continue
    }

    if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }

    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++; posA--; posB--;
      }
      return {a: posA, b: posB}
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) { return inner }
    }
    posA -= size; posB -= size;
  }
}

// ::- A fragment represents a node's collection of child nodes.
//
// Like nodes, fragments are persistent data structures, and you
// should not mutate them or their content. Rather, you create new
// instances whenever needed. The API tries to make this easy.
var Fragment = function Fragment(content, size) {
  this.content = content;
  // :: number
  // The size of the fragment, which is the total of the size of its
  // content nodes.
  this.size = size || 0;
  if (size == null) { for (var i = 0; i < content.length; i++)
    { this.size += content[i].nodeSize; } }
};

var prototypeAccessors = { firstChild: { configurable: true },lastChild: { configurable: true },childCount: { configurable: true } };

// :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)
// Invoke a callback for all descendant nodes between the given two
// positions (relative to start of this fragment). Doesn't descend
// into a node when the callback returns `false`.
Fragment.prototype.nodesBetween = function nodesBetween (from, to, f, nodeStart, parent) {
    if ( nodeStart === void 0 ) nodeStart = 0;

  for (var i = 0, pos = 0; pos < to; i++) {
    var child = this.content[i], end = pos + child.nodeSize;
    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {
      var start = pos + 1;
      child.nodesBetween(Math.max(0, from - start),
                         Math.min(child.content.size, to - start),
                         f, nodeStart + start);
    }
    pos = end;
  }
};

// :: ((node: Node, pos: number, parent: Node) → ?bool)
// Call the given callback for every descendant node. The callback
// may return `false` to prevent traversal of a given node's children.
Fragment.prototype.descendants = function descendants (f) {
  this.nodesBetween(0, this.size, f);
};

// :: (number, number, ?string, ?string | ?(leafNode: Node) -> string) → string
// Extract the text between `from` and `to`. See the same method on
// [`Node`](#model.Node.textBetween).
Fragment.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {
  var text = "", separated = true;
  this.nodesBetween(from, to, function (node, pos) {
    if (node.isText) {
      text += node.text.slice(Math.max(from, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node.isLeaf && leafText) {
      text += typeof leafText === 'function' ? leafText(node): leafText;
      separated = !blockSeparator;
    } else if (!separated && node.isBlock) {
      text += blockSeparator;
      separated = true;
    }
  }, 0);
  return text
};

// :: (Fragment) → Fragment
// Create a new fragment containing the combined content of this
// fragment and the other.
Fragment.prototype.append = function append (other) {
  if (!other.size) { return this }
  if (!this.size) { return other }
  var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first)) {
    content[content.length - 1] = last.withText(last.text + first.text);
    i = 1;
  }
  for (; i < other.content.length; i++) { content.push(other.content[i]); }
  return new Fragment(content, this.size + other.size)
};

// :: (number, ?number) → Fragment
// Cut out the sub-fragment between the two given positions.
Fragment.prototype.cut = function cut (from, to) {
  if (to == null) { to = this.size; }
  if (from == 0 && to == this.size) { return this }
  var result = [], size = 0;
  if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {
    var child = this.content[i], end = pos + child.nodeSize;
    if (end > from) {
      if (pos < from || end > to) {
        if (child.isText)
          { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)); }
        else
          { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)); }
      }
      result.push(child);
      size += child.nodeSize;
    }
    pos = end;
  } }
  return new Fragment(result, size)
};

Fragment.prototype.cutByIndex = function cutByIndex (from, to) {
  if (from == to) { return Fragment.empty }
  if (from == 0 && to == this.content.length) { return this }
  return new Fragment(this.content.slice(from, to))
};

// :: (number, Node) → Fragment
// Create a new fragment in which the node at the given index is
// replaced by the given node.
Fragment.prototype.replaceChild = function replaceChild (index, node) {
  var current = this.content[index];
  if (current == node) { return this }
  var copy = this.content.slice();
  var size = this.size + node.nodeSize - current.nodeSize;
  copy[index] = node;
  return new Fragment(copy, size)
};

// : (Node) → Fragment
// Create a new fragment by prepending the given node to this
// fragment.
Fragment.prototype.addToStart = function addToStart (node) {
  return new Fragment([node].concat(this.content), this.size + node.nodeSize)
};

// : (Node) → Fragment
// Create a new fragment by appending the given node to this
// fragment.
Fragment.prototype.addToEnd = function addToEnd (node) {
  return new Fragment(this.content.concat(node), this.size + node.nodeSize)
};

// :: (Fragment) → bool
// Compare this fragment to another one.
Fragment.prototype.eq = function eq (other) {
  if (this.content.length != other.content.length) { return false }
  for (var i = 0; i < this.content.length; i++)
    { if (!this.content[i].eq(other.content[i])) { return false } }
  return true
};

// :: ?Node
// The first child of the fragment, or `null` if it is empty.
prototypeAccessors.firstChild.get = function () { return this.content.length ? this.content[0] : null };

// :: ?Node
// The last child of the fragment, or `null` if it is empty.
prototypeAccessors.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };

// :: number
// The number of child nodes in this fragment.
prototypeAccessors.childCount.get = function () { return this.content.length };

// :: (number) → Node
// Get the child node at the given index. Raise an error when the
// index is out of range.
Fragment.prototype.child = function child (index) {
  var found = this.content[index];
  if (!found) { throw new RangeError("Index " + index + " out of range for " + this) }
  return found
};

// :: (number) → ?Node
// Get the child node at the given index, if it exists.
Fragment.prototype.maybeChild = function maybeChild (index) {
  return this.content[index]
};

// :: ((node: Node, offset: number, index: number))
// Call `f` for every child node, passing the node, its offset
// into this parent node, and its index.
Fragment.prototype.forEach = function forEach (f) {
  for (var i = 0, p = 0; i < this.content.length; i++) {
    var child = this.content[i];
    f(child, p, i);
    p += child.nodeSize;
  }
};

// :: (Fragment) → ?number
// Find the first position at which this fragment and another
// fragment differ, or `null` if they are the same.
Fragment.prototype.findDiffStart = function findDiffStart$1 (other, pos) {
    if ( pos === void 0 ) pos = 0;

  return findDiffStart(this, other, pos)
};

// :: (Fragment) → ?{a: number, b: number}
// Find the first position, searching from the end, at which this
// fragment and the given fragment differ, or `null` if they are the
// same. Since this position will not be the same in both nodes, an
// object with two separate positions is returned.
Fragment.prototype.findDiffEnd = function findDiffEnd$1 (other, pos, otherPos) {
    if ( pos === void 0 ) pos = this.size;
    if ( otherPos === void 0 ) otherPos = other.size;

  return findDiffEnd(this, other, pos, otherPos)
};

// : (number, ?number) → {index: number, offset: number}
// Find the index and inner offset corresponding to a given relative
// position in this fragment. The result object will be reused
// (overwritten) the next time the function is called. (Not public.)
Fragment.prototype.findIndex = function findIndex (pos, round) {
    if ( round === void 0 ) round = -1;

  if (pos == 0) { return retIndex(0, pos) }
  if (pos == this.size) { return retIndex(this.content.length, pos) }
  if (pos > this.size || pos < 0) { throw new RangeError(("Position " + pos + " outside of fragment (" + (this) + ")")) }
  for (var i = 0, curPos = 0;; i++) {
    var cur = this.child(i), end = curPos + cur.nodeSize;
    if (end >= pos) {
      if (end == pos || round > 0) { return retIndex(i + 1, end) }
      return retIndex(i, curPos)
    }
    curPos = end;
  }
};

// :: () → string
// Return a debugging string that describes this fragment.
Fragment.prototype.toString = function toString () { return "<" + this.toStringInner() + ">" };

Fragment.prototype.toStringInner = function toStringInner () { return this.content.join(", ") };

// :: () → ?Object
// Create a JSON-serializeable representation of this fragment.
Fragment.prototype.toJSON = function toJSON () {
  return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null
};

// :: (Schema, ?Object) → Fragment
// Deserialize a fragment from its JSON representation.
Fragment.fromJSON = function fromJSON (schema, value) {
  if (!value) { return Fragment.empty }
  if (!Array.isArray(value)) { throw new RangeError("Invalid input for Fragment.fromJSON") }
  return new Fragment(value.map(schema.nodeFromJSON))
};

// :: ([Node]) → Fragment
// Build a fragment from an array of nodes. Ensures that adjacent
// text nodes with the same marks are joined together.
Fragment.fromArray = function fromArray (array) {
  if (!array.length) { return Fragment.empty }
  var joined, size = 0;
  for (var i = 0; i < array.length; i++) {
    var node = array[i];
    size += node.nodeSize;
    if (i && node.isText && array[i - 1].sameMarkup(node)) {
      if (!joined) { joined = array.slice(0, i); }
      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
    } else if (joined) {
      joined.push(node);
    }
  }
  return new Fragment(joined || array, size)
};

// :: (?union<Fragment, Node, [Node]>) → Fragment
// Create a fragment from something that can be interpreted as a set
// of nodes. For `null`, it returns the empty fragment. For a
// fragment, the fragment itself. For a node or array of nodes, a
// fragment containing those nodes.
Fragment.from = function from (nodes) {
  if (!nodes) { return Fragment.empty }
  if (nodes instanceof Fragment) { return nodes }
  if (Array.isArray(nodes)) { return this.fromArray(nodes) }
  if (nodes.attrs) { return new Fragment([nodes], nodes.nodeSize) }
  throw new RangeError("Can not convert " + nodes + " to a Fragment" +
                       (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""))
};

Object.defineProperties( Fragment.prototype, prototypeAccessors );

var found = {index: 0, offset: 0};
function retIndex(index, offset) {
  found.index = index;
  found.offset = offset;
  return found
}

// :: Fragment
// An empty fragment. Intended to be reused whenever a node doesn't
// contain anything (rather than allocating a new empty fragment for
// each leaf node).
Fragment.empty = new Fragment([], 0);

function compareDeep(a, b) {
  if (a === b) { return true }
  if (!(a && typeof a == "object") ||
      !(b && typeof b == "object")) { return false }
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) { return false }
  if (array) {
    if (a.length != b.length) { return false }
    for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }
  } else {
    for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }
    for (var p$1 in b) { if (!(p$1 in a)) { return false } }
  }
  return true
}

// ::- A mark is a piece of information that can be attached to a node,
// such as it being emphasized, in code font, or a link. It has a type
// and optionally a set of attributes that provide further information
// (such as the target of the link). Marks are created through a
// `Schema`, which controls which types exist and which
// attributes they have.
var Mark = function Mark(type, attrs) {
  // :: MarkType
  // The type of this mark.
  this.type = type;
  // :: Object
  // The attributes associated with this mark.
  this.attrs = attrs;
};

// :: ([Mark]) → [Mark]
// Given a set of marks, create a new set which contains this one as
// well, in the right position. If this mark is already in the set,
// the set itself is returned. If any marks that are set to be
// [exclusive](#model.MarkSpec.excludes) with this mark are present,
// those are replaced by this one.
Mark.prototype.addToSet = function addToSet (set) {
  var copy, placed = false;
  for (var i = 0; i < set.length; i++) {
    var other = set[i];
    if (this.eq(other)) { return set }
    if (this.type.excludes(other.type)) {
      if (!copy) { copy = set.slice(0, i); }
    } else if (other.type.excludes(this.type)) {
      return set
    } else {
      if (!placed && other.type.rank > this.type.rank) {
        if (!copy) { copy = set.slice(0, i); }
        copy.push(this);
        placed = true;
      }
      if (copy) { copy.push(other); }
    }
  }
  if (!copy) { copy = set.slice(); }
  if (!placed) { copy.push(this); }
  return copy
};

// :: ([Mark]) → [Mark]
// Remove this mark from the given set, returning a new set. If this
// mark is not in the set, the set itself is returned.
Mark.prototype.removeFromSet = function removeFromSet (set) {
  for (var i = 0; i < set.length; i++)
    { if (this.eq(set[i]))
      { return set.slice(0, i).concat(set.slice(i + 1)) } }
  return set
};

// :: ([Mark]) → bool
// Test whether this mark is in the given set of marks.
Mark.prototype.isInSet = function isInSet (set) {
  for (var i = 0; i < set.length; i++)
    { if (this.eq(set[i])) { return true } }
  return false
};

// :: (Mark) → bool
// Test whether this mark has the same type and attributes as
// another mark.
Mark.prototype.eq = function eq (other) {
  return this == other ||
    (this.type == other.type && compareDeep(this.attrs, other.attrs))
};

// :: () → Object
// Convert this mark to a JSON-serializeable representation.
Mark.prototype.toJSON = function toJSON () {
  var obj = {type: this.type.name};
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break
  }
  return obj
};

// :: (Schema, Object) → Mark
Mark.fromJSON = function fromJSON (schema, json) {
  if (!json) { throw new RangeError("Invalid input for Mark.fromJSON") }
  var type = schema.marks[json.type];
  if (!type) { throw new RangeError(("There is no mark type " + (json.type) + " in this schema")) }
  return type.create(json.attrs)
};

// :: ([Mark], [Mark]) → bool
// Test whether two sets of marks are identical.
Mark.sameSet = function sameSet (a, b) {
  if (a == b) { return true }
  if (a.length != b.length) { return false }
  for (var i = 0; i < a.length; i++)
    { if (!a[i].eq(b[i])) { return false } }
  return true
};

// :: (?union<Mark, [Mark]>) → [Mark]
// Create a properly sorted mark set from null, a single mark, or an
// unsorted array of marks.
Mark.setFrom = function setFrom (marks) {
  if (!marks || marks.length == 0) { return Mark.none }
  if (marks instanceof Mark) { return [marks] }
  var copy = marks.slice();
  copy.sort(function (a, b) { return a.type.rank - b.type.rank; });
  return copy
};

// :: [Mark] The empty set of marks.
Mark.none = [];

// ReplaceError:: class extends Error
// Error type raised by [`Node.replace`](#model.Node.replace) when
// given an invalid replacement.

function ReplaceError(message) {
  var err = Error.call(this, message);
  err.__proto__ = ReplaceError.prototype;
  return err
}

ReplaceError.prototype = Object.create(Error.prototype);
ReplaceError.prototype.constructor = ReplaceError;
ReplaceError.prototype.name = "ReplaceError";

// ::- A slice represents a piece cut out of a larger document. It
// stores not only a fragment, but also the depth up to which nodes on
// both side are ‘open’ (cut through).
var Slice = function Slice(content, openStart, openEnd) {
  // :: Fragment The slice's content.
  this.content = content;
  // :: number The open depth at the start.
  this.openStart = openStart;
  // :: number The open depth at the end.
  this.openEnd = openEnd;
};

var prototypeAccessors$1 = { size: { configurable: true } };

// :: number
// The size this slice would add when inserted into a document.
prototypeAccessors$1.size.get = function () {
  return this.content.size - this.openStart - this.openEnd
};

Slice.prototype.insertAt = function insertAt (pos, fragment) {
  var content = insertInto(this.content, pos + this.openStart, fragment, null);
  return content && new Slice(content, this.openStart, this.openEnd)
};

Slice.prototype.removeBetween = function removeBetween (from, to) {
  return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)
};

// :: (Slice) → bool
// Tests whether this slice is equal to another slice.
Slice.prototype.eq = function eq (other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd
};

Slice.prototype.toString = function toString () {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")"
};

// :: () → ?Object
// Convert a slice to a JSON-serializable representation.
Slice.prototype.toJSON = function toJSON () {
  if (!this.content.size) { return null }
  var json = {content: this.content.toJSON()};
  if (this.openStart > 0) { json.openStart = this.openStart; }
  if (this.openEnd > 0) { json.openEnd = this.openEnd; }
  return json
};

// :: (Schema, ?Object) → Slice
// Deserialize a slice from its JSON representation.
Slice.fromJSON = function fromJSON (schema, json) {
  if (!json) { return Slice.empty }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number")
    { throw new RangeError("Invalid input for Slice.fromJSON") }
  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)
};

// :: (Fragment, ?bool) → Slice
// Create a slice from a fragment by taking the maximum possible
// open value on both side of the fragment.
Slice.maxOpen = function maxOpen (fragment, openIsolating) {
    if ( openIsolating === void 0 ) openIsolating=true;

  var openStart = 0, openEnd = 0;
  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) { openStart++; }
  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) { openEnd++; }
  return new Slice(fragment, openStart, openEnd)
};

Object.defineProperties( Slice.prototype, prototypeAccessors$1 );

function removeRange(content, from, to) {
  var ref = content.findIndex(from);
  var index = ref.index;
  var offset = ref.offset;
  var child = content.maybeChild(index);
  var ref$1 = content.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError("Removing non-flat range") }
    return content.cut(0, from).append(content.cut(to))
  }
  if (index != indexTo) { throw new RangeError("Removing non-flat range") }
  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))
}

function insertInto(content, dist, insert, parent) {
  var ref = content.findIndex(dist);
  var index = ref.index;
  var offset = ref.offset;
  var child = content.maybeChild(index);
  if (offset == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert)) { return null }
    return content.cut(0, dist).append(insert).append(content.cut(dist))
  }
  var inner = insertInto(child.content, dist - offset - 1, insert);
  return inner && content.replaceChild(index, child.copy(inner))
}

// :: Slice
// The empty slice.
Slice.empty = new Slice(Fragment.empty, 0, 0);

function replace($from, $to, slice) {
  if (slice.openStart > $from.depth)
    { throw new ReplaceError("Inserted content deeper than insertion position") }
  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
    { throw new ReplaceError("Inconsistent open depths") }
  return replaceOuter($from, $to, slice, 0)
}

function replaceOuter($from, $to, slice, depth) {
  var index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
    var inner = replaceOuter($from, $to, slice, depth + 1);
    return node.copy(node.content.replaceChild(index, inner))
  } else if (!slice.content.size) {
    return close(node, replaceTwoWay($from, $to, depth))
  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case
    var parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))
  } else {
    var ref = prepareSliceForReplace(slice, $from);
    var start = ref.start;
    var end = ref.end;
    return close(node, replaceThreeWay($from, start, end, $to, depth))
  }
}

function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    { throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name) }
}

function joinable($before, $after, depth) {
  var node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node
}

function addNode(child, target) {
  var last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    { target[last] = child.withText(target[last].text + child.text); }
  else
    { target.push(child); }
}

function addRange($start, $end, depth, target) {
  var node = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target); }
  if ($end && $end.depth == depth && $end.textOffset)
    { addNode($end.nodeBefore, target); }
}

function close(node, content) {
  if (!node.type.validContent(content))
    { throw new ReplaceError("Invalid content for node " + node.type.name) }
  return node.copy(content)
}

function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);

  var content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      { addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content); }
    addRange($start, $end, depth, content);
    if (openEnd)
      { addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content); }
  }
  addRange($to, null, depth, content);
  return new Fragment(content)
}

function replaceTwoWay($from, $to, depth) {
  var content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    var type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content)
}

function prepareSliceForReplace(slice, $along) {
  var extra = $along.depth - slice.openStart, parent = $along.node(extra);
  var node = parent.copy(slice.content);
  for (var i = extra - 1; i >= 0; i--)
    { node = $along.node(i).copy(Fragment.from(node)); }
  return {start: node.resolveNoCache(slice.openStart + extra),
          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}
}

// ::- You can [_resolve_](#model.Node.resolve) a position to get more
// information about it. Objects of this class represent such a
// resolved position, providing various pieces of context information,
// and some helper methods.
//
// Throughout this interface, methods that take an optional `depth`
// parameter will interpret undefined as `this.depth` and negative
// numbers as `this.depth + value`.
var ResolvedPos = function ResolvedPos(pos, path, parentOffset) {
  // :: number The position that was resolved.
  this.pos = pos;
  this.path = path;
  // :: number
  // The number of levels the parent node is from the root. If this
  // position points directly into the root node, it is 0. If it
  // points into a top-level paragraph, 1, and so on.
  this.depth = path.length / 3 - 1;
  // :: number The offset this position has into its parent node.
  this.parentOffset = parentOffset;
};

var prototypeAccessors$2 = { parent: { configurable: true },doc: { configurable: true },textOffset: { configurable: true },nodeAfter: { configurable: true },nodeBefore: { configurable: true } };

ResolvedPos.prototype.resolveDepth = function resolveDepth (val) {
  if (val == null) { return this.depth }
  if (val < 0) { return this.depth + val }
  return val
};

// :: Node
// The parent node that the position points into. Note that even if
// a position points into a text node, that node is not considered
// the parent—text nodes are ‘flat’ in this model, and have no content.
prototypeAccessors$2.parent.get = function () { return this.node(this.depth) };

// :: Node
// The root node in which the position was resolved.
prototypeAccessors$2.doc.get = function () { return this.node(0) };

// :: (?number) → Node
// The ancestor node at the given level. `p.node(p.depth)` is the
// same as `p.parent`.
ResolvedPos.prototype.node = function node (depth) { return this.path[this.resolveDepth(depth) * 3] };

// :: (?number) → number
// The index into the ancestor at the given level. If this points at
// the 3rd node in the 2nd paragraph on the top level, for example,
// `p.index(0)` is 1 and `p.index(1)` is 2.
ResolvedPos.prototype.index = function index (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };

// :: (?number) → number
// The index pointing after this position into the ancestor at the
// given level.
ResolvedPos.prototype.indexAfter = function indexAfter (depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)
};

// :: (?number) → number
// The (absolute) position at the start of the node at the given
// level.
ResolvedPos.prototype.start = function start (depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1
};

// :: (?number) → number
// The (absolute) position at the end of the node at the given
// level.
ResolvedPos.prototype.end = function end (depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size
};

// :: (?number) → number
// The (absolute) position directly before the wrapping node at the
// given level, or, when `depth` is `this.depth + 1`, the original
// position.
ResolvedPos.prototype.before = function before (depth) {
  depth = this.resolveDepth(depth);
  if (!depth) { throw new RangeError("There is no position before the top-level node") }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]
};

// :: (?number) → number
// The (absolute) position directly after the wrapping node at the
// given level, or the original position when `depth` is `this.depth + 1`.
ResolvedPos.prototype.after = function after (depth) {
  depth = this.resolveDepth(depth);
  if (!depth) { throw new RangeError("There is no position after the top-level node") }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize
};

// :: number
// When this position points into a text node, this returns the
// distance between the position and the start of the text node.
// Will be zero for positions that point between nodes.
prototypeAccessors$2.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };

// :: ?Node
// Get the node directly after the position, if any. If the position
// points into a text node, only the part of that node after the
// position is returned.
prototypeAccessors$2.nodeAfter.get = function () {
  var parent = this.parent, index = this.index(this.depth);
  if (index == parent.childCount) { return null }
  var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
  return dOff ? parent.child(index).cut(dOff) : child
};

// :: ?Node
// Get the node directly before the position, if any. If the
// position points into a text node, only the part of that node
// before the position is returned.
prototypeAccessors$2.nodeBefore.get = function () {
  var index = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) { return this.parent.child(index).cut(0, dOff) }
  return index == 0 ? null : this.parent.child(index - 1)
};

// :: (number, ?number) → number
// Get the position at the given index in the parent node at the
// given depth (which defaults to `this.depth`).
ResolvedPos.prototype.posAtIndex = function posAtIndex (index, depth) {
  depth = this.resolveDepth(depth);
  var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  for (var i = 0; i < index; i++) { pos += node.child(i).nodeSize; }
  return pos
};

// :: () → [Mark]
// Get the marks at this position, factoring in the surrounding
// marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the
// position is at the start of a non-empty node, the marks of the
// node after it (if any) are returned.
ResolvedPos.prototype.marks = function marks () {
  var parent = this.parent, index = this.index();

  // In an empty parent, return the empty array
  if (parent.content.size == 0) { return Mark.none }

  // When inside a text node, just return the text node's marks
  if (this.textOffset) { return parent.child(index).marks }

  var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
  // If the `after` flag is true of there is no node before, make
  // the node after this position the main reference.
  if (!main) { var tmp = main; main = other; other = tmp; }

  // Use all marks in the main node, except those that have
  // `inclusive` set to false and are not present in the other node.
  var marks = main.marks;
  for (var i = 0; i < marks.length; i++)
    { if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
      { marks = marks[i--].removeFromSet(marks); } }

  return marks
};

// :: (ResolvedPos) → ?[Mark]
// Get the marks after the current position, if any, except those
// that are non-inclusive and not present at position `$end`. This
// is mostly useful for getting the set of marks to preserve after a
// deletion. Will return `null` if this position is at the end of
// its parent node or its parent node isn't a textblock (in which
// case no marks should be preserved).
ResolvedPos.prototype.marksAcross = function marksAcross ($end) {
  var after = this.parent.maybeChild(this.index());
  if (!after || !after.isInline) { return null }

  var marks = after.marks, next = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks.length; i++)
    { if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
      { marks = marks[i--].removeFromSet(marks); } }
  return marks
};

// :: (number) → number
// The depth up to which this position and the given (non-resolved)
// position share the same parent nodes.
ResolvedPos.prototype.sharedDepth = function sharedDepth (pos) {
  for (var depth = this.depth; depth > 0; depth--)
    { if (this.start(depth) <= pos && this.end(depth) >= pos) { return depth } }
  return 0
};

// :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange
// Returns a range based on the place where this position and the
// given position diverge around block content. If both point into
// the same textblock, for example, a range around that textblock
// will be returned. If they point into different blocks, the range
// around those blocks in their shared ancestor is returned. You can
// pass in an optional predicate that will be called with a parent
// node to see if a range into that parent is acceptable.
ResolvedPos.prototype.blockRange = function blockRange (other, pred) {
    if ( other === void 0 ) other = this;

  if (other.pos < this.pos) { return other.blockRange(this) }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
    { if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
      { return new NodeRange(this, other, d) } }
};

// :: (ResolvedPos) → bool
// Query whether the given position shares the same parent node.
ResolvedPos.prototype.sameParent = function sameParent (other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset
};

// :: (ResolvedPos) → ResolvedPos
// Return the greater of this and the given position.
ResolvedPos.prototype.max = function max (other) {
  return other.pos > this.pos ? other : this
};

// :: (ResolvedPos) → ResolvedPos
// Return the smaller of this and the given position.
ResolvedPos.prototype.min = function min (other) {
  return other.pos < this.pos ? other : this
};

ResolvedPos.prototype.toString = function toString () {
  var str = "";
  for (var i = 1; i <= this.depth; i++)
    { str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1); }
  return str + ":" + this.parentOffset
};

ResolvedPos.resolve = function resolve (doc, pos) {
  if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError("Position " + pos + " out of range") }
  var path = [];
  var start = 0, parentOffset = pos;
  for (var node = doc;;) {
    var ref = node.content.findIndex(parentOffset);
      var index = ref.index;
      var offset = ref.offset;
    var rem = parentOffset - offset;
    path.push(node, index, start + offset);
    if (!rem) { break }
    node = node.child(index);
    if (node.isText) { break }
    parentOffset = rem - 1;
    start += offset + 1;
  }
  return new ResolvedPos(pos, path, parentOffset)
};

ResolvedPos.resolveCached = function resolveCached (doc, pos) {
  for (var i = 0; i < resolveCache.length; i++) {
    var cached = resolveCache[i];
    if (cached.pos == pos && cached.doc == doc) { return cached }
  }
  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);
  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
  return result
};

Object.defineProperties( ResolvedPos.prototype, prototypeAccessors$2 );

var resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;

// ::- Represents a flat range of content, i.e. one that starts and
// ends in the same node.
var NodeRange = function NodeRange($from, $to, depth) {
  // :: ResolvedPos A resolved position along the start of the
  // content. May have a `depth` greater than this object's `depth`
  // property, since these are the positions that were used to
  // compute the range, not re-resolved positions directly at its
  // boundaries.
  this.$from = $from;
  // :: ResolvedPos A position along the end of the content. See
  // caveat for [`$from`](#model.NodeRange.$from).
  this.$to = $to;
  // :: number The depth of the node that this range points into.
  this.depth = depth;
};

var prototypeAccessors$1$1 = { start: { configurable: true },end: { configurable: true },parent: { configurable: true },startIndex: { configurable: true },endIndex: { configurable: true } };

// :: number The position at the start of the range.
prototypeAccessors$1$1.start.get = function () { return this.$from.before(this.depth + 1) };
// :: number The position at the end of the range.
prototypeAccessors$1$1.end.get = function () { return this.$to.after(this.depth + 1) };

// :: Node The parent node that the range points into.
prototypeAccessors$1$1.parent.get = function () { return this.$from.node(this.depth) };
// :: number The start index of the range in the parent node.
prototypeAccessors$1$1.startIndex.get = function () { return this.$from.index(this.depth) };
// :: number The end index of the range in the parent node.
prototypeAccessors$1$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };

Object.defineProperties( NodeRange.prototype, prototypeAccessors$1$1 );

var emptyAttrs = Object.create(null);

// ::- This class represents a node in the tree that makes up a
// ProseMirror document. So a document is an instance of `Node`, with
// children that are also instances of `Node`.
//
// Nodes are persistent data structures. Instead of changing them, you
// create new ones with the content you want. Old ones keep pointing
// at the old document shape. This is made cheaper by sharing
// structure between the old and new data as much as possible, which a
// tree shape like this (without back pointers) makes easy.
//
// **Do not** directly mutate the properties of a `Node` object. See
// [the guide](/docs/guide/#doc) for more information.
var Node = function Node(type, attrs, content, marks) {
  // :: NodeType
  // The type of node that this is.
  this.type = type;

  // :: Object
  // An object mapping attribute names to values. The kind of
  // attributes allowed and required are
  // [determined](#model.NodeSpec.attrs) by the node type.
  this.attrs = attrs;

  // :: Fragment
  // A container holding the node's children.
  this.content = content || Fragment.empty;

  // :: [Mark]
  // The marks (things like whether it is emphasized or part of a
  // link) applied to this node.
  this.marks = marks || Mark.none;
};

var prototypeAccessors$3 = { nodeSize: { configurable: true },childCount: { configurable: true },textContent: { configurable: true },firstChild: { configurable: true },lastChild: { configurable: true },isBlock: { configurable: true },isTextblock: { configurable: true },inlineContent: { configurable: true },isInline: { configurable: true },isText: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };

// text:: ?string
// For text nodes, this contains the node's text content.

// :: number
// The size of this node, as defined by the integer-based [indexing
// scheme](/docs/guide/#doc.indexing). For text nodes, this is the
// amount of characters. For other leaf nodes, it is one. For
// non-leaf nodes, it is the size of the content plus two (the start
// and end token).
prototypeAccessors$3.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };

// :: number
// The number of children that the node has.
prototypeAccessors$3.childCount.get = function () { return this.content.childCount };

// :: (number) → Node
// Get the child node at the given index. Raises an error when the
// index is out of range.
Node.prototype.child = function child (index) { return this.content.child(index) };

// :: (number) → ?Node
// Get the child node at the given index, if it exists.
Node.prototype.maybeChild = function maybeChild (index) { return this.content.maybeChild(index) };

// :: ((node: Node, offset: number, index: number))
// Call `f` for every child node, passing the node, its offset
// into this parent node, and its index.
Node.prototype.forEach = function forEach (f) { this.content.forEach(f); };

// :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)
// Invoke a callback for all descendant nodes recursively between
// the given two positions that are relative to start of this node's
// content. The callback is invoked with the node, its
// parent-relative position, its parent node, and its child index.
// When the callback returns false for a given node, that node's
// children will not be recursed over. The last parameter can be
// used to specify a starting position to count from.
Node.prototype.nodesBetween = function nodesBetween (from, to, f, startPos) {
    if ( startPos === void 0 ) startPos = 0;

  this.content.nodesBetween(from, to, f, startPos, this);
};

// :: ((node: Node, pos: number, parent: Node) → ?bool)
// Call the given callback for every descendant node. Doesn't
// descend into a node when the callback returns `false`.
Node.prototype.descendants = function descendants (f) {
  this.nodesBetween(0, this.content.size, f);
};

// :: string
// Concatenates all the text nodes found in this fragment and its
// children.
prototypeAccessors$3.textContent.get = function () { return this.textBetween(0, this.content.size, "") };

// :: (number, number, ?string, ?string | ?(leafNode: Node) -> string) → string
// Get all text between positions `from` and `to`. When
// `blockSeparator` is given, it will be inserted whenever a new
// block node is started. When `leafText` is given, it'll be
// inserted for every non-text leaf node encountered.
Node.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {
  return this.content.textBetween(from, to, blockSeparator, leafText)
};

// :: ?Node
// Returns this node's first child, or `null` if there are no
// children.
prototypeAccessors$3.firstChild.get = function () { return this.content.firstChild };

// :: ?Node
// Returns this node's last child, or `null` if there are no
// children.
prototypeAccessors$3.lastChild.get = function () { return this.content.lastChild };

// :: (Node) → bool
// Test whether two nodes represent the same piece of document.
Node.prototype.eq = function eq (other) {
  return this == other || (this.sameMarkup(other) && this.content.eq(other.content))
};

// :: (Node) → bool
// Compare the markup (type, attributes, and marks) of this node to
// those of another. Returns `true` if both have the same markup.
Node.prototype.sameMarkup = function sameMarkup (other) {
  return this.hasMarkup(other.type, other.attrs, other.marks)
};

// :: (NodeType, ?Object, ?[Mark]) → bool
// Check whether this node's markup correspond to the given type,
// attributes, and marks.
Node.prototype.hasMarkup = function hasMarkup (type, attrs, marks) {
  return this.type == type &&
    compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&
    Mark.sameSet(this.marks, marks || Mark.none)
};

// :: (?Fragment) → Node
// Create a new node with the same markup as this node, containing
// the given content (or empty, if no content is given).
Node.prototype.copy = function copy (content) {
    if ( content === void 0 ) content = null;

  if (content == this.content) { return this }
  return new this.constructor(this.type, this.attrs, content, this.marks)
};

// :: ([Mark]) → Node
// Create a copy of this node, with the given set of marks instead
// of the node's own marks.
Node.prototype.mark = function mark (marks) {
  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)
};

// :: (number, ?number) → Node
// Create a copy of this node with only the content between the
// given positions. If `to` is not given, it defaults to the end of
// the node.
Node.prototype.cut = function cut (from, to) {
  if (from == 0 && to == this.content.size) { return this }
  return this.copy(this.content.cut(from, to))
};

// :: (number, ?number) → Slice
// Cut out the part of the document between the given positions, and
// return it as a `Slice` object.
Node.prototype.slice = function slice (from, to, includeParents) {
    if ( to === void 0 ) to = this.content.size;
    if ( includeParents === void 0 ) includeParents = false;

  if (from == to) { return Slice.empty }

  var $from = this.resolve(from), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start = $from.start(depth), node = $from.node(depth);
  var content = node.content.cut($from.pos - start, $to.pos - start);
  return new Slice(content, $from.depth - depth, $to.depth - depth)
};

// :: (number, number, Slice) → Node
// Replace the part of the document between the given positions with
// the given slice. The slice must 'fit', meaning its open sides
// must be able to connect to the surrounding content, and its
// content nodes must be valid children for the node they are placed
// into. If any of this is violated, an error of type
// [`ReplaceError`](#model.ReplaceError) is thrown.
Node.prototype.replace = function replace$1 (from, to, slice) {
  return replace(this.resolve(from), this.resolve(to), slice)
};

// :: (number) → ?Node
// Find the node directly after the given position.
Node.prototype.nodeAt = function nodeAt (pos) {
  for (var node = this;;) {
    var ref = node.content.findIndex(pos);
      var index = ref.index;
      var offset = ref.offset;
    node = node.maybeChild(index);
    if (!node) { return null }
    if (offset == pos || node.isText) { return node }
    pos -= offset + 1;
  }
};

// :: (number) → {node: ?Node, index: number, offset: number}
// Find the (direct) child node after the given offset, if any,
// and return it along with its index and offset relative to this
// node.
Node.prototype.childAfter = function childAfter (pos) {
  var ref = this.content.findIndex(pos);
    var index = ref.index;
    var offset = ref.offset;
  return {node: this.content.maybeChild(index), index: index, offset: offset}
};

// :: (number) → {node: ?Node, index: number, offset: number}
// Find the (direct) child node before the given offset, if any,
// and return it along with its index and offset relative to this
// node.
Node.prototype.childBefore = function childBefore (pos) {
  if (pos == 0) { return {node: null, index: 0, offset: 0} }
  var ref = this.content.findIndex(pos);
    var index = ref.index;
    var offset = ref.offset;
  if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }
  var node = this.content.child(index - 1);
  return {node: node, index: index - 1, offset: offset - node.nodeSize}
};

// :: (number) → ResolvedPos
// Resolve the given position in the document, returning an
// [object](#model.ResolvedPos) with information about its context.
Node.prototype.resolve = function resolve (pos) { return ResolvedPos.resolveCached(this, pos) };

Node.prototype.resolveNoCache = function resolveNoCache (pos) { return ResolvedPos.resolve(this, pos) };

// :: (number, number, union<Mark, MarkType>) → bool
// Test whether a given mark or mark type occurs in this document
// between the two given positions.
Node.prototype.rangeHasMark = function rangeHasMark (from, to, type) {
  var found = false;
  if (to > from) { this.nodesBetween(from, to, function (node) {
    if (type.isInSet(node.marks)) { found = true; }
    return !found
  }); }
  return found
};

// :: bool
// True when this is a block (non-inline node)
prototypeAccessors$3.isBlock.get = function () { return this.type.isBlock };

// :: bool
// True when this is a textblock node, a block node with inline
// content.
prototypeAccessors$3.isTextblock.get = function () { return this.type.isTextblock };

// :: bool
// True when this node allows inline content.
prototypeAccessors$3.inlineContent.get = function () { return this.type.inlineContent };

// :: bool
// True when this is an inline node (a text node or a node that can
// appear among text).
prototypeAccessors$3.isInline.get = function () { return this.type.isInline };

// :: bool
// True when this is a text node.
prototypeAccessors$3.isText.get = function () { return this.type.isText };

// :: bool
// True when this is a leaf node.
prototypeAccessors$3.isLeaf.get = function () { return this.type.isLeaf };

// :: bool
// True when this is an atom, i.e. when it does not have directly
// editable content. This is usually the same as `isLeaf`, but can
// be configured with the [`atom` property](#model.NodeSpec.atom) on
// a node's spec (typically used when the node is displayed as an
// uneditable [node view](#view.NodeView)).
prototypeAccessors$3.isAtom.get = function () { return this.type.isAtom };

// :: () → string
// Return a string representation of this node for debugging
// purposes.
Node.prototype.toString = function toString () {
  if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }
  var name = this.type.name;
  if (this.content.size)
    { name += "(" + this.content.toStringInner() + ")"; }
  return wrapMarks(this.marks, name)
};

// :: (number) → ContentMatch
// Get the content match in this node at the given index.
Node.prototype.contentMatchAt = function contentMatchAt (index) {
  var match = this.type.contentMatch.matchFragment(this.content, 0, index);
  if (!match) { throw new Error("Called contentMatchAt on a node with invalid content") }
  return match
};

// :: (number, number, ?Fragment, ?number, ?number) → bool
// Test whether replacing the range between `from` and `to` (by
// child index) with the given replacement fragment (which defaults
// to the empty fragment) would leave the node's content valid. You
// can optionally pass `start` and `end` indices into the
// replacement fragment.
Node.prototype.canReplace = function canReplace (from, to, replacement, start, end) {
    if ( replacement === void 0 ) replacement = Fragment.empty;
    if ( start === void 0 ) start = 0;
    if ( end === void 0 ) end = replacement.childCount;

  var one = this.contentMatchAt(from).matchFragment(replacement, start, end);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) { return false }
  for (var i = start; i < end; i++) { if (!this.type.allowsMarks(replacement.child(i).marks)) { return false } }
  return true
};

// :: (number, number, NodeType, ?[Mark]) → bool
// Test whether replacing the range `from` to `to` (by index) with a
// node of the given type would leave the node's content valid.
Node.prototype.canReplaceWith = function canReplaceWith (from, to, type, marks) {
  if (marks && !this.type.allowsMarks(marks)) { return false }
  var start = this.contentMatchAt(from).matchType(type);
  var end = start && start.matchFragment(this.content, to);
  return end ? end.validEnd : false
};

// :: (Node) → bool
// Test whether the given node's content could be appended to this
// node. If that node is empty, this will only return true if there
// is at least one node type that can appear in both nodes (to avoid
// merging completely incompatible nodes).
Node.prototype.canAppend = function canAppend (other) {
  if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }
  else { return this.type.compatibleContent(other.type) }
};

// :: ()
// Check whether this node and its descendants conform to the
// schema, and raise error when they do not.
Node.prototype.check = function check () {
  if (!this.type.validContent(this.content))
    { throw new RangeError(("Invalid content for node " + (this.type.name) + ": " + (this.content.toString().slice(0, 50)))) }
  var copy = Mark.none;
  for (var i = 0; i < this.marks.length; i++) { copy = this.marks[i].addToSet(copy); }
  if (!Mark.sameSet(copy, this.marks))
    { throw new RangeError(("Invalid collection of marks for node " + (this.type.name) + ": " + (this.marks.map(function (m) { return m.type.name; })))) }
  this.content.forEach(function (node) { return node.check(); });
};

// :: () → Object
// Return a JSON-serializeable representation of this node.
Node.prototype.toJSON = function toJSON () {
  var obj = {type: this.type.name};
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break
  }
  if (this.content.size)
    { obj.content = this.content.toJSON(); }
  if (this.marks.length)
    { obj.marks = this.marks.map(function (n) { return n.toJSON(); }); }
  return obj
};

// :: (Schema, Object) → Node
// Deserialize a node from its JSON representation.
Node.fromJSON = function fromJSON (schema, json) {
  if (!json) { throw new RangeError("Invalid input for Node.fromJSON") }
  var marks = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) { throw new RangeError("Invalid mark data for Node.fromJSON") }
    marks = json.marks.map(schema.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") { throw new RangeError("Invalid text node in JSON") }
    return schema.text(json.text, marks)
  }
  var content = Fragment.fromJSON(schema, json.content);
  return schema.nodeType(json.type).create(json.attrs, content, marks)
};

Object.defineProperties( Node.prototype, prototypeAccessors$3 );

var TextNode = /*@__PURE__*/(function (Node) {
  function TextNode(type, attrs, content, marks) {
    Node.call(this, type, attrs, null, marks);

    if (!content) { throw new RangeError("Empty text nodes are not allowed") }

    this.text = content;
  }

  if ( Node ) TextNode.__proto__ = Node;
  TextNode.prototype = Object.create( Node && Node.prototype );
  TextNode.prototype.constructor = TextNode;

  var prototypeAccessors$1 = { textContent: { configurable: true },nodeSize: { configurable: true } };

  TextNode.prototype.toString = function toString () {
    if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }
    return wrapMarks(this.marks, JSON.stringify(this.text))
  };

  prototypeAccessors$1.textContent.get = function () { return this.text };

  TextNode.prototype.textBetween = function textBetween (from, to) { return this.text.slice(from, to) };

  prototypeAccessors$1.nodeSize.get = function () { return this.text.length };

  TextNode.prototype.mark = function mark (marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)
  };

  TextNode.prototype.withText = function withText (text) {
    if (text == this.text) { return this }
    return new TextNode(this.type, this.attrs, text, this.marks)
  };

  TextNode.prototype.cut = function cut (from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.text.length;

    if (from == 0 && to == this.text.length) { return this }
    return this.withText(this.text.slice(from, to))
  };

  TextNode.prototype.eq = function eq (other) {
    return this.sameMarkup(other) && this.text == other.text
  };

  TextNode.prototype.toJSON = function toJSON () {
    var base = Node.prototype.toJSON.call(this);
    base.text = this.text;
    return base
  };

  Object.defineProperties( TextNode.prototype, prototypeAccessors$1 );

  return TextNode;
}(Node));

function wrapMarks(marks, str) {
  for (var i = marks.length - 1; i >= 0; i--)
    { str = marks[i].type.name + "(" + str + ")"; }
  return str
}

// ::- Instances of this class represent a match state of a node
// type's [content expression](#model.NodeSpec.content), and can be
// used to find out whether further content matches here, and whether
// a given position is a valid end of the node.
var ContentMatch = function ContentMatch(validEnd) {
  // :: bool
  // True when this match state represents a valid end of the node.
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};

var prototypeAccessors$4 = { inlineContent: { configurable: true },defaultType: { configurable: true },edgeCount: { configurable: true } };

ContentMatch.parse = function parse (string, nodeTypes) {
  var stream = new TokenStream(string, nodeTypes);
  if (stream.next == null) { return ContentMatch.empty }
  var expr = parseExpr(stream);
  if (stream.next) { stream.err("Unexpected trailing text"); }
  var match = dfa(nfa(expr));
  checkForDeadEnds(match, stream);
  return match
};

// :: (NodeType) → ?ContentMatch
// Match a node type, returning a match after that node if
// successful.
ContentMatch.prototype.matchType = function matchType (type) {
  for (var i = 0; i < this.next.length; i += 2)
    { if (this.next[i] == type) { return this.next[i + 1] } }
  return null
};

// :: (Fragment, ?number, ?number) → ?ContentMatch
// Try to match a fragment. Returns the resulting match when
// successful.
ContentMatch.prototype.matchFragment = function matchFragment (frag, start, end) {
    if ( start === void 0 ) start = 0;
    if ( end === void 0 ) end = frag.childCount;

  var cur = this;
  for (var i = start; cur && i < end; i++)
    { cur = cur.matchType(frag.child(i).type); }
  return cur
};

prototypeAccessors$4.inlineContent.get = function () {
  var first = this.next[0];
  return first ? first.isInline : false
};

// :: ?NodeType
// Get the first matching node type at this match position that can
// be generated.
prototypeAccessors$4.defaultType.get = function () {
  for (var i = 0; i < this.next.length; i += 2) {
    var type = this.next[i];
    if (!(type.isText || type.hasRequiredAttrs())) { return type }
  }
};

ContentMatch.prototype.compatible = function compatible (other) {
  for (var i = 0; i < this.next.length; i += 2)
    { for (var j = 0; j < other.next.length; j += 2)
      { if (this.next[i] == other.next[j]) { return true } } }
  return false
};

// :: (Fragment, bool, ?number) → ?Fragment
// Try to match the given fragment, and if that fails, see if it can
// be made to match by inserting nodes in front of it. When
// successful, return a fragment of inserted nodes (which may be
// empty if nothing had to be inserted). When `toEnd` is true, only
// return a fragment if the resulting match goes to the end of the
// content expression.
ContentMatch.prototype.fillBefore = function fillBefore (after, toEnd, startIndex) {
    if ( toEnd === void 0 ) toEnd = false;
    if ( startIndex === void 0 ) startIndex = 0;

  var seen = [this];
  function search(match, types) {
    var finished = match.matchFragment(after, startIndex);
    if (finished && (!toEnd || finished.validEnd))
      { return Fragment.from(types.map(function (tp) { return tp.createAndFill(); })) }

    for (var i = 0; i < match.next.length; i += 2) {
      var type = match.next[i], next = match.next[i + 1];
      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
        seen.push(next);
        var found = search(next, types.concat(type));
        if (found) { return found }
      }
    }
  }

  return search(this, [])
};

// :: (NodeType) → ?[NodeType]
// Find a set of wrapping node types that would allow a node of the
// given type to appear at this position. The result may be empty
// (when it fits directly) and will be null when no such wrapping
// exists.
ContentMatch.prototype.findWrapping = function findWrapping (target) {
  for (var i = 0; i < this.wrapCache.length; i += 2)
    { if (this.wrapCache[i] == target) { return this.wrapCache[i + 1] } }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed
};

ContentMatch.prototype.computeWrapping = function computeWrapping (target) {
  var seen = Object.create(null), active = [{match: this, type: null, via: null}];
  while (active.length) {
    var current = active.shift(), match = current.match;
    if (match.matchType(target)) {
      var result = [];
      for (var obj = current; obj.type; obj = obj.via)
        { result.push(obj.type); }
      return result.reverse()
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type = match.next[i];
      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
        active.push({match: type.contentMatch, type: type, via: current});
        seen[type.name] = true;
      }
    }
  }
};

// :: number
// The number of outgoing edges this node has in the finite
// automaton that describes the content expression.
prototypeAccessors$4.edgeCount.get = function () {
  return this.next.length >> 1
};

// :: (number) → {type: NodeType, next: ContentMatch}
// Get the _n_​th outgoing edge from this node in the finite
// automaton that describes the content expression.
ContentMatch.prototype.edge = function edge (n) {
  var i = n << 1;
  if (i >= this.next.length) { throw new RangeError(("There's no " + n + "th edge in this content match")) }
  return {type: this.next[i], next: this.next[i + 1]}
};

ContentMatch.prototype.toString = function toString () {
  var seen = [];
  function scan(m) {
    seen.push(m);
    for (var i = 1; i < m.next.length; i += 2)
      { if (seen.indexOf(m.next[i]) == -1) { scan(m.next[i]); } }
  }
  scan(this);
  return seen.map(function (m, i) {
    var out = i + (m.validEnd ? "*" : " ") + " ";
    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2)
      { out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]); }
    return out
  }).join("\n")
};

Object.defineProperties( ContentMatch.prototype, prototypeAccessors$4 );

ContentMatch.empty = new ContentMatch(true);

var TokenStream = function TokenStream(string, nodeTypes) {
  this.string = string;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") { this.tokens.pop(); }
  if (this.tokens[0] == "") { this.tokens.shift(); }
};

var prototypeAccessors$1$2 = { next: { configurable: true } };

prototypeAccessors$1$2.next.get = function () { return this.tokens[this.pos] };

TokenStream.prototype.eat = function eat (tok) { return this.next == tok && (this.pos++ || true) };

TokenStream.prototype.err = function err (str) { throw new SyntaxError(str + " (in content expression '" + this.string + "')") };

Object.defineProperties( TokenStream.prototype, prototypeAccessors$1$2 );

function parseExpr(stream) {
  var exprs = [];
  do { exprs.push(parseExprSeq(stream)); }
  while (stream.eat("|"))
  return exprs.length == 1 ? exprs[0] : {type: "choice", exprs: exprs}
}

function parseExprSeq(stream) {
  var exprs = [];
  do { exprs.push(parseExprSubscript(stream)); }
  while (stream.next && stream.next != ")" && stream.next != "|")
  return exprs.length == 1 ? exprs[0] : {type: "seq", exprs: exprs}
}

function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);
  for (;;) {
    if (stream.eat("+"))
      { expr = {type: "plus", expr: expr}; }
    else if (stream.eat("*"))
      { expr = {type: "star", expr: expr}; }
    else if (stream.eat("?"))
      { expr = {type: "opt", expr: expr}; }
    else if (stream.eat("{"))
      { expr = parseExprRange(stream, expr); }
    else { break }
  }
  return expr
}

function parseNum(stream) {
  if (/\D/.test(stream.next)) { stream.err("Expected number, got '" + stream.next + "'"); }
  var result = Number(stream.next);
  stream.pos++;
  return result
}

function parseExprRange(stream, expr) {
  var min = parseNum(stream), max = min;
  if (stream.eat(",")) {
    if (stream.next != "}") { max = parseNum(stream); }
    else { max = -1; }
  }
  if (!stream.eat("}")) { stream.err("Unclosed braced range"); }
  return {type: "range", min: min, max: max, expr: expr}
}

function resolveName(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) { return [type] }
  var result = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) { result.push(type$1); }
  }
  if (result.length == 0) { stream.err("No node type or group '" + name + "' found"); }
  return result
}

function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) { stream.err("Missing closing paren"); }
    return expr
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function (type) {
      if (stream.inline == null) { stream.inline = type.isInline; }
      else if (stream.inline != type.isInline) { stream.err("Mixing inline and block content"); }
      return {type: "name", value: type}
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : {type: "choice", exprs: exprs}
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}

// The code below helps compile a regular-expression-like language
// into a deterministic finite automaton. For a good introduction to
// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html

// : (Object) → [[{term: ?any, to: number}]]
// Construct an NFA from an expression as returned by the parser. The
// NFA is represented as an array of states, which are themselves
// arrays of edges, which are `{term, to}` objects. The first state is
// the entry state and the last node is the success state.
//
// Note that unlike typical NFAs, the edge ordering in this one is
// significant, in that it is used to contruct filler content when
// necessary.
function nfa(expr) {
  var nfa = [[]];
  connect(compile(expr, 0), node());
  return nfa

  function node() { return nfa.push([]) - 1 }
  function edge(from, to, term) {
    var edge = {term: term, to: to};
    nfa[from].push(edge);
    return edge
  }
  function connect(edges, to) { edges.forEach(function (edge) { return edge.to = to; }); }

  function compile(expr, from) {
    if (expr.type == "choice") {
      return expr.exprs.reduce(function (out, expr) { return out.concat(compile(expr, from)); }, [])
    } else if (expr.type == "seq") {
      for (var i = 0;; i++) {
        var next = compile(expr.exprs[i], from);
        if (i == expr.exprs.length - 1) { return next }
        connect(next, from = node());
      }
    } else if (expr.type == "star") {
      var loop = node();
      edge(from, loop);
      connect(compile(expr.expr, loop), loop);
      return [edge(loop)]
    } else if (expr.type == "plus") {
      var loop$1 = node();
      connect(compile(expr.expr, from), loop$1);
      connect(compile(expr.expr, loop$1), loop$1);
      return [edge(loop$1)]
    } else if (expr.type == "opt") {
      return [edge(from)].concat(compile(expr.expr, from))
    } else if (expr.type == "range") {
      var cur = from;
      for (var i$1 = 0; i$1 < expr.min; i$1++) {
        var next$1 = node();
        connect(compile(expr.expr, cur), next$1);
        cur = next$1;
      }
      if (expr.max == -1) {
        connect(compile(expr.expr, cur), cur);
      } else {
        for (var i$2 = expr.min; i$2 < expr.max; i$2++) {
          var next$2 = node();
          edge(cur, next$2);
          connect(compile(expr.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge(cur)]
    } else if (expr.type == "name") {
      return [edge(from, null, expr.value)]
    }
  }
}

function cmp(a, b) { return b - a }

// Get the set of nodes reachable by null edges from `node`. Omit
// nodes with only a single null-out-edge, since they may lead to
// needless duplicated nodes.
function nullFrom(nfa, node) {
  var result = [];
  scan(node);
  return result.sort(cmp)

  function scan(node) {
    var edges = nfa[node];
    if (edges.length == 1 && !edges[0].term) { return scan(edges[0].to) }
    result.push(node);
    for (var i = 0; i < edges.length; i++) {
      var ref = edges[i];
      var term = ref.term;
      var to = ref.to;
      if (!term && result.indexOf(to) == -1) { scan(to); }
    }
  }
}

// : ([[{term: ?any, to: number}]]) → ContentMatch
// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set
// of state objects (`ContentMatch` instances) with transitions
// between them.
function dfa(nfa) {
  var labeled = Object.create(null);
  return explore(nullFrom(nfa, 0))

  function explore(states) {
    var out = [];
    states.forEach(function (node) {
      nfa[node].forEach(function (ref) {
        var term = ref.term;
        var to = ref.to;

        if (!term) { return }
        var known = out.indexOf(term), set = known > -1 && out[known + 1];
        nullFrom(nfa, to).forEach(function (node) {
          if (!set) { out.push(term, set = []); }
          if (set.indexOf(node) == -1) { set.push(node); }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state
  }
}

function checkForDeadEnds(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node = state.next[j], next = state.next[j + 1];
      nodes.push(node.name);
      if (dead && !(node.isText || node.hasRequiredAttrs())) { dead = false; }
      if (work.indexOf(next) == -1) { work.push(next); }
    }
    if (dead) { stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)"); }
  }
}

// For node types where all attrs have a default value (or which don't
// have any attributes), build up a single reusable default attribute
// object, and use it for all nodes that don't specify specific
// attributes.
function defaultAttrs(attrs) {
  var defaults = Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) { return null }
    defaults[attrName] = attr.default;
  }
  return defaults
}

function computeAttrs(attrs, value) {
  var built = Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === undefined) {
      var attr = attrs[name];
      if (attr.hasDefault) { given = attr.default; }
      else { throw new RangeError("No value supplied for attribute " + name) }
    }
    built[name] = given;
  }
  return built
}

function initAttrs(attrs) {
  var result = Object.create(null);
  if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]); } }
  return result
}

// ::- Node types are objects allocated once per `Schema` and used to
// [tag](#model.Node.type) `Node` instances. They contain information
// about the node type, such as its name and what kind of node it
// represents.
var NodeType = function NodeType(name, schema, spec) {
  // :: string
  // The name the node type has in this schema.
  this.name = name;

  // :: Schema
  // A link back to the `Schema` the node type belongs to.
  this.schema = schema;

  // :: NodeSpec
  // The spec that this type is based on
  this.spec = spec;

  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs(spec.attrs);

  this.defaultAttrs = defaultAttrs(this.attrs);

  // :: ContentMatch
  // The starting match of the node type's content expression.
  this.contentMatch = null;

  // : ?[MarkType]
  // The set of marks allowed in this node. `null` means all marks
  // are allowed.
  this.markSet = null;

  // :: bool
  // True if this node type has inline content.
  this.inlineContent = null;

  // :: bool
  // True if this is a block type
  this.isBlock = !(spec.inline || name == "text");

  // :: bool
  // True if this is the text node type.
  this.isText = name == "text";
};

var prototypeAccessors$5 = { isInline: { configurable: true },isTextblock: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };

// :: bool
// True if this is an inline type.
prototypeAccessors$5.isInline.get = function () { return !this.isBlock };

// :: bool
// True if this is a textblock type, a block that contains inline
// content.
prototypeAccessors$5.isTextblock.get = function () { return this.isBlock && this.inlineContent };

// :: bool
// True for node types that allow no content.
prototypeAccessors$5.isLeaf.get = function () { return this.contentMatch == ContentMatch.empty };

// :: bool
// True when this node is an atom, i.e. when it does not have
// directly editable content.
prototypeAccessors$5.isAtom.get = function () { return this.isLeaf || this.spec.atom };

// :: () → bool
// Tells you whether this node type has any required attributes.
NodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs () {
  for (var n in this.attrs) { if (this.attrs[n].isRequired) { return true } }
  return false
};

NodeType.prototype.compatibleContent = function compatibleContent (other) {
  return this == other || this.contentMatch.compatible(other.contentMatch)
};

NodeType.prototype.computeAttrs = function computeAttrs$1 (attrs) {
  if (!attrs && this.defaultAttrs) { return this.defaultAttrs }
  else { return computeAttrs(this.attrs, attrs) }
};

// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
// Create a `Node` of this type. The given attributes are
// checked and defaulted (you can pass `null` to use the type's
// defaults entirely, if no required attributes exist). `content`
// may be a `Fragment`, a node, an array of nodes, or
// `null`. Similarly `marks` may be `null` to default to the empty
// set of marks.
NodeType.prototype.create = function create (attrs, content, marks) {
  if (this.isText) { throw new Error("NodeType.create can't construct text nodes") }
  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))
};

// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
// Like [`create`](#model.NodeType.create), but check the given content
// against the node type's content restrictions, and throw an error
// if it doesn't match.
NodeType.prototype.createChecked = function createChecked (attrs, content, marks) {
  content = Fragment.from(content);
  if (!this.validContent(content))
    { throw new RangeError("Invalid content for node " + this.name) }
  return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))
};

// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node
// Like [`create`](#model.NodeType.create), but see if it is necessary to
// add nodes to the start or end of the given fragment to make it
// fit the node. If no fitting wrapping can be found, return null.
// Note that, due to the fact that required nodes can always be
// created, this will always succeed if you pass null or
// `Fragment.empty` as content.
NodeType.prototype.createAndFill = function createAndFill (attrs, content, marks) {
  attrs = this.computeAttrs(attrs);
  content = Fragment.from(content);
  if (content.size) {
    var before = this.contentMatch.fillBefore(content);
    if (!before) { return null }
    content = before.append(content);
  }
  var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);
  if (!after) { return null }
  return new Node(this, attrs, content.append(after), Mark.setFrom(marks))
};

// :: (Fragment) → bool
// Returns true if the given fragment is valid content for this node
// type with the given attributes.
NodeType.prototype.validContent = function validContent (content) {
  var result = this.contentMatch.matchFragment(content);
  if (!result || !result.validEnd) { return false }
  for (var i = 0; i < content.childCount; i++)
    { if (!this.allowsMarks(content.child(i).marks)) { return false } }
  return true
};

// :: (MarkType) → bool
// Check whether the given mark type is allowed in this node.
NodeType.prototype.allowsMarkType = function allowsMarkType (markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1
};

// :: ([Mark]) → bool
// Test whether the given set of marks are allowed in this node.
NodeType.prototype.allowsMarks = function allowsMarks (marks) {
  if (this.markSet == null) { return true }
  for (var i = 0; i < marks.length; i++) { if (!this.allowsMarkType(marks[i].type)) { return false } }
  return true
};

// :: ([Mark]) → [Mark]
// Removes the marks that are not allowed in this node from the given set.
NodeType.prototype.allowedMarks = function allowedMarks (marks) {
  if (this.markSet == null) { return marks }
  var copy;
  for (var i = 0; i < marks.length; i++) {
    if (!this.allowsMarkType(marks[i].type)) {
      if (!copy) { copy = marks.slice(0, i); }
    } else if (copy) {
      copy.push(marks[i]);
    }
  }
  return !copy ? marks : copy.length ? copy : Mark.empty
};

NodeType.compile = function compile (nodes, schema) {
  var result = Object.create(null);
  nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); });

  var topType = schema.spec.topNode || "doc";
  if (!result[topType]) { throw new RangeError("Schema is missing its top node type ('" + topType + "')") }
  if (!result.text) { throw new RangeError("Every schema needs a 'text' type") }
  for (var _ in result.text.attrs) { throw new RangeError("The text node type should not have attributes") }

  return result
};

Object.defineProperties( NodeType.prototype, prototypeAccessors$5 );

// Attribute descriptors

var Attribute = function Attribute(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};

var prototypeAccessors$1$3 = { isRequired: { configurable: true } };

prototypeAccessors$1$3.isRequired.get = function () {
  return !this.hasDefault
};

Object.defineProperties( Attribute.prototype, prototypeAccessors$1$3 );

// Marks

// ::- Like nodes, marks (which are associated with nodes to signify
// things like emphasis or being part of a link) are
// [tagged](#model.Mark.type) with type objects, which are
// instantiated once per `Schema`.
var MarkType = function MarkType(name, rank, schema, spec) {
  // :: string
  // The name of the mark type.
  this.name = name;

  // :: Schema
  // The schema that this mark type instance is part of.
  this.schema = schema;

  // :: MarkSpec
  // The spec on which the type is based.
  this.spec = spec;

  this.attrs = initAttrs(spec.attrs);

  this.rank = rank;
  this.excluded = null;
  var defaults = defaultAttrs(this.attrs);
  this.instance = defaults && new Mark(this, defaults);
};

// :: (?Object) → Mark
// Create a mark of this type. `attrs` may be `null` or an object
// containing only some of the mark's attributes. The others, if
// they have defaults, will be added.
MarkType.prototype.create = function create (attrs) {
  if (!attrs && this.instance) { return this.instance }
  return new Mark(this, computeAttrs(this.attrs, attrs))
};

MarkType.compile = function compile (marks, schema) {
  var result = Object.create(null), rank = 0;
  marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); });
  return result
};

// :: ([Mark]) → [Mark]
// When there is a mark of this type in the given set, a new set
// without it is returned. Otherwise, the input set is returned.
MarkType.prototype.removeFromSet = function removeFromSet (set) {
  for (var i = 0; i < set.length; i++) { if (set[i].type == this) {
    set = set.slice(0, i).concat(set.slice(i + 1));
    i--;
  } }
  return set
};

// :: ([Mark]) → ?Mark
// Tests whether there is a mark of this type in the given set.
MarkType.prototype.isInSet = function isInSet (set) {
  for (var i = 0; i < set.length; i++)
    { if (set[i].type == this) { return set[i] } }
};

// :: (MarkType) → bool
// Queries whether a given mark type is
// [excluded](#model.MarkSpec.excludes) by this one.
MarkType.prototype.excludes = function excludes (other) {
  return this.excluded.indexOf(other) > -1
};

// SchemaSpec:: interface
// An object describing a schema, as passed to the [`Schema`](#model.Schema)
// constructor.
//
//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>
//   The node types in this schema. Maps names to
//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type
//   associated with that name. Their order is significant—it
//   determines which [parse rules](#model.NodeSpec.parseDOM) take
//   precedence by default, and which nodes come first in a given
//   [group](#model.NodeSpec.group).
//
//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>
//   The mark types that exist in this schema. The order in which they
//   are provided determines the order in which [mark
//   sets](#model.Mark.addToSet) are sorted and in which [parse
//   rules](#model.MarkSpec.parseDOM) are tried.
//
//   topNode:: ?string
//   The name of the default top-level node for the schema. Defaults
//   to `"doc"`.

// NodeSpec:: interface
//
//   content:: ?string
//   The content expression for this node, as described in the [schema
//   guide](/docs/guide/#schema.content_expressions). When not given,
//   the node does not allow any content.
//
//   marks:: ?string
//   The marks that are allowed inside of this node. May be a
//   space-separated string referring to mark names or groups, `"_"`
//   to explicitly allow all marks, or `""` to disallow marks. When
//   not given, nodes with inline content default to allowing all
//   marks, other nodes default to not allowing marks.
//
//   group:: ?string
//   The group or space-separated groups to which this node belongs,
//   which can be referred to in the content expressions for the
//   schema.
//
//   inline:: ?bool
//   Should be set to true for inline nodes. (Implied for text nodes.)
//
//   atom:: ?bool
//   Can be set to true to indicate that, though this isn't a [leaf
//   node](#model.NodeType.isLeaf), it doesn't have directly editable
//   content and should be treated as a single unit in the view.
//
//   attrs:: ?Object<AttributeSpec>
//   The attributes that nodes of this type get.
//
//   selectable:: ?bool
//   Controls whether nodes of this type can be selected as a [node
//   selection](#state.NodeSelection). Defaults to true for non-text
//   nodes.
//
//   draggable:: ?bool
//   Determines whether nodes of this type can be dragged without
//   being selected. Defaults to false.
//
//   code:: ?bool
//   Can be used to indicate that this node contains code, which
//   causes some commands to behave differently.
//
//   defining:: ?bool
//   Determines whether this node is considered an important parent
//   node during replace operations (such as paste). Non-defining (the
//   default) nodes get dropped when their entire content is replaced,
//   whereas defining nodes persist and wrap the inserted content.
//   Likewise, in _inserted_ content the defining parents of the
//   content are preserved when possible. Typically,
//   non-default-paragraph textblock types, and possibly list items,
//   are marked as defining.
//
//   isolating:: ?bool
//   When enabled (default is false), the sides of nodes of this type
//   count as boundaries that regular editing operations, like
//   backspacing or lifting, won't cross. An example of a node that
//   should probably have this enabled is a table cell.
//
//   toDOM:: ?(node: Node) → DOMOutputSpec
//   Defines the default way a node of this type should be serialized
//   to DOM/HTML (as used by
//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).
//   Should return a DOM node or an [array
//   structure](#model.DOMOutputSpec) that describes one, with an
//   optional number zero (“hole”) in it to indicate where the node's
//   content should be inserted.
//
//   For text nodes, the default is to create a text DOM node. Though
//   it is possible to create a serializer where text is rendered
//   differently, this is not supported inside the editor, so you
//   shouldn't override that in your text node spec.
//
//   parseDOM:: ?[ParseRule]
//   Associates DOM parser information with this node, which can be
//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to
//   automatically derive a parser. The `node` field in the rules is
//   implied (the name of this node will be filled in automatically).
//   If you supply your own parser, you do not need to also specify
//   parsing rules in your schema.
//
//   toDebugString:: ?(node: Node) -> string
//   Defines the default way a node of this type should be serialized
//   to a string representation for debugging (e.g. in error messages).

// MarkSpec:: interface
//
//   attrs:: ?Object<AttributeSpec>
//   The attributes that marks of this type get.
//
//   inclusive:: ?bool
//   Whether this mark should be active when the cursor is positioned
//   at its end (or at its start when that is also the start of the
//   parent node). Defaults to true.
//
//   excludes:: ?string
//   Determines which other marks this mark can coexist with. Should
//   be a space-separated strings naming other marks or groups of marks.
//   When a mark is [added](#model.Mark.addToSet) to a set, all marks
//   that it excludes are removed in the process. If the set contains
//   any mark that excludes the new mark but is not, itself, excluded
//   by the new mark, the mark can not be added an the set. You can
//   use the value `"_"` to indicate that the mark excludes all
//   marks in the schema.
//
//   Defaults to only being exclusive with marks of the same type. You
//   can set it to an empty string (or any string not containing the
//   mark's own name) to allow multiple marks of a given type to
//   coexist (as long as they have different attributes).
//
//   group:: ?string
//   The group or space-separated groups to which this mark belongs.
//
//   spanning:: ?bool
//   Determines whether marks of this type can span multiple adjacent
//   nodes when serialized to DOM/HTML. Defaults to true.
//
//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec
//   Defines the default way marks of this type should be serialized
//   to DOM/HTML. When the resulting spec contains a hole, that is
//   where the marked content is placed. Otherwise, it is appended to
//   the top node.
//
//   parseDOM:: ?[ParseRule]
//   Associates DOM parser information with this mark (see the
//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The
//   `mark` field in the rules is implied.

// AttributeSpec:: interface
//
// Used to [define](#model.NodeSpec.attrs) attributes on nodes or
// marks.
//
//   default:: ?any
//   The default value for this attribute, to use when no explicit
//   value is provided. Attributes that have no default must be
//   provided whenever a node or mark of a type that has them is
//   created.

// ::- A document schema. Holds [node](#model.NodeType) and [mark
// type](#model.MarkType) objects for the nodes and marks that may
// occur in conforming documents, and provides functionality for
// creating and deserializing such documents.
var Schema = function Schema(spec) {
  // :: SchemaSpec
  // The [spec](#model.SchemaSpec) on which the schema is based,
  // with the added guarantee that its `nodes` and `marks`
  // properties are
  // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances
  // (not raw objects).
  this.spec = {};
  for (var prop in spec) { this.spec[prop] = spec[prop]; }
  this.spec.nodes = orderedmap__WEBPACK_IMPORTED_MODULE_0__["default"].from(spec.nodes);
  this.spec.marks = orderedmap__WEBPACK_IMPORTED_MODULE_0__["default"].from(spec.marks);

  // :: Object<NodeType>
  // An object mapping the schema's node names to node type objects.
  this.nodes = NodeType.compile(this.spec.nodes, this);

  // :: Object<MarkType>
  // A map from mark names to mark type objects.
  this.marks = MarkType.compile(this.spec.marks, this);

  var contentExprCache = Object.create(null);
  for (var prop$1 in this.nodes) {
    if (prop$1 in this.marks)
      { throw new RangeError(prop$1 + " can not be both a node and a mark") }
    var type = this.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
    type.contentMatch = contentExprCache[contentExpr] ||
      (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
    type.inlineContent = type.contentMatch.inlineContent;
    type.markSet = markExpr == "_" ? null :
      markExpr ? gatherMarks(this, markExpr.split(" ")) :
      markExpr == "" || !type.inlineContent ? [] : null;
  }
  for (var prop$2 in this.marks) {
    var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
  }

  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);

  // :: NodeType
  // The type of the [default top node](#model.SchemaSpec.topNode)
  // for this schema.
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];

  // :: Object
  // An object for storing whatever values modules may want to
  // compute and cache per schema. (If you want to store something
  // in it, try to use property names unlikely to clash.)
  this.cached = Object.create(null);
  this.cached.wrappings = Object.create(null);
};

// :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
// Create a node in this schema. The `type` may be a string or a
// `NodeType` instance. Attributes will be extended
// with defaults, `content` may be a `Fragment`,
// `null`, a `Node`, or an array of nodes.
Schema.prototype.node = function node (type, attrs, content, marks) {
  if (typeof type == "string")
    { type = this.nodeType(type); }
  else if (!(type instanceof NodeType))
    { throw new RangeError("Invalid node type: " + type) }
  else if (type.schema != this)
    { throw new RangeError("Node type from different schema used (" + type.name + ")") }

  return type.createChecked(attrs, content, marks)
};

// :: (string, ?[Mark]) → Node
// Create a text node in the schema. Empty text nodes are not
// allowed.
Schema.prototype.text = function text (text$1, marks) {
  var type = this.nodes.text;
  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))
};

// :: (union<string, MarkType>, ?Object) → Mark
// Create a mark with the given type and attributes.
Schema.prototype.mark = function mark (type, attrs) {
  if (typeof type == "string") { type = this.marks[type]; }
  return type.create(attrs)
};

// :: (Object) → Node
// Deserialize a node from its JSON representation. This method is
// bound.
Schema.prototype.nodeFromJSON = function nodeFromJSON (json) {
  return Node.fromJSON(this, json)
};

// :: (Object) → Mark
// Deserialize a mark from its JSON representation. This method is
// bound.
Schema.prototype.markFromJSON = function markFromJSON (json) {
  return Mark.fromJSON(this, json)
};

Schema.prototype.nodeType = function nodeType (name) {
  var found = this.nodes[name];
  if (!found) { throw new RangeError("Unknown node type: " + name) }
  return found
};

function gatherMarks(schema, marks) {
  var found = [];
  for (var i = 0; i < marks.length; i++) {
    var name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found.push(mark);
    } else {
      for (var prop in schema.marks) {
        var mark$1 = schema.marks[prop];
        if (name == "_" || (mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1))
          { found.push(ok = mark$1); }
      }
    }
    if (!ok) { throw new SyntaxError("Unknown mark type: '" + marks[i] + "'") }
  }
  return found
}

// ParseOptions:: interface
// These are the options recognized by the
// [`parse`](#model.DOMParser.parse) and
// [`parseSlice`](#model.DOMParser.parseSlice) methods.
//
//   preserveWhitespace:: ?union<bool, "full">
//   By default, whitespace is collapsed as per HTML's rules. Pass
//   `true` to preserve whitespace, but normalize newlines to
//   spaces, and `"full"` to preserve whitespace entirely.
//
//   findPositions:: ?[{node: dom.Node, offset: number}]
//   When given, the parser will, beside parsing the content,
//   record the document positions of the given DOM positions. It
//   will do so by writing to the objects, adding a `pos` property
//   that holds the document position. DOM positions that are not
//   in the parsed content will not be written to.
//
//   from:: ?number
//   The child node index to start parsing from.
//
//   to:: ?number
//   The child node index to stop parsing at.
//
//   topNode:: ?Node
//   By default, the content is parsed into the schema's default
//   [top node type](#model.Schema.topNodeType). You can pass this
//   option to use the type and attributes from a different node
//   as the top container.
//
//   topMatch:: ?ContentMatch
//   Provide the starting content match that content parsed into the
//   top node is matched against.
//
//   context:: ?ResolvedPos
//   A set of additional nodes to count as
//   [context](#model.ParseRule.context) when parsing, above the
//   given [top node](#model.ParseOptions.topNode).

// ParseRule:: interface
// A value that describes how to parse a given DOM node or inline
// style as a ProseMirror node or mark.
//
//   tag:: ?string
//   A CSS selector describing the kind of DOM elements to match. A
//   single rule should have _either_ a `tag` or a `style` property.
//
//   namespace:: ?string
//   The namespace to match. This should be used with `tag`.
//   Nodes are only matched when the namespace matches or this property
//   is null.
//
//   style:: ?string
//   A CSS property name to match. When given, this rule matches
//   inline styles that list that property. May also have the form
//   `"property=value"`, in which case the rule only matches if the
//   property's value exactly matches the given value. (For more
//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)
//   and return false to indicate that the match failed.) Rules
//   matching styles may only produce [marks](#model.ParseRule.mark),
//   not nodes.
//
//   priority:: ?number
//   Can be used to change the order in which the parse rules in a
//   schema are tried. Those with higher priority come first. Rules
//   without a priority are counted as having priority 50. This
//   property is only meaningful in a schema—when directly
//   constructing a parser, the order of the rule array is used.
//
//   consuming:: ?boolean
//   By default, when a rule matches an element or style, no further
//   rules get a chance to match it. By setting this to `false`, you
//   indicate that even when this rule matches, other rules that come
//   after it should also run.
//
//   context:: ?string
//   When given, restricts this rule to only match when the current
//   context—the parent nodes into which the content is being
//   parsed—matches this expression. Should contain one or more node
//   names or node group names followed by single or double slashes.
//   For example `"paragraph/"` means the rule only matches when the
//   parent node is a paragraph, `"blockquote/paragraph/"` restricts
//   it to be in a paragraph that is inside a blockquote, and
//   `"section//"` matches any position inside a section—a double
//   slash matches any sequence of ancestor nodes. To allow multiple
//   different contexts, they can be separated by a pipe (`|`)
//   character, as in `"blockquote/|list_item/"`.
//
//   node:: ?string
//   The name of the node type to create when this rule matches. Only
//   valid for rules with a `tag` property, not for style rules. Each
//   rule should have one of a `node`, `mark`, or `ignore` property
//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or
//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`
//   or `mark` property will be derived from its position).
//
//   mark:: ?string
//   The name of the mark type to wrap the matched content in.
//
//   ignore:: ?bool
//   When true, ignore content that matches this rule.
//
//   closeParent:: ?bool
//   When true, finding an element that matches this rule will close
//   the current node.
//
//   skip:: ?bool
//   When true, ignore the node that matches this rule, but do parse
//   its content.
//
//   attrs:: ?Object
//   Attributes for the node or mark created by this rule. When
//   `getAttrs` is provided, it takes precedence.
//
//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>
//   A function used to compute the attributes for the node or mark
//   created by this rule. Can also be used to describe further
//   conditions the DOM element or style must match. When it returns
//   `false`, the rule won't match. When it returns null or undefined,
//   that is interpreted as an empty/default set of attributes.
//
//   Called with a DOM Element for `tag` rules, and with a string (the
//   style's value) for `style` rules.
//
//   contentElement:: ?union<string, (dom.Node) → dom.Node>
//   For `tag` rules that produce non-leaf nodes or marks, by default
//   the content of the DOM element is parsed as content of the mark
//   or node. If the child nodes are in a descendent node, this may be
//   a CSS selector string that the parser must use to find the actual
//   content element, or a function that returns the actual content
//   element to the parser.
//
//   getContent:: ?(dom.Node, schema: Schema) → Fragment
//   Can be used to override the content of a matched node. When
//   present, instead of parsing the node's child nodes, the result of
//   this function is used.
//
//   preserveWhitespace:: ?union<bool, "full">
//   Controls whether whitespace should be preserved when parsing the
//   content inside the matched element. `false` means whitespace may
//   be collapsed, `true` means that whitespace should be preserved
//   but newlines normalized to spaces, and `"full"` means that
//   newlines should also be preserved.

// ::- A DOM parser represents a strategy for parsing DOM content into
// a ProseMirror document conforming to a given schema. Its behavior
// is defined by an array of [rules](#model.ParseRule).
var DOMParser = function DOMParser(schema, rules) {
  var this$1 = this;

  // :: Schema
  // The schema into which the parser parses.
  this.schema = schema;
  // :: [ParseRule]
  // The set of [parse rules](#model.ParseRule) that the parser
  // uses, in order of precedence.
  this.rules = rules;
  this.tags = [];
  this.styles = [];

  rules.forEach(function (rule) {
    if (rule.tag) { this$1.tags.push(rule); }
    else if (rule.style) { this$1.styles.push(rule); }
  });

  // Only normalize list elements when lists in the schema can't directly contain themselves
  this.normalizeLists = !this.tags.some(function (r) {
    if (!/^(ul|ol)\b/.test(r.tag) || !r.node) { return false }
    var node = schema.nodes[r.node];
    return node.contentMatch.matchType(node)
  });
};

// :: (dom.Node, ?ParseOptions) → Node
// Parse a document from the content of a DOM node.
DOMParser.prototype.parse = function parse (dom, options) {
    if ( options === void 0 ) options = {};

  var context = new ParseContext(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish()
};

// :: (dom.Node, ?ParseOptions) → Slice
// Parses the content of the given DOM node, like
// [`parse`](#model.DOMParser.parse), and takes the same set of
// options. But unlike that method, which produces a whole node,
// this one returns a slice that is open at the sides, meaning that
// the schema constraints aren't applied to the start of nodes to
// the left of the input and the end of nodes at the end.
DOMParser.prototype.parseSlice = function parseSlice (dom, options) {
    if ( options === void 0 ) options = {};

  var context = new ParseContext(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice.maxOpen(context.finish())
};

DOMParser.prototype.matchTag = function matchTag (dom, context, after) {
  for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
    var rule = this.tags[i];
    if (matches(dom, rule.tag) &&
        (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&
        (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result = rule.getAttrs(dom);
        if (result === false) { continue }
        rule.attrs = result;
      }
      return rule
    }
  }
};

DOMParser.prototype.matchStyle = function matchStyle (prop, value, context, after) {
  for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
    var rule = this.styles[i];
    if (rule.style.indexOf(prop) != 0 ||
        rule.context && !context.matchesContext(rule.context) ||
        // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        rule.style.length > prop.length &&
        (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))
      { continue }
    if (rule.getAttrs) {
      var result = rule.getAttrs(value);
      if (result === false) { continue }
      rule.attrs = result;
    }
    return rule
  }
};

// : (Schema) → [ParseRule]
DOMParser.schemaRules = function schemaRules (schema) {
  var result = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i = 0;
    for (; i < result.length; i++) {
      var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
      if (nextPriority < priority) { break }
    }
    result.splice(i, 0, rule);
  }

  var loop = function ( name ) {
    var rules = schema.marks[name].spec.parseDOM;
    if (rules) { rules.forEach(function (rule) {
      insert(rule = copy(rule));
      rule.mark = name;
    }); }
  };

    for (var name in schema.marks) loop( name );
  var loop$1 = function ( name ) {
    var rules$1 = schema.nodes[name$1].spec.parseDOM;
    if (rules$1) { rules$1.forEach(function (rule) {
      insert(rule = copy(rule));
      rule.node = name$1;
    }); }
  };

    for (var name$1 in schema.nodes) loop$1();
  return result
};

// :: (Schema) → DOMParser
// Construct a DOM parser using the parsing rules listed in a
// schema's [node specs](#model.NodeSpec.parseDOM), reordered by
// [priority](#model.ParseRule.priority).
DOMParser.fromSchema = function fromSchema (schema) {
  return schema.cached.domParser ||
    (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))
};

// : Object<bool> The block-level tags in HTML5
var blockTags = {
  address: true, article: true, aside: true, blockquote: true, canvas: true,
  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,
  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,
  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,
  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true
};

// : Object<bool> The tags that we normally ignore.
var ignoreTags = {
  head: true, noscript: true, object: true, script: true, style: true, title: true
};

// : Object<bool> List tags.
var listTags = {ol: true, ul: true};

// Using a bitfield for node context options
var OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;

function wsOptionsFor(preserveWhitespace) {
  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0)
}

var NodeContext = function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {
  this.type = type;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  this.options = options;
  this.content = [];
  // Marks applied to this node itself
  this.marks = marks;
  // Marks applied to its children
  this.activeMarks = Mark.none;
  // Marks that can't apply here, but will be used in children if possible
  this.pendingMarks = pendingMarks;
  // Nested Marks with same type
  this.stashMarks = [];
};

NodeContext.prototype.findWrapping = function findWrapping (node) {
  if (!this.match) {
    if (!this.type) { return [] }
    var fill = this.type.contentMatch.fillBefore(Fragment.from(node));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start = this.type.contentMatch, wrap;
      if (wrap = start.findWrapping(node.type)) {
        this.match = start;
        return wrap
      } else {
        return null
      }
    }
  }
  return this.match.findWrapping(node.type)
};

NodeContext.prototype.finish = function finish (openEnd) {
  if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace
    var last = this.content[this.content.length - 1], m;
    if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
      if (last.text.length == m[0].length) { this.content.pop(); }
      else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)); }
    }
  }
  var content = Fragment.from(this.content);
  if (!openEnd && this.match)
    { content = content.append(this.match.fillBefore(Fragment.empty, true)); }
  return this.type ? this.type.create(this.attrs, content, this.marks) : content
};

NodeContext.prototype.popFromStashMark = function popFromStashMark (mark) {
  for (var i = this.stashMarks.length - 1; i >= 0; i--)
    { if (mark.eq(this.stashMarks[i])) { return this.stashMarks.splice(i, 1)[0] } }
};

NodeContext.prototype.applyPending = function applyPending (nextType) {
  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
    var mark = pending[i];
    if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&
        !mark.isInSet(this.activeMarks)) {
      this.activeMarks = mark.addToSet(this.activeMarks);
      this.pendingMarks = mark.removeFromSet(this.pendingMarks);
    }
  }
};

NodeContext.prototype.inlineContext = function inlineContext (node) {
  if (this.type) { return this.type.inlineContent }
  if (this.content.length) { return this.content[0].isInline }
  return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())
};

var ParseContext = function ParseContext(parser, options, open) {
  // : DOMParser The parser we are using.
  this.parser = parser;
  // : Object The options passed to this parse.
  this.options = options;
  this.isOpen = open;
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);
  if (topNode)
    { topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,
                                 options.topMatch || topNode.type.contentMatch, topOptions); }
  else if (open)
    { topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions); }
  else
    { topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions); }
  this.nodes = [topContext];
  // : [Mark] The current set of marks
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};

var prototypeAccessors$6 = { top: { configurable: true },currentPos: { configurable: true } };

prototypeAccessors$6.top.get = function () {
  return this.nodes[this.open]
};

// : (dom.Node)
// Add a DOM node to the content. Text is inserted as text node,
// otherwise, the node is passed to `addElement` or, if it has a
// `style` attribute, `addElementWithStyles`.
ParseContext.prototype.addDOM = function addDOM (dom) {
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style = dom.getAttribute("style");
    var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;
    if (marks != null) { for (var i = 0; i < marks.length; i++) { this.addPendingMark(marks[i]); } }
    this.addElement(dom);
    if (marks != null) { for (var i$1 = 0; i$1 < marks.length; i$1++) { this.removePendingMark(marks[i$1], top); } }
  }
};

ParseContext.prototype.addTextNode = function addTextNode (dom) {
  var value = dom.nodeValue;
  var top = this.top;
  if (top.options & OPT_PRESERVE_WS_FULL ||
      top.inlineContext(dom) ||
      /[^ \t\r\n\u000c]/.test(value)) {
    if (!(top.options & OPT_PRESERVE_WS)) {
      value = value.replace(/[ \t\r\n\u000c]+/g, " ");
      // If this starts with whitespace, and there is no node before it, or
      // a hard break, or a text node that ends with whitespace, strip the
      // leading space.
      if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top.content[top.content.length - 1];
        var domNodeBefore = dom.previousSibling;
        if (!nodeBefore ||
            (domNodeBefore && domNodeBefore.nodeName == 'BR') ||
            (nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)))
          { value = value.slice(1); }
      }
    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
      value = value.replace(/\r?\n|\r/g, " ");
    } else {
      value = value.replace(/\r\n?/g, "\n");
    }
    if (value) { this.insertNode(this.parser.schema.text(value)); }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};

// : (dom.Element, ?ParseRule)
// Try to find a handler for the given tag and use that to parse. If
// none is found, the element's content nodes are added directly.
ParseContext.prototype.addElement = function addElement (dom, matchAfter) {
  var name = dom.nodeName.toLowerCase(), ruleID;
  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) { normalizeList(dom); }
  var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||
      (ruleID = this.parser.matchTag(dom, this, matchAfter));
  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
    this.findInside(dom);
    this.ignoreFallback(dom);
  } else if (!rule || rule.skip || rule.closeParent) {
    if (rule && rule.closeParent) { this.open = Math.max(0, this.open - 1); }
    else if (rule && rule.skip.nodeType) { dom = rule.skip; }
    var sync, top = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags.hasOwnProperty(name)) {
      sync = true;
      if (!top.type) { this.needsBlock = true; }
    } else if (!dom.firstChild) {
      this.leafFallback(dom);
      return
    }
    this.addAll(dom);
    if (sync) { this.sync(top); }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
  }
};

// Called for leaf DOM nodes that would otherwise be ignored
ParseContext.prototype.leafFallback = function leafFallback (dom) {
  if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
    { this.addTextNode(dom.ownerDocument.createTextNode("\n")); }
};

// Called for ignored nodes
ParseContext.prototype.ignoreFallback = function ignoreFallback (dom) {
  // Ignored BR nodes should at least create an inline context
  if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
    { this.findPlace(this.parser.schema.text("-")); }
};

// Run any style parser associated with the node's styles. Either
// return an array of marks, or null to indicate some of the styles
// had a rule with `ignore` set.
ParseContext.prototype.readStyles = function readStyles (styles) {
  var marks = Mark.none;
  style: for (var i = 0; i < styles.length; i += 2) {
    for (var after = null;;) {
      var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
      if (!rule) { continue style }
      if (rule.ignore) { return null }
      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
      if (rule.consuming === false) { after = rule; }
      else { break }
    }
  }
  return marks
};

// : (dom.Element, ParseRule) → bool
// Look up a handler for the given node. If none are found, return
// false. Otherwise, apply it, use its return value to drive the way
// the node's content is wrapped, and return true.
ParseContext.prototype.addElementByRule = function addElementByRule (dom, rule, continueAfter) {
    var this$1 = this;

  var sync, nodeType, markType, mark;
  if (rule.node) {
    nodeType = this.parser.schema.nodes[rule.node];
    if (!nodeType.isLeaf) {
      sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);
    } else if (!this.insertNode(nodeType.create(rule.attrs))) {
      this.leafFallback(dom);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark = markType.create(rule.attrs);
    this.addPendingMark(mark);
  }
  var startIn = this.top;

  if (nodeType && nodeType.isLeaf) {
    this.findInside(dom);
  } else if (continueAfter) {
    this.addElement(dom, continueAfter);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function (node) { return this$1.insertNode(node); });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") { contentDOM = dom.querySelector(contentDOM); }
    else if (typeof contentDOM == "function") { contentDOM = contentDOM(dom); }
    if (!contentDOM) { contentDOM = dom; }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync);
  }
  if (sync) { this.sync(startIn); this.open--; }
  if (mark) { this.removePendingMark(mark, startIn); }
};

// : (dom.Node, ?NodeBuilder, ?number, ?number)
// Add all child nodes between `startIndex` and `endIndex` (or the
// whole node, if not given). If `sync` is passed, use it to
// synchronize after every block element.
ParseContext.prototype.addAll = function addAll (parent, sync, startIndex, endIndex) {
  var index = startIndex || 0;
  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,
           end = endIndex == null ? null : parent.childNodes[endIndex];
       dom != end; dom = dom.nextSibling, ++index) {
    this.findAtPoint(parent, index);
    this.addDOM(dom);
    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))
      { this.sync(sync); }
  }
  this.findAtPoint(parent, index);
};

// Try to find a way to fit the given node type into the current
// context. May add intermediate wrappers and/or leave non-solid
// nodes that we're in.
ParseContext.prototype.findPlace = function findPlace (node) {
  var route, sync;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this.nodes[depth];
    var found = cx.findWrapping(node);
    if (found && (!route || route.length > found.length)) {
      route = found;
      sync = cx;
      if (!found.length) { break }
    }
    if (cx.solid) { break }
  }
  if (!route) { return false }
  this.sync(sync);
  for (var i = 0; i < route.length; i++)
    { this.enterInner(route[i], null, false); }
  return true
};

// : (Node) → ?Node
// Try to insert the given node, adjusting the context when needed.
ParseContext.prototype.insertNode = function insertNode (node) {
  if (node.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) { this.enterInner(block); }
  }
  if (this.findPlace(node)) {
    this.closeExtra();
    var top = this.top;
    top.applyPending(node.type);
    if (top.match) { top.match = top.match.matchType(node.type); }
    var marks = top.activeMarks;
    for (var i = 0; i < node.marks.length; i++)
      { if (!top.type || top.type.allowsMarkType(node.marks[i].type))
        { marks = node.marks[i].addToSet(marks); } }
    top.content.push(node.mark(marks));
    return true
  }
  return false
};

// : (NodeType, ?Object) → bool
// Try to start a node of the given type, adjusting the context when
// necessary.
ParseContext.prototype.enter = function enter (type, attrs, preserveWS) {
  var ok = this.findPlace(type.create(attrs));
  if (ok) { this.enterInner(type, attrs, true, preserveWS); }
  return ok
};

// Open a node of the given type
ParseContext.prototype.enterInner = function enterInner (type, attrs, solid, preserveWS) {
  this.closeExtra();
  var top = this.top;
  top.applyPending(type);
  top.match = top.match && top.match.matchType(type, attrs);
  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);
  if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT; }
  this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
  this.open++;
};

// Make sure all nodes above this.open are finished and added to
// their parents
ParseContext.prototype.closeExtra = function closeExtra (openEnd) {
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) { this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd)); }
    this.nodes.length = this.open + 1;
  }
};

ParseContext.prototype.finish = function finish () {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen)
};

ParseContext.prototype.sync = function sync (to) {
  for (var i = this.open; i >= 0; i--) { if (this.nodes[i] == to) {
    this.open = i;
    return
  } }
};

prototypeAccessors$6.currentPos.get = function () {
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content = this.nodes[i].content;
    for (var j = content.length - 1; j >= 0; j--)
      { pos += content[j].nodeSize; }
    if (i) { pos++; }
  }
  return pos
};

ParseContext.prototype.findAtPoint = function findAtPoint (parent, offset) {
  if (this.find) { for (var i = 0; i < this.find.length; i++) {
    if (this.find[i].node == parent && this.find[i].offset == offset)
      { this.find[i].pos = this.currentPos; }
  } }
};

ParseContext.prototype.findInside = function findInside (parent) {
  if (this.find) { for (var i = 0; i < this.find.length; i++) {
    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
      { this.find[i].pos = this.currentPos; }
  } }
};

ParseContext.prototype.findAround = function findAround (parent, content, before) {
  if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {
    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
      var pos = content.compareDocumentPosition(this.find[i].node);
      if (pos & (before ? 2 : 4))
        { this.find[i].pos = this.currentPos; }
    }
  } }
};

ParseContext.prototype.findInText = function findInText (textNode) {
  if (this.find) { for (var i = 0; i < this.find.length; i++) {
    if (this.find[i].node == textNode)
      { this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset); }
  } }
};

// : (string) → bool
// Determines whether the given [context
// string](#ParseRule.context) matches this context.
ParseContext.prototype.matchesContext = function matchesContext (context) {
    var this$1 = this;

  if (context.indexOf("|") > -1)
    { return context.split(/\s*\|\s*/).some(this.matchesContext, this) }

  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match = function (i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) { continue }
        for (; depth >= minDepth; depth--)
          { if (match(i - 1, depth)) { return true } }
        return false
      } else {
        var next = depth > 0 || (depth == 0 && useRoot) ? this$1.nodes[depth].type
            : option && depth >= minDepth ? option.node(depth - minDepth).type
            : null;
        if (!next || (next.name != part && next.groups.indexOf(part) == -1))
          { return false }
        depth--;
      }
    }
    return true
  };
  return match(parts.length - 1, this.open)
};

ParseContext.prototype.textblockFromContext = function textblockFromContext () {
  var $context = this.options.context;
  if ($context) { for (var d = $context.depth; d >= 0; d--) {
    var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
    if (deflt && deflt.isTextblock && deflt.defaultAttrs) { return deflt }
  } }
  for (var name in this.parser.schema.nodes) {
    var type = this.parser.schema.nodes[name];
    if (type.isTextblock && type.defaultAttrs) { return type }
  }
};

ParseContext.prototype.addPendingMark = function addPendingMark (mark) {
  var found = findSameMarkInSet(mark, this.top.pendingMarks);
  if (found) { this.top.stashMarks.push(found); }
  this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
};

ParseContext.prototype.removePendingMark = function removePendingMark (mark, upto) {
  for (var depth = this.open; depth >= 0; depth--) {
    var level = this.nodes[depth];
    var found = level.pendingMarks.lastIndexOf(mark);
    if (found > -1) {
      level.pendingMarks = mark.removeFromSet(level.pendingMarks);
    } else {
      level.activeMarks = mark.removeFromSet(level.activeMarks);
      var stashMark = level.popFromStashMark(mark);
      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
        { level.activeMarks = stashMark.addToSet(level.activeMarks); }
    }
    if (level == upto) { break }
  }
};

Object.defineProperties( ParseContext.prototype, prototypeAccessors$6 );

// Kludge to work around directly nested list nodes produced by some
// tools and allowed by browsers to mean that the nested list is
// actually part of the list item above it.
function normalizeList(dom) {
  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}

// Apply a CSS selector.
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)
}

// : (string) → [string]
// Tokenize a style attribute into property/value pairs.
function parseStyles(style) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
  while (m = re.exec(style)) { result.push(m[1], m[2].trim()); }
  return result
}

function copy(obj) {
  var copy = {};
  for (var prop in obj) { copy[prop] = obj[prop]; }
  return copy
}

// Used when finding a mark at the top level of a fragment parse.
// Checks whether it would be reasonable to apply a given mark type to
// a given node, by looking at the way the mark occurs in the schema.
function markMayApply(markType, nodeType) {
  var nodes = nodeType.schema.nodes;
  var loop = function ( name ) {
    var parent = nodes[name];
    if (!parent.allowsMarkType(markType)) { return }
    var seen = [], scan = function (match) {
      seen.push(match);
      for (var i = 0; i < match.edgeCount; i++) {
        var ref = match.edge(i);
        var type = ref.type;
        var next = ref.next;
        if (type == nodeType) { return true }
        if (seen.indexOf(next) < 0 && scan(next)) { return true }
      }
    };
    if (scan(parent.contentMatch)) { return { v: true } }
  };

  for (var name in nodes) {
    var returned = loop( name );

    if ( returned ) return returned.v;
  }
}

function findSameMarkInSet(mark, set) {
  for (var i = 0; i < set.length; i++) {
    if (mark.eq(set[i])) { return set[i] }
  }
}

// DOMOutputSpec:: interface
// A description of a DOM structure. Can be either a string, which is
// interpreted as a text node, a DOM node, which is interpreted as
// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.
//
// An array describes a DOM element. The first value in the array
// should be a string—the name of the DOM element, optionally prefixed
// by a namespace URL and a space. If the second element is plain
// object, it is interpreted as a set of attributes for the element.
// Any elements after that (including the 2nd if it's not an attribute
// object) are interpreted as children of the DOM elements, and must
// either be valid `DOMOutputSpec` values, or the number zero.
//
// The number zero (pronounced “hole”) is used to indicate the place
// where a node's child nodes should be inserted. If it occurs in an
// output spec, it should be the only child element in its parent
// node.

// ::- A DOM serializer knows how to convert ProseMirror nodes and
// marks of various types to DOM nodes.
var DOMSerializer = function DOMSerializer(nodes, marks) {
  // :: Object<(node: Node) → DOMOutputSpec>
  // The node serialization functions.
  this.nodes = nodes || {};
  // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>
  // The mark serialization functions.
  this.marks = marks || {};
};

// :: (Fragment, ?Object) → dom.DocumentFragment
// Serialize the content of this fragment to a DOM fragment. When
// not in the browser, the `document` option, containing a DOM
// document, should be passed so that the serializer can create
// nodes.
DOMSerializer.prototype.serializeFragment = function serializeFragment (fragment, options, target) {
    var this$1 = this;
    if ( options === void 0 ) options = {};

  if (!target) { target = doc(options).createDocumentFragment(); }

  var top = target, active = null;
  fragment.forEach(function (node) {
    if (active || node.marks.length) {
      if (!active) { active = []; }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node.marks.length) {
        var next = node.marks[rendered];
        if (!this$1.marks[next.type.name]) { rendered++; continue }
        if (!next.eq(active[keep]) || next.type.spec.spanning === false) { break }
        keep += 2; rendered++;
      }
      while (keep < active.length) {
        top = active.pop();
        active.pop();
      }
      while (rendered < node.marks.length) {
        var add = node.marks[rendered++];
        var markDOM = this$1.serializeMark(add, node.isInline, options);
        if (markDOM) {
          active.push(add, top);
          top.appendChild(markDOM.dom);
          top = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top.appendChild(this$1.serializeNodeInner(node, options));
  });

  return target
};

DOMSerializer.prototype.serializeNodeInner = function serializeNodeInner (node, options) {
    if ( options === void 0 ) options = {};

  var ref =
      DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
    var dom = ref.dom;
    var contentDOM = ref.contentDOM;
  if (contentDOM) {
    if (node.isLeaf)
      { throw new RangeError("Content hole not allowed in a leaf node spec") }
    if (options.onContent)
      { options.onContent(node, contentDOM, options); }
    else
      { this.serializeFragment(node.content, options, contentDOM); }
  }
  return dom
};

// :: (Node, ?Object) → dom.Node
// Serialize this node to a DOM node. This can be useful when you
// need to serialize a part of a document, as opposed to the whole
// document. To serialize a whole document, use
// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on
// its [content](#model.Node.content).
DOMSerializer.prototype.serializeNode = function serializeNode (node, options) {
    if ( options === void 0 ) options = {};

  var dom = this.serializeNodeInner(node, options);
  for (var i = node.marks.length - 1; i >= 0; i--) {
    var wrap = this.serializeMark(node.marks[i], node.isInline, options);
    if (wrap) {
(wrap.contentDOM || wrap.dom).appendChild(dom);
      dom = wrap.dom;
    }
  }
  return dom
};

DOMSerializer.prototype.serializeMark = function serializeMark (mark, inline, options) {
    if ( options === void 0 ) options = {};

  var toDOM = this.marks[mark.type.name];
  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))
};

// :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}
// Render an [output spec](#model.DOMOutputSpec) to a DOM node. If
// the spec has a hole (zero) in it, `contentDOM` will point at the
// node with the hole.
DOMSerializer.renderSpec = function renderSpec (doc, structure, xmlNS) {
    if ( xmlNS === void 0 ) xmlNS = null;

  if (typeof structure == "string")
    { return {dom: doc.createTextNode(structure)} }
  if (structure.nodeType != null)
    { return {dom: structure} }
  if (structure.dom && structure.dom.nodeType != null)
    { return structure }
  var tagName = structure[0], space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  var contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);
  var attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (var name in attrs) { if (attrs[name] != null) {
      var space$1 = name.indexOf(" ");
      if (space$1 > 0) { dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]); }
      else { dom.setAttribute(name, attrs[name]); }
    } }
  }
  for (var i = start; i < structure.length; i++) {
    var child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start)
        { throw new RangeError("Content hole must be the only child of its parent node") }
      return {dom: dom, contentDOM: dom}
    } else {
      var ref = DOMSerializer.renderSpec(doc, child, xmlNS);
        var inner = ref.dom;
        var innerContent = ref.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) { throw new RangeError("Multiple content holes") }
        contentDOM = innerContent;
      }
    }
  }
  return {dom: dom, contentDOM: contentDOM}
};

// :: (Schema) → DOMSerializer
// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)
// properties in a schema's node and mark specs.
DOMSerializer.fromSchema = function fromSchema (schema) {
  return schema.cached.domSerializer ||
    (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))
};

// : (Schema) → Object<(node: Node) → DOMOutputSpec>
// Gather the serializers in a schema's node specs into an object.
// This can be useful as a base to build a custom serializer from.
DOMSerializer.nodesFromSchema = function nodesFromSchema (schema) {
  var result = gatherToDOM(schema.nodes);
  if (!result.text) { result.text = function (node) { return node.text; }; }
  return result
};

// : (Schema) → Object<(mark: Mark) → DOMOutputSpec>
// Gather the serializers in a schema's mark specs into an object.
DOMSerializer.marksFromSchema = function marksFromSchema (schema) {
  return gatherToDOM(schema.marks)
};

function gatherToDOM(obj) {
  var result = {};
  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) { result[name] = toDOM; }
  }
  return result
}

function doc(options) {
  // declare global: window
  return options.document || window.document
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-schema-basic/dist/index.es.js":
/*!****************************************************************!*\
  !*** ./node_modules/prosemirror-schema-basic/dist/index.es.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "marks": () => (/* binding */ marks),
/* harmony export */   "nodes": () => (/* binding */ nodes),
/* harmony export */   "schema": () => (/* binding */ schema)
/* harmony export */ });
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");


var pDOM = ["p", 0], blockquoteDOM = ["blockquote", 0], hrDOM = ["hr"],
      preDOM = ["pre", ["code", 0]], brDOM = ["br"];

// :: Object
// [Specs](#model.NodeSpec) for the nodes defined in this schema.
var nodes = {
  // :: NodeSpec The top level document node.
  doc: {
    content: "block+"
  },

  // :: NodeSpec A plain paragraph textblock. Represented in the DOM
  // as a `<p>` element.
  paragraph: {
    content: "inline*",
    group: "block",
    parseDOM: [{tag: "p"}],
    toDOM: function toDOM() { return pDOM }
  },

  // :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.
  blockquote: {
    content: "block+",
    group: "block",
    defining: true,
    parseDOM: [{tag: "blockquote"}],
    toDOM: function toDOM() { return blockquoteDOM }
  },

  // :: NodeSpec A horizontal rule (`<hr>`).
  horizontal_rule: {
    group: "block",
    parseDOM: [{tag: "hr"}],
    toDOM: function toDOM() { return hrDOM }
  },

  // :: NodeSpec A heading textblock, with a `level` attribute that
  // should hold the number 1 to 6. Parsed and serialized as `<h1>` to
  // `<h6>` elements.
  heading: {
    attrs: {level: {default: 1}},
    content: "inline*",
    group: "block",
    defining: true,
    parseDOM: [{tag: "h1", attrs: {level: 1}},
               {tag: "h2", attrs: {level: 2}},
               {tag: "h3", attrs: {level: 3}},
               {tag: "h4", attrs: {level: 4}},
               {tag: "h5", attrs: {level: 5}},
               {tag: "h6", attrs: {level: 6}}],
    toDOM: function toDOM(node) { return ["h" + node.attrs.level, 0] }
  },

  // :: NodeSpec A code listing. Disallows marks or non-text inline
  // nodes by default. Represented as a `<pre>` element with a
  // `<code>` element inside of it.
  code_block: {
    content: "text*",
    marks: "",
    group: "block",
    code: true,
    defining: true,
    parseDOM: [{tag: "pre", preserveWhitespace: "full"}],
    toDOM: function toDOM() { return preDOM }
  },

  // :: NodeSpec The text node.
  text: {
    group: "inline"
  },

  // :: NodeSpec An inline image (`<img>`) node. Supports `src`,
  // `alt`, and `href` attributes. The latter two default to the empty
  // string.
  image: {
    inline: true,
    attrs: {
      src: {},
      alt: {default: null},
      title: {default: null}
    },
    group: "inline",
    draggable: true,
    parseDOM: [{tag: "img[src]", getAttrs: function getAttrs(dom) {
      return {
        src: dom.getAttribute("src"),
        title: dom.getAttribute("title"),
        alt: dom.getAttribute("alt")
      }
    }}],
    toDOM: function toDOM(node) { var ref = node.attrs;
    var src = ref.src;
    var alt = ref.alt;
    var title = ref.title; return ["img", {src: src, alt: alt, title: title}] }
  },

  // :: NodeSpec A hard line break, represented in the DOM as `<br>`.
  hard_break: {
    inline: true,
    group: "inline",
    selectable: false,
    parseDOM: [{tag: "br"}],
    toDOM: function toDOM() { return brDOM }
  }
};

var emDOM = ["em", 0], strongDOM = ["strong", 0], codeDOM = ["code", 0];

// :: Object [Specs](#model.MarkSpec) for the marks in the schema.
var marks = {
  // :: MarkSpec A link. Has `href` and `title` attributes. `title`
  // defaults to the empty string. Rendered and parsed as an `<a>`
  // element.
  link: {
    attrs: {
      href: {},
      title: {default: null}
    },
    inclusive: false,
    parseDOM: [{tag: "a[href]", getAttrs: function getAttrs(dom) {
      return {href: dom.getAttribute("href"), title: dom.getAttribute("title")}
    }}],
    toDOM: function toDOM(node) { var ref = node.attrs;
    var href = ref.href;
    var title = ref.title; return ["a", {href: href, title: title}, 0] }
  },

  // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.
  // Has parse rules that also match `<i>` and `font-style: italic`.
  em: {
    parseDOM: [{tag: "i"}, {tag: "em"}, {style: "font-style=italic"}],
    toDOM: function toDOM() { return emDOM }
  },

  // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules
  // also match `<b>` and `font-weight: bold`.
  strong: {
    parseDOM: [{tag: "strong"},
               // This works around a Google Docs misbehavior where
               // pasted content will be inexplicably wrapped in `<b>`
               // tags with a font-weight normal.
               {tag: "b", getAttrs: function (node) { return node.style.fontWeight != "normal" && null; }},
               {style: "font-weight", getAttrs: function (value) { return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null; }}],
    toDOM: function toDOM() { return strongDOM }
  },

  // :: MarkSpec Code font mark. Represented as a `<code>` element.
  code: {
    parseDOM: [{tag: "code"}],
    toDOM: function toDOM() { return codeDOM }
  }
};

// :: Schema
// This schema roughly corresponds to the document schema used by
// [CommonMark](http://commonmark.org/), minus the list elements,
// which are defined in the [`prosemirror-schema-list`](#schema-list)
// module.
//
// To reuse elements from this schema, extend or read from its
// `spec.nodes` and `spec.marks` [properties](#model.Schema.spec).
var schema = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema({nodes: nodes, marks: marks});


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-schema-list/dist/index.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/prosemirror-schema-list/dist/index.es.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "liftListItem": () => (/* binding */ liftListItem),
/* harmony export */   "sinkListItem": () => (/* binding */ sinkListItem),
/* harmony export */   "splitListItem": () => (/* binding */ splitListItem),
/* harmony export */   "wrapInList": () => (/* binding */ wrapInList)
/* harmony export */ });
/* unused harmony exports addListNodes, bulletList, listItem, orderedList */
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");



var olDOM = ["ol", 0], ulDOM = ["ul", 0], liDOM = ["li", 0];

// :: NodeSpec
// An ordered list [node spec](#model.NodeSpec). Has a single
// attribute, `order`, which determines the number at which the list
// starts counting, and defaults to 1. Represented as an `<ol>`
// element.
var orderedList = {
  attrs: {order: {default: 1}},
  parseDOM: [{tag: "ol", getAttrs: function getAttrs(dom) {
    return {order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1}
  }}],
  toDOM: function toDOM(node) {
    return node.attrs.order == 1 ? olDOM : ["ol", {start: node.attrs.order}, 0]
  }
};

// :: NodeSpec
// A bullet list node spec, represented in the DOM as `<ul>`.
var bulletList = {
  parseDOM: [{tag: "ul"}],
  toDOM: function toDOM() { return ulDOM }
};

// :: NodeSpec
// A list item (`<li>`) spec.
var listItem = {
  parseDOM: [{tag: "li"}],
  toDOM: function toDOM() { return liDOM },
  defining: true
};

function add(obj, props) {
  var copy = {};
  for (var prop in obj) { copy[prop] = obj[prop]; }
  for (var prop$1 in props) { copy[prop$1] = props[prop$1]; }
  return copy
}

// :: (OrderedMap<NodeSpec>, string, ?string) → OrderedMap<NodeSpec>
// Convenience function for adding list-related node types to a map
// specifying the nodes for a schema. Adds
// [`orderedList`](#schema-list.orderedList) as `"ordered_list"`,
// [`bulletList`](#schema-list.bulletList) as `"bullet_list"`, and
// [`listItem`](#schema-list.listItem) as `"list_item"`.
//
// `itemContent` determines the content expression for the list items.
// If you want the commands defined in this module to apply to your
// list structure, it should have a shape like `"paragraph block*"` or
// `"paragraph (ordered_list | bullet_list)*"`. `listGroup` can be
// given to assign a group name to the list node types, for example
// `"block"`.
function addListNodes(nodes, itemContent, listGroup) {
  return nodes.append({
    ordered_list: add(orderedList, {content: "list_item+", group: listGroup}),
    bullet_list: add(bulletList, {content: "list_item+", group: listGroup}),
    list_item: add(listItem, {content: itemContent})
  })
}

// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command function that wraps the selection in a list with
// the given type an attributes. If `dispatch` is null, only return a
// value to indicate whether this is possible, but don't actually
// perform the change.
function wrapInList(listType, attrs) {
  return function(state, dispatch) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to), doJoin = false, outerRange = range;
    if (!range) { return false }
    // This is at the top of an existing list item
    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      // Don't do anything if this is the top of the list
      if ($from.index(range.depth - 1) == 0) { return false }
      var $insert = state.doc.resolve(range.start - 2);
      outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount)
        { range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth); }
      doJoin = true;
    }
    var wrap = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(outerRange, listType, attrs, range);
    if (!wrap) { return false }
    if (dispatch) { dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView()); }
    return true
  }
}

function doWrapInList(tr, range, wrappers, joinBefore, listType) {
  var content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;
  for (var i = wrappers.length - 1; i >= 0; i--)
    { content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)); }

  tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end,
                                new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, 0, 0), wrappers.length, true));

  var found = 0;
  for (var i$1 = 0; i$1 < wrappers.length; i$1++) { if (wrappers[i$1].type == listType) { found = i$1 + 1; } }
  var splitDepth = wrappers.length - found;

  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (var i$2 = range.startIndex, e = range.endIndex, first = true; i$2 < e; i$2++, first = false) {
    if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i$2).nodeSize;
  }
  return tr
}

// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Build a command that splits a non-empty textblock at the top level
// of a list item by also splitting that list item.
function splitListItem(itemType) {
  return function(state, dispatch) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var node = ref.node;
    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) { return false }
    var grandParent = $from.node(-1);
    if (grandParent.type != itemType) { return false }
    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
      // In an empty block. If this is a nested list, the wrapping
      // list item should be split. Otherwise, bail out and let next
      // command handle lifting.
      if ($from.depth == 2 || $from.node(-3).type != itemType ||
          $from.index(-2) != $from.node(-2).childCount - 1) { return false }
      if (dispatch) {
        var wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;
        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        // Build a fragment containing empty versions of the structure
        // from the outer list item to the parent node of the cursor
        for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d--)
          { wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from($from.node(d).copy(wrap)); }
        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1
            : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        // Add a second list item with an empty default start node
        wrap = wrap.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(itemType.createAndFill()));
        var start = $from.before($from.depth - (depthBefore - 1));
        var tr$1 = state.tr.replace(start, $from.after(-depthAfter), new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(wrap, 4 - depthBefore, 0));
        var sel = -1;
        tr$1.doc.nodesBetween(start, tr$1.doc.content.size, function (node, pos) {
          if (sel > -1) { return false }
          if (node.isTextblock && node.content.size == 0) { sel = pos + 1; }
        });
        if (sel > -1) { tr$1.setSelection(state.selection.constructor.near(tr$1.doc.resolve(sel))); }
        dispatch(tr$1.scrollIntoView());
      }
      return true
    }
    var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    var tr = state.tr.delete($from.pos, $to.pos);
    var types = nextType && [null, {type: nextType}];
    if (!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, $from.pos, 2, types)) { return false }
    if (dispatch) { dispatch(tr.split($from.pos, 2, types).scrollIntoView()); }
    return true
  }
}

// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Create a command to lift the list item around the selection up into
// a wrapping list.
function liftListItem(itemType) {
  return function(state, dispatch) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == itemType; });
    if (!range) { return false }
    if (!dispatch) { return true }
    if ($from.node(range.depth - 1).type == itemType) // Inside a parent list
      { return liftToOuterList(state, dispatch, itemType, range) }
    else // Outer list node
      { return liftOutOfList(state, dispatch, range) }
  }
}

function liftToOuterList(state, dispatch, itemType, range) {
  var tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    // There are siblings after the lifted items, which must become
    // children of the last item
    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep(end - 1, endOfList, end, endOfList,
                                  new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }
  dispatch(tr.lift(range, (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range)).scrollIntoView());
  return true
}

function liftOutOfList(state, dispatch, range) {
  var tr = state.tr, list = range.parent;
  // Merge the list items into a single big item
  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  var $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) { return false }
  var atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  var parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1,
                         item.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list))))
    { return false }
  var start = $start.pos, end = start + item.nodeSize;
  // Strip off the surrounding list. At the sides where we're not at
  // the end of the list, the existing list is closed. At sides where
  // this is the end, it is overwritten to its end.
  tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1,
                                new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty)))
                                          .append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty))),
                                          atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true
}

// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Create a command to sink the list item around the selection down
// into an inner list.
function sinkListItem(itemType) {
  return function(state, dispatch) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == itemType; });
    if (!range) { return false }
    var startIndex = range.startIndex;
    if (startIndex == 0) { return false }
    var parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType) { return false }

    if (dispatch) {
      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      var inner = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(nestedBefore ? itemType.create() : null);
      var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(itemType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(parent.type.create(null, inner)))),
                            nestedBefore ? 3 : 1, 0);
      var before = range.start, after = range.end;
      dispatch(state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after,
                                                   before, after, slice, 1, true))
               .scrollIntoView());
    }
    return true
  }
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-state/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-state/dist/index.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AllSelection": () => (/* binding */ AllSelection),
/* harmony export */   "EditorState": () => (/* binding */ EditorState),
/* harmony export */   "NodeSelection": () => (/* binding */ NodeSelection),
/* harmony export */   "Plugin": () => (/* binding */ Plugin),
/* harmony export */   "PluginKey": () => (/* binding */ PluginKey),
/* harmony export */   "Selection": () => (/* binding */ Selection),
/* harmony export */   "SelectionRange": () => (/* binding */ SelectionRange),
/* harmony export */   "TextSelection": () => (/* binding */ TextSelection),
/* harmony export */   "Transaction": () => (/* binding */ Transaction)
/* harmony export */ });
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");



var classesById = Object.create(null);

// ::- Superclass for editor selections. Every selection type should
// extend this. Should not be instantiated directly.
var Selection = function Selection($anchor, $head, ranges) {
  // :: [SelectionRange]
  // The ranges covered by the selection.
  this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  // :: ResolvedPos
  // The resolved anchor of the selection (the side that stays in
  // place when the selection is modified).
  this.$anchor = $anchor;
  // :: ResolvedPos
  // The resolved head of the selection (the side that moves when
  // the selection is modified).
  this.$head = $head;
};

var prototypeAccessors = { anchor: { configurable: true },head: { configurable: true },from: { configurable: true },to: { configurable: true },$from: { configurable: true },$to: { configurable: true },empty: { configurable: true } };

// :: number
// The selection's anchor, as an unresolved position.
prototypeAccessors.anchor.get = function () { return this.$anchor.pos };

// :: number
// The selection's head.
prototypeAccessors.head.get = function () { return this.$head.pos };

// :: number
// The lower bound of the selection's main range.
prototypeAccessors.from.get = function () { return this.$from.pos };

// :: number
// The upper bound of the selection's main range.
prototypeAccessors.to.get = function () { return this.$to.pos };

// :: ResolvedPos
// The resolved lowerbound of the selection's main range.
prototypeAccessors.$from.get = function () {
  return this.ranges[0].$from
};

// :: ResolvedPos
// The resolved upper bound of the selection's main range.
prototypeAccessors.$to.get = function () {
  return this.ranges[0].$to
};

// :: bool
// Indicates whether the selection contains any content.
prototypeAccessors.empty.get = function () {
  var ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++)
    { if (ranges[i].$from.pos != ranges[i].$to.pos) { return false } }
  return true
};

// eq:: (Selection) → bool
// Test whether the selection is the same as another selection.

// map:: (doc: Node, mapping: Mappable) → Selection
// Map this selection through a [mappable](#transform.Mappable) thing. `doc`
// should be the new document to which we are mapping.

// :: () → Slice
// Get the content of this selection as a slice.
Selection.prototype.content = function content () {
  return this.$from.node(0).slice(this.from, this.to, true)
};

// :: (Transaction, ?Slice)
// Replace the selection with a slice or, if no slice is given,
// delete the selection. Will append to the given transaction.
Selection.prototype.replace = function replace (tr, content) {
    if ( content === void 0 ) content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

  // Put the new selection at the position after the inserted
  // content. When that ended in an inline node, search backwards,
  // to get the position after that node. If not, search forward.
  var lastNode = content.content.lastChild, lastParent = null;
  for (var i = 0; i < content.openEnd; i++) {
    lastParent = lastNode;
    lastNode = lastNode.lastChild;
  }

  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i$1 = 0; i$1 < ranges.length; i$1++) {
    var ref = ranges[i$1];
      var $from = ref.$from;
      var $to = ref.$to;
      var mapping = tr.mapping.slice(mapFrom);
    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : content);
    if (i$1 == 0)
      { selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1); }
  }
};

// :: (Transaction, Node)
// Replace the selection with the given node, appending the changes
// to the given transaction.
Selection.prototype.replaceWith = function replaceWith (tr, node) {
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++) {
    var ref = ranges[i];
      var $from = ref.$from;
      var $to = ref.$to;
      var mapping = tr.mapping.slice(mapFrom);
    var from = mapping.map($from.pos), to = mapping.map($to.pos);
    if (i) {
      tr.deleteRange(from, to);
    } else {
      tr.replaceRangeWith(from, to, node);
      selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
    }
  }
};

// toJSON:: () → Object
// Convert the selection to a JSON representation. When implementing
// this for a custom selection class, make sure to give the object a
// `type` property whose value matches the ID under which you
// [registered](#state.Selection^jsonID) your class.

// :: (ResolvedPos, number, ?bool) → ?Selection
// Find a valid cursor or leaf node selection starting at the given
// position and searching back if `dir` is negative, and forward if
// positive. When `textOnly` is true, only consider cursor
// selections. Will return null when no valid selection position is
// found.
Selection.findFrom = function findFrom ($pos, dir, textOnly) {
  var inner = $pos.parent.inlineContent ? new TextSelection($pos)
      : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
  if (inner) { return inner }

  for (var depth = $pos.depth - 1; depth >= 0; depth--) {
    var found = dir < 0
        ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)
        : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
    if (found) { return found }
  }
};

// :: (ResolvedPos, ?number) → Selection
// Find a valid cursor or leaf node selection near the given
// position. Searches forward first by default, but if `bias` is
// negative, it will search backwards first.
Selection.near = function near ($pos, bias) {
    if ( bias === void 0 ) bias = 1;

  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))
};

// :: (Node) → Selection
// Find the cursor or leaf node selection closest to the start of
// the given document. Will return an
// [`AllSelection`](#state.AllSelection) if no valid position
// exists.
Selection.atStart = function atStart (doc) {
  return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)
};

// :: (Node) → Selection
// Find the cursor or leaf node selection closest to the end of the
// given document.
Selection.atEnd = function atEnd (doc) {
  return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)
};

// :: (Node, Object) → Selection
// Deserialize the JSON representation of a selection. Must be
// implemented for custom classes (as a static class method).
Selection.fromJSON = function fromJSON (doc, json) {
  if (!json || !json.type) { throw new RangeError("Invalid input for Selection.fromJSON") }
  var cls = classesById[json.type];
  if (!cls) { throw new RangeError(("No selection type " + (json.type) + " defined")) }
  return cls.fromJSON(doc, json)
};

// :: (string, constructor<Selection>)
// To be able to deserialize selections from JSON, custom selection
// classes must register themselves with an ID string, so that they
// can be disambiguated. Try to pick something that's unlikely to
// clash with classes from other modules.
Selection.jsonID = function jsonID (id, selectionClass) {
  if (id in classesById) { throw new RangeError("Duplicate use of selection JSON ID " + id) }
  classesById[id] = selectionClass;
  selectionClass.prototype.jsonID = id;
  return selectionClass
};

// :: () → SelectionBookmark
// Get a [bookmark](#state.SelectionBookmark) for this selection,
// which is a value that can be mapped without having access to a
// current document, and later resolved to a real selection for a
// given document again. (This is used mostly by the history to
// track and restore old selections.) The default implementation of
// this method just converts the selection to a text selection and
// returns the bookmark for that.
Selection.prototype.getBookmark = function getBookmark () {
  return TextSelection.between(this.$anchor, this.$head).getBookmark()
};

Object.defineProperties( Selection.prototype, prototypeAccessors );

// :: bool
// Controls whether, when a selection of this type is active in the
// browser, the selected range should be visible to the user. Defaults
// to `true`.
Selection.prototype.visible = true;

// SelectionBookmark:: interface
// A lightweight, document-independent representation of a selection.
// You can define a custom bookmark type for a custom selection class
// to make the history handle it well.
//
//   map:: (mapping: Mapping) → SelectionBookmark
//   Map the bookmark through a set of changes.
//
//   resolve:: (doc: Node) → Selection
//   Resolve the bookmark to a real selection again. This may need to
//   do some error checking and may fall back to a default (usually
//   [`TextSelection.between`](#state.TextSelection^between)) if
//   mapping made the bookmark invalid.

// ::- Represents a selected range in a document.
var SelectionRange = function SelectionRange($from, $to) {
  // :: ResolvedPos
  // The lower bound of the range.
  this.$from = $from;
  // :: ResolvedPos
  // The upper bound of the range.
  this.$to = $to;
};

// ::- A text selection represents a classical editor selection, with
// a head (the moving side) and anchor (immobile side), both of which
// point into textblock nodes. It can be empty (a regular cursor
// position).
var TextSelection = /*@__PURE__*/(function (Selection) {
  function TextSelection($anchor, $head) {
    if ( $head === void 0 ) $head = $anchor;

    Selection.call(this, $anchor, $head);
  }

  if ( Selection ) TextSelection.__proto__ = Selection;
  TextSelection.prototype = Object.create( Selection && Selection.prototype );
  TextSelection.prototype.constructor = TextSelection;

  var prototypeAccessors$1 = { $cursor: { configurable: true } };

  // :: ?ResolvedPos
  // Returns a resolved position if this is a cursor selection (an
  // empty text selection), and null otherwise.
  prototypeAccessors$1.$cursor.get = function () { return this.$anchor.pos == this.$head.pos ? this.$head : null };

  TextSelection.prototype.map = function map (doc, mapping) {
    var $head = doc.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent) { return Selection.near($head) }
    var $anchor = doc.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)
  };

  TextSelection.prototype.replace = function replace (tr, content) {
    if ( content === void 0 ) content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

    Selection.prototype.replace.call(this, tr, content);
    if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {
      var marks = this.$from.marksAcross(this.$to);
      if (marks) { tr.ensureMarks(marks); }
    }
  };

  TextSelection.prototype.eq = function eq (other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head
  };

  TextSelection.prototype.getBookmark = function getBookmark () {
    return new TextBookmark(this.anchor, this.head)
  };

  TextSelection.prototype.toJSON = function toJSON () {
    return {type: "text", anchor: this.anchor, head: this.head}
  };

  TextSelection.fromJSON = function fromJSON (doc, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      { throw new RangeError("Invalid input for TextSelection.fromJSON") }
    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))
  };

  // :: (Node, number, ?number) → TextSelection
  // Create a text selection from non-resolved positions.
  TextSelection.create = function create (doc, anchor, head) {
    if ( head === void 0 ) head = anchor;

    var $anchor = doc.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))
  };

  // :: (ResolvedPos, ResolvedPos, ?number) → Selection
  // Return a text selection that spans the given positions or, if
  // they aren't text positions, find a text selection near them.
  // `bias` determines whether the method searches forward (default)
  // or backwards (negative number) first. Will fall back to calling
  // [`Selection.near`](#state.Selection^near) when the document
  // doesn't contain a valid text position.
  TextSelection.between = function between ($anchor, $head, bias) {
    var dPos = $anchor.pos - $head.pos;
    if (!bias || dPos) { bias = dPos >= 0 ? 1 : -1; }
    if (!$head.parent.inlineContent) {
      var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found) { $head = found.$head; }
      else { return Selection.near($head, bias) }
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if (($anchor.pos < $head.pos) != (dPos < 0)) { $anchor = $head; }
      }
    }
    return new TextSelection($anchor, $head)
  };

  Object.defineProperties( TextSelection.prototype, prototypeAccessors$1 );

  return TextSelection;
}(Selection));

Selection.jsonID("text", TextSelection);

var TextBookmark = function TextBookmark(anchor, head) {
  this.anchor = anchor;
  this.head = head;
};
TextBookmark.prototype.map = function map (mapping) {
  return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))
};
TextBookmark.prototype.resolve = function resolve (doc) {
  return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))
};

// ::- A node selection is a selection that points at a single node.
// All nodes marked [selectable](#model.NodeSpec.selectable) can be
// the target of a node selection. In such a selection, `from` and
// `to` point directly before and after the selected node, `anchor`
// equals `from`, and `head` equals `to`..
var NodeSelection = /*@__PURE__*/(function (Selection) {
  function NodeSelection($pos) {
    var node = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    Selection.call(this, $pos, $end);
    // :: Node The selected node.
    this.node = node;
  }

  if ( Selection ) NodeSelection.__proto__ = Selection;
  NodeSelection.prototype = Object.create( Selection && Selection.prototype );
  NodeSelection.prototype.constructor = NodeSelection;

  NodeSelection.prototype.map = function map (doc, mapping) {
    var ref = mapping.mapResult(this.anchor);
    var deleted = ref.deleted;
    var pos = ref.pos;
    var $pos = doc.resolve(pos);
    if (deleted) { return Selection.near($pos) }
    return new NodeSelection($pos)
  };

  NodeSelection.prototype.content = function content () {
    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(this.node), 0, 0)
  };

  NodeSelection.prototype.eq = function eq (other) {
    return other instanceof NodeSelection && other.anchor == this.anchor
  };

  NodeSelection.prototype.toJSON = function toJSON () {
    return {type: "node", anchor: this.anchor}
  };

  NodeSelection.prototype.getBookmark = function getBookmark () { return new NodeBookmark(this.anchor) };

  NodeSelection.fromJSON = function fromJSON (doc, json) {
    if (typeof json.anchor != "number")
      { throw new RangeError("Invalid input for NodeSelection.fromJSON") }
    return new NodeSelection(doc.resolve(json.anchor))
  };

  // :: (Node, number) → NodeSelection
  // Create a node selection from non-resolved positions.
  NodeSelection.create = function create (doc, from) {
    return new this(doc.resolve(from))
  };

  // :: (Node) → bool
  // Determines whether the given node may be selected as a node
  // selection.
  NodeSelection.isSelectable = function isSelectable (node) {
    return !node.isText && node.type.spec.selectable !== false
  };

  return NodeSelection;
}(Selection));

NodeSelection.prototype.visible = false;

Selection.jsonID("node", NodeSelection);

var NodeBookmark = function NodeBookmark(anchor) {
  this.anchor = anchor;
};
NodeBookmark.prototype.map = function map (mapping) {
  var ref = mapping.mapResult(this.anchor);
    var deleted = ref.deleted;
    var pos = ref.pos;
  return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)
};
NodeBookmark.prototype.resolve = function resolve (doc) {
  var $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;
  if (node && NodeSelection.isSelectable(node)) { return new NodeSelection($pos) }
  return Selection.near($pos)
};

// ::- A selection type that represents selecting the whole document
// (which can not necessarily be expressed with a text selection, when
// there are for example leaf block nodes at the start or end of the
// document).
var AllSelection = /*@__PURE__*/(function (Selection) {
  function AllSelection(doc) {
    Selection.call(this, doc.resolve(0), doc.resolve(doc.content.size));
  }

  if ( Selection ) AllSelection.__proto__ = Selection;
  AllSelection.prototype = Object.create( Selection && Selection.prototype );
  AllSelection.prototype.constructor = AllSelection;

  AllSelection.prototype.replace = function replace (tr, content) {
    if ( content === void 0 ) content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

    if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      var sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection)) { tr.setSelection(sel); }
    } else {
      Selection.prototype.replace.call(this, tr, content);
    }
  };

  AllSelection.prototype.toJSON = function toJSON () { return {type: "all"} };

  AllSelection.fromJSON = function fromJSON (doc) { return new AllSelection(doc) };

  AllSelection.prototype.map = function map (doc) { return new AllSelection(doc) };

  AllSelection.prototype.eq = function eq (other) { return other instanceof AllSelection };

  AllSelection.prototype.getBookmark = function getBookmark () { return AllBookmark };

  return AllSelection;
}(Selection));

Selection.jsonID("all", AllSelection);

var AllBookmark = {
  map: function map() { return this },
  resolve: function resolve(doc) { return new AllSelection(doc) }
};

// FIXME we'll need some awareness of text direction when scanning for selections

// Try to find a selection inside the given node. `pos` points at the
// position where the search starts. When `text` is true, only return
// text selections.
function findSelectionIn(doc, node, pos, index, dir, text) {
  if (node.inlineContent) { return TextSelection.create(doc, pos) }
  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    var child = node.child(i);
    if (!child.isAtom) {
      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner) { return inner }
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))
    }
    pos += child.nodeSize * dir;
  }
}

function selectionToInsertionEnd(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) { return }
  var step = tr.steps[last];
  if (!(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceStep || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep)) { return }
  var map = tr.mapping.maps[last], end;
  map.forEach(function (_from, _to, _newFrom, newTo) { if (end == null) { end = newTo; } });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}

var UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;

// ::- An editor state transaction, which can be applied to a state to
// create an updated state. Use
// [`EditorState.tr`](#state.EditorState.tr) to create an instance.
//
// Transactions track changes to the document (they are a subclass of
// [`Transform`](#transform.Transform)), but also other state changes,
// like selection updates and adjustments of the set of [stored
// marks](#state.EditorState.storedMarks). In addition, you can store
// metadata properties in a transaction, which are extra pieces of
// information that client code or plugins can use to describe what a
// transacion represents, so that they can update their [own
// state](#state.StateField) accordingly.
//
// The [editor view](#view.EditorView) uses a few metadata properties:
// it will attach a property `"pointer"` with the value `true` to
// selection transactions directly caused by mouse or touch input, and
// a `"uiEvent"` property of that may be `"paste"`, `"cut"`, or `"drop"`.
var Transaction = /*@__PURE__*/(function (Transform) {
  function Transaction(state) {
    Transform.call(this, state.doc);
    // :: number
    // The timestamp associated with this transaction, in the same
    // format as `Date.now()`.
    this.time = Date.now();
    this.curSelection = state.selection;
    // The step count for which the current selection is valid.
    this.curSelectionFor = 0;
    // :: ?[Mark]
    // The stored marks set by this transaction, if any.
    this.storedMarks = state.storedMarks;
    // Bitfield to track which aspects of the state were updated by
    // this transaction.
    this.updated = 0;
    // Object used to store metadata properties for the transaction.
    this.meta = Object.create(null);
  }

  if ( Transform ) Transaction.__proto__ = Transform;
  Transaction.prototype = Object.create( Transform && Transform.prototype );
  Transaction.prototype.constructor = Transaction;

  var prototypeAccessors = { selection: { configurable: true },selectionSet: { configurable: true },storedMarksSet: { configurable: true },isGeneric: { configurable: true },scrolledIntoView: { configurable: true } };

  // :: Selection
  // The transaction's current selection. This defaults to the editor
  // selection [mapped](#state.Selection.map) through the steps in the
  // transaction, but can be overwritten with
  // [`setSelection`](#state.Transaction.setSelection).
  prototypeAccessors.selection.get = function () {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection
  };

  // :: (Selection) → Transaction
  // Update the transaction's current selection. Will determine the
  // selection that the editor gets when the transaction is applied.
  Transaction.prototype.setSelection = function setSelection (selection) {
    if (selection.$from.doc != this.doc)
      { throw new RangeError("Selection passed to setSelection must point at the current document") }
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this
  };

  // :: bool
  // Whether the selection was explicitly updated by this transaction.
  prototypeAccessors.selectionSet.get = function () {
    return (this.updated & UPDATED_SEL) > 0
  };

  // :: (?[Mark]) → Transaction
  // Set the current stored marks.
  Transaction.prototype.setStoredMarks = function setStoredMarks (marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this
  };

  // :: ([Mark]) → Transaction
  // Make sure the current stored marks or, if that is null, the marks
  // at the selection, match the given set of marks. Does nothing if
  // this is already the case.
  Transaction.prototype.ensureMarks = function ensureMarks (marks) {
    if (!prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      { this.setStoredMarks(marks); }
    return this
  };

  // :: (Mark) → Transaction
  // Add a mark to the set of stored marks.
  Transaction.prototype.addStoredMark = function addStoredMark (mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))
  };

  // :: (union<Mark, MarkType>) → Transaction
  // Remove a mark or mark type from the set of stored marks.
  Transaction.prototype.removeStoredMark = function removeStoredMark (mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))
  };

  // :: bool
  // Whether the stored marks were explicitly set for this transaction.
  prototypeAccessors.storedMarksSet.get = function () {
    return (this.updated & UPDATED_MARKS) > 0
  };

  Transaction.prototype.addStep = function addStep (step, doc) {
    Transform.prototype.addStep.call(this, step, doc);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  };

  // :: (number) → Transaction
  // Update the timestamp for the transaction.
  Transaction.prototype.setTime = function setTime (time) {
    this.time = time;
    return this
  };

  // :: (Slice) → Transaction
  // Replace the current selection with the given slice.
  Transaction.prototype.replaceSelection = function replaceSelection (slice) {
    this.selection.replace(this, slice);
    return this
  };

  // :: (Node, ?bool) → Transaction
  // Replace the selection with the given node. When `inheritMarks` is
  // true and the content is inline, it inherits the marks from the
  // place where it is inserted.
  Transaction.prototype.replaceSelectionWith = function replaceSelectionWith (node, inheritMarks) {
    var selection = this.selection;
    if (inheritMarks !== false)
      { node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none))); }
    selection.replaceWith(this, node);
    return this
  };

  // :: () → Transaction
  // Delete the selection.
  Transaction.prototype.deleteSelection = function deleteSelection () {
    this.selection.replace(this);
    return this
  };

  // :: (string, from: ?number, to: ?number) → Transaction
  // Replace the given range, or the selection if no range is given,
  // with a text node containing the given string.
  Transaction.prototype.insertText = function insertText (text, from, to) {
    if ( to === void 0 ) to = from;

    var schema = this.doc.type.schema;
    if (from == null) {
      if (!text) { return this.deleteSelection() }
      return this.replaceSelectionWith(schema.text(text), true)
    } else {
      if (!text) { return this.deleteRange(from, to) }
      var marks = this.storedMarks;
      if (!marks) {
        var $from = this.doc.resolve(from);
        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from, to, schema.text(text, marks));
      if (!this.selection.empty) { this.setSelection(Selection.near(this.selection.$to)); }
      return this
    }
  };

  // :: (union<string, Plugin, PluginKey>, any) → Transaction
  // Store a metadata property in this transaction, keyed either by
  // name or by plugin.
  Transaction.prototype.setMeta = function setMeta (key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this
  };

  // :: (union<string, Plugin, PluginKey>) → any
  // Retrieve a metadata property for a given name or plugin.
  Transaction.prototype.getMeta = function getMeta (key) {
    return this.meta[typeof key == "string" ? key : key.key]
  };

  // :: bool
  // Returns true if this transaction doesn't contain any metadata,
  // and can thus safely be extended.
  prototypeAccessors.isGeneric.get = function () {
    for (var _ in this.meta) { return false }
    return true
  };

  // :: () → Transaction
  // Indicate that the editor should scroll the selection into view
  // when updated to the state produced by this transaction.
  Transaction.prototype.scrollIntoView = function scrollIntoView () {
    this.updated |= UPDATED_SCROLL;
    return this
  };

  prototypeAccessors.scrolledIntoView.get = function () {
    return (this.updated & UPDATED_SCROLL) > 0
  };

  Object.defineProperties( Transaction.prototype, prototypeAccessors );

  return Transaction;
}(prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Transform));

function bind(f, self) {
  return !self || !f ? f : f.bind(self)
}

var FieldDesc = function FieldDesc(name, desc, self) {
  this.name = name;
  this.init = bind(desc.init, self);
  this.apply = bind(desc.apply, self);
};

var baseFields = [
  new FieldDesc("doc", {
    init: function init(config) { return config.doc || config.schema.topNodeType.createAndFill() },
    apply: function apply(tr) { return tr.doc }
  }),

  new FieldDesc("selection", {
    init: function init(config, instance) { return config.selection || Selection.atStart(instance.doc) },
    apply: function apply(tr) { return tr.selection }
  }),

  new FieldDesc("storedMarks", {
    init: function init(config) { return config.storedMarks || null },
    apply: function apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }
  }),

  new FieldDesc("scrollToSelection", {
    init: function init() { return 0 },
    apply: function apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }
  })
];

// Object wrapping the part of a state object that stays the same
// across transactions. Stored in the state's `config` property.
var Configuration = function Configuration(schema, plugins) {
  var this$1 = this;

  this.schema = schema;
  this.fields = baseFields.concat();
  this.plugins = [];
  this.pluginsByKey = Object.create(null);
  if (plugins) { plugins.forEach(function (plugin) {
    if (this$1.pluginsByKey[plugin.key])
      { throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")") }
    this$1.plugins.push(plugin);
    this$1.pluginsByKey[plugin.key] = plugin;
    if (plugin.spec.state)
      { this$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin)); }
  }); }
};

// ::- The state of a ProseMirror editor is represented by an object
// of this type. A state is a persistent data structure—it isn't
// updated, but rather a new state value is computed from an old one
// using the [`apply`](#state.EditorState.apply) method.
//
// A state holds a number of built-in fields, and plugins can
// [define](#state.PluginSpec.state) additional fields.
var EditorState = function EditorState(config) {
  this.config = config;
};

var prototypeAccessors$1 = { schema: { configurable: true },plugins: { configurable: true },tr: { configurable: true } };

// doc:: Node
// The current document.

// selection:: Selection
// The selection.

// storedMarks:: ?[Mark]
// A set of marks to apply to the next input. Will be null when
// no explicit marks have been set.

// :: Schema
// The schema of the state's document.
prototypeAccessors$1.schema.get = function () {
  return this.config.schema
};

// :: [Plugin]
// The plugins that are active in this state.
prototypeAccessors$1.plugins.get = function () {
  return this.config.plugins
};

// :: (Transaction) → EditorState
// Apply the given transaction to produce a new state.
EditorState.prototype.apply = function apply (tr) {
  return this.applyTransaction(tr).state
};

// : (Transaction) → bool
EditorState.prototype.filterTransaction = function filterTransaction (tr, ignore) {
    if ( ignore === void 0 ) ignore = -1;

  for (var i = 0; i < this.config.plugins.length; i++) { if (i != ignore) {
    var plugin = this.config.plugins[i];
    if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
      { return false }
  } }
  return true
};

// :: (Transaction) → {state: EditorState, transactions: [Transaction]}
// Verbose variant of [`apply`](#state.EditorState.apply) that
// returns the precise transactions that were applied (which might
// be influenced by the [transaction
// hooks](#state.PluginSpec.filterTransaction) of
// plugins) along with the new state.
EditorState.prototype.applyTransaction = function applyTransaction (rootTr) {
  if (!this.filterTransaction(rootTr)) { return {state: this, transactions: []} }

  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
  // This loop repeatedly gives plugins a chance to respond to
  // transactions as new transactions are added, making sure to only
  // pass the transactions the plugin did not see before.
   for (;;) {
    var haveNew = false;
    for (var i = 0; i < this.config.plugins.length; i++) {
      var plugin = this.config.plugins[i];
      if (plugin.spec.appendTransaction) {
        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
        var tr = n < trs.length &&
            plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
        if (tr && newState.filterTransaction(tr, i)) {
          tr.setMeta("appendedTransaction", rootTr);
          if (!seen) {
            seen = [];
            for (var j = 0; j < this.config.plugins.length; j++)
              { seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0}); }
          }
          trs.push(tr);
          newState = newState.applyInner(tr);
          haveNew = true;
        }
        if (seen) { seen[i] = {state: newState, n: trs.length}; }
      }
    }
    if (!haveNew) { return {state: newState, transactions: trs} }
  }
};

// : (Transaction) → EditorState
EditorState.prototype.applyInner = function applyInner (tr) {
  if (!tr.before.eq(this.doc)) { throw new RangeError("Applying a mismatched transaction") }
  var newInstance = new EditorState(this.config), fields = this.config.fields;
  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
  }
  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) { applyListeners[i$1](this, tr, newInstance); }
  return newInstance
};

// :: Transaction
// Start a [transaction](#state.Transaction) from this state.
prototypeAccessors$1.tr.get = function () { return new Transaction(this) };

// :: (Object) → EditorState
// Create a new state.
//
// config::- Configuration options. Must contain `schema` or `doc` (or both).
//
//    schema:: ?Schema
//    The schema to use (only relevant if no `doc` is specified).
//
//    doc:: ?Node
//    The starting document.
//
//    selection:: ?Selection
//    A valid selection in the document.
//
//    storedMarks:: ?[Mark]
//    The initial set of [stored marks](#state.EditorState.storedMarks).
//
//    plugins:: ?[Plugin]
//    The plugins that should be active in this state.
EditorState.create = function create (config) {
  var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
  var instance = new EditorState($config);
  for (var i = 0; i < $config.fields.length; i++)
    { instance[$config.fields[i].name] = $config.fields[i].init(config, instance); }
  return instance
};

// :: (Object) → EditorState
// Create a new state based on this one, but with an adjusted set of
// active plugins. State fields that exist in both sets of plugins
// are kept unchanged. Those that no longer exist are dropped, and
// those that are new are initialized using their
// [`init`](#state.StateField.init) method, passing in the new
// configuration object..
//
// config::- configuration options
//
//   plugins:: [Plugin]
//   New set of active plugins.
EditorState.prototype.reconfigure = function reconfigure (config) {
  var $config = new Configuration(this.schema, config.plugins);
  var fields = $config.fields, instance = new EditorState($config);
  for (var i = 0; i < fields.length; i++) {
    var name = fields[i].name;
    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
  }
  return instance
};

// :: (?union<Object<Plugin>, string, number>) → Object
// Serialize this state to JSON. If you want to serialize the state
// of plugins, pass an object mapping property names to use in the
// resulting JSON object to plugin objects. The argument may also be
// a string or number, in which case it is ignored, to support the
// way `JSON.stringify` calls `toString` methods.
EditorState.prototype.toJSON = function toJSON (pluginFields) {
  var result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()};
  if (this.storedMarks) { result.storedMarks = this.storedMarks.map(function (m) { return m.toJSON(); }); }
  if (pluginFields && typeof pluginFields == 'object') { for (var prop in pluginFields) {
    if (prop == "doc" || prop == "selection")
      { throw new RangeError("The JSON fields `doc` and `selection` are reserved") }
    var plugin = pluginFields[prop], state = plugin.spec.state;
    if (state && state.toJSON) { result[prop] = state.toJSON.call(plugin, this[plugin.key]); }
  } }
  return result
};

// :: (Object, Object, ?Object<Plugin>) → EditorState
// Deserialize a JSON representation of a state. `config` should
// have at least a `schema` field, and should contain array of
// plugins to initialize the state with. `pluginFields` can be used
// to deserialize the state of plugins, by associating plugin
// instances with the property names they use in the JSON object.
//
// config::- configuration options
//
//   schema:: Schema
//   The schema to use.
//
//   plugins:: ?[Plugin]
//   The set of active plugins.
EditorState.fromJSON = function fromJSON (config, json, pluginFields) {
  if (!json) { throw new RangeError("Invalid input for EditorState.fromJSON") }
  if (!config.schema) { throw new RangeError("Required config field 'schema' missing") }
  var $config = new Configuration(config.schema, config.plugins);
  var instance = new EditorState($config);
  $config.fields.forEach(function (field) {
    if (field.name == "doc") {
      instance.doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node.fromJSON(config.schema, json.doc);
    } else if (field.name == "selection") {
      instance.selection = Selection.fromJSON(instance.doc, json.selection);
    } else if (field.name == "storedMarks") {
      if (json.storedMarks) { instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON); }
    } else {
      if (pluginFields) { for (var prop in pluginFields) {
        var plugin = pluginFields[prop], state = plugin.spec.state;
        if (plugin.key == field.name && state && state.fromJSON &&
            Object.prototype.hasOwnProperty.call(json, prop)) {
          // This field belongs to a plugin mapped to a JSON field, read it from there.
          instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
          return
        }
      } }
      instance[field.name] = field.init(config, instance);
    }
  });
  return instance
};

// Kludge to allow the view to track mappings between different
// instances of a state.
//
// FIXME this is no longer needed as of prosemirror-view 1.9.0,
// though due to backwards-compat we should probably keep it around
// for a while (if only as a no-op)
EditorState.addApplyListener = function addApplyListener (f) {
  applyListeners.push(f);
};
EditorState.removeApplyListener = function removeApplyListener (f) {
  var found = applyListeners.indexOf(f);
  if (found > -1) { applyListeners.splice(found, 1); }
};

Object.defineProperties( EditorState.prototype, prototypeAccessors$1 );

var applyListeners = [];

// PluginSpec:: interface
//
// This is the type passed to the [`Plugin`](#state.Plugin)
// constructor. It provides a definition for a plugin.
//
//   props:: ?EditorProps
//   The [view props](#view.EditorProps) added by this plugin. Props
//   that are functions will be bound to have the plugin instance as
//   their `this` binding.
//
//   state:: ?StateField<any>
//   Allows a plugin to define a [state field](#state.StateField), an
//   extra slot in the state object in which it can keep its own data.
//
//   key:: ?PluginKey
//   Can be used to make this a keyed plugin. You can have only one
//   plugin with a given key in a given state, but it is possible to
//   access the plugin's configuration and state through the key,
//   without having access to the plugin instance object.
//
//   view:: ?(EditorView) → Object
//   When the plugin needs to interact with the editor view, or
//   set something up in the DOM, use this field. The function
//   will be called when the plugin's state is associated with an
//   editor view.
//
//     return::-
//     Should return an object with the following optional
//     properties:
//
//       update:: ?(view: EditorView, prevState: EditorState)
//       Called whenever the view's state is updated.
//
//       destroy:: ?()
//       Called when the view is destroyed or receives a state
//       with different plugins.
//
//   filterTransaction:: ?(Transaction, EditorState) → bool
//   When present, this will be called before a transaction is
//   applied by the state, allowing the plugin to cancel it (by
//   returning false).
//
//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction
//   Allows the plugin to append another transaction to be applied
//   after the given array of transactions. When another plugin
//   appends a transaction after this was called, it is called again
//   with the new state and new transactions—but only the new
//   transactions, i.e. it won't be passed transactions that it
//   already saw.

function bindProps(obj, self, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function) { val = val.bind(self); }
    else if (prop == "handleDOMEvents") { val = bindProps(val, self, {}); }
    target[prop] = val;
  }
  return target
}

// ::- Plugins bundle functionality that can be added to an editor.
// They are part of the [editor state](#state.EditorState) and
// may influence that state and the view that contains it.
var Plugin = function Plugin(spec) {
  // :: EditorProps
  // The [props](#view.EditorProps) exported by this plugin.
  this.props = {};
  if (spec.props) { bindProps(spec.props, this, this.props); }
  // :: Object
  // The plugin's [spec object](#state.PluginSpec).
  this.spec = spec;
  this.key = spec.key ? spec.key.key : createKey("plugin");
};

// :: (EditorState) → any
// Extract the plugin's state field from an editor state.
Plugin.prototype.getState = function getState (state) { return state[this.key] };

// StateField:: interface<T>
// A plugin spec may provide a state field (under its
// [`state`](#state.PluginSpec.state) property) of this type, which
// describes the state it wants to keep. Functions provided here are
// always called with the plugin instance as their `this` binding.
//
//   init:: (config: Object, instance: EditorState) → T
//   Initialize the value of the field. `config` will be the object
//   passed to [`EditorState.create`](#state.EditorState^create). Note
//   that `instance` is a half-initialized state instance, and will
//   not have values for plugin fields initialized after this one.
//
//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T
//   Apply the given transaction to this state field, producing a new
//   field value. Note that the `newState` argument is again a partially
//   constructed state does not yet contain the state from plugins
//   coming after this one.
//
//   toJSON:: ?(value: T) → *
//   Convert this field to JSON. Optional, can be left off to disable
//   JSON serialization for the field.
//
//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T
//   Deserialize the JSON representation of this field. Note that the
//   `state` argument is again a half-initialized state.

var keys = Object.create(null);

function createKey(name) {
  if (name in keys) { return name + "$" + ++keys[name] }
  keys[name] = 0;
  return name + "$"
}

// ::- A key is used to [tag](#state.PluginSpec.key)
// plugins in a way that makes it possible to find them, given an
// editor state. Assigning a key does mean only one plugin of that
// type can be active in a state.
var PluginKey = function PluginKey(name) {
if ( name === void 0 ) name = "key";
 this.key = createKey(name); };

// :: (EditorState) → ?Plugin
// Get the active plugin with this key, if any, from an editor
// state.
PluginKey.prototype.get = function get (state) { return state.config.pluginsByKey[this.key] };

// :: (EditorState) → ?any
// Get the plugin's state from an editor state.
PluginKey.prototype.getState = function getState (state) { return state[this.key] };


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-transform/dist/index.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.es.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Mapping": () => (/* binding */ Mapping),
/* harmony export */   "ReplaceAroundStep": () => (/* binding */ ReplaceAroundStep),
/* harmony export */   "ReplaceStep": () => (/* binding */ ReplaceStep),
/* harmony export */   "Transform": () => (/* binding */ Transform),
/* harmony export */   "canJoin": () => (/* binding */ canJoin),
/* harmony export */   "canSplit": () => (/* binding */ canSplit),
/* harmony export */   "dropPoint": () => (/* binding */ dropPoint),
/* harmony export */   "findWrapping": () => (/* binding */ findWrapping),
/* harmony export */   "joinPoint": () => (/* binding */ joinPoint),
/* harmony export */   "liftTarget": () => (/* binding */ liftTarget)
/* harmony export */ });
/* unused harmony exports AddMarkStep, MapResult, RemoveMarkStep, Step, StepMap, StepResult, TransformError, insertPoint, replaceStep */
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");


// Mappable:: interface
// There are several things that positions can be mapped through.
// Such objects conform to this interface.
//
//   map:: (pos: number, assoc: ?number) → number
//   Map a position through this object. When given, `assoc` (should
//   be -1 or 1, defaults to 1) determines with which side the
//   position is associated, which determines in which direction to
//   move when a chunk of content is inserted at the mapped position.
//
//   mapResult:: (pos: number, assoc: ?number) → MapResult
//   Map a position, and return an object containing additional
//   information about the mapping. The result's `deleted` field tells
//   you whether the position was deleted (completely enclosed in a
//   replaced range) during the mapping. When content on only one side
//   is deleted, the position itself is only considered deleted when
//   `assoc` points in the direction of the deleted content.

// Recovery values encode a range index and an offset. They are
// represented as numbers, because tons of them will be created when
// mapping, for example, a large number of decorations. The number's
// lower 16 bits provide the index, the remaining bits the offset.
//
// Note: We intentionally don't use bit shift operators to en- and
// decode these, since those clip to 32 bits, which we might in rare
// cases want to overflow. A 64-bit float can represent 48-bit
// integers precisely.

var lower16 = 0xffff;
var factor16 = Math.pow(2, 16);

function makeRecover(index, offset) { return index + offset * factor16 }
function recoverIndex(value) { return value & lower16 }
function recoverOffset(value) { return (value - (value & lower16)) / factor16 }

// ::- An object representing a mapped position with extra
// information.
var MapResult = function MapResult(pos, deleted, recover) {
  if ( deleted === void 0 ) deleted = false;
  if ( recover === void 0 ) recover = null;

  // :: number The mapped version of the position.
  this.pos = pos;
  // :: bool Tells you whether the position was deleted, that is,
  // whether the step removed its surroundings from the document.
  this.deleted = deleted;
  this.recover = recover;
};

// :: class extends Mappable
// A map describing the deletions and insertions made by a step, which
// can be used to find the correspondence between positions in the
// pre-step version of a document and the same position in the
// post-step version.
var StepMap = function StepMap(ranges, inverted) {
  if ( inverted === void 0 ) inverted = false;

  this.ranges = ranges;
  this.inverted = inverted;
};

StepMap.prototype.recover = function recover (value) {
  var diff = 0, index = recoverIndex(value);
  if (!this.inverted) { for (var i = 0; i < index; i++)
    { diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]; } }
  return this.ranges[index * 3] + diff + recoverOffset(value)
};

// : (number, ?number) → MapResult
StepMap.prototype.mapResult = function mapResult (pos, assoc) {
  if ( assoc === void 0 ) assoc = 1;
 return this._map(pos, assoc, false) };

// : (number, ?number) → number
StepMap.prototype.map = function map (pos, assoc) {
  if ( assoc === void 0 ) assoc = 1;
 return this._map(pos, assoc, true) };

StepMap.prototype._map = function _map (pos, assoc, simple) {
  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start = this.ranges[i] - (this.inverted ? diff : 0);
    if (start > pos) { break }
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
    if (pos <= end) {
      var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
      var result = start + diff + (side < 0 ? 0 : newSize);
      if (simple) { return result }
      var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
      return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)
    }
    diff += newSize - oldSize;
  }
  return simple ? pos + diff : new MapResult(pos + diff)
};

StepMap.prototype.touches = function touches (pos, recover) {
  var diff = 0, index = recoverIndex(recover);
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start = this.ranges[i] - (this.inverted ? diff : 0);
    if (start > pos) { break }
    var oldSize = this.ranges[i + oldIndex], end = start + oldSize;
    if (pos <= end && i == index * 3) { return true }
    diff += this.ranges[i + newIndex] - oldSize;
  }
  return false
};

// :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))
// Calls the given function on each of the changed ranges included in
// this map.
StepMap.prototype.forEach = function forEach (f) {
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
    var start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
    diff += newSize - oldSize;
  }
};

// :: () → StepMap
// Create an inverted version of this map. The result can be used to
// map positions in the post-step document to the pre-step document.
StepMap.prototype.invert = function invert () {
  return new StepMap(this.ranges, !this.inverted)
};

StepMap.prototype.toString = function toString () {
  return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
};

// :: (n: number) → StepMap
// Create a map that moves all positions by offset `n` (which may be
// negative). This can be useful when applying steps meant for a
// sub-document to a larger document, or vice-versa.
StepMap.offset = function offset (n) {
  return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])
};

StepMap.empty = new StepMap([]);

// :: class extends Mappable
// A mapping represents a pipeline of zero or more [step
// maps](#transform.StepMap). It has special provisions for losslessly
// handling mapping positions through a series of steps in which some
// steps are inverted versions of earlier steps. (This comes up when
// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for
// collaboration or history management.)
var Mapping = function Mapping(maps, mirror, from, to) {
  // :: [StepMap]
  // The step maps in this mapping.
  this.maps = maps || [];
  // :: number
  // The starting position in the `maps` array, used when `map` or
  // `mapResult` is called.
  this.from = from || 0;
  // :: number
  // The end position in the `maps` array.
  this.to = to == null ? this.maps.length : to;
  this.mirror = mirror;
};

// :: (?number, ?number) → Mapping
// Create a mapping that maps only through a part of this one.
Mapping.prototype.slice = function slice (from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.maps.length;

  return new Mapping(this.maps, this.mirror, from, to)
};

Mapping.prototype.copy = function copy () {
  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)
};

// :: (StepMap, ?number)
// Add a step map to the end of this mapping. If `mirrors` is
// given, it should be the index of the step map that is the mirror
// image of this one.
Mapping.prototype.appendMap = function appendMap (map, mirrors) {
  this.to = this.maps.push(map);
  if (mirrors != null) { this.setMirror(this.maps.length - 1, mirrors); }
};

// :: (Mapping)
// Add all the step maps in a given mapping to this one (preserving
// mirroring information).
Mapping.prototype.appendMapping = function appendMapping (mapping) {
  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
  }
};

// :: (number) → ?number
// Finds the offset of the step map that mirrors the map at the
// given offset, in this mapping (as per the second argument to
// `appendMap`).
Mapping.prototype.getMirror = function getMirror (n) {
  if (this.mirror) { for (var i = 0; i < this.mirror.length; i++)
    { if (this.mirror[i] == n) { return this.mirror[i + (i % 2 ? -1 : 1)] } } }
};

Mapping.prototype.setMirror = function setMirror (n, m) {
  if (!this.mirror) { this.mirror = []; }
  this.mirror.push(n, m);
};

// :: (Mapping)
// Append the inverse of the given mapping to this one.
Mapping.prototype.appendMappingInverted = function appendMappingInverted (mapping) {
  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
  }
};

// :: () → Mapping
// Create an inverted version of this mapping.
Mapping.prototype.invert = function invert () {
  var inverse = new Mapping;
  inverse.appendMappingInverted(this);
  return inverse
};

// : (number, ?number) → number
// Map a position through this mapping.
Mapping.prototype.map = function map (pos, assoc) {
    if ( assoc === void 0 ) assoc = 1;

  if (this.mirror) { return this._map(pos, assoc, true) }
  for (var i = this.from; i < this.to; i++)
    { pos = this.maps[i].map(pos, assoc); }
  return pos
};

// : (number, ?number) → MapResult
// Map a position through this mapping, returning a mapping
// result.
Mapping.prototype.mapResult = function mapResult (pos, assoc) {
  if ( assoc === void 0 ) assoc = 1;
 return this._map(pos, assoc, false) };

Mapping.prototype._map = function _map (pos, assoc, simple) {
  var deleted = false;

  for (var i = this.from; i < this.to; i++) {
    var map = this.maps[i], result = map.mapResult(pos, assoc);
    if (result.recover != null) {
      var corr = this.getMirror(i);
      if (corr != null && corr > i && corr < this.to) {
        i = corr;
        pos = this.maps[corr].recover(result.recover);
        continue
      }
    }

    if (result.deleted) { deleted = true; }
    pos = result.pos;
  }

  return simple ? pos : new MapResult(pos, deleted)
};

function TransformError(message) {
  var err = Error.call(this, message);
  err.__proto__ = TransformError.prototype;
  return err
}

TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";

// ::- Abstraction to build up and track an array of
// [steps](#transform.Step) representing a document transformation.
//
// Most transforming methods return the `Transform` object itself, so
// that they can be chained.
var Transform = function Transform(doc) {
  // :: Node
  // The current document (the result of applying the steps in the
  // transform).
  this.doc = doc;
  // :: [Step]
  // The steps in this transform.
  this.steps = [];
  // :: [Node]
  // The documents before each of the steps.
  this.docs = [];
  // :: Mapping
  // A mapping with the maps for each of the steps in this transform.
  this.mapping = new Mapping;
};

var prototypeAccessors = { before: { configurable: true },docChanged: { configurable: true } };

// :: Node The starting document.
prototypeAccessors.before.get = function () { return this.docs.length ? this.docs[0] : this.doc };

// :: (step: Step) → this
// Apply a new step in this transform, saving the result. Throws an
// error when the step fails.
Transform.prototype.step = function step (object) {
  var result = this.maybeStep(object);
  if (result.failed) { throw new TransformError(result.failed) }
  return this
};

// :: (Step) → StepResult
// Try to apply a step in this transformation, ignoring it if it
// fails. Returns the step result.
Transform.prototype.maybeStep = function maybeStep (step) {
  var result = step.apply(this.doc);
  if (!result.failed) { this.addStep(step, result.doc); }
  return result
};

// :: bool
// True when the document has been changed (when there are any
// steps).
prototypeAccessors.docChanged.get = function () {
  return this.steps.length > 0
};

Transform.prototype.addStep = function addStep (step, doc) {
  this.docs.push(this.doc);
  this.steps.push(step);
  this.mapping.appendMap(step.getMap());
  this.doc = doc;
};

Object.defineProperties( Transform.prototype, prototypeAccessors );

function mustOverride() { throw new Error("Override me") }

var stepsByID = Object.create(null);

// ::- A step object represents an atomic change. It generally applies
// only to the document it was created for, since the positions
// stored in it will only make sense for that document.
//
// New steps are defined by creating classes that extend `Step`,
// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
// methods, and registering your class with a unique
// JSON-serialization identifier using
// [`Step.jsonID`](#transform.Step^jsonID).
var Step = function Step () {};

Step.prototype.apply = function apply (_doc) { return mustOverride() };

// :: () → StepMap
// Get the step map that represents the changes made by this step,
// and which can be used to transform between positions in the old
// and the new document.
Step.prototype.getMap = function getMap () { return StepMap.empty };

// :: (doc: Node) → Step
// Create an inverted version of this step. Needs the document as it
// was before the step as argument.
Step.prototype.invert = function invert (_doc) { return mustOverride() };

// :: (mapping: Mappable) → ?Step
// Map this step through a mappable thing, returning either a
// version of that step with its positions adjusted, or `null` if
// the step was entirely deleted by the mapping.
Step.prototype.map = function map (_mapping) { return mustOverride() };

// :: (other: Step) → ?Step
// Try to merge this step with another one, to be applied directly
// after it. Returns the merged step when possible, null if the
// steps can't be merged.
Step.prototype.merge = function merge (_other) { return null };

// :: () → Object
// Create a JSON-serializeable representation of this step. When
// defining this for a custom subclass, make sure the result object
// includes the step type's [JSON id](#transform.Step^jsonID) under
// the `stepType` property.
Step.prototype.toJSON = function toJSON () { return mustOverride() };

// :: (Schema, Object) → Step
// Deserialize a step from its JSON representation. Will call
// through to the step class' own implementation of this method.
Step.fromJSON = function fromJSON (schema, json) {
  if (!json || !json.stepType) { throw new RangeError("Invalid input for Step.fromJSON") }
  var type = stepsByID[json.stepType];
  if (!type) { throw new RangeError(("No step type " + (json.stepType) + " defined")) }
  return type.fromJSON(schema, json)
};

// :: (string, constructor<Step>)
// To be able to serialize steps to JSON, each step needs a string
// ID to attach to its JSON representation. Use this method to
// register an ID for your step classes. Try to pick something
// that's unlikely to clash with steps from other modules.
Step.jsonID = function jsonID (id, stepClass) {
  if (id in stepsByID) { throw new RangeError("Duplicate use of step JSON ID " + id) }
  stepsByID[id] = stepClass;
  stepClass.prototype.jsonID = id;
  return stepClass
};

// ::- The result of [applying](#transform.Step.apply) a step. Contains either a
// new document or a failure value.
var StepResult = function StepResult(doc, failed) {
  // :: ?Node The transformed document.
  this.doc = doc;
  // :: ?string Text providing information about a failed step.
  this.failed = failed;
};

// :: (Node) → StepResult
// Create a successful step result.
StepResult.ok = function ok (doc) { return new StepResult(doc, null) };

// :: (string) → StepResult
// Create a failed step result.
StepResult.fail = function fail (message) { return new StepResult(null, message) };

// :: (Node, number, number, Slice) → StepResult
// Call [`Node.replace`](#model.Node.replace) with the given
// arguments. Create a successful result if it succeeds, and a
// failed one if it throws a `ReplaceError`.
StepResult.fromReplace = function fromReplace (doc, from, to, slice) {
  try {
    return StepResult.ok(doc.replace(from, to, slice))
  } catch (e) {
    if (e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError) { return StepResult.fail(e.message) }
    throw e
  }
};

// ::- Replace a part of the document with a slice of new content.
var ReplaceStep = /*@__PURE__*/(function (Step) {
  function ReplaceStep(from, to, slice, structure) {
    Step.call(this);
    // :: number
    // The start position of the replaced range.
    this.from = from;
    // :: number
    // The end position of the replaced range.
    this.to = to;
    // :: Slice
    // The slice to insert.
    this.slice = slice;
    this.structure = !!structure;
  }

  if ( Step ) ReplaceStep.__proto__ = Step;
  ReplaceStep.prototype = Object.create( Step && Step.prototype );
  ReplaceStep.prototype.constructor = ReplaceStep;

  ReplaceStep.prototype.apply = function apply (doc) {
    if (this.structure && contentBetween(doc, this.from, this.to))
      { return StepResult.fail("Structure replace would overwrite content") }
    return StepResult.fromReplace(doc, this.from, this.to, this.slice)
  };

  ReplaceStep.prototype.getMap = function getMap () {
    return new StepMap([this.from, this.to - this.from, this.slice.size])
  };

  ReplaceStep.prototype.invert = function invert (doc) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))
  };

  ReplaceStep.prototype.map = function map (mapping) {
    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted) { return null }
    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)
  };

  ReplaceStep.prototype.merge = function merge (other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure) { return null }

    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      var slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty
          : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      var slice$1 = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty
          : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice$1, this.structure)
    } else {
      return null
    }
  };

  ReplaceStep.prototype.toJSON = function toJSON () {
    var json = {stepType: "replace", from: this.from, to: this.to};
    if (this.slice.size) { json.slice = this.slice.toJSON(); }
    if (this.structure) { json.structure = true; }
    return json
  };

  ReplaceStep.fromJSON = function fromJSON (schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      { throw new RangeError("Invalid input for ReplaceStep.fromJSON") }
    return new ReplaceStep(json.from, json.to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), !!json.structure)
  };

  return ReplaceStep;
}(Step));

Step.jsonID("replace", ReplaceStep);

// ::- Replace a part of the document with a slice of content, but
// preserve a range of the replaced content by moving it into the
// slice.
var ReplaceAroundStep = /*@__PURE__*/(function (Step) {
  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {
    Step.call(this);
    // :: number
    // The start position of the replaced range.
    this.from = from;
    // :: number
    // The end position of the replaced range.
    this.to = to;
    // :: number
    // The start of preserved range.
    this.gapFrom = gapFrom;
    // :: number
    // The end of preserved range.
    this.gapTo = gapTo;
    // :: Slice
    // The slice to insert.
    this.slice = slice;
    // :: number
    // The position in the slice where the preserved range should be
    // inserted.
    this.insert = insert;
    this.structure = !!structure;
  }

  if ( Step ) ReplaceAroundStep.__proto__ = Step;
  ReplaceAroundStep.prototype = Object.create( Step && Step.prototype );
  ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;

  ReplaceAroundStep.prototype.apply = function apply (doc) {
    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||
                           contentBetween(doc, this.gapTo, this.to)))
      { return StepResult.fail("Structure gap-replace would overwrite content") }

    var gap = doc.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      { return StepResult.fail("Gap is not a flat range") }
    var inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted) { return StepResult.fail("Content does not fit in gap") }
    return StepResult.fromReplace(doc, this.from, this.to, inserted)
  };

  ReplaceAroundStep.prototype.getMap = function getMap () {
    return new StepMap([this.from, this.gapFrom - this.from, this.insert,
                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])
  };

  ReplaceAroundStep.prototype.invert = function invert (doc) {
    var gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,
                                 this.from + this.insert, this.from + this.insert + gap,
                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
                                 this.gapFrom - this.from, this.structure)
  };

  ReplaceAroundStep.prototype.map = function map (mapping) {
    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) { return null }
    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)
  };

  ReplaceAroundStep.prototype.toJSON = function toJSON () {
    var json = {stepType: "replaceAround", from: this.from, to: this.to,
                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert};
    if (this.slice.size) { json.slice = this.slice.toJSON(); }
    if (this.structure) { json.structure = true; }
    return json
  };

  ReplaceAroundStep.fromJSON = function fromJSON (schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" ||
        typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      { throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON") }
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,
                                 prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)
  };

  return ReplaceAroundStep;
}(Step));

Step.jsonID("replaceAround", ReplaceAroundStep);

function contentBetween(doc, from, to) {
  var $from = doc.resolve(from), dist = to - from, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf) { return true }
      next = next.firstChild;
      dist--;
    }
  }
  return false
}

function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) &&
    (end == node.childCount || node.canReplace(0, end))
}

// :: (NodeRange) → ?number
// Try to find a target depth to which the content in the given range
// can be lifted. Will not go across
// [isolating](#model.NodeSpec.isolating) parent nodes.
function liftTarget(range) {
  var parent = range.parent;
  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (var depth = range.depth;; --depth) {
    var node = range.$from.node(depth);
    var index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content))
      { return depth }
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) { break }
  }
}

// :: (NodeRange, number) → this
// Split the content in the given range off from its parent, if there
// is sibling content before or after it, and move it up the tree to
// the depth specified by `target`. You'll probably want to use
// [`liftTarget`](#transform.liftTarget) to compute `target`, to make
// sure the lift is valid.
Transform.prototype.lift = function(range, target) {
  var $from = range.$from;
  var $to = range.$to;
  var depth = range.depth;

  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  var start = gapStart, end = gapEnd;

  var before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openStart = 0;
  for (var d = depth, splitting = false; d > target; d--)
    { if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    } }
  var after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openEnd = 0;
  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--)
    { if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
      splitting$1 = true;
      after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($to.node(d$1).copy(after));
      openEnd++;
    } else {
      end++;
    } }

  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,
                                         new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), openStart, openEnd),
                                         before.size - openStart, true))
};

// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]
// Try to find a valid way to wrap the content in the given range in a
// node of the given type. May introduce extra nodes around and inside
// the wrapper node, if necessary. Returns null if no valid wrapping
// could be found. When `innerRange` is given, that range's content is
// used as the content to fit into the wrapping, instead of the
// content of `range`.
function findWrapping(range, nodeType, attrs, innerRange) {
  if ( innerRange === void 0 ) innerRange = range;

  var around = findWrappingOutside(range, nodeType);
  var inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner) { return null }
  return around.map(withAttrs).concat({type: nodeType, attrs: attrs}).concat(inner.map(withAttrs))
}

function withAttrs(type) { return {type: type, attrs: null} }

function findWrappingOutside(range, type) {
  var parent = range.parent;
  var startIndex = range.startIndex;
  var endIndex = range.endIndex;
  var around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around) { return null }
  var outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null
}

function findWrappingInside(range, type) {
  var parent = range.parent;
  var startIndex = range.startIndex;
  var endIndex = range.endIndex;
  var inner = parent.child(startIndex);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (!inside) { return null }
  var lastType = inside.length ? inside[inside.length - 1] : type;
  var innerMatch = lastType.contentMatch;
  for (var i = startIndex; innerMatch && i < endIndex; i++)
    { innerMatch = innerMatch.matchType(parent.child(i).type); }
  if (!innerMatch || !innerMatch.validEnd) { return null }
  return inside
}

// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this
// Wrap the given [range](#model.NodeRange) in the given set of wrappers.
// The wrappers are assumed to be valid in this position, and should
// probably be computed with [`findWrapping`](#transform.findWrapping).
Transform.prototype.wrap = function(range, wrappers) {
  var content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
  for (var i = wrappers.length - 1; i >= 0; i--)
    { content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)); }

  var start = range.start, end = range.end;
  return this.step(new ReplaceAroundStep(start, end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true))
};

// :: (number, ?number, NodeType, ?Object) → this
// Set the type of all textblocks (partly) between `from` and `to` to
// the given node type with the given attributes.
Transform.prototype.setBlockType = function(from, to, type, attrs) {
  var this$1 = this;
  if ( to === void 0 ) to = from;

  if (!type.isTextblock) { throw new RangeError("Type given to setBlockType should be a textblock") }
  var mapFrom = this.steps.length;
  this.doc.nodesBetween(from, to, function (node, pos) {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {
      // Ensure all markup that isn't allowed in the new node type is cleared
      this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);
      var mapping = this$1.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,
                                      new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false
    }
  });
  return this
};

function canChangeType(doc, pos, type) {
  var $pos = doc.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type)
}

// :: (number, ?NodeType, ?Object, ?[Mark]) → this
// Change the type, attributes, and/or marks of the node at `pos`.
// When `type` isn't given, the existing node type is preserved,
Transform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {
  var node = this.doc.nodeAt(pos);
  if (!node) { throw new RangeError("No node at given position") }
  if (!type) { type = node.type; }
  var newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    { return this.replaceWith(pos, pos + node.nodeSize, newNode) }

  if (!type.validContent(node.content))
    { throw new RangeError("Invalid content for node type " + type.name) }

  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,
                                         new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(newNode), 0, 0), 1, true))
};

// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool
// Check whether splitting at the given position is allowed.
function canSplit(doc, pos, depth, typesAfter) {
  if ( depth === void 0 ) depth = 1;

  var $pos = doc.resolve(pos), base = $pos.depth - depth;
  var innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;
  if (base < 0 || $pos.parent.type.spec.isolating ||
      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||
      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    { return false }
  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
    var node = $pos.node(d), index$1 = $pos.index(d);
    if (node.type.spec.isolating) { return false }
    var rest = node.content.cutByIndex(index$1, node.childCount);
    var after = (typesAfter && typesAfter[i]) || node;
    if (after != node) { rest = rest.replaceChild(0, after.type.create(after.attrs)); }
    if (!node.canReplace(index$1 + 1, node.childCount) || !after.type.validContent(rest))
      { return false }
  }
  var index = $pos.indexAfter(base);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)
}

// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this
// Split the node at the given position, and optionally, if `depth` is
// greater than one, any number of nodes above that. By default, the
// parts split off will inherit the node type of the original node.
// This can be changed by passing an array of types and attributes to
// use after the split.
Transform.prototype.split = function(pos, depth, typesAfter) {
  if ( depth === void 0 ) depth = 1;

  var $pos = this.doc.resolve(pos), before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($pos.node(d).copy(before));
    var typeAfter = typesAfter && typesAfter[i];
    after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  return this.step(new ReplaceStep(pos, pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), depth, depth), true))
};

// :: (Node, number) → bool
// Test whether the blocks before and after a given position can be
// joined.
function canJoin(doc, pos) {
  var $pos = doc.resolve(pos), index = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) &&
    $pos.parent.canReplace(index, index + 1)
}

function joinable(a, b) {
  return a && b && !a.isLeaf && a.canAppend(b)
}

// :: (Node, number, ?number) → ?number
// Find an ancestor of the given position that can be joined to the
// block before (or after if `dir` is positive). Returns the joinable
// point, if any.
function joinPoint(doc, pos, dir) {
  if ( dir === void 0 ) dir = -1;

  var $pos = doc.resolve(pos);
  for (var d = $pos.depth;; d--) {
    var before = (void 0), after = (void 0), index = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable(before, after) &&
        $pos.node(d).canReplace(index, index + 1)) { return pos }
    if (d == 0) { break }
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}

// :: (number, ?number) → this
// Join the blocks around the given position. If depth is 2, their
// last and first siblings are also joined, and so on.
Transform.prototype.join = function(pos, depth) {
  if ( depth === void 0 ) depth = 1;

  var step = new ReplaceStep(pos - depth, pos + depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, true);
  return this.step(step)
};

// :: (Node, number, NodeType) → ?number
// Try to find a point where a node of the given type can be inserted
// near `pos`, by searching up the node hierarchy when `pos` itself
// isn't a valid place but is at the start or end of a node. Return
// null if no position was found.
function insertPoint(doc, pos, nodeType) {
  var $pos = doc.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) { return pos }

  if ($pos.parentOffset == 0)
    { for (var d = $pos.depth - 1; d >= 0; d--) {
      var index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType)) { return $pos.before(d + 1) }
      if (index > 0) { return null }
    } }
  if ($pos.parentOffset == $pos.parent.content.size)
    { for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
      var index$1 = $pos.indexAfter(d$1);
      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType)) { return $pos.after(d$1 + 1) }
      if (index$1 < $pos.node(d$1).childCount) { return null }
    } }
}

// :: (Node, number, Slice) → ?number
// Finds a position at or around the given position where the given
// slice can be inserted. Will look at parent nodes' nearest boundary
// and try there, even if the original position wasn't directly at the
// start or end of that node. Returns null when no position was found.
function dropPoint(doc, pos, slice) {
  var $pos = doc.resolve(pos);
  if (!slice.content.size) { return pos }
  var content = slice.content;
  for (var i = 0; i < slice.openStart; i++) { content = content.firstChild.content; }
  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
    for (var d = $pos.depth; d >= 0; d--) {
      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        { return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1) }
    }
  }
  return null
}

function mapFragment(fragment, f, parent) {
  var mapped = [];
  for (var i = 0; i < fragment.childCount; i++) {
    var child = fragment.child(i);
    if (child.content.size) { child = child.copy(mapFragment(child.content, f, child)); }
    if (child.isInline) { child = f(child, parent, i); }
    mapped.push(child);
  }
  return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(mapped)
}

// ::- Add a mark to all inline content between two positions.
var AddMarkStep = /*@__PURE__*/(function (Step) {
  function AddMarkStep(from, to, mark) {
    Step.call(this);
    // :: number
    // The start of the marked range.
    this.from = from;
    // :: number
    // The end of the marked range.
    this.to = to;
    // :: Mark
    // The mark to add.
    this.mark = mark;
  }

  if ( Step ) AddMarkStep.__proto__ = Step;
  AddMarkStep.prototype = Object.create( Step && Step.prototype );
  AddMarkStep.prototype.constructor = AddMarkStep;

  AddMarkStep.prototype.apply = function apply (doc) {
    var this$1 = this;

    var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);
    var parent = $from.node($from.sharedDepth(this.to));
    var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, function (node, parent) {
      if (!node.isAtom || !parent.type.allowsMarkType(this$1.mark.type)) { return node }
      return node.mark(this$1.mark.addToSet(node.marks))
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc, this.from, this.to, slice)
  };

  AddMarkStep.prototype.invert = function invert () {
    return new RemoveMarkStep(this.from, this.to, this.mark)
  };

  AddMarkStep.prototype.map = function map (mapping) {
    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }
    return new AddMarkStep(from.pos, to.pos, this.mark)
  };

  AddMarkStep.prototype.merge = function merge (other) {
    if (other instanceof AddMarkStep &&
        other.mark.eq(this.mark) &&
        this.from <= other.to && this.to >= other.from)
      { return new AddMarkStep(Math.min(this.from, other.from),
                             Math.max(this.to, other.to), this.mark) }
  };

  AddMarkStep.prototype.toJSON = function toJSON () {
    return {stepType: "addMark", mark: this.mark.toJSON(),
            from: this.from, to: this.to}
  };

  AddMarkStep.fromJSON = function fromJSON (schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      { throw new RangeError("Invalid input for AddMarkStep.fromJSON") }
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))
  };

  return AddMarkStep;
}(Step));

Step.jsonID("addMark", AddMarkStep);

// ::- Remove a mark from all inline content between two positions.
var RemoveMarkStep = /*@__PURE__*/(function (Step) {
  function RemoveMarkStep(from, to, mark) {
    Step.call(this);
    // :: number
    // The start of the unmarked range.
    this.from = from;
    // :: number
    // The end of the unmarked range.
    this.to = to;
    // :: Mark
    // The mark to remove.
    this.mark = mark;
  }

  if ( Step ) RemoveMarkStep.__proto__ = Step;
  RemoveMarkStep.prototype = Object.create( Step && Step.prototype );
  RemoveMarkStep.prototype.constructor = RemoveMarkStep;

  RemoveMarkStep.prototype.apply = function apply (doc) {
    var this$1 = this;

    var oldSlice = doc.slice(this.from, this.to);
    var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, function (node) {
      return node.mark(this$1.mark.removeFromSet(node.marks))
    }), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc, this.from, this.to, slice)
  };

  RemoveMarkStep.prototype.invert = function invert () {
    return new AddMarkStep(this.from, this.to, this.mark)
  };

  RemoveMarkStep.prototype.map = function map (mapping) {
    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }
    return new RemoveMarkStep(from.pos, to.pos, this.mark)
  };

  RemoveMarkStep.prototype.merge = function merge (other) {
    if (other instanceof RemoveMarkStep &&
        other.mark.eq(this.mark) &&
        this.from <= other.to && this.to >= other.from)
      { return new RemoveMarkStep(Math.min(this.from, other.from),
                                Math.max(this.to, other.to), this.mark) }
  };

  RemoveMarkStep.prototype.toJSON = function toJSON () {
    return {stepType: "removeMark", mark: this.mark.toJSON(),
            from: this.from, to: this.to}
  };

  RemoveMarkStep.fromJSON = function fromJSON (schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      { throw new RangeError("Invalid input for RemoveMarkStep.fromJSON") }
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))
  };

  return RemoveMarkStep;
}(Step));

Step.jsonID("removeMark", RemoveMarkStep);

// :: (number, number, Mark) → this
// Add the given mark to the inline content between `from` and `to`.
Transform.prototype.addMark = function(from, to, mark) {
  var this$1 = this;

  var removed = [], added = [], removing = null, adding = null;
  this.doc.nodesBetween(from, to, function (node, pos, parent) {
    if (!node.isInline) { return }
    var marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
      var newSet = mark.addToSet(marks);

      for (var i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            { removing.to = end; }
          else
            { removed.push(removing = new RemoveMarkStep(start, end, marks[i])); }
        }
      }

      if (adding && adding.to == start)
        { adding.to = end; }
      else
        { added.push(adding = new AddMarkStep(start, end, mark)); }
    }
  });

  removed.forEach(function (s) { return this$1.step(s); });
  added.forEach(function (s) { return this$1.step(s); });
  return this
};

// :: (number, number, ?union<Mark, MarkType>) → this
// Remove marks from inline nodes between `from` and `to`. When `mark`
// is a single mark, remove precisely that mark. When it is a mark type,
// remove all marks of that type. When it is null, remove all marks of
// any type.
Transform.prototype.removeMark = function(from, to, mark) {
  var this$1 = this;
  if ( mark === void 0 ) mark = null;

  var matched = [], step = 0;
  this.doc.nodesBetween(from, to, function (node, pos) {
    if (!node.isInline) { return }
    step++;
    var toRemove = null;
    if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType) {
      var set = node.marks, found;
      while (found = mark.isInSet(set)) {
(toRemove || (toRemove = [])).push(found);
        set = found.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks)) { toRemove = [mark]; }
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      var end = Math.min(pos + node.nodeSize, to);
      for (var i = 0; i < toRemove.length; i++) {
        var style = toRemove[i], found$1 = (void 0);
        for (var j = 0; j < matched.length; j++) {
          var m = matched[j];
          if (m.step == step - 1 && style.eq(matched[j].style)) { found$1 = m; }
        }
        if (found$1) {
          found$1.to = end;
          found$1.step = step;
        } else {
          matched.push({style: style, from: Math.max(pos, from), to: end, step: step});
        }
      }
    }
  });
  matched.forEach(function (m) { return this$1.step(new RemoveMarkStep(m.from, m.to, m.style)); });
  return this
};

// :: (number, NodeType, ?ContentMatch) → this
// Removes all marks and nodes from the content of the node at `pos`
// that don't match the given new parent node type. Accepts an
// optional starting [content match](#model.ContentMatch) as third
// argument.
Transform.prototype.clearIncompatible = function(pos, parentType, match) {
  if ( match === void 0 ) match = parentType.contentMatch;

  var node = this.doc.nodeAt(pos);
  var delSteps = [], cur = pos + 1;
  for (var i = 0; i < node.childCount; i++) {
    var child = node.child(i), end = cur + child.nodeSize;
    var allowed = match.matchType(child.type, child.attrs);
    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty));
    } else {
      match = allowed;
      for (var j = 0; j < child.marks.length; j++) { if (!parentType.allowsMarkType(child.marks[j].type))
        { this.step(new RemoveMarkStep(cur, end, child.marks[j])); } }
    }
    cur = end;
  }
  if (!match.validEnd) {
    var fill = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);
    this.replace(cur, cur, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fill, 0, 0));
  }
  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) { this.step(delSteps[i$1]); }
  return this
};

// :: (Node, number, ?number, ?Slice) → ?Step
// ‘Fit’ a slice into a given position in the document, producing a
// [step](#transform.Step) that inserts it. Will return null if
// there's no meaningful way to insert the slice here, or inserting it
// would be a no-op (an empty slice over an empty range).
function replaceStep(doc, from, to, slice) {
  if ( to === void 0 ) to = from;
  if ( slice === void 0 ) slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

  if (from == to && !slice.size) { return null }

  var $from = doc.resolve(from), $to = doc.resolve(to);
  // Optimization -- avoid work if it's obvious that it's not needed.
  if (fitsTrivially($from, $to, slice)) { return new ReplaceStep(from, to, slice) }
  return new Fitter($from, $to, slice).fit()
}

// :: (number, ?number, ?Slice) → this
// Replace the part of the document between `from` and `to` with the
// given `slice`.
Transform.prototype.replace = function(from, to, slice) {
  if ( to === void 0 ) to = from;
  if ( slice === void 0 ) slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

  var step = replaceStep(this.doc, from, to, slice);
  if (step) { this.step(step); }
  return this
};

// :: (number, number, union<Fragment, Node, [Node]>) → this
// Replace the given range with the given content, which may be a
// fragment, node, or array of nodes.
Transform.prototype.replaceWith = function(from, to, content) {
  return this.replace(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content), 0, 0))
};

// :: (number, number) → this
// Delete the content between the given positions.
Transform.prototype.delete = function(from, to) {
  return this.replace(from, to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty)
};

// :: (number, union<Fragment, Node, [Node]>) → this
// Insert the given content at the given position.
Transform.prototype.insert = function(pos, content) {
  return this.replaceWith(pos, pos, content)
};

function fitsTrivially($from, $to, slice) {
  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&
    $from.parent.canReplace($from.index(), $to.index(), slice.content)
}

// Algorithm for 'placing' the elements of a slice into a gap:
//
// We consider the content of each node that is open to the left to be
// independently placeable. I.e. in <p("foo"), p("bar")>, when the
// paragraph on the left is open, "foo" can be placed (somewhere on
// the left side of the replacement gap) independently from p("bar").
//
// This class tracks the state of the placement progress in the
// following properties:
//
//  - `frontier` holds a stack of `{type, match}` objects that
//    represent the open side of the replacement. It starts at
//    `$from`, then moves forward as content is placed, and is finally
//    reconciled with `$to`.
//
//  - `unplaced` is a slice that represents the content that hasn't
//    been placed yet.
//
//  - `placed` is a fragment of placed content. Its open-start value
//    is implicit in `$from`, and its open-end value in `frontier`.
var Fitter = function Fitter($from, $to, slice) {
  this.$to = $to;
  this.$from = $from;
  this.unplaced = slice;

  this.frontier = [];
  for (var i = 0; i <= $from.depth; i++) {
    var node = $from.node(i);
    this.frontier.push({
      type: node.type,
      match: node.contentMatchAt($from.indexAfter(i))
    });
  }

  this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
  for (var i$1 = $from.depth; i$1 > 0; i$1--)
    { this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(i$1).copy(this.placed)); }
};

var prototypeAccessors$1 = { depth: { configurable: true } };

prototypeAccessors$1.depth.get = function () { return this.frontier.length - 1 };

Fitter.prototype.fit = function fit () {
  // As long as there's unplaced content, try to place some of it.
  // If that fails, either increase the open score of the unplaced
  // slice, or drop nodes from it, and then try again.
  while (this.unplaced.size) {
    var fit = this.findFittable();
    if (fit) { this.placeNodes(fit); }
    else { this.openMore() || this.dropNode(); }
  }
  // When there's inline content directly after the frontier _and_
  // directly after `this.$to`, we must generate a `ReplaceAround`
  // step that pulls that content into the node after the frontier.
  // That means the fitting must be done to the end of the textblock
  // node after `this.$to`, not `this.$to` itself.
  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
  if (!$to) { return null }

  // If closing to `$to` succeeded, create a step
  var content = this.placed, openStart = $from.depth, openEnd = $to.depth;
  while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes
    content = content.firstChild.content;
    openStart--; openEnd--;
  }
  var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);
  if (moveInline > -1)
    { return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize) }
  if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps
    { return new ReplaceStep($from.pos, $to.pos, slice) }
};

// Find a position on the start spine of `this.unplaced` that has
// content that can be moved somewhere on the frontier. Returns two
// depths, one for the slice and one for the frontier.
Fitter.prototype.findFittable = function findFittable () {
  // Only try wrapping nodes (pass 2) after finding a place without
  // wrapping failed.
  for (var pass = 1; pass <= 2; pass++) {
    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
      var fragment = (void 0), parent = (void 0);
      if (sliceDepth) {
        parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
        fragment = parent.content;
      } else {
        fragment = this.unplaced.content;
      }
      var first = fragment.firstChild;
      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
        var ref = this.frontier[frontierDepth];
          var type = ref.type;
          var match = ref.match;
          var wrap = (void 0), inject = (void 0);
        // In pass 1, if the next node matches, or there is no next
        // node but the parents look compatible, we've found a
        // place.
        if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(first), false))
                          : type.compatibleContent(parent.type)))
          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, inject: inject} }
        // In pass 2, look for a set of wrapping nodes that make
        // `first` fit here.
        else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))
          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, wrap: wrap} }
        // Don't continue looking further up if the parent node
        // would fit here.
        if (parent && match.matchType(parent.type)) { break }
      }
    }
  }
};

Fitter.prototype.openMore = function openMore () {
  var ref = this.unplaced;
    var content = ref.content;
    var openStart = ref.openStart;
    var openEnd = ref.openEnd;
  var inner = contentAt(content, openStart);
  if (!inner.childCount || inner.firstChild.isLeaf) { return false }
  this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart + 1,
                            Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
  return true
};

Fitter.prototype.dropNode = function dropNode () {
  var ref = this.unplaced;
    var content = ref.content;
    var openStart = ref.openStart;
    var openEnd = ref.openEnd;
  var inner = contentAt(content, openStart);
  if (inner.childCount <= 1 && openStart > 0) {
    var openAtEnd = content.size - openStart <= openStart + inner.size;
    this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,
                              openAtEnd ? openStart - 1 : openEnd);
  } else {
    this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
  }
};

// : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})
// Move content from the unplaced slice at `sliceDepth` to the
// frontier node at `frontierDepth`. Close that frontier node when
// applicable.
Fitter.prototype.placeNodes = function placeNodes (ref) {
    var sliceDepth = ref.sliceDepth;
    var frontierDepth = ref.frontierDepth;
    var parent = ref.parent;
    var inject = ref.inject;
    var wrap = ref.wrap;

  while (this.depth > frontierDepth) { this.closeFrontierNode(); }
  if (wrap) { for (var i = 0; i < wrap.length; i++) { this.openFrontierNode(wrap[i]); } }

  var slice = this.unplaced, fragment = parent ? parent.content : slice.content;
  var openStart = slice.openStart - sliceDepth;
  var taken = 0, add = [];
  var ref$1 = this.frontier[frontierDepth];
    var match = ref$1.match;
    var type = ref$1.type;
  if (inject) {
    for (var i$1 = 0; i$1 < inject.childCount; i$1++) { add.push(inject.child(i$1)); }
    match = match.matchFragment(inject);
  }
  // Computes the amount of (end) open nodes at the end of the
  // fragment. When 0, the parent is open, but no more. When
  // negative, nothing is open.
  var openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);
  // Scan over the fragment, fitting as many child nodes as
  // possible.
  while (taken < fragment.childCount) {
    var next = fragment.child(taken), matches = match.matchType(next.type);
    if (!matches) { break }
    taken++;
    if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes
      match = matches;
      add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,
                              taken == fragment.childCount ? openEndCount : -1));
    }
  }
  var toEnd = taken == fragment.childCount;
  if (!toEnd) { openEndCount = -1; }

  this.placed = addToFragment(this.placed, frontierDepth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(add));
  this.frontier[frontierDepth].match = match;

  // If the parent types match, and the entire node was moved, and
  // it's not open, close this frontier node right away.
  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
    { this.closeFrontierNode(); }

  // Add new frontier nodes for any open nodes at the end.
  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
    var node = cur.lastChild;
    this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)});
    cur = node.content;
  }

  // Update `this.unplaced`. Drop the entire node from which we
  // placed it we got to its end, otherwise just drop the placed
  // nodes.
  this.unplaced = !toEnd ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)
    : sliceDepth == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty
    : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),
                sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
};

Fitter.prototype.mustMoveInline = function mustMoveInline () {
  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) { return -1 }
  var top = this.frontier[this.depth], level;
  if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||
      (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) { return -1 }

  var ref = this.$to;
    var depth = ref.depth;
    var after = this.$to.after(depth);
  while (depth > 1 && after == this.$to.end(--depth)) { ++after; }
  return after
};

Fitter.prototype.findCloseLevel = function findCloseLevel ($to) {
  scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
    var ref = this.frontier[i];
      var match = ref.match;
      var type = ref.type;
    var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
    var fit = contentAfterFits($to, i, type, match, dropInner);
    if (!fit) { continue }
    for (var d = i - 1; d >= 0; d--) {
      var ref$1 = this.frontier[d];
        var match$1 = ref$1.match;
        var type$1 = ref$1.type;
      var matches = contentAfterFits($to, d, type$1, match$1, true);
      if (!matches || matches.childCount) { continue scan }
    }
    return {depth: i, fit: fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}
  }
};

Fitter.prototype.close = function close ($to) {
  var close = this.findCloseLevel($to);
  if (!close) { return null }

  while (this.depth > close.depth) { this.closeFrontierNode(); }
  if (close.fit.childCount) { this.placed = addToFragment(this.placed, close.depth, close.fit); }
  $to = close.move;
  for (var d = close.depth + 1; d <= $to.depth; d++) {
    var node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
    this.openFrontierNode(node.type, node.attrs, add);
  }
  return $to
};

Fitter.prototype.openFrontierNode = function openFrontierNode (type, attrs, content) {
  var top = this.frontier[this.depth];
  top.match = top.match.matchType(type);
  this.placed = addToFragment(this.placed, this.depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, content)));
  this.frontier.push({type: type, match: type.contentMatch});
};

Fitter.prototype.closeFrontierNode = function closeFrontierNode () {
  var open = this.frontier.pop();
  var add = open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);
  if (add.childCount) { this.placed = addToFragment(this.placed, this.frontier.length, add); }
};

Object.defineProperties( Fitter.prototype, prototypeAccessors$1 );

function dropFromFragment(fragment, depth, count) {
  if (depth == 0) { return fragment.cutByIndex(count) }
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))
}

function addToFragment(fragment, depth, content) {
  if (depth == 0) { return fragment.append(content) }
  return fragment.replaceChild(fragment.childCount - 1,
                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))
}

function contentAt(fragment, depth) {
  for (var i = 0; i < depth; i++) { fragment = fragment.firstChild.content; }
  return fragment
}

function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0) { return node }
  var frag = node.content;
  if (openStart > 1)
    { frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0)); }
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) { frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true)); }
  }
  return node.copy(frag)
}

function contentAfterFits($to, depth, type, match, open) {
  var node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type)) { return null }
  var fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null
}

function invalidMarks(type, fragment, start) {
  for (var i = start; i < fragment.childCount; i++)
    { if (!type.allowsMarks(fragment.child(i).marks)) { return true } }
  return false
}

// :: (number, number, Slice) → this
// Replace a range of the document with a given slice, using `from`,
// `to`, and the slice's [`openStart`](#model.Slice.openStart) property
// as hints, rather than fixed start and end points. This method may
// grow the replaced area or close open nodes in the slice in order to
// get a fit that is more in line with WYSIWYG expectations, by
// dropping fully covered parent nodes of the replaced region when
// they are marked [non-defining](#model.NodeSpec.defining), or
// including an open parent node from the slice that _is_ marked as
// [defining](#model.NodeSpec.defining).
//
// This is the method, for example, to handle paste. The similar
// [`replace`](#transform.Transform.replace) method is a more
// primitive tool which will _not_ move the start and end of its given
// range, and is useful in situations where you need more precise
// control over what happens.
Transform.prototype.replaceRange = function(from, to, slice) {
  if (!slice.size) { return this.deleteRange(from, to) }

  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);
  if (fitsTrivially($from, $to, slice))
    { return this.step(new ReplaceStep(from, to, slice)) }

  var targetDepths = coveredDepths($from, this.doc.resolve(to));
  // Can't replace the whole document, so remove 0 if it's present
  if (targetDepths[targetDepths.length - 1] == 0) { targetDepths.pop(); }
  // Negative numbers represent not expansion over the whole node at
  // that depth, but replacing from $from.before(-D) to $to.pos.
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  // This loop picks a preferred target depth, if one of the covering
  // depths is not outside of a defining node, and adds negative
  // depths for any depth that has $from at its start and does not
  // cross a defining node.
  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.isolating) { break }
    if (targetDepths.indexOf(d) > -1) { preferredTarget = d; }
    else if ($from.before(d) == pos) { targetDepths.splice(1, 0, -d); }
  }
  // Try to fit each possible depth of the slice into each possible
  // target depth, starting with the preferred depths.
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);

  var leftNodes = [], preferredDepth = slice.openStart;
  for (var content = slice.content, i = 0;; i++) {
    var node = content.firstChild;
    leftNodes.push(node);
    if (i == slice.openStart) { break }
    content = node.content;
  }
  // Back up if the node directly above openStart, or the node above
  // that separated only by a non-defining textblock node, is defining.
  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&
      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)
    { preferredDepth -= 1; }
  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&
           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)
    { preferredDepth -= 2; }

  for (var j = slice.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) { continue }
    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
      // Loop over possible expansion levels, starting with the
      // preferred one
      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth; }
      var parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks))
        { return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,
                            new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),
                                      openDepth, slice.openEnd)) }
    }
  }

  var startSteps = this.steps.length;
  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
    this.replace(from, to, slice);
    if (this.steps.length > startSteps) { break }
    var depth = targetDepths[i$2];
    if (depth < 0) { continue }
    from = $from.before(depth); to = $to.after(depth);
  }
  return this
};

function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));
  }
  return fragment
}

// :: (number, number, Node) → this
// Replace the given range with a node, but use `from` and `to` as
// hints, rather than precise positions. When from and to are the same
// and are at the start or end of a parent node in which the given
// node doesn't fit, this method may _move_ them out towards a parent
// that does allow the given node to be placed. When the given range
// completely covers a parent node, this method may completely replace
// that parent node.
Transform.prototype.replaceRangeWith = function(from, to, node) {
  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {
    var point = insertPoint(this.doc, from, node.type);
    if (point != null) { from = to = point; }
  }
  return this.replaceRange(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node), 0, 0))
};

// :: (number, number) → this
// Delete the given range, expanding it to cover fully covered
// parent nodes until a valid replace is found.
Transform.prototype.deleteRange = function(from, to) {
  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);
  var covered = coveredDepths($from, $to);
  for (var i = 0; i < covered.length; i++) {
    var depth = covered[i], last = i == covered.length - 1;
    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)
      { return this.delete($from.start(depth), $to.end(depth)) }
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      { return this.delete($from.before(depth), $to.after(depth)) }
  }
  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
      { return this.delete($from.before(d), to) }
  }
  return this.delete(from, to)
};

// : (ResolvedPos, ResolvedPos) → [number]
// Returns an array of all depths for which $from - $to spans the
// whole content of the nodes at that depth.
function coveredDepths($from, $to) {
  var result = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d = minDepth; d >= 0; d--) {
    var start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) ||
        $to.end(d) > $to.pos + ($to.depth - d) ||
        $from.node(d).type.spec.isolating ||
        $to.node(d).type.spec.isolating) { break }
    if (start == $to.start(d) ||
        (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&
         d && $to.start(d - 1) == start - 1))
      { result.push(d); }
  }
  return result
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-view/dist/index.es.js":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.es.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Decoration": () => (/* binding */ Decoration),
/* harmony export */   "DecorationSet": () => (/* binding */ DecorationSet),
/* harmony export */   "EditorView": () => (/* binding */ EditorView),
/* harmony export */   "__endComposition": () => (/* binding */ endComposition),
/* harmony export */   "__parseFromClipboard": () => (/* binding */ parseFromClipboard),
/* harmony export */   "__serializeForClipboard": () => (/* binding */ serializeForClipboard)
/* harmony export */ });
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");




var result = {};

if (typeof navigator != "undefined" && typeof document != "undefined") {
  var ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

  var ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
  result.gecko = !ie && /gecko\/(\d+)/i.test(navigator.userAgent);
  result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  var chrome = !ie && /Chrome\/(\d+)/.exec(navigator.userAgent);
  result.chrome = !!chrome;
  result.chrome_version = chrome && +chrome[1];
  // Is true for both iOS and iPadOS for convenience
  result.safari = !ie && /Apple Computer/.test(navigator.vendor);
  result.ios = result.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
  result.mac = result.ios || /Mac/.test(navigator.platform);
  result.android = /Android \d/.test(navigator.userAgent);
  result.webkit = "webkitFontSmoothing" in document.documentElement.style;
  result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
}

var domIndex = function(node) {
  for (var index = 0;; index++) {
    node = node.previousSibling;
    if (!node) { return index }
  }
};

var parentNode = function(node) {
  var parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent
};

var reusedRange = null;

// Note that this will always return the same range, because DOM range
// objects are every expensive, and keep slowing down subsequent DOM
// updates, for some reason.
var textRange = function(node, from, to) {
  var range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from || 0);
  return range
};

// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||
                        scanFor(node, off, targetNode, targetOff, 1))
};

var atomElements = /^(img|br|input|textarea|hr)$/i;

function scanFor(node, off, targetNode, targetOff, dir) {
  for (;;) {
    if (node == targetNode && off == targetOff) { return true }
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      var parent = node.parentNode;
      if (parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        { return false }
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false") { return false }
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false
    }
  }
}

function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length
}

function isOnEdge(node, offset, parent) {
  for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {
    if (node == parent) { return true }
    var index = domIndex(node);
    node = node.parentNode;
    if (!node) { return false }
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}

function hasBlockDesc(dom) {
  var desc;
  for (var cur = dom; cur; cur = cur.parentNode) { if (desc = cur.pmViewDesc) { break } }
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom)
}

// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
// (isCollapsed inappropriately returns true in shadow dom)
var selectionCollapsed = function(domSel) {
  var collapsed = domSel.isCollapsed;
  if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)
    { collapsed = false; }
  return collapsed
};

function keyEvent(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event
}

function windowRect(doc) {
  return {left: 0, right: doc.documentElement.clientWidth,
          top: 0, bottom: doc.documentElement.clientHeight}
}

function getSide(value, side) {
  return typeof value == "number" ? value : value[side]
}

function clientRect(node) {
  var rect = node.getBoundingClientRect();
  // Adjust for elements with style "transform: scale()"
  var scaleX = (rect.width / node.offsetWidth) || 1;
  var scaleY = (rect.height / node.offsetHeight) || 1;
  // Make sure scrollbar width isn't included in the rectangle
  return {left: rect.left, right: rect.left + node.clientWidth * scaleX,
          top: rect.top, bottom: rect.top + node.clientHeight * scaleY}
}

function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  var doc = view.dom.ownerDocument;
  for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {
    if (!parent) { break }
    if (parent.nodeType != 1) { continue }
    var atTop = parent == doc.body || parent.nodeType != 1;
    var bounding = atTop ? windowRect(doc) : clientRect(parent);
    var moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      { moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top")); }
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      { moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom"); }
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      { moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left")); }
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      { moveX = rect.right - bounding.right + getSide(scrollMargin, "right"); }
    if (moveX || moveY) {
      if (atTop) {
        doc.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = parent.scrollLeft, startY = parent.scrollTop;
        if (moveY) { parent.scrollTop += moveY; }
        if (moveX) { parent.scrollLeft += moveX; }
        var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
        rect = {left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY};
      }
    }
    if (atTop) { break }
  }
}

// Store the scroll position of the editor's parent nodes, along with
// the top position of an element near the top of the editor, which
// will be used to make sure the visible viewport remains stable even
// when the size of the content above changes.
function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  var refDOM, refTop;
  for (var x = (rect.left + rect.right) / 2, y = startY + 1;
       y < Math.min(innerHeight, rect.bottom); y += 5) {
    var dom = view.root.elementFromPoint(x, y);
    if (dom == view.dom || !view.dom.contains(dom)) { continue }
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break
    }
  }
  return {refDOM: refDOM, refTop: refTop, stack: scrollStack(view.dom)}
}

function scrollStack(dom) {
  var stack = [], doc = dom.ownerDocument;
  for (; dom; dom = parentNode(dom)) {
    stack.push({dom: dom, top: dom.scrollTop, left: dom.scrollLeft});
    if (dom == doc) { break }
  }
  return stack
}

// Reset the scroll position of the editor's parent nodes to that what
// it was before, when storeScrollPos was called.
function resetScrollPos(ref) {
  var refDOM = ref.refDOM;
  var refTop = ref.refTop;
  var stack = ref.stack;

  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}

function restoreScrollStack(stack, dTop) {
  for (var i = 0; i < stack.length; i++) {
    var ref = stack[i];
    var dom = ref.dom;
    var top = ref.top;
    var left = ref.left;
    if (dom.scrollTop != top + dTop) { dom.scrollTop = top + dTop; }
    if (dom.scrollLeft != left) { dom.scrollLeft = left; }
  }
}

var preventScrollSupported = null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom) {
  if (dom.setActive) { return dom.setActive() } // in IE
  if (preventScrollSupported) { return dom.focus(preventScrollSupported) }

  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = {preventScroll: true};
      return true
    }
  } : undefined);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}

function findOffsetInNode(node, coords) {
  var closest, dxClosest = 2e8, coordsClosest, offset = 0;
  var rowBot = coords.top, rowTop = coords.top;
  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    var rects = (void 0);
    if (child.nodeType == 1) { rects = child.getClientRects(); }
    else if (child.nodeType == 3) { rects = textRange(child).getClientRects(); }
    else { continue }

    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left
            : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords;
          if (child.nodeType == 1 && dx)
            { offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0); }
          continue
        }
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||
                       coords.left >= rect.left && coords.top >= rect.bottom))
        { offset = childIndex + 1; }
    }
  }
  if (closest && closest.nodeType == 3) { return findOffsetInText(closest, coordsClosest) }
  if (!closest || (dxClosest && closest.nodeType == 1)) { return {node: node, offset: offset} }
  return findOffsetInNode(closest, coordsClosest)
}

function findOffsetInText(node, coords) {
  var len = node.nodeValue.length;
  var range = document.createRange();
  for (var i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    var rect = singleRect(range, 1);
    if (rect.top == rect.bottom) { continue }
    if (inRect(coords, rect))
      { return {node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)} }
  }
  return {node: node, offset: 0}
}

function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1&&
    coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1
}

function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    { return parent }
  return dom
}

function posFromElement(view, elt, coords) {
  var ref = findOffsetInNode(elt, coords);
  var node = ref.node;
  var offset = ref.offset;
  var bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    var rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset, bias)
}

function posFromCaret(view, node, offset, coords) {
  // Browser (in caretPosition/RangeFromPoint) will agressively
  // normalize towards nearby inline nodes. Since we are interested in
  // positions between block nodes too, we first walk up the hierarchy
  // of nodes to see if there are block nodes that the coordinates
  // fall outside of. If so, we take the position before/after that
  // block. If not, we call `posFromDOM` on the raw node/offset.
  var outside = -1;
  for (var cur = node;;) {
    if (cur == view.dom) { break }
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) { return null }
    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) { outside = desc.posBefore; }
      else if (rect.right < coords.left || rect.bottom < coords.top) { outside = desc.posAfter; }
      else { break }
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view.docView.posFromDOM(node, offset)
}

function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {
      var child = element.childNodes[i];
      if (child.nodeType == 1) {
        var rects = child.getClientRects();
        for (var j = 0; j < rects.length; j++) {
          var rect = rects[j];
          if (inRect(coords, rect)) { return elementFromPoint(child, coords, rect) }
        }
      }
      if ((i = (i + 1) % len) == startI) { break }
    }
  }
  return element
}

// Given an x,y position on the editor, get the position in the document.
function posAtCoords(view, coords) {
  var assign, assign$1;

  var doc = view.dom.ownerDocument, node, offset;
  if (doc.caretPositionFromPoint) {
    try { // Firefox throws for this call in hard-to-predict circumstances (#994)
      var pos$1 = doc.caretPositionFromPoint(coords.left, coords.top);
      if (pos$1) { ((assign = pos$1, node = assign.offsetNode, offset = assign.offset)); }
    } catch (_) {}
  }
  if (!node && doc.caretRangeFromPoint) {
    var range = doc.caretRangeFromPoint(coords.left, coords.top);
    if (range) { ((assign$1 = range, node = assign$1.startContainer, offset = assign$1.startOffset)); }
  }

  var elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) { return null }
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) { return null }
  }
  // Safari's caretRangeFromPoint returns nonsense when on a draggable element
  if (result.safari) {
    for (var p = elt; node && p; p = parentNode(p))
      { if (p.draggable) { node = offset = null; } }
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (result.gecko && node.nodeType == 1) {
      // Firefox will sometimes return offsets into <input> nodes, which
      // have no actual children, from caretPositionFromPoint (#953)
      offset = Math.min(offset, node.childNodes.length);
      // It'll also move the returned position before image nodes,
      // even if those are behind it.
      if (offset < node.childNodes.length) {
        var next = node.childNodes[offset], box$1;
        if (next.nodeName == "IMG" && (box$1 = next.getBoundingClientRect()).right <= coords.left &&
            box$1.bottom > coords.top)
          { offset++; }
      }
    }
    // Suspiciously specific kludge to work around caret*FromPoint
    // never returning a position at the end of the document
    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&
        coords.top > node.lastChild.getBoundingClientRect().bottom)
      { pos = view.state.doc.content.size; }
    // Ignore positions directly after a BR, since caret*FromPoint
    // 'round up' positions that would be more accurately placed
    // before the BR node.
    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")
      { pos = posFromCaret(view, node, offset, coords); }
  }
  if (pos == null) { pos = posFromElement(view, elt, coords); }

  var desc = view.docView.nearestDesc(elt, true);
  return {pos: pos, inside: desc ? desc.posAtStart - desc.border : -1}
}

function singleRect(object, bias) {
  var rects = object.getClientRects();
  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]
}

var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;

// : (EditorView, number, number) → {left: number, top: number, right: number, bottom: number}
// Given a position in the document model, get a bounding box of the
// character at that position, relative to the window.
function coordsAtPos(view, pos, side) {
  var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  var node = ref.node;
  var offset = ref.offset;

  var supportEmptyRange = result.webkit || result.gecko;
  if (node.nodeType == 3) {
    // These browsers support querying empty text ranges. Prefer that in
    // bidi context or when at the end of a node.
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
      var rect = singleRect(textRange(node, offset, offset), side);
      // Firefox returns bad results (the position before the space)
      // when querying a position directly after line-broken
      // whitespace. Detect this situation and and kludge around it
      if (result.gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
        var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
          if (rectAfter.top != rect.top)
            { return flattenV(rectAfter, rectAfter.left < rectBefore.left) }
        }
      }
      return rect
    } else {
      var from = offset, to = offset, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset) { to++; takeSide = -1; }
      else if (side >= 0 && offset == node.nodeValue.length) { from--; takeSide = 1; }
      else if (side < 0) { from--; }
      else { to ++; }
      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0)
    }
  }

  // Return a horizontal line in block context
  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset && (side < 0 || offset == nodeSize(node))) {
      var before = node.childNodes[offset - 1];
      if (before.nodeType == 1) { return flattenH(before.getBoundingClientRect(), false) }
    }
    if (offset < nodeSize(node)) {
      var after = node.childNodes[offset];
      if (after.nodeType == 1) { return flattenH(after.getBoundingClientRect(), true) }
    }
    return flattenH(node.getBoundingClientRect(), side >= 0)
  }

  // Inline, not in text node (this is not Bidi-safe)
  if (offset && (side < 0 || offset == nodeSize(node))) {
    var before$1 = node.childNodes[offset - 1];
    var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1))
        // BR nodes tend to only return the rectangle before them.
        // Only use them if they are the last element in their parent
        : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
    if (target) { return flattenV(singleRect(target, 1), false) }
  }
  if (offset < nodeSize(node)) {
    var after$1 = node.childNodes[offset];
    while (after$1.pmViewDesc && after$1.pmViewDesc.ignoreForCoords) { after$1 = after$1.nextSibling; }
    var target$1 = !after$1 ? null : after$1.nodeType == 3 ? textRange(after$1, 0, (supportEmptyRange ? 0 : 1))
        : after$1.nodeType == 1 ? after$1 : null;
    if (target$1) { return flattenV(singleRect(target$1, -1), true) }
  }
  // All else failed, just try to get a rectangle for the target node
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0)
}

function flattenV(rect, left) {
  if (rect.width == 0) { return rect }
  var x = left ? rect.left : rect.right;
  return {top: rect.top, bottom: rect.bottom, left: x, right: x}
}

function flattenH(rect, top) {
  if (rect.height == 0) { return rect }
  var y = top ? rect.top : rect.bottom;
  return {top: y, bottom: y, left: rect.left, right: rect.right}
}

function withFlushedState(view, state, f) {
  var viewState = view.state, active = view.root.activeElement;
  if (viewState != state) { view.updateState(state); }
  if (active != view.dom) { view.focus(); }
  try {
    return f()
  } finally {
    if (viewState != state) { view.updateState(viewState); }
    if (active != view.dom && active) { active.focus(); }
  }
}

// : (EditorView, number, number)
// Whether vertical position motion in a given direction
// from a position would leave a text block.
function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function () {
    var ref = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    var dom = ref.node;
    for (;;) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) { break }
      if (nearest.node.isBlock) { dom = nearest.dom; break }
      dom = nearest.dom.parentNode;
    }
    var coords = coordsAtPos(view, $pos.pos, 1);
    for (var child = dom.firstChild; child; child = child.nextSibling) {
      var boxes = (void 0);
      if (child.nodeType == 1) { boxes = child.getClientRects(); }
      else if (child.nodeType == 3) { boxes = textRange(child, 0, child.nodeValue.length).getClientRects(); }
      else { continue }
      for (var i = 0; i < boxes.length; i++) {
        var box = boxes[i];
        if (box.bottom > box.top + 1 &&
            (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2
             : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          { return false }
      }
    }
    return true
  })
}

var maybeRTL = /[\u0590-\u08ac]/;

function endOfTextblockHorizontal(view, state, dir) {
  var ref = state.selection;
  var $head = ref.$head;
  if (!$head.parent.isTextblock) { return false }
  var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
  var sel = view.root.getSelection();
  // If the textblock is all LTR, or the browser doesn't support
  // Selection.modify (Edge), fall back to a primitive approach
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    { return dir == "left" || dir == "backward" ? atStart : atEnd }

  return withFlushedState(view, state, function () {
    // This is a huge hack, but appears to be the best we can
    // currently do: use `Selection.modify` to move the selection by
    // one character, and see if that moves the cursor out of the
    // textblock (or doesn't move it at all, when at the start/end of
    // the document).
    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    var oldBidiLevel = sel.caretBidiLevel; // Only for Firefox
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||
        (oldNode == sel.focusNode && oldOff == sel.focusOffset);
    // Restore the previous selection
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) { sel.caretBidiLevel = oldBidiLevel; }
    return result
  })
}

var cachedState = null, cachedDir = null, cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) { return cachedResult }
  cachedState = state; cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down"
    ? endOfTextblockVertical(view, state, dir)
    : endOfTextblockHorizontal(view, state, dir)
}

// NodeView:: interface
//
// By default, document nodes are rendered using the result of the
// [`toDOM`](#model.NodeSpec.toDOM) method of their spec, and managed
// entirely by the editor. For some use cases, such as embedded
// node-specific editing interfaces, you want more control over
// the behavior of a node's in-editor representation, and need to
// [define](#view.EditorProps.nodeViews) a custom node view.
//
// Mark views only support `dom` and `contentDOM`, and don't support
// any of the node view methods.
//
// Objects returned as node views must conform to this interface.
//
//   dom:: ?dom.Node
//   The outer DOM node that represents the document node. When not
//   given, the default strategy is used to create a DOM node.
//
//   contentDOM:: ?dom.Node
//   The DOM node that should hold the node's content. Only meaningful
//   if the node view also defines a `dom` property and if its node
//   type is not a leaf node type. When this is present, ProseMirror
//   will take care of rendering the node's children into it. When it
//   is not present, the node view itself is responsible for rendering
//   (or deciding not to render) its child nodes.
//
//   update:: ?(node: Node, decorations: [Decoration], innerDecorations: DecorationSource) → bool
//   When given, this will be called when the view is updating itself.
//   It will be given a node (possibly of a different type), an array
//   of active decorations around the node (which are automatically
//   drawn, and the node view may ignore if it isn't interested in
//   them), and a [decoration source](#view.DecorationSource) that
//   represents any decorations that apply to the content of the node
//   (which again may be ignored). It should return true if it was
//   able to update to that node, and false otherwise. If the node
//   view has a `contentDOM` property (or no `dom` property), updating
//   its child nodes will be handled by ProseMirror.
//
//   selectNode:: ?()
//   Can be used to override the way the node's selected status (as a
//   node selection) is displayed.
//
//   deselectNode:: ?()
//   When defining a `selectNode` method, you should also provide a
//   `deselectNode` method to remove the effect again.
//
//   setSelection:: ?(anchor: number, head: number, root: dom.Document)
//   This will be called to handle setting the selection inside the
//   node. The `anchor` and `head` positions are relative to the start
//   of the node. By default, a DOM selection will be created between
//   the DOM positions corresponding to those positions, but if you
//   override it you can do something else.
//
//   stopEvent:: ?(event: dom.Event) → bool
//   Can be used to prevent the editor view from trying to handle some
//   or all DOM events that bubble up from the node view. Events for
//   which this returns true are not handled by the editor.
//
//   ignoreMutation:: ?(dom.MutationRecord) → bool
//   Called when a DOM
//   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
//   or a selection change happens within the view. When the change is
//   a selection change, the record will have a `type` property of
//   `"selection"` (which doesn't occur for native mutation records).
//   Return false if the editor should re-read the selection or
//   re-parse the range around the mutation, true if it can safely be
//   ignored.
//
//   destroy:: ?()
//   Called when the node view is removed from the editor or the whole
//   editor is destroyed. (Not available for marks.)

// View descriptions are data structures that describe the DOM that is
// used to represent the editor's content. They are used for:
//
// - Incremental redrawing when the document changes
//
// - Figuring out what part of the document a given DOM position
//   corresponds to
//
// - Wiring in custom implementations of the editing interface for a
//   given node
//
// They form a doubly-linked mutable tree, starting at `view.docView`.

var NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;

// Superclass for the various kinds of descriptions. Defines their
// basic structure and shared methods.
var ViewDesc = function ViewDesc(parent, children, dom, contentDOM) {
  this.parent = parent;
  this.children = children;
  this.dom = dom;
  // An expando property on the DOM node provides a link back to its
  // description.
  dom.pmViewDesc = this;
  // This is the node that holds the child views. It may be null for
  // descs that don't have children.
  this.contentDOM = contentDOM;
  this.dirty = NOT_DIRTY;
};

var prototypeAccessors = { size: { configurable: true },border: { configurable: true },posBefore: { configurable: true },posAtStart: { configurable: true },posAfter: { configurable: true },posAtEnd: { configurable: true },contentLost: { configurable: true },domAtom: { configurable: true },ignoreForCoords: { configurable: true } };

// Used to check whether a given description corresponds to a
// widget/mark/node.
ViewDesc.prototype.matchesWidget = function matchesWidget () { return false };
ViewDesc.prototype.matchesMark = function matchesMark () { return false };
ViewDesc.prototype.matchesNode = function matchesNode () { return false };
ViewDesc.prototype.matchesHack = function matchesHack (_nodeName) { return false };

// : () → ?ParseRule
// When parsing in-editor content (in domchange.js), we allow
// descriptions to determine the parse rules that should be used to
// parse them.
ViewDesc.prototype.parseRule = function parseRule () { return null };

// : (dom.Event) → bool
// Used by the editor's event handler to ignore events that come
// from certain descs.
ViewDesc.prototype.stopEvent = function stopEvent () { return false };

// The size of the content represented by this desc.
prototypeAccessors.size.get = function () {
  var size = 0;
  for (var i = 0; i < this.children.length; i++) { size += this.children[i].size; }
  return size
};

// For block nodes, this represents the space taken up by their
// start/end tokens.
prototypeAccessors.border.get = function () { return 0 };

ViewDesc.prototype.destroy = function destroy () {
  this.parent = null;
  if (this.dom.pmViewDesc == this) { this.dom.pmViewDesc = null; }
  for (var i = 0; i < this.children.length; i++)
    { this.children[i].destroy(); }
};

ViewDesc.prototype.posBeforeChild = function posBeforeChild (child) {
  for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {
    var cur = this.children[i];
    if (cur == child) { return pos }
    pos += cur.size;
  }
};

prototypeAccessors.posBefore.get = function () {
  return this.parent.posBeforeChild(this)
};

prototypeAccessors.posAtStart.get = function () {
  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
};

prototypeAccessors.posAfter.get = function () {
  return this.posBefore + this.size
};

prototypeAccessors.posAtEnd.get = function () {
  return this.posAtStart + this.size - 2 * this.border
};

// : (dom.Node, number, ?number) → number
ViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {
  // If the DOM position is in the content, use the child desc after
  // it to figure out a position.
  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
    if (bias < 0) {
      var domBefore, desc;
      if (dom == this.contentDOM) {
        domBefore = dom.childNodes[offset - 1];
      } else {
        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }
        domBefore = dom.previousSibling;
      }
      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) { domBefore = domBefore.previousSibling; }
      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart
    } else {
      var domAfter, desc$1;
      if (dom == this.contentDOM) {
        domAfter = dom.childNodes[offset];
      } else {
        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }
        domAfter = dom.nextSibling;
      }
      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) { domAfter = domAfter.nextSibling; }
      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd
    }
  }
  // Otherwise, use various heuristics, falling back on the bias
  // parameter, to determine whether to return the position at the
  // start or at the end of this view desc.
  var atEnd;
  if (dom == this.dom && this.contentDOM) {
    atEnd = offset > domIndex(this.contentDOM);
  } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
    atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
  } else if (this.dom.firstChild) {
    if (offset == 0) { for (var search = dom;; search = search.parentNode) {
      if (search == this.dom) { atEnd = false; break }
      if (search.parentNode.firstChild != search) { break }
    } }
    if (atEnd == null && offset == dom.childNodes.length) { for (var search$1 = dom;; search$1 = search$1.parentNode) {
      if (search$1 == this.dom) { atEnd = true; break }
      if (search$1.parentNode.lastChild != search$1) { break }
    } }
  }
  return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart
};

// Scan up the dom finding the first desc that is a descendant of
// this one.
ViewDesc.prototype.nearestDesc = function nearestDesc (dom, onlyNodes) {
  for (var first = true, cur = dom; cur; cur = cur.parentNode) {
    var desc = this.getDesc(cur);
    if (desc && (!onlyNodes || desc.node)) {
      // If dom is outside of this desc's nodeDOM, don't count it.
      if (first && desc.nodeDOM &&
          !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom))
        { first = false; }
      else
        { return desc }
    }
  }
};

ViewDesc.prototype.getDesc = function getDesc (dom) {
  var desc = dom.pmViewDesc;
  for (var cur = desc; cur; cur = cur.parent) { if (cur == this) { return desc } }
};

ViewDesc.prototype.posFromDOM = function posFromDOM (dom, offset, bias) {
  for (var scan = dom; scan; scan = scan.parentNode) {
    var desc = this.getDesc(scan);
    if (desc) { return desc.localPosFromDOM(dom, offset, bias) }
  }
  return -1
};

// : (number) → ?NodeViewDesc
// Find the desc for the node after the given pos, if any. (When a
// parent node overrode rendering, there might not be one.)
ViewDesc.prototype.descAt = function descAt (pos) {
  for (var i = 0, offset = 0; i < this.children.length; i++) {
    var child = this.children[i], end = offset + child.size;
    if (offset == pos && end != offset) {
      while (!child.border && child.children.length) { child = child.children[0]; }
      return child
    }
    if (pos < end) { return child.descAt(pos - offset - child.border) }
    offset = end;
  }
};

// : (number, number) → {node: dom.Node, offset: number}
ViewDesc.prototype.domFromPos = function domFromPos (pos, side) {
  if (!this.contentDOM) { return {node: this.dom, offset: 0} }
  // First find the position in the child array
  var i = 0, offset = 0;
  for (var curPos = 0; i < this.children.length; i++) {
    var child = this.children[i], end = curPos + child.size;
    if (end > pos || child instanceof TrailingHackViewDesc) { offset = pos - curPos; break }
    curPos = end;
  }
  // If this points into the middle of a child, call through
  if (offset) { return this.children[i].domFromPos(offset - this.children[i].border, side) }
  // Go back if there were any zero-length widgets with side >= 0 before this point
  for (var prev = (void 0); i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.widget.type.side >= 0; i--) {}
  // Scan towards the first useable node
  if (side <= 0) {
    var prev$1, enter = true;
    for (;; i--, enter = false) {
      prev$1 = i ? this.children[i - 1] : null;
      if (!prev$1 || prev$1.dom.parentNode == this.contentDOM) { break }
    }
    if (prev$1 && side && enter && !prev$1.border && !prev$1.domAtom) { return prev$1.domFromPos(prev$1.size, side) }
    return {node: this.contentDOM, offset: prev$1 ? domIndex(prev$1.dom) + 1 : 0}
  } else {
    var next, enter$1 = true;
    for (;; i++, enter$1 = false) {
      next = i < this.children.length ? this.children[i] : null;
      if (!next || next.dom.parentNode == this.contentDOM) { break }
    }
    if (next && enter$1 && !next.border && !next.domAtom) { return next.domFromPos(0, side) }
    return {node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length}
  }
};

// Used to find a DOM range in a single parent for a given changed
// range.
ViewDesc.prototype.parseRange = function parseRange (from, to, base) {
    if ( base === void 0 ) base = 0;

  if (this.children.length == 0)
    { return {node: this.contentDOM, from: from, to: to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length} }

  var fromOffset = -1, toOffset = -1;
  for (var offset = base, i = 0;; i++) {
    var child = this.children[i], end = offset + child.size;
    if (fromOffset == -1 && from <= end) {
      var childBase = offset + child.border;
      // FIXME maybe descend mark views to parse a narrower range?
      if (from >= childBase && to <= end - child.border && child.node &&
          child.contentDOM && this.contentDOM.contains(child.contentDOM))
        { return child.parseRange(from, to, childBase) }

      from = offset;
      for (var j = i; j > 0; j--) {
        var prev = this.children[j - 1];
        if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
          fromOffset = domIndex(prev.dom) + 1;
          break
        }
        from -= prev.size;
      }
      if (fromOffset == -1) { fromOffset = 0; }
    }
    if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
      to = end;
      for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {
        var next = this.children[j$1];
        if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
          toOffset = domIndex(next.dom);
          break
        }
        to += next.size;
      }
      if (toOffset == -1) { toOffset = this.contentDOM.childNodes.length; }
      break
    }
    offset = end;
  }
  return {node: this.contentDOM, from: from, to: to, fromOffset: fromOffset, toOffset: toOffset}
};

ViewDesc.prototype.emptyChildAt = function emptyChildAt (side) {
  if (this.border || !this.contentDOM || !this.children.length) { return false }
  var child = this.children[side < 0 ? 0 : this.children.length - 1];
  return child.size == 0 || child.emptyChildAt(side)
};

// : (number) → dom.Node
ViewDesc.prototype.domAfterPos = function domAfterPos (pos) {
  var ref = this.domFromPos(pos, 0);
    var node = ref.node;
    var offset = ref.offset;
  if (node.nodeType != 1 || offset == node.childNodes.length)
    { throw new RangeError("No node after pos " + pos) }
  return node.childNodes[offset]
};

// : (number, number, dom.Document)
// View descs are responsible for setting any selection that falls
// entirely inside of them, so that custom implementations can do
// custom things with the selection. Note that this falls apart when
// a selection starts in such a node and ends in another, in which
// case we just use whatever domFromPos produces as a best effort.
ViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {
  // If the selection falls entirely in a child, give it to that child
  var from = Math.min(anchor, head), to = Math.max(anchor, head);
  for (var i = 0, offset = 0; i < this.children.length; i++) {
    var child = this.children[i], end = offset + child.size;
    if (from > offset && to < end)
      { return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force) }
    offset = end;
  }

  var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
  var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
  var domSel = root.getSelection();

  var brKludge = false;
  // On Firefox, using Selection.collapse to put the cursor after a
  // BR node for some reason doesn't always work (#1073). On Safari,
  // the cursor sometimes inexplicable visually lags behind its
  // reported position in such situations (#1092).
  if ((result.gecko || result.safari) && anchor == head) {
    var node = anchorDOM.node;
      var offset$1 = anchorDOM.offset;
    if (node.nodeType == 3) {
      brKludge = offset$1 && node.nodeValue[offset$1 - 1] == "\n";
      // Issue #1128
      if (brKludge && offset$1 == node.nodeValue.length) {
        for (var scan = node, after = (void 0); scan; scan = scan.parentNode) {
          if (after = scan.nextSibling) {
            if (after.nodeName == "BR")
              { anchorDOM = headDOM = {node: after.parentNode, offset: domIndex(after) + 1}; }
            break
          }
          var desc = scan.pmViewDesc;
          if (desc && desc.node && desc.node.isBlock) { break }
        }
      }
    } else {
      var prev = node.childNodes[offset$1 - 1];
      brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
    }
  }
  // Firefox can act strangely when the selection is in front of an
  // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536
  if (result.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
    var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];
    if (after$1 && after$1.contentEditable == "false") { force = true; }
  }

  if (!(force || brKludge && result.safari) &&
      isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&
      isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
    { return }

  // Selection.extend can be used to create an 'inverted' selection
  // (one where the focus is before the anchor), but not all
  // browsers support it yet.
  var domSelExtended = false;
  if ((domSel.extend || anchor == head) && !brKludge) {
    domSel.collapse(anchorDOM.node, anchorDOM.offset);
    try {
      if (anchor != head) { domSel.extend(headDOM.node, headDOM.offset); }
      domSelExtended = true;
    } catch (err) {
      // In some cases with Chrome the selection is empty after calling
      // collapse, even when it should be valid. This appears to be a bug, but
      // it is difficult to isolate. If this happens fallback to the old path
      // without using extend.
      if (!(err instanceof DOMException)) { throw err }
      // declare global: DOMException
    }
  }
  if (!domSelExtended) {
    if (anchor > head) { var tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp; }
    var range = document.createRange();
    range.setEnd(headDOM.node, headDOM.offset);
    range.setStart(anchorDOM.node, anchorDOM.offset);
    domSel.removeAllRanges();
    domSel.addRange(range);
  }
};

// : (dom.MutationRecord) → bool
ViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
  return !this.contentDOM && mutation.type != "selection"
};

prototypeAccessors.contentLost.get = function () {
  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
};

// Remove a subtree of the element tree that has been touched
// by a DOM change, so that the next update will redraw it.
ViewDesc.prototype.markDirty = function markDirty (from, to) {
  for (var offset = 0, i = 0; i < this.children.length; i++) {
    var child = this.children[i], end = offset + child.size;
    if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
      var startInside = offset + child.border, endInside = end - child.border;
      if (from >= startInside && to <= endInside) {
        this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
        if (from == startInside && to == endInside &&
            (child.contentLost || child.dom.parentNode != this.contentDOM)) { child.dirty = NODE_DIRTY; }
        else { child.markDirty(from - startInside, to - startInside); }
        return
      } else {
        child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM ? CONTENT_DIRTY : NODE_DIRTY;
      }
    }
    offset = end;
  }
  this.dirty = CONTENT_DIRTY;
};

ViewDesc.prototype.markParentsDirty = function markParentsDirty () {
  var level = 1;
  for (var node = this.parent; node; node = node.parent, level++) {
    var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
    if (node.dirty < dirty) { node.dirty = dirty; }
  }
};

prototypeAccessors.domAtom.get = function () { return false };

prototypeAccessors.ignoreForCoords.get = function () { return false };

Object.defineProperties( ViewDesc.prototype, prototypeAccessors );

// Reused array to avoid allocating fresh arrays for things that will
// stay empty anyway.
var nothing = [];

// A widget desc represents a widget decoration, which is a DOM node
// drawn between the document nodes.
var WidgetViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function WidgetViewDesc(parent, widget, view, pos) {
    var self, dom = widget.type.toDOM;
    if (typeof dom == "function") { dom = dom(view, function () {
      if (!self) { return pos }
      if (self.parent) { return self.parent.posBeforeChild(self) }
    }); }
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }
      dom.contentEditable = false;
      dom.classList.add("ProseMirror-widget");
    }
    ViewDesc.call(this, parent, nothing, dom, null);
    this.widget = widget;
    self = this;
  }

  if ( ViewDesc ) WidgetViewDesc.__proto__ = ViewDesc;
  WidgetViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  WidgetViewDesc.prototype.constructor = WidgetViewDesc;

  var prototypeAccessors$1 = { domAtom: { configurable: true } };

  WidgetViewDesc.prototype.matchesWidget = function matchesWidget (widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type)
  };

  WidgetViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };

  WidgetViewDesc.prototype.stopEvent = function stopEvent (event) {
    var stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false
  };

  WidgetViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection
  };

  prototypeAccessors$1.domAtom.get = function () { return true };

  Object.defineProperties( WidgetViewDesc.prototype, prototypeAccessors$1 );

  return WidgetViewDesc;
}(ViewDesc));

var CompositionViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function CompositionViewDesc(parent, dom, textDOM, text) {
    ViewDesc.call(this, parent, nothing, dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }

  if ( ViewDesc ) CompositionViewDesc.__proto__ = ViewDesc;
  CompositionViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  CompositionViewDesc.prototype.constructor = CompositionViewDesc;

  var prototypeAccessors$2 = { size: { configurable: true } };

  prototypeAccessors$2.size.get = function () { return this.text.length };

  CompositionViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset) {
    if (dom != this.textDOM) { return this.posAtStart + (offset ? this.size : 0) }
    return this.posAtStart + offset
  };

  CompositionViewDesc.prototype.domFromPos = function domFromPos (pos) {
    return {node: this.textDOM, offset: pos}
  };

  CompositionViewDesc.prototype.ignoreMutation = function ignoreMutation (mut) {
    return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue
   };

  Object.defineProperties( CompositionViewDesc.prototype, prototypeAccessors$2 );

  return CompositionViewDesc;
}(ViewDesc));

// A mark desc represents a mark. May have multiple children,
// depending on how the mark is split. Note that marks are drawn using
// a fixed nesting order, for simplicity and predictability, so in
// some cases they will be split more often than would appear
// necessary.
var MarkViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function MarkViewDesc(parent, mark, dom, contentDOM) {
    ViewDesc.call(this, parent, [], dom, contentDOM);
    this.mark = mark;
  }

  if ( ViewDesc ) MarkViewDesc.__proto__ = ViewDesc;
  MarkViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  MarkViewDesc.prototype.constructor = MarkViewDesc;

  MarkViewDesc.create = function create (parent, mark, inline, view) {
    var custom = view.nodeViews[mark.type.name];
    var spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      { spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline)); }
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom)
  };

  MarkViewDesc.prototype.parseRule = function parseRule () { return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM} };

  MarkViewDesc.prototype.matchesMark = function matchesMark (mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) };

  MarkViewDesc.prototype.markDirty = function markDirty (from, to) {
    ViewDesc.prototype.markDirty.call(this, from, to);
    // Move dirty info to nearest node view
    if (this.dirty != NOT_DIRTY) {
      var parent = this.parent;
      while (!parent.node) { parent = parent.parent; }
      if (parent.dirty < this.dirty) { parent.dirty = this.dirty; }
      this.dirty = NOT_DIRTY;
    }
  };

  MarkViewDesc.prototype.slice = function slice (from, to, view) {
    var copy = MarkViewDesc.create(this.parent, this.mark, true, view);
    var nodes = this.children, size = this.size;
    if (to < size) { nodes = replaceNodes(nodes, to, size, view); }
    if (from > 0) { nodes = replaceNodes(nodes, 0, from, view); }
    for (var i = 0; i < nodes.length; i++) { nodes[i].parent = copy; }
    copy.children = nodes;
    return copy
  };

  return MarkViewDesc;
}(ViewDesc));

// Node view descs are the main, most common type of view desc, and
// correspond to an actual node in the document. Unlike mark descs,
// they populate their child array themselves.
var NodeViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    ViewDesc.call(this, parent, node.isLeaf ? nothing : [], dom, contentDOM);
    this.nodeDOM = nodeDOM;
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    if (contentDOM) { this.updateChildren(view, pos); }
  }

  if ( ViewDesc ) NodeViewDesc.__proto__ = ViewDesc;
  NodeViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  NodeViewDesc.prototype.constructor = NodeViewDesc;

  var prototypeAccessors$3 = { size: { configurable: true },border: { configurable: true },domAtom: { configurable: true } };

  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  NodeViewDesc.create = function create (parent, node, outerDeco, innerDeco, view, pos) {
    var assign;

    var custom = view.nodeViews[node.type.name], descObj;
    var spec = custom && custom(node, view, function () {
      // (This is a function that allows the custom view to find its
      // own position)
      if (!descObj) { return pos }
      if (descObj.parent) { return descObj.parent.posBeforeChild(descObj) }
    }, outerDeco, innerDeco);

    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom) { dom = document.createTextNode(node.text); }
      else if (dom.nodeType != 3) { throw new RangeError("Text must be rendered as a DOM text node") }
    } else if (!dom) {
((assign = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)), dom = assign.dom, contentDOM = assign.contentDOM));
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") { // Chrome gets confused by <br contenteditable=false>
      if (!dom.hasAttribute("contenteditable")) { dom.contentEditable = false; }
      if (node.type.spec.draggable) { dom.draggable = true; }
    }

    var nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);

    if (spec)
      { return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM,
                                              spec, view, pos + 1) }
    else if (node.isText)
      { return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) }
    else
      { return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1) }
  };

  NodeViewDesc.prototype.parseRule = function parseRule () {
    var this$1 = this;

    // Experimental kludge to allow opt-in re-parsing of nodes
    if (this.node.type.spec.reparseInView) { return null }
    // FIXME the assumption that this can always return the current
    // attrs means that if the user somehow manages to change the
    // attrs in the dom, that won't be picked up. Not entirely sure
    // whether this is a problem
    var rule = {node: this.node.type.name, attrs: this.node.attrs};
    if (this.node.type.spec.code) { rule.preserveWhitespace = "full"; }
    if (this.contentDOM && !this.contentLost) { rule.contentElement = this.contentDOM; }
    else { rule.getContent = function () { return this$1.contentDOM ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : this$1.node.content; }; }
    return rule
  };

  NodeViewDesc.prototype.matchesNode = function matchesNode (node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) &&
      sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)
  };

  prototypeAccessors$3.size.get = function () { return this.node.nodeSize };

  prototypeAccessors$3.border.get = function () { return this.node.isLeaf ? 0 : 1 };

  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  NodeViewDesc.prototype.updateChildren = function updateChildren (view, pos) {
    var this$1 = this;

    var inline = this.node.inlineContent, off = pos;
    var composition = view.composing && this.localCompositionInfo(view, pos);
    var localComposition = composition && composition.pos > -1 ? composition : null;
    var compositionInChild = composition && composition.pos < 0;
    var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
    iterDeco(this.node, this.innerDeco, function (widget, i, insideNode) {
      if (widget.spec.marks)
        { updater.syncToMarks(widget.spec.marks, inline, view); }
      else if (widget.type.side >= 0 && !insideNode)
        { updater.syncToMarks(i == this$1.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.none : this$1.node.child(i).marks, inline, view); }
      // If the next node is a desc matching this widget, reuse it,
      // otherwise insert the widget as a new view desc.
      updater.placeWidget(widget, view, off);
    }, function (child, outerDeco, innerDeco, i) {
      // Make sure the wrapping mark descs match the node's marks.
      updater.syncToMarks(child.marks, inline, view);
      // Try several strategies for drawing this node
      var compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ; else if (compositionInChild && view.state.selection.from > off &&
                 view.state.selection.to < off + child.nodeSize &&
                 (compIndex = updater.findIndexWithChild(composition.node)) > -1 &&
                 updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ; else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i)) ; else {
        // Add it as a new view
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    // Drop all remaining descs after the current position.
    updater.syncToMarks(nothing, inline, view);
    if (this.node.isTextblock) { updater.addTextblockHacks(); }
    updater.destroyRest();

    // Sync the DOM if anything changed
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      // May have to protect focused DOM from being changed if a composition is active
      if (localComposition) { this.protectLocalComposition(view, localComposition); }
      renderDescs(this.contentDOM, this.children, view);
      if (result.ios) { iosHacks(this.dom); }
    }
  };

  NodeViewDesc.prototype.localCompositionInfo = function localCompositionInfo (view, pos) {
    // Only do something if both the selection and a focused text node
    // are inside of this node
    var ref = view.state.selection;
    var from = ref.from;
    var to = ref.to;
    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) || from < pos || to > pos + this.node.content.size) { return }
    var sel = view.root.getSelection();
    var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode)) { return }

    if (this.node.inlineContent) {
      // Find the text in the focused node in the node, stop if it's not
      // there (may have been modified through other means, in which
      // case it should overwritten)
      var text = textNode.nodeValue;
      var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
      return textPos < 0 ? null : {node: textNode, pos: textPos, text: text}
    } else {
      return {node: textNode, pos: -1}
    }
  };

  NodeViewDesc.prototype.protectLocalComposition = function protectLocalComposition (view, ref) {
    var node = ref.node;
    var pos = ref.pos;
    var text = ref.text;

    // The node is already part of a local view desc, leave it there
    if (this.getDesc(node)) { return }

    // Create a composition view for the orphaned nodes
    var topNode = node;
    for (;; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM) { break }
      while (topNode.previousSibling) { topNode.parentNode.removeChild(topNode.previousSibling); }
      while (topNode.nextSibling) { topNode.parentNode.removeChild(topNode.nextSibling); }
      if (topNode.pmViewDesc) { topNode.pmViewDesc = null; }
    }
    var desc = new CompositionViewDesc(this, topNode, node, text);
    view.compositionNodes.push(desc);

    // Patch up this.children to contain the composition view
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  };

  // : (Node, [Decoration], DecorationSource, EditorView) → bool
  // If this desc be updated to match the given node decoration,
  // do so and return true.
  NodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY ||
        !node.sameMarkup(this.node)) { return false }
    this.updateInner(node, outerDeco, innerDeco, view);
    return true
  };

  NodeViewDesc.prototype.updateInner = function updateInner (node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM) { this.updateChildren(view, this.posAtStart); }
    this.dirty = NOT_DIRTY;
  };

  NodeViewDesc.prototype.updateOuterDeco = function updateOuterDeco (outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco)) { return }
    var needsWrap = this.nodeDOM.nodeType != 1;
    var oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM,
                              computeOuterDeco(this.outerDeco, this.node, needsWrap),
                              computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = null;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  };

  // Mark this node as being the selected node.
  NodeViewDesc.prototype.selectNode = function selectNode () {
    this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) { this.dom.draggable = true; }
  };

  // Remove selected node marking from this node.
  NodeViewDesc.prototype.deselectNode = function deselectNode () {
    this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) { this.dom.removeAttribute("draggable"); }
  };

  prototypeAccessors$3.domAtom.get = function () { return this.node.isAtom };

  Object.defineProperties( NodeViewDesc.prototype, prototypeAccessors$3 );

  return NodeViewDesc;
}(ViewDesc));

// Create a view desc for the top-level document node, to be exported
// and used by the view class.
function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc);
  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0)
}

var TextViewDesc = /*@__PURE__*/(function (NodeViewDesc) {
  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view);
  }

  if ( NodeViewDesc ) TextViewDesc.__proto__ = NodeViewDesc;
  TextViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );
  TextViewDesc.prototype.constructor = TextViewDesc;

  var prototypeAccessors$4 = { domAtom: { configurable: true } };

  TextViewDesc.prototype.parseRule = function parseRule () {
    var skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco) { skip = skip.parentNode; }
    return {skip: skip || true}
  };

  TextViewDesc.prototype.update = function update (node, outerDeco, _, view) {
    if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||
        !node.sameMarkup(this.node)) { return false }
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM) { view.trackWrites = null; }
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true
  };

  TextViewDesc.prototype.inParent = function inParent () {
    var parentDOM = this.parent.contentDOM;
    for (var n = this.nodeDOM; n; n = n.parentNode) { if (n == parentDOM) { return true } }
    return false
  };

  TextViewDesc.prototype.domFromPos = function domFromPos (pos) {
    return {node: this.nodeDOM, offset: pos}
  };

  TextViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {
    if (dom == this.nodeDOM) { return this.posAtStart + Math.min(offset, this.node.text.length) }
    return NodeViewDesc.prototype.localPosFromDOM.call(this, dom, offset, bias)
  };

  TextViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
    return mutation.type != "characterData" && mutation.type != "selection"
  };

  TextViewDesc.prototype.slice = function slice (from, to, view) {
    var node = this.node.cut(from, to), dom = document.createTextNode(node.text);
    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view)
  };

  TextViewDesc.prototype.markDirty = function markDirty (from, to) {
    NodeViewDesc.prototype.markDirty.call(this, from, to);
    if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))
      { this.dirty = NODE_DIRTY; }
  };

  prototypeAccessors$4.domAtom.get = function () { return false };

  Object.defineProperties( TextViewDesc.prototype, prototypeAccessors$4 );

  return TextViewDesc;
}(NodeViewDesc));

// A dummy desc used to tag trailing BR or IMG nodes created to work
// around contentEditable terribleness.
var TrailingHackViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function TrailingHackViewDesc () {
    ViewDesc.apply(this, arguments);
  }

  if ( ViewDesc ) TrailingHackViewDesc.__proto__ = ViewDesc;
  TrailingHackViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  TrailingHackViewDesc.prototype.constructor = TrailingHackViewDesc;

  var prototypeAccessors$5 = { domAtom: { configurable: true },ignoreForCoords: { configurable: true } };

  TrailingHackViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };
  TrailingHackViewDesc.prototype.matchesHack = function matchesHack (nodeName) { return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName };
  prototypeAccessors$5.domAtom.get = function () { return true };
  prototypeAccessors$5.ignoreForCoords.get = function () { return this.dom.nodeName == "IMG" };

  Object.defineProperties( TrailingHackViewDesc.prototype, prototypeAccessors$5 );

  return TrailingHackViewDesc;
}(ViewDesc));

// A separate subclass is used for customized node views, so that the
// extra checks only have to be made for nodes that are actually
// customized.
var CustomNodeViewDesc = /*@__PURE__*/(function (NodeViewDesc) {
  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }

  if ( NodeViewDesc ) CustomNodeViewDesc.__proto__ = NodeViewDesc;
  CustomNodeViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );
  CustomNodeViewDesc.prototype.constructor = CustomNodeViewDesc;

  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  CustomNodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY) { return false }
    if (this.spec.update) {
      var result = this.spec.update(node, outerDeco, innerDeco);
      if (result) { this.updateInner(node, outerDeco, innerDeco, view); }
      return result
    } else if (!this.contentDOM && !node.isLeaf) {
      return false
    } else {
      return NodeViewDesc.prototype.update.call(this, node, outerDeco, innerDeco, view)
    }
  };

  CustomNodeViewDesc.prototype.selectNode = function selectNode () {
    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc.prototype.selectNode.call(this);
  };

  CustomNodeViewDesc.prototype.deselectNode = function deselectNode () {
    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc.prototype.deselectNode.call(this);
  };

  CustomNodeViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root)
      : NodeViewDesc.prototype.setSelection.call(this, anchor, head, root, force);
  };

  CustomNodeViewDesc.prototype.destroy = function destroy () {
    if (this.spec.destroy) { this.spec.destroy(); }
    NodeViewDesc.prototype.destroy.call(this);
  };

  CustomNodeViewDesc.prototype.stopEvent = function stopEvent (event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false
  };

  CustomNodeViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc.prototype.ignoreMutation.call(this, mutation)
  };

  return CustomNodeViewDesc;
}(NodeViewDesc));

// : (dom.Node, [ViewDesc])
// Sync the content of the given DOM node with the nodes associated
// with the given array of view descs, recursing into mark descs
// because this should sync the subtree for a whole node at a time.
function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild, written = false;
  for (var i = 0; i < descs.length; i++) {
    var desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) { dom = rm(dom); written = true; }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) { dom = rm(dom); written = true; }
  if (written && view.trackWrites == parentDOM) { view.trackWrites = null; }
}

function OuterDecoLevel(nodeName) {
  if (nodeName) { this.nodeName = nodeName; }
}
OuterDecoLevel.prototype = Object.create(null);

var noDeco = [new OuterDecoLevel];

function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0) { return noDeco }

  var top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];

  for (var i = 0; i < outerDeco.length; i++) {
    var attrs = outerDeco[i].type.attrs;
    if (!attrs) { continue }
    if (attrs.nodeName)
      { result.push(top = new OuterDecoLevel(attrs.nodeName)); }

    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) { continue }
      if (needsWrap && result.length == 1)
        { result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div")); }
      if (name == "class") { top.class = (top.class ? top.class + " " : "") + val; }
      else if (name == "style") { top.style = (top.style ? top.style + ";" : "") + val; }
      else if (name != "nodeName") { top[name] = val; }
    }
  }

  return result
}

function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  // Shortcut for trivial case
  if (prevComputed == noDeco && curComputed == noDeco) { return nodeDOM }

  var curDOM = nodeDOM;
  for (var i = 0; i < curComputed.length; i++) {
    var deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      var parent = (void 0);
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&
          (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM
}

function patchAttributes(dom, prev, cur) {
  for (var name in prev)
    { if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      { dom.removeAttribute(name); } }
  for (var name$1 in cur)
    { if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1])
      { dom.setAttribute(name$1, cur[name$1]); } }
  if (prev.class != cur.class) {
    var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : nothing;
    var curList = cur.class ? cur.class.split(" ").filter(Boolean) : nothing;
    for (var i = 0; i < prevList.length; i++) { if (curList.indexOf(prevList[i]) == -1)
      { dom.classList.remove(prevList[i]); } }
    for (var i$1 = 0; i$1 < curList.length; i$1++) { if (prevList.indexOf(curList[i$1]) == -1)
      { dom.classList.add(curList[i$1]); } }
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        { dom.style.removeProperty(m[1]); }
    }
    if (cur.style)
      { dom.style.cssText += cur.style; }
  }
}

function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))
}

// : ([Decoration], [Decoration]) → bool
function sameOuterDeco(a, b) {
  if (a.length != b.length) { return false }
  for (var i = 0; i < a.length; i++) { if (!a[i].type.eq(b[i].type)) { return false } }
  return true
}

// Remove a DOM node and return its next sibling.
function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next
}

// Helper class for incrementally updating a tree of mark descs and
// the widget and node descs inside of them.
var ViewTreeUpdater = function ViewTreeUpdater(top, lockedNode) {
  this.top = top;
  this.lock = lockedNode;
  // Index into `this.top`'s child array, represents the current
  // update position.
  this.index = 0;
  // When entering a mark, the current top and index are pushed
  // onto this.
  this.stack = [];
  // Tracks whether anything was changed
  this.changed = false;

  this.preMatch = preMatch(top.node.content, top.children);
};

// Destroy and remove the children between the given indices in
// `this.top`.
ViewTreeUpdater.prototype.destroyBetween = function destroyBetween (start, end) {
  if (start == end) { return }
  for (var i = start; i < end; i++) { this.top.children[i].destroy(); }
  this.top.children.splice(start, end - start);
  this.changed = true;
};

// Destroy all remaining children in `this.top`.
ViewTreeUpdater.prototype.destroyRest = function destroyRest () {
  this.destroyBetween(this.index, this.top.children.length);
};

// : ([Mark], EditorView)
// Sync the current stack of mark descs with the given array of
// marks, reusing existing mark descs when possible.
ViewTreeUpdater.prototype.syncToMarks = function syncToMarks (marks, inline, view) {
  var keep = 0, depth = this.stack.length >> 1;
  var maxKeep = Math.min(depth, marks.length);
  while (keep < maxKeep &&
         (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
    { keep++; }

  while (keep < depth) {
    this.destroyRest();
    this.top.dirty = NOT_DIRTY;
    this.index = this.stack.pop();
    this.top = this.stack.pop();
    depth--;
  }
  while (depth < marks.length) {
    this.stack.push(this.top, this.index + 1);
    var found = -1;
    for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
      if (this.top.children[i].matchesMark(marks[depth])) { found = i; break }
    }
    if (found > -1) {
      if (found > this.index) {
        this.changed = true;
        this.destroyBetween(this.index, found);
      }
      this.top = this.top.children[this.index];
    } else {
      var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
      this.top.children.splice(this.index, 0, markDesc);
      this.top = markDesc;
      this.changed = true;
    }
    this.index = 0;
    depth++;
  }
};

// : (Node, [Decoration], DecorationSource) → bool
// Try to find a node desc matching the given data. Skip over it and
// return true when successful.
ViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch (node, outerDeco, innerDeco, index) {
  var children = this.top.children, found = -1;
  if (index >= this.preMatch.index) {
    for (var i = this.index; i < children.length; i++) { if (children[i].matchesNode(node, outerDeco, innerDeco)) {
      found = i;
      break
    } }
  } else {
    for (var i$1 = this.index, e = Math.min(children.length, i$1 + 1); i$1 < e; i$1++) {
      var child = children[i$1];
      if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
        found = i$1;
        break
      }
    }
  }
  if (found < 0) { return false }
  this.destroyBetween(this.index, found);
  this.index++;
  return true
};

ViewTreeUpdater.prototype.updateNodeAt = function updateNodeAt (node, outerDeco, innerDeco, index, view) {
  var child = this.top.children[index];
  if (!child.update(node, outerDeco, innerDeco, view)) { return false }
  this.destroyBetween(this.index, index);
  this.index = index + 1;
  return true
};

ViewTreeUpdater.prototype.findIndexWithChild = function findIndexWithChild (domNode) {
  for (;;) {
    var parent = domNode.parentNode;
    if (!parent) { return -1 }
    if (parent == this.top.contentDOM) {
      var desc = domNode.pmViewDesc;
      if (desc) { for (var i = this.index; i < this.top.children.length; i++) {
        if (this.top.children[i] == desc) { return i }
      } }
      return -1
    }
    domNode = parent;
  }
};

// : (Node, [Decoration], DecorationSource, EditorView, Fragment, number) → bool
// Try to update the next node, if any, to the given data. Checks
// pre-matches to avoid overwriting nodes that could still be used.
ViewTreeUpdater.prototype.updateNextNode = function updateNextNode (node, outerDeco, innerDeco, view, index) {
  for (var i = this.index; i < this.top.children.length; i++) {
    var next = this.top.children[i];
    if (next instanceof NodeViewDesc) {
      var preMatch = this.preMatch.matched.get(next);
      if (preMatch != null && preMatch != index) { return false }
      var nextDOM = next.dom;

      // Can't update if nextDOM is or contains this.lock, except if
      // it's a text node whose content already matches the new text
      // and whose decorations match the new ones.
      var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) &&
          !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&
            next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
      if (!locked && next.update(node, outerDeco, innerDeco, view)) {
        this.destroyBetween(this.index, i);
        if (next.dom != nextDOM) { this.changed = true; }
        this.index++;
        return true
      }
      break
    }
  }
  return false
};

// : (Node, [Decoration], DecorationSource, EditorView)
// Insert the node as a newly created node desc.
ViewTreeUpdater.prototype.addNode = function addNode (node, outerDeco, innerDeco, view, pos) {
  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));
  this.changed = true;
};

ViewTreeUpdater.prototype.placeWidget = function placeWidget (widget, view, pos) {
  var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
  if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
    this.index++;
  } else {
    var desc = new WidgetViewDesc(this.top, widget, view, pos);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
};

// Make sure a textblock looks and behaves correctly in
// contentEditable.
ViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks () {
  var lastChild = this.top.children[this.index - 1];
  while (lastChild instanceof MarkViewDesc) { lastChild = lastChild.children[lastChild.children.length - 1]; }

  if (!lastChild || // Empty textblock
      !(lastChild instanceof TextViewDesc) ||
      /\n$/.test(lastChild.node.text)) {
    // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)
    if ((result.safari || result.chrome) && lastChild && lastChild.dom.contentEditable == "false")
      { this.addHackNode("IMG"); }
    this.addHackNode("BR");
  }
};

ViewTreeUpdater.prototype.addHackNode = function addHackNode (nodeName) {
  if (this.index < this.top.children.length && this.top.children[this.index].matchesHack(nodeName)) {
    this.index++;
  } else {
    var dom = document.createElement(nodeName);
    if (nodeName == "IMG") { dom.className = "ProseMirror-separator"; }
    if (nodeName == "BR") { dom.className = "ProseMirror-trailingBreak"; }
    this.top.children.splice(this.index++, 0, new TrailingHackViewDesc(this.top, nothing, dom, null));
    this.changed = true;
  }
};

// : (Fragment, [ViewDesc]) → {index: number, matched: Map<ViewDesc, number>}
// Iterate from the end of the fragment and array of descs to find
// directly matching ones, in order to avoid overeagerly reusing those
// for other nodes. Returns the fragment index of the first node that
// is part of the sequence of matched nodes at the end of the
// fragment.
function preMatch(frag, descs) {
  var fI = frag.childCount, dI = descs.length, matched = new Map;
  for (; fI > 0 && dI > 0; dI--) {
    var desc = descs[dI - 1], node = desc.node;
    if (!node) { continue }
    if (node != frag.child(fI - 1)) { break }
    --fI;
    matched.set(desc, fI);
  }
  return {index: fI, matched: matched}
}

function compareSide(a, b) { return a.type.side - b.type.side }

// : (ViewDesc, DecorationSource, (Decoration, number), (Node, [Decoration], DecorationSource, number))
// This function abstracts iterating over the nodes and decorations in
// a fragment. Calls `onNode` for each node, with its local and child
// decorations. Splits text nodes when there is a decoration starting
// or ending inside of them. Calls `onWidget` for each widget.
function iterDeco(parent, deco, onWidget, onNode) {
  var locals = deco.locals(parent), offset = 0;
  // Simple, cheap variant for when there are no local decorations
  if (locals.length == 0) {
    for (var i = 0; i < parent.childCount; i++) {
      var child = parent.child(i);
      onNode(child, locals, deco.forChild(offset, child), i);
      offset += child.nodeSize;
    }
    return
  }

  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0;;) {
    if (decoIndex < locals.length && locals[decoIndex].to == offset) {
      var widget = locals[decoIndex++], widgets = (void 0);
      while (decoIndex < locals.length && locals[decoIndex].to == offset)
        { (widgets || (widgets = [widget])).push(locals[decoIndex++]); }
      if (widgets) {
        widgets.sort(compareSide);
        for (var i$1 = 0; i$1 < widgets.length; i$1++) { onWidget(widgets[i$1], parentIndex, !!restNode); }
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }

    var child$1 = (void 0), index = (void 0);
    if (restNode) {
      index = -1;
      child$1 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child$1 = parent.child(parentIndex++);
    } else {
      break
    }

    for (var i$2 = 0; i$2 < active.length; i$2++) { if (active[i$2].to <= offset) { active.splice(i$2--, 1); } }
    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)
      { active.push(locals[decoIndex++]); }

    var end = offset + child$1.nodeSize;
    if (child$1.isText) {
      var cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) { cutAt = locals[decoIndex].from; }
      for (var i$3 = 0; i$3 < active.length; i$3++) { if (active[i$3].to < cutAt) { cutAt = active[i$3].to; } }
      if (cutAt < end) {
        restNode = child$1.cut(cutAt - offset);
        child$1 = child$1.cut(0, cutAt - offset);
        end = cutAt;
        index = -1;
      }
    }

    var outerDeco = !active.length ? nothing
        : child$1.isInline && !child$1.isLeaf ? active.filter(function (d) { return !d.inline; })
        : active.slice();
    onNode(child$1, outerDeco, deco.forChild(offset, child$1), index);
    offset = end;
  }
}

// List markers in Mobile Safari will mysteriously disappear
// sometimes. This works around that.
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}

function nearbyTextNode(node, offset) {
  for (;;) {
    if (node.nodeType == 3) { return node }
    if (node.nodeType == 1 && offset > 0) {
      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)
        { return node.childNodes[offset] }
      node = node.childNodes[offset - 1];
      offset = nodeSize(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null
    }
  }
}

// Find a piece of text in an inline fragment, overlapping from-to
function findTextInFragment(frag, text, from, to) {
  for (var i = 0, pos = 0; i < frag.childCount && pos <= to;) {
    var child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText) { continue }
    var str = child.text;
    while (i < frag.childCount) {
      var next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText) { break }
      str += next.text;
    }
    if (pos >= from) {
      var found = str.lastIndexOf(text, to - childStart);
      if (found >= 0 && found + text.length + childStart >= from)
        { return childStart + found }
    }
  }
  return -1
}

// Replace range from-to in an array of view descs with replacement
// (may be null to just delete). This goes very much against the grain
// of the rest of this code, which tends to create nodes with the
// right shape in one go, rather than messing with them after
// creation, but is necessary in the composition hack.
function replaceNodes(nodes, from, to, view, replacement) {
  var result = [];
  for (var i = 0, off = 0; i < nodes.length; i++) {
    var child = nodes[i], start = off, end = off += child.size;
    if (start >= to || end <= from) {
      result.push(child);
    } else {
      if (start < from) { result.push(child.slice(0, from - start, view)); }
      if (replacement) {
        result.push(replacement);
        replacement = null;
      }
      if (end > to) { result.push(child.slice(to - start, child.size, view)); }
    }
  }
  return result
}

function selectionFromDOM(view, origin) {
  var domSel = view.root.getSelection(), doc = view.state.doc;
  if (!domSel.focusNode) { return null }
  var nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  if (head < 0) { return null }
  var $head = doc.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node) { nearestDesc = nearestDesc.parent; }
    if (nearestDesc && nearestDesc.node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent
        && !(nearestDesc.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      var pos = nearestDesc.posBefore;
      selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection(head == pos ? $head : doc.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (anchor < 0) { return null }
    $anchor = doc.resolve(anchor);
  }

  if (!selection) {
    var bias = origin == "pointer" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection
}

function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() :
    hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom)
}

function selectionToDOM(view, force) {
  var sel = view.state.selection;
  syncNodeSelection(view, sel);

  if (!editorOwnsSelection(view)) { return }

  if (!force && view.mouseDown && view.mouseDown.allowDefault) {
    view.mouseDown.delayedSelectionSync = true;
    view.domObserver.setCurSelection();
    return
  }

  view.domObserver.disconnectSelection();

  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor = sel.anchor;
    var head = sel.head;
    var resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        { resetEditableFrom = temporarilyEditableNear(view, sel.from); }
      if (!sel.empty && !sel.$from.parent.inlineContent)
        { resetEditableTo = temporarilyEditableNear(view, sel.to); }
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) { resetEditable(resetEditableFrom); }
      if (resetEditableTo) { resetEditable(resetEditableTo); }
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) { removeClassOnSelectionChange(view); }
    }
  }

  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}

// Kludge to work around Webkit not allowing a selection to start/end
// between non-editable block nodes. We briefly make something
// editable, set the selection, then set it uneditable again.

var brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;

function temporarilyEditableNear(view, pos) {
  var ref = view.docView.domFromPos(pos, 0);
  var node = ref.node;
  var offset = ref.offset;
  var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
  var before = offset ? node.childNodes[offset - 1] : null;
  if (result.safari && after && after.contentEditable == "false") { return setEditable(after) }
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after) { return setEditable(after) }
    else if (before) { return setEditable(before) }
  }
}

function setEditable(element) {
  element.contentEditable = "true";
  if (result.safari && element.draggable) { element.draggable = false; element.wasDraggable = true; }
  return element
}

function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) { element.draggable = true; element.wasDraggable = null; }
}

function removeClassOnSelectionChange(view) {
  var doc = view.dom.ownerDocument;
  doc.removeEventListener("selectionchange", view.hideSelectionGuard);
  var domSel = view.root.getSelection();
  var node = domSel.anchorNode, offset = domSel.anchorOffset;
  doc.addEventListener("selectionchange", view.hideSelectionGuard = function () {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
      doc.removeEventListener("selectionchange", view.hideSelectionGuard);
      setTimeout(function () {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          { view.dom.classList.remove("ProseMirror-hideselection"); }
      }, 20);
    }
  });
}

function selectCursorWrapper(view) {
  var domSel = view.root.getSelection(), range = document.createRange();
  var node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img) { range.setEnd(node.parentNode, domIndex(node) + 1); }
  else { range.setEnd(node, 0); }
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  // Kludge to kill 'control selection' in IE11 when selecting an
  // invisible cursor wrapper, since that would result in those weird
  // resize handles and a selection that considers the absolutely
  // positioned wrapper, rather than the root editable node, the
  // focused element.
  if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}

function syncNodeSelection(view, sel) {
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection) {
    var desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) { desc.selectNode(); }
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}

// Clear all DOM statefulness of the last node selection.
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      { view.lastSelectedViewDesc.deselectNode(); }
    view.lastSelectedViewDesc = null;
  }
}

function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function (f) { return f(view, $anchor, $head); })
    || prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.between($anchor, $head, bias)
}

function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom) { return false }
  return hasSelection(view)
}

function hasSelection(view) {
  var sel = view.root.getSelection();
  if (!sel.anchorNode) { return false }
  try {
    // Firefox will raise 'permission denied' errors when accessing
    // properties of `sel.anchorNode` when it's in a generated CSS
    // element.
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&
      (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode))
  } catch(_) {
    return false
  }
}

function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.root.getSelection();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset)
}

function moveSelectionBlock(state, dir) {
  var ref = state.selection;
  var $anchor = ref.$anchor;
  var $head = ref.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom($start, dir)
}

function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true
}

function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection)) { return apply(view, next) }
      return false
    } else if (!(result.mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText) { return false }
      var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) { return false }
      if (prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(node)) {
        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head))
      } else if (result.webkit) {
        // Chrome and Safari will introduce extra pointless cursor
        // positions around inline uneditable nodes, so we have to
        // take over and move the cursor past them (#937)
        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)))
      } else {
        return false
      }
    }
  } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && sel.node.isInline) {
    return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(dir > 0 ? sel.$to : sel.$from))
  } else {
    var next$1 = moveSelectionBlock(view.state, dir);
    if (next$1) { return apply(view, next$1) }
    return false
  }
}

function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length
}

function isIgnorable(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR")
}

// Make sure the cursor isn't directly after one or more ignored
// nodes, which will confuse the browser's cursor motion logic.
function skipIgnoredNodesLeft(view) {
  var sel = view.root.getSelection();
  var node = sel.focusNode, offset = sel.focusOffset;
  if (!node) { return }
  var moveNode, moveOffset, force = false;
  // Gecko will do odd things when the selection is directly in front
  // of a non-editable node, so in that case, move it into the next
  // node if possible. Issue prosemirror/prosemirror#832.
  if (result.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) { force = true; }
  for (;;) {
    if (offset > 0) {
      if (node.nodeType != 1) {
        break
      } else {
        var before = node.childNodes[offset - 1];
        if (isIgnorable(before)) {
          moveNode = node;
          moveOffset = --offset;
        } else if (before.nodeType == 3) {
          node = before;
          offset = node.nodeValue.length;
        } else { break }
      }
    } else if (isBlockNode(node)) {
      break
    } else {
      var prev = node.previousSibling;
      while (prev && isIgnorable(prev)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom) { break }
        offset = 0;
      } else {
        node = prev;
        offset = nodeLen(node);
      }
    }
  }
  if (force) { setSelFocus(view, sel, node, offset); }
  else if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }
}

// Make sure the cursor isn't directly before one or more ignored
// nodes.
function skipIgnoredNodesRight(view) {
  var sel = view.root.getSelection();
  var node = sel.focusNode, offset = sel.focusOffset;
  if (!node) { return }
  var len = nodeLen(node);
  var moveNode, moveOffset;
  for (;;) {
    if (offset < len) {
      if (node.nodeType != 1) { break }
      var after = node.childNodes[offset];
      if (isIgnorable(after)) {
        moveNode = node;
        moveOffset = ++offset;
      }
      else { break }
    } else if (isBlockNode(node)) {
      break
    } else {
      var next = node.nextSibling;
      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom) { break }
        offset = len = 0;
      } else {
        node = next;
        offset = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }
}

function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock
}

function setSelFocus(view, sel, node, offset) {
  if (selectionCollapsed(sel)) {
    var range = document.createRange();
    range.setEnd(node, offset);
    range.setStart(node, offset);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset);
  }
  view.domObserver.setCurSelection();
  var state = view.state;
  // If no state update ends up happening, reset the selection.
  setTimeout(function () {
    if (view.state == state) { selectionToDOM(view); }
  }, 50);
}

// : (EditorState, number)
// Check whether vertical selection motion would involve node
// selections. If so, apply it (if not, the result is left to the
// browser)
function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && !sel.empty || mods.indexOf("s") > -1) { return false }
  if (result.mac && mods.indexOf("m") > -1) { return false }
  var $from = sel.$from;
  var $to = sel.$to;

  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock(view.state, dir);
    if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection))
      { return apply(view, next) }
  }
  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false
  }
  return false
}

function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection)) { return true }
  var ref = view.state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  var empty = ref.empty;
  if (!$head.sameParent($anchor)) { return true }
  if (!empty) { return false }
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) { return true }
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) { tr.delete($head.pos - nextNode.nodeSize, $head.pos); }
    else { tr.delete($head.pos, $head.pos + nextNode.nodeSize); }
    view.dispatch(tr);
    return true
  }
  return false
}

function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}

// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
// In which Safari (and at some point in the past, Chrome) does really
// wrong things when the down arrow is pressed when the cursor is
// directly at the start of a textblock and has an uneditable node
// after it
function safariDownArrowBug(view) {
  if (!result.safari || view.state.selection.$head.parentOffset > 0) { return }
  var ref = view.root.getSelection();
  var focusNode = ref.focusNode;
  var focusOffset = ref.focusOffset;
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&
      focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child = focusNode.firstChild;
    switchEditable(view, child, true);
    setTimeout(function () { return switchEditable(view, child, false); }, 20);
  }
}

// A backdrop key mapping used to make sure we always suppress keys
// that have a dangerous default effect, even if the commands they are
// bound to return false, and to make sure that cursor-motion keys
// find a cursor (as opposed to a node selection) when pressed. For
// cursor-motion keys, the code in the handlers also takes care of
// block selections.

function getMods(event) {
  var result = "";
  if (event.ctrlKey) { result += "c"; }
  if (event.metaKey) { result += "m"; }
  if (event.altKey) { result += "a"; }
  if (event.shiftKey) { result += "s"; }
  return result
}

function captureKeyDown(view, event) {
  var code = event.keyCode, mods = getMods(event);
  if (code == 8 || (result.mac && code == 72 && mods == "c")) { // Backspace, Ctrl-h on Mac
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)
  } else if (code == 46 || (result.mac && code == 68 && mods == "c")) { // Delete, Ctrl-d on Mac
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)
  } else if (code == 13 || code == 27) { // Enter, Esc
    return true
  } else if (code == 37) { // Left arrow
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view)
  } else if (code == 39) { // Right arrow
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view)
  } else if (code == 38) { // Up arrow
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view)
  } else if (code == 40) { // Down arrow
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view)
  } else if (mods == (result.mac ? "m" : "c") &&
             (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]
    return true
  }
  return false
}

// Note that all referencing and parsing is done with the
// start-of-operation selection and document, since that's the one
// that the DOM represents. If any changes came in in the meantime,
// the modification is mapped over those before it is applied, in
// readDOMChange.

function parseBetween(view, from_, to_) {
  var ref = view.docView.parseRange(from_, to_);
  var parent = ref.node;
  var fromOffset = ref.fromOffset;
  var toOffset = ref.toOffset;
  var from = ref.from;
  var to = ref.to;

  var domSel = view.root.getSelection(), find = null, anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{node: anchor, offset: domSel.anchorOffset}];
    if (!selectionCollapsed(domSel))
      { find.push({node: domSel.focusNode, offset: domSel.focusOffset}); }
  }
  // Work around issue in Chrome where backspacing sometimes replaces
  // the deleted content with a random BR node (issues #799, #831)
  if (result.chrome && view.lastKeyCode === 8) {
    for (var off = toOffset; off > fromOffset; off--) {
      var node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) { toOffset = off; break }
      if (!desc || desc.size) { break }
    }
  }
  var startDoc = view.state.doc;
  var parser = view.someProp("domParser") || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from);

  var sel = null, doc = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.spec.code ? "full" : true,
    editableContent: true,
    findPositions: find,
    ruleFromNode: ruleFromNode,
    context: $from
  });
  if (find && find[0].pos != null) {
    var anchor$1 = find[0].pos, head = find[1] && find[1].pos;
    if (head == null) { head = anchor$1; }
    sel = {anchor: anchor$1 + from, head: head + from};
  }
  return {doc: doc, sel: sel, from: from, to: to}
}

function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule()
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    // Safari replaces the list item or table cell with a BR
    // directly in the list node (?!) if you delete the last
    // character in a list item or table cell (#708, #862)
    if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return {skip: skip}
    } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return {ignore: true}
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return {ignore: true}
  }
}

function readDOMChange(view, from, to, typeOver, addedNodes) {
  if (from < 0) {
    var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      var tr$1 = view.state.tr.setSelection(newSel);
      if (origin == "pointer") { tr$1.setMeta("pointer", true); }
      else if (origin == "key") { tr$1.scrollIntoView(); }
      view.dispatch(tr$1);
    }
    return
  }

  var $before = view.state.doc.resolve(from);
  var shared = $before.sharedDepth(to);
  from = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);

  var sel = view.state.selection;
  var parse = parseBetween(view, from, to);
  // Chrome sometimes leaves the cursor before the inserted text when
  // composing after a cursor wrapper. This moves it forward.
  if (result.chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {
    var text = view.cursorWrapper.deco.type.toDOM.nextSibling;
    var size = text && text.nodeValue ? text.nodeValue.length : 1;
    parse.sel = {anchor: parse.sel.anchor + size, head: parse.sel.anchor + size};
  }

  var doc = view.state.doc, compare = doc.slice(parse.from, parse.to);
  var preferredPos, preferredSide;
  // Prefer anchoring to end when Backspace is pressed
  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.lastKeyCode = null;

  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if (!change) {
    if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&
        !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = {start: sel.from, endA: sel.to, endB: sel.to};
    } else if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) &&
               addedNodes.some(function (n) { return n.nodeName == "DIV" || n.nodeName == "P"; }) &&
               view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); })) {
      view.lastIOSEnter = 0;
      return
    } else {
      if (parse.sel) {
        var sel$1 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel$1 && !sel$1.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel$1)); }
      }
      return
    }
  }
  view.domChangeCount++;
  // Handle the case where overwriting a selection by typing matches
  // the start or end of the selected content, creating a change
  // that's smaller than what was actually overwritten.
  if (view.state.selection.from < view.state.selection.to &&
      change.start == change.endB &&
      view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {
      change.endB += (view.state.selection.to - change.endA);
      change.endA = view.state.selection.to;
    }
  }

  // IE11 will insert a non-breaking space _ahead_ of the space after
  // the cursor space when adding a space before another space. When
  // that happened, adjust the change to cover the space instead.
  if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 &&
      change.endA == change.start && change.start > parse.from &&
      parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \u00a0") {
    change.start--;
    change.endA--;
    change.endB--;
  }

  var $from = parse.doc.resolveNoCache(change.start - parse.from);
  var $to = parse.doc.resolveNoCache(change.endB - parse.from);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
  var nextSel;
  // If this looks like the effect of pressing Enter (or was recorded
  // as being an iOS enter press), just dispatch an Enter key instead.
  if (((result.ios && view.lastIOSEnter > Date.now() - 225 &&
        (!inlineChange || addedNodes.some(function (n) { return n.nodeName == "DIV" || n.nodeName == "P"; }))) ||
       (!inlineChange && $from.pos < parse.doc.content.size &&
        (nextSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&
        nextSel.head == $to.pos)) &&
      view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); })) {
    view.lastIOSEnter = 0;
    return
  }
  // Same for backspace
  if (view.state.selection.anchor > change.start &&
      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&
      view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(8, "Backspace")); })) {
    if (result.android && result.chrome) { view.domObserver.suppressSelectionUpdates(); } // #820
    return
  }

  // Chrome Android will occasionally, during composition, delete the
  // entire composition and then immediately insert it again. This is
  // used to detect that situation.
  if (result.chrome && result.android && change.toB == change.from)
    { view.lastAndroidDelete = Date.now(); }

  // This tries to detect Android virtual keyboard
  // enter-and-pick-suggestion action. That sometimes (see issue
  // #1059) first fires a DOM mutation, before moving the selection to
  // the newly created block. And then, because ProseMirror cleans up
  // the DOM selection, it gives up moving the selection entirely,
  // leaving the cursor in the wrong place. When that happens, we drop
  // the new paragraph from the initial change, and fire a simulated
  // enter key afterwards.
  if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&
      parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(function () {
      view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); });
    }, 20);
  }

  var chFrom = change.start, chTo = change.endA;

  var tr, storedMarks, markChange, $from1;
  if (inlineChange) {
    if ($from.pos == $to.pos) { // Deletion
      // IE11 sometimes weirdly moves the DOM selection around after
      // backspacing out the first element in a textblock
      if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function () { return selectionToDOM(view); }, 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
    } else if ( // Adding or removing a mark
      change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&
      (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),
                                 $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))
    ) {
      tr = view.state.tr;
      if (markChange.type == "add") { tr.addMark(chFrom, chTo, markChange.mark); }
      else { tr.removeMark(chFrom, chTo, markChange.mark); }
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      // Both positions in the same text node -- simply insert text
      var text$1 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function (f) { return f(view, chFrom, chTo, text$1); })) { return }
      tr = view.state.tr.insertText(text$1, chFrom, chTo);
    }
  }

  if (!tr)
    { tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from)); }
  if (parse.sel) {
    var sel$2 = resolveSelection(view, tr.doc, parse.sel);
    // Chrome Android will sometimes, during composition, report the
    // selection in the wrong place. If it looks like that is
    // happening, don't update the selection.
    // Edge just doesn't move the cursor forward when you start typing
    // in an empty block or between br nodes.
    if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty &&
                 (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) &&
                 (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) ||
                 result.ie && sel$2.empty && sel$2.head == chFrom))
      { tr.setSelection(sel$2); }
  }
  if (storedMarks) { tr.ensureMarks(storedMarks); }
  view.dispatch(tr.scrollIntoView());
}

function resolveSelection(view, doc, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) { return null }
  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head))
}

// : (Fragment, Fragment) → ?{mark: Mark, type: string}
// Given two same-length, non-empty fragments of inline content,
// determine whether the first could be created from the second by
// removing or adding a single mark type.
function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  var added = curMarks, removed = prevMarks, type, mark, update;
  for (var i = 0; i < prevMarks.length; i++) { added = prevMarks[i].removeFromSet(added); }
  for (var i$1 = 0; i$1 < curMarks.length; i$1++) { removed = curMarks[i$1].removeFromSet(removed); }
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = function (node) { return node.mark(mark.addToSet(node.marks)); };
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = function (node) { return node.mark(mark.removeFromSet(node.marks)); };
  } else {
    return null
  }
  var updated = [];
  for (var i$2 = 0; i$2 < prev.childCount; i$2++) { updated.push(update(prev.child(i$2))); }
  if (prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(updated).eq(cur)) { return {mark: mark, type: type} }
}

function looksLikeJoin(old, start, end, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock ||
      // The content must have shrunk
      end - start <= $newEnd.pos - $newStart.pos ||
      // newEnd must point directly at or after the end of the block that newStart points into
      skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
    { return false }

  var $start = old.resolve(start);
  // Start must be at the end of a block
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    { return false }
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  // The next textblock must start before end and end near it
  if (!$next.parent.isTextblock || $next.pos > end ||
      skipClosingAndOpening($next, true, false) < end)
    { return false }

  // The fragments after the join point must match
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)
}

function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end
}

function findDiff(a, b, pos, preferredPos, preferredSide) {
  var start = a.findDiffStart(b, pos);
  if (start == null) { return null }
  var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);
  var endA = ref.a;
  var endB = ref.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a.size < b.size) {
    var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    var move$1 = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move$1;
    endA = start + (endA - endB);
    endB = start;
  }
  return {start: start, endA: endA, endB: endB}
}

function serializeForClipboard(view, slice) {
  var context = [];
  var content = slice.content;
  var openStart = slice.openStart;
  var openEnd = slice.openEnd;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }

  var serializer = view.someProp("clipboardSerializer") || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.fromSchema(view.state.schema);
  var doc = detachedDoc(), wrap = doc.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, {document: doc}));

  var firstChild = wrap.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i = needsWrap.length - 1; i >= 0; i--) {
      var wrapper = doc.createElement(needsWrap[i]);
      while (wrap.firstChild) { wrapper.appendChild(wrap.firstChild); }
      wrap.appendChild(wrapper);
      if (needsWrap[i] != "tbody") {
        openStart++;
        openEnd++;
      }
    }
    firstChild = wrap.firstChild;
  }

  if (firstChild && firstChild.nodeType == 1)
    { firstChild.setAttribute("data-pm-slice", (openStart + " " + openEnd + " " + (JSON.stringify(context)))); }

  var text = view.someProp("clipboardTextSerializer", function (f) { return f(slice); }) ||
      slice.content.textBetween(0, slice.content.size, "\n\n");

  return {dom: wrap, text: text}
}

// : (EditorView, string, string, ?bool, ResolvedPos) → ?Slice
// Read a slice of content from the clipboard (or drop data).
function parseFromClipboard(view, text, html, plainText, $context) {
  var dom, inCode = $context.parent.type.spec.code, slice;
  if (!html && !text) { return null }
  var asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", function (f) { text = f(text, inCode || plainText); });
    if (inCode) { return text ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty }
    var parsed = view.someProp("clipboardTextParser", function (f) { return f(text, $context, plainText); });
    if (parsed) {
      slice = parsed;
    } else {
      var marks = $context.marks();
      var ref = view.state;
      var schema = ref.schema;
      var serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach(function (block) {
        var p = dom.appendChild(document.createElement("p"));
        if (block) { p.appendChild(serializer.serializeNode(schema.text(block, marks))); }
      });
    }
  } else {
    view.someProp("transformPastedHTML", function (f) { html = f(html); });
    dom = readHTML(html);
    if (result.webkit) { restoreReplacedSpaces(dom); }
  }

  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (!slice) {
    var parser = view.someProp("clipboardParser") || view.someProp("domParser") || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(view.state.schema);
    slice = parser.parseSlice(dom, {preserveWhitespace: !!(asText || sliceData), context: $context});
  }
  if (sliceData) {
    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[3]);
  } else { // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
    slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);
    if (slice.openStart || slice.openEnd) {
      var openStart = 0, openEnd = 0;
      for (var node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating;
           openStart++, node = node.firstChild) {}
      for (var node$1 = slice.content.lastChild; openEnd < slice.openEnd && !node$1.type.spec.isolating;
           openEnd++, node$1 = node$1.lastChild) {}
      slice = closeSlice(slice, openStart, openEnd);
    }
  }

  view.someProp("transformPasted", function (f) { slice = f(slice); });
  return slice
}

// Takes a slice parsed with parseSlice, which means there hasn't been
// any content-expression checking done on the top nodes, tries to
// find a parent node in the current context that might fit the nodes,
// and if successful, rebuilds the slice so that it fits into that parent.
//
// This addresses the problem that Transform.replace expects a
// coherent slice, and will fail to place a set of siblings that don't
// fit anywhere in the schema.
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) { return fragment }
  var loop = function ( d ) {
    var parent = $context.node(d);
    var match = parent.contentMatchAt($context.index(d));
    var lastWrap = (void 0), result = [];
    fragment.forEach(function (node) {
      if (!result) { return }
      var wrap = match.findWrapping(node.type), inLast;
      if (!wrap) { return result = null }
      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length) { result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length); }
        var wrapped = withWrappers(node, wrap);
        result.push(wrapped);
        match = match.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap;
      }
    });
    if (result) { return { v: prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(result) } }
  };

  for (var d = $context.depth; d >= 0; d--) {
    var returned = loop( d );

    if ( returned ) return returned.v;
  }
  return fragment
}

function withWrappers(node, wrap, from) {
  if ( from === void 0 ) from = 0;

  for (var i = wrap.length - 1; i >= from; i--)
    { node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node)); }
  return node
}

// Used to group adjacent nodes wrapped in similar parents by
// normalizeSiblings into the same parent node
function addToSibling(wrap, lastWrap, node, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner) { return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner)) }
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))
      { return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(withWrappers(node, wrap, depth + 1)))) }
  }
}

function closeRight(node, depth) {
  if (depth == 0) { return node }
  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty, true);
  return node.copy(fragment.append(fill))
}

function closeRange(fragment, side, from, to, depth, openEnd) {
  var node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (depth < to - 1) { inner = closeRange(inner, side, from, to, depth + 1, openEnd); }
  if (depth >= from)
    { inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner)
      : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty, true)); }
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner))
}

function closeSlice(slice, openStart, openEnd) {
  if (openStart < slice.openStart)
    { slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd); }
  if (openEnd < slice.openEnd)
    { slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd); }
  return slice
}

// Trick from jQuery -- some elements must be wrapped in other
// elements for innerHTML to work. I.e. if you do `div.innerHTML =
// "<td>..</td>"` the table cells are ignored.
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};

var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"))
}

function readHTML(html) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas) { html = html.slice(metas[0].length); }
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])
    { html = wrap.map(function (n) { return "<" + n + ">"; }).join("") + html + wrap.map(function (n) { return "</" + n + ">"; }).reverse().join(""); }
  elt.innerHTML = html;
  if (wrap) { for (var i = 0; i < wrap.length; i++) { elt = elt.querySelector(wrap[i]) || elt; } }
  return elt
}

// Webkit browsers do some hard-to-predict replacement of regular
// spaces with non-breaking spaces when putting content on the
// clipboard. This tries to convert such non-breaking spaces (which
// will be wrapped in a plain span on Chrome, a span with class
// Apple-converted-space on Safari) back to regular spaces.
function restoreReplacedSpaces(dom) {
  var nodes = dom.querySelectorAll(result.chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\u00a0" && node.parentNode)
      { node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node); }
  }
}

function addContext(slice, context) {
  if (!slice.size) { return slice }
  var schema = slice.content.firstChild.type.schema, array;
  try { array = JSON.parse(context); }
  catch(e) { return slice }
  var content = slice.content;
  var openStart = slice.openStart;
  var openEnd = slice.openEnd;
  for (var i = array.length - 2; i >= 0; i -= 2) {
    var type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs()) { break }
    content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(type.create(array[i + 1], content));
    openStart++; openEnd++;
  }
  return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, openStart, openEnd)
}

var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified
var useCharData = result.ie && result.ie_version <= 11;

var SelectionState = function SelectionState() {
  this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
};

SelectionState.prototype.set = function set (sel) {
  this.anchorNode = sel.anchorNode; this.anchorOffset = sel.anchorOffset;
  this.focusNode = sel.focusNode; this.focusOffset = sel.focusOffset;
};

SelectionState.prototype.eq = function eq (sel) {
  return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&
    sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset
};

var DOMObserver = function DOMObserver(view, handleDOMChange) {
  var this$1 = this;

  this.view = view;
  this.handleDOMChange = handleDOMChange;
  this.queue = [];
  this.flushingSoon = -1;
  this.observer = window.MutationObserver &&
    new window.MutationObserver(function (mutations) {
      for (var i = 0; i < mutations.length; i++) { this$1.queue.push(mutations[i]); }
      // IE11 will sometimes (on backspacing out a single character
      // text node after a BR node) call the observer callback
      // before actually updating the DOM, which will cause
      // ProseMirror to miss the change (see #930)
      if (result.ie && result.ie_version <= 11 && mutations.some(
        function (m) { return m.type == "childList" && m.removedNodes.length ||
             m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length; }))
        { this$1.flushSoon(); }
      else
        { this$1.flush(); }
    });
  this.currentSelection = new SelectionState;
  if (useCharData) {
    this.onCharData = function (e) {
      this$1.queue.push({target: e.target, type: "characterData", oldValue: e.prevValue});
      this$1.flushSoon();
    };
  }
  this.onSelectionChange = this.onSelectionChange.bind(this);
  this.suppressingSelectionUpdates = false;
};

DOMObserver.prototype.flushSoon = function flushSoon () {
    var this$1 = this;

  if (this.flushingSoon < 0)
    { this.flushingSoon = window.setTimeout(function () { this$1.flushingSoon = -1; this$1.flush(); }, 20); }
};

DOMObserver.prototype.forceFlush = function forceFlush () {
  if (this.flushingSoon > -1) {
    window.clearTimeout(this.flushingSoon);
    this.flushingSoon = -1;
    this.flush();
  }
};

DOMObserver.prototype.start = function start () {
  if (this.observer)
    { this.observer.observe(this.view.dom, observeOptions); }
  if (useCharData)
    { this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData); }
  this.connectSelection();
};

DOMObserver.prototype.stop = function stop () {
    var this$1 = this;

  if (this.observer) {
    var take = this.observer.takeRecords();
    if (take.length) {
      for (var i = 0; i < take.length; i++) { this.queue.push(take[i]); }
      window.setTimeout(function () { return this$1.flush(); }, 20);
    }
    this.observer.disconnect();
  }
  if (useCharData) { this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData); }
  this.disconnectSelection();
};

DOMObserver.prototype.connectSelection = function connectSelection () {
  this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
};

DOMObserver.prototype.disconnectSelection = function disconnectSelection () {
  this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
};

DOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates () {
    var this$1 = this;

  this.suppressingSelectionUpdates = true;
  setTimeout(function () { return this$1.suppressingSelectionUpdates = false; }, 50);
};

DOMObserver.prototype.onSelectionChange = function onSelectionChange () {
  if (!hasFocusAndSelection(this.view)) { return }
  if (this.suppressingSelectionUpdates) { return selectionToDOM(this.view) }
  // Deletions on IE11 fire their events in the wrong order, giving
  // us a selection change event before the DOM changes are
  // reported.
  if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {
    var sel = this.view.root.getSelection();
    // Selection.isCollapsed isn't reliable on IE
    if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      { return this.flushSoon() }
  }
  this.flush();
};

DOMObserver.prototype.setCurSelection = function setCurSelection () {
  this.currentSelection.set(this.view.root.getSelection());
};

DOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange (sel) {
  if (sel.rangeCount == 0) { return true }
  var container = sel.getRangeAt(0).commonAncestorContainer;
  var desc = this.view.docView.nearestDesc(container);
  if (desc && desc.ignoreMutation({type: "selection", target: container.nodeType == 3 ? container.parentNode : container})) {
    this.setCurSelection();
    return true
  }
};

DOMObserver.prototype.flush = function flush () {
  if (!this.view.docView || this.flushingSoon > -1) { return }
  var mutations = this.observer ? this.observer.takeRecords() : [];
  if (this.queue.length) {
    mutations = this.queue.concat(mutations);
    this.queue.length = 0;
  }

  var sel = this.view.root.getSelection();
  var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);

  var from = -1, to = -1, typeOver = false, added = [];
  if (this.view.editable) {
    for (var i = 0; i < mutations.length; i++) {
      var result$1 = this.registerMutation(mutations[i], added);
      if (result$1) {
        from = from < 0 ? result$1.from : Math.min(result$1.from, from);
        to = to < 0 ? result$1.to : Math.max(result$1.to, to);
        if (result$1.typeOver) { typeOver = true; }
      }
    }
  }

  if (result.gecko && added.length > 1) {
    var brs = added.filter(function (n) { return n.nodeName == "BR"; });
    if (brs.length == 2) {
      var a = brs[0];
        var b = brs[1];
      if (a.parentNode && a.parentNode.parentNode == b.parentNode) { b.remove(); }
      else { a.remove(); }
    }
  }

  if (from > -1 || newSel) {
    if (from > -1) {
      this.view.docView.markDirty(from, to);
      checkCSS(this.view);
    }
    this.handleDOMChange(from, to, typeOver, added);
    if (this.view.docView.dirty) { this.view.updateState(this.view.state); }
    else if (!this.currentSelection.eq(sel)) { selectionToDOM(this.view); }
    this.currentSelection.set(sel);
  }
};

DOMObserver.prototype.registerMutation = function registerMutation (mut, added) {
  // Ignore mutations inside nodes that were already noted as inserted
  if (added.indexOf(mut.target) > -1) { return null }
  var desc = this.view.docView.nearestDesc(mut.target);
  if (mut.type == "attributes" &&
      (desc == this.view.docView || mut.attributeName == "contenteditable" ||
       // Firefox sometimes fires spurious events for null/empty styles
       (mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))))
    { return null }
  if (!desc || desc.ignoreMutation(mut)) { return null }

  if (mut.type == "childList") {
    for (var i = 0; i < mut.addedNodes.length; i++) { added.push(mut.addedNodes[i]); }
    if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
      { return {from: desc.posBefore, to: desc.posAfter} }
    var prev = mut.previousSibling, next = mut.nextSibling;
    if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {
      // IE11 gives us incorrect next/prev siblings for some
      // insertions, so if there are added nodes, recompute those
      for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {
        var ref = mut.addedNodes[i$1];
          var previousSibling = ref.previousSibling;
          var nextSibling = ref.nextSibling;
        if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) { prev = previousSibling; }
        if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) { next = nextSibling; }
      }
    }
    var fromOffset = prev && prev.parentNode == mut.target
        ? domIndex(prev) + 1 : 0;
    var from = desc.localPosFromDOM(mut.target, fromOffset, -1);
    var toOffset = next && next.parentNode == mut.target
        ? domIndex(next) : mut.target.childNodes.length;
    var to = desc.localPosFromDOM(mut.target, toOffset, 1);
    return {from: from, to: to}
  } else if (mut.type == "attributes") {
    return {from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border}
  } else { // "characterData"
    return {
      from: desc.posAtStart,
      to: desc.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: mut.target.nodeValue == mut.oldValue
    }
  }
};

var cssChecked = false;

function checkCSS(view) {
  if (cssChecked) { return }
  cssChecked = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal")
    { console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."); }
}

// A collection of DOM events that occur within the editor, and callback functions
// to invoke when the event fires.
var handlers = {}, editHandlers = {};

function initInput(view) {
  view.shiftKey = false;
  view.mouseDown = null;
  view.lastKeyCode = null;
  view.lastKeyCodeTime = 0;
  view.lastClick = {time: 0, x: 0, y: 0, type: ""};
  view.lastSelectionOrigin = null;
  view.lastSelectionTime = 0;

  view.lastIOSEnter = 0;
  view.lastIOSEnterFallbackTimeout = null;
  view.lastAndroidDelete = 0;

  view.composing = false;
  view.composingTimeout = null;
  view.compositionNodes = [];
  view.compositionEndedAt = -2e8;

  view.domObserver = new DOMObserver(view, function (from, to, typeOver, added) { return readDOMChange(view, from, to, typeOver, added); });
  view.domObserver.start();
  // Used by hacks like the beforeinput handler to check whether anything happened in the DOM
  view.domChangeCount = 0;

  view.eventHandlers = Object.create(null);
  var loop = function ( event ) {
    var handler = handlers[event];
    view.dom.addEventListener(event, view.eventHandlers[event] = function (event) {
      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&
          (view.editable || !(event.type in editHandlers)))
        { handler(view, event); }
    });
  };

  for (var event in handlers) loop( event );
  // On Safari, for reasons beyond my understanding, adding an input
  // event handler makes an issue where the composition vanishes when
  // you press enter go away.
  if (result.safari) { view.dom.addEventListener("input", function () { return null; }); }

  ensureListeners(view);
}

function setSelectionOrigin(view, origin) {
  view.lastSelectionOrigin = origin;
  view.lastSelectionTime = Date.now();
}

function destroyInput(view) {
  view.domObserver.stop();
  for (var type in view.eventHandlers)
    { view.dom.removeEventListener(type, view.eventHandlers[type]); }
  clearTimeout(view.composingTimeout);
  clearTimeout(view.lastIOSEnterFallbackTimeout);
}

function ensureListeners(view) {
  view.someProp("handleDOMEvents", function (currentHandlers) {
    for (var type in currentHandlers) { if (!view.eventHandlers[type])
      { view.dom.addEventListener(type, view.eventHandlers[type] = function (event) { return runCustomHandler(view, event); }); } }
  });
}

function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function (handlers) {
    var handler = handlers[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false
  })
}

function eventBelongsToView(view, event) {
  if (!event.bubbles) { return true }
  if (event.defaultPrevented) { return false }
  for (var node = event.target; node != view.dom; node = node.parentNode)
    { if (!node || node.nodeType == 11 ||
        (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))
      { return false } }
  return true
}

function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] &&
      (view.editable || !(event.type in editHandlers)))
    { handlers[event.type](view, event); }
}

editHandlers.keydown = function (view, event) {
  view.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event)) { return }
  if (event.keyCode != 229) { view.domObserver.forceFlush(); }
  view.lastKeyCode = event.keyCode;
  view.lastKeyCodeTime = Date.now();
  // On iOS, if we preventDefault enter key presses, the virtual
  // keyboard gets confused. So the hack here is to set a flag that
  // makes the DOM change code recognize that what just happens should
  // be replaced by whatever the Enter key handlers do.
  if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now = Date.now();
    view.lastIOSEnter = now;
    view.lastIOSEnterFallbackTimeout = setTimeout(function () {
      if (view.lastIOSEnter == now) {
        view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); });
        view.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function (f) { return f(view, event); }) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};

editHandlers.keyup = function (view, e) {
  if (e.keyCode == 16) { view.shiftKey = false; }
};

editHandlers.keypress = function (view, event) {
  if (inOrNearComposition(view, event) || !event.charCode ||
      event.ctrlKey && !event.altKey || result.mac && event.metaKey) { return }

  if (view.someProp("handleKeyPress", function (f) { return f(view, event); })) {
    event.preventDefault();
    return
  }

  var sel = view.state.selection;
  if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", function (f) { return f(view, sel.$from.pos, sel.$to.pos, text); }))
      { view.dispatch(view.state.tr.insertText(text).scrollIntoView()); }
    event.preventDefault();
  }
};

function eventCoords(event) { return {left: event.clientX, top: event.clientY} }

function isNear(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100
}

function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) { return false }
  var $pos = view.state.doc.resolve(inside);
  var loop = function ( i ) {
    if (view.someProp(propName, function (f) { return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)
                                                    : f(view, pos, $pos.node(i), $pos.before(i), event, false); }))
      { return { v: true } }
  };

  for (var i = $pos.depth + 1; i > 0; i--) {
    var returned = loop( i );

    if ( returned ) return returned.v;
  }
  return false
}

function updateSelection(view, selection, origin) {
  if (!view.focused) { view.focus(); }
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") { tr.setMeta("pointer", true); }
  view.dispatch(tr);
}

function selectClickedLeaf(view, inside) {
  if (inside == -1) { return false }
  var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(node)) {
    updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection($pos), "pointer");
    return true
  }
  return false
}

function selectClickedNode(view, inside) {
  if (inside == -1) { return false }
  var sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection) { selectedNode = sel.node; }

  var $pos = view.state.doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 &&
          i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        { selectAt = $pos.before(sel.$from.depth); }
      else
        { selectAt = $pos.before(i); }
      break
    }
  }

  if (selectAt != null) {
    updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true
  } else {
    return false
  }
}

function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) ||
    view.someProp("handleClick", function (f) { return f(view, pos, event); }) ||
    (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside))
}

function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) ||
    view.someProp("handleDoubleClick", function (f) { return f(view, pos, event); })
}

function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) ||
    view.someProp("handleTripleClick", function (f) { return f(view, pos, event); }) ||
    defaultTripleClick(view, inside, event)
}

function defaultTripleClick(view, inside, event) {
  if (event.button != 0) { return false }
  var doc = view.state.doc;
  if (inside == -1) {
    if (doc.inlineContent) {
      updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, 0, doc.content.size), "pointer");
      return true
    }
    return false
  }

  var $pos = doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    var nodePos = $pos.before(i);
    if (node.inlineContent)
      { updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer"); }
    else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(node))
      { updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(doc, nodePos), "pointer"); }
    else
      { continue }
    return true
  }
}

function forceDOMFlush(view) {
  return endComposition(view)
}

var selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";

handlers.mousedown = function (view, event) {
  view.shiftKey = event.shiftKey;
  var flushed = forceDOMFlush(view);
  var now = Date.now(), type = "singleClick";
  if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
    if (view.lastClick.type == "singleClick") { type = "doubleClick"; }
    else if (view.lastClick.type == "doubleClick") { type = "tripleClick"; }
  }
  view.lastClick = {time: now, x: event.clientX, y: event.clientY, type: type};

  var pos = view.posAtCoords(eventCoords(event));
  if (!pos) { return }

  if (type == "singleClick") {
    if (view.mouseDown) { view.mouseDown.done(); }
    view.mouseDown = new MouseDown(view, pos, event, flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};

var MouseDown = function MouseDown(view, pos, event, flushed) {
  var this$1 = this;

  this.view = view;
  this.startDoc = view.state.doc;
  this.pos = pos;
  this.event = event;
  this.flushed = flushed;
  this.selectNode = event[selectNodeModifier];
  this.allowDefault = event.shiftKey;
  this.delayedSelectionSync = false;

  var targetNode, targetPos;
  if (pos.inside > -1) {
    targetNode = view.state.doc.nodeAt(pos.inside);
    targetPos = pos.inside;
  } else {
    var $pos = view.state.doc.resolve(pos.pos);
    targetNode = $pos.parent;
    targetPos = $pos.depth ? $pos.before() : 0;
  }

  this.mightDrag = null;

  var target = flushed ? null : event.target;
  var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
  this.target = targetDesc ? targetDesc.dom : null;

  var ref = view.state;
  var selection = ref.selection;
  if (event.button == 0 &&
      targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||
      selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && selection.from <= targetPos && selection.to > targetPos)
    { this.mightDrag = {node: targetNode,
                      pos: targetPos,
                      addAttr: this.target && !this.target.draggable,
                      setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")}; }

  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) { this.target.draggable = true; }
    if (this.mightDrag.setUneditable)
      { setTimeout(function () {
        if (this$1.view.mouseDown == this$1) { this$1.target.setAttribute("contentEditable", "false"); }
      }, 20); }
    this.view.domObserver.start();
  }

  view.root.addEventListener("mouseup", this.up = this.up.bind(this));
  view.root.addEventListener("mousemove", this.move = this.move.bind(this));
  setSelectionOrigin(view, "pointer");
};

MouseDown.prototype.done = function done () {
    var this$1 = this;

  this.view.root.removeEventListener("mouseup", this.up);
  this.view.root.removeEventListener("mousemove", this.move);
  if (this.mightDrag && this.target) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) { this.target.removeAttribute("draggable"); }
    if (this.mightDrag.setUneditable) { this.target.removeAttribute("contentEditable"); }
    this.view.domObserver.start();
  }
  if (this.delayedSelectionSync) { setTimeout(function () { return selectionToDOM(this$1.view); }); }
  this.view.mouseDown = null;
};

MouseDown.prototype.up = function up (event) {
  this.done();

  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))
    { return }

  var pos = this.pos;
  if (this.view.state.doc != this.startDoc) { pos = this.view.posAtCoords(eventCoords(event)); }

  if (this.allowDefault || !pos) {
    setSelectionOrigin(this.view, "pointer");
  } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
    event.preventDefault();
  } else if (event.button == 0 &&
             (this.flushed ||
              // Safari ignores clicks on draggable elements
              (result.safari && this.mightDrag && !this.mightDrag.node.isAtom) ||
              // Chrome will sometimes treat a node selection as a
              // cursor, but still report that the node is selected
              // when asked through getSelection. You'll then get a
              // situation where clicking at the point where that
              // (hidden) cursor is doesn't change the selection, and
              // thus doesn't get a reaction from ProseMirror. This
              // works around that.
              (result.chrome && !(this.view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) &&
               Math.min(Math.abs(pos.pos - this.view.state.selection.from),
                        Math.abs(pos.pos - this.view.state.selection.to)) <= 2))) {
    updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
    event.preventDefault();
  } else {
    setSelectionOrigin(this.view, "pointer");
  }
};

MouseDown.prototype.move = function move (event) {
  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||
                             Math.abs(this.event.y - event.clientY) > 4))
    { this.allowDefault = true; }
  setSelectionOrigin(this.view, "pointer");
  if (event.buttons == 0) { this.done(); }
};

handlers.touchdown = function (view) {
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};

handlers.contextmenu = function (view) { return forceDOMFlush(view); };

function inOrNearComposition(view, event) {
  if (view.composing) { return true }
  // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
  // On Japanese input method editors (IMEs), the Enter key is used to confirm character
  // selection. On Safari, when Enter is pressed, compositionend and keydown events are
  // emitted. The keydown event triggers newline insertion, which we don't want.
  // This method returns true if the keydown event should be ignored.
  // We only ignore it once, as pressing Enter a second time *should* insert a newline.
  // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
  // This guards against the case where compositionend is triggered without the keyboard
  // (e.g. character confirmation may be done with the mouse), and keydown is triggered
  // afterwards- we wouldn't want to ignore the keydown event in this case.
  if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
    view.compositionEndedAt = -2e8;
    return true
  }
  return false
}

// Drop active composition after 5 seconds of inactivity on Android
var timeoutComposition = result.android ? 5000 : -1;

editHandlers.compositionstart = editHandlers.compositionupdate = function (view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state;
    var $pos = state.selection.$from;
    if (state.selection.empty &&
        (state.storedMarks ||
         (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function (m) { return m.type.spec.inclusive === false; })))) {
      // Need to wrap the cursor in mark nodes different from the ones in the DOM context
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      // In firefox, if the cursor is after but outside a marked node,
      // the inserted text won't inherit the marks. So this moves it
      // inside if necessary.
      if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.root.getSelection();
        for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {
          var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
          if (!before) { break }
          if (before.nodeType == 3) {
            sel.collapse(before, before.nodeValue.length);
            break
          } else {
            node = before;
            offset = -1;
          }
        }
      }
    }
    view.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};

editHandlers.compositionend = function (view, event) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view, 20);
  }
};

function scheduleComposeEnd(view, delay) {
  clearTimeout(view.composingTimeout);
  if (delay > -1) { view.composingTimeout = setTimeout(function () { return endComposition(view); }, delay); }
}

function clearComposition(view) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.compositionNodes.length > 0) { view.compositionNodes.pop().markParentsDirty(); }
}

function timestampFromCustomEvent() {
  var event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp
}

function endComposition(view, forceUpdate) {
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel)); }
    else { view.updateState(view.state); }
    return true
  }
  return false
}

function captureCopy(view, dom) {
  // The extra wrapper is somehow necessary on IE/Edge to prevent the
  // content from being mangled when it is put onto the clipboard
  if (!view.dom.parentNode) { return }
  var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  // Done because IE will fire a selectionchange moving the selection
  // to its start when removeAllRanges is called and the editor still
  // has focus (which will mess up the editor's selection state).
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function () {
    if (wrap.parentNode) { wrap.parentNode.removeChild(wrap); }
    view.focus();
  }, 50);
}

// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
var brokenClipboardAPI = (result.ie && result.ie_version < 15) ||
      (result.ios && result.webkit_version < 604);

handlers.copy = editHandlers.cut = function (view, e) {
  var sel = view.state.selection, cut = e.type == "cut";
  if (sel.empty) { return }

  // IE and Edge's clipboard interface is completely broken
  var data = brokenClipboardAPI ? null : e.clipboardData;
  var slice = sel.content();
  var ref = serializeForClipboard(view, slice);
  var dom = ref.dom;
  var text = ref.text;
  if (data) {
    e.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut) { view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")); }
};

function sliceSingleNode(slice) {
  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null
}

function capturePaste(view, e) {
  if (!view.dom.parentNode) { return }
  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) { target.contentEditable = "true"; }
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function () {
    view.focus();
    if (target.parentNode) { target.parentNode.removeChild(target); }
    if (plainText) { doPaste(view, target.value, null, e); }
    else { doPaste(view, target.textContent, target.innerHTML, e); }
  }, 50);
}

function doPaste(view, text, html, e) {
  var slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", function (f) { return f(view, e, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty); })) { return true }
  if (!slice) { return false }

  var singleNode = sliceSingleNode(slice);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true
}

editHandlers.paste = function (view, e) {
  var data = brokenClipboardAPI ? null : e.clipboardData;
  if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), e)) { e.preventDefault(); }
  else { capturePaste(view, e); }
};

var Dragging = function Dragging(slice, move) {
  this.slice = slice;
  this.move = move;
};

var dragCopyModifier = result.mac ? "altKey" : "ctrlKey";

handlers.dragstart = function (view, e) {
  var mouseDown = view.mouseDown;
  if (mouseDown) { mouseDown.done(); }
  if (!e.dataTransfer) { return }

  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords(e));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection ? sel.to - 1: sel.to)) ; else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (e.target && e.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(e.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      { view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, desc.posBefore))); }
  }
  var slice = view.state.selection.content();
  var ref = serializeForClipboard(view, slice);
  var dom = ref.dom;
  var text = ref.text;
  e.dataTransfer.clearData();
  e.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  // See https://github.com/ProseMirror/prosemirror/issues/1156
  e.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI) { e.dataTransfer.setData("text/plain", text); }
  view.dragging = new Dragging(slice, !e[dragCopyModifier]);
};

handlers.dragend = function (view) {
  var dragging = view.dragging;
  window.setTimeout(function () {
    if (view.dragging == dragging)  { view.dragging = null; }
  }, 50);
};

editHandlers.dragover = editHandlers.dragenter = function (_, e) { return e.preventDefault(); };

editHandlers.drop = function (view, e) {
  var dragging = view.dragging;
  view.dragging = null;

  if (!e.dataTransfer) { return }

  var eventPos = view.posAtCoords(eventCoords(e));
  if (!eventPos) { return }
  var $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse) { return }
  var slice = dragging && dragging.slice;
  if (slice) {
    view.someProp("transformPasted", function (f) { slice = f(slice); });
  } else {
    slice = parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"),
                               brokenClipboardAPI ? null : e.dataTransfer.getData("text/html"), false, $mouse);
  }
  var move = dragging && !e[dragCopyModifier];
  if (view.someProp("handleDrop", function (f) { return f(view, e, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty, move); })) {
    e.preventDefault();
    return
  }
  if (!slice) { return }

  e.preventDefault();
  var insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;
  if (insertPos == null) { insertPos = $mouse.pos; }

  var tr = view.state.tr;
  if (move) { tr.deleteSelection(); }

  var pos = tr.mapping.map(insertPos);
  var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode)
    { tr.replaceRangeWith(pos, pos, slice.content.firstChild); }
  else
    { tr.replaceRange(pos, pos, slice); }
  if (tr.doc.eq(beforeInsert)) { return }

  var $pos = tr.doc.resolve(pos);
  if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(slice.content.firstChild) &&
      $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
    tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection($pos));
  } else {
    var end = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function (_from, _to, _newFrom, newTo) { return end = newTo; });
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};

handlers.focus = function (view) {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function () {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection()))
        { selectionToDOM(view); }
    }, 20);
  }
};

handlers.blur = function (view, e) {
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (e.relatedTarget && view.dom.contains(e.relatedTarget))
      { view.domObserver.currentSelection.set({}); }
    view.focused = false;
  }
};

handlers.beforeinput = function (view, event) {
  // We should probably do more with beforeinput events, but support
  // is so spotty that I'm still waiting to see where they are going.

  // Very specific hack to deal with backspace sometimes failing on
  // Chrome Android when after an uneditable node.
  if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
    var domChangeCount = view.domChangeCount;
    setTimeout(function () {
      if (view.domChangeCount != domChangeCount) { return } // Event already had some effect
      // This bug tends to close the virtual keyboard, so we refocus
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(8, "Backspace")); })) { return }
      var ref = view.state.selection;
      var $cursor = ref.$cursor;
      // Crude approximation of backspace behavior when no command handled it
      if ($cursor && $cursor.pos > 0) { view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView()); }
    }, 50);
  }
};

// Make sure all handlers get registered
for (var prop in editHandlers) { handlers[prop] = editHandlers[prop]; }

function compareObjs(a, b) {
  if (a == b) { return true }
  for (var p in a) { if (a[p] !== b[p]) { return false } }
  for (var p$1 in b) { if (!(p$1 in a)) { return false } }
  return true
}

var WidgetType = function WidgetType(toDOM, spec) {
  this.spec = spec || noSpec;
  this.side = this.spec.side || 0;
  this.toDOM = toDOM;
};

WidgetType.prototype.map = function map (mapping, span, offset, oldOffset) {
  var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    var pos = ref.pos;
    var deleted = ref.deleted;
  return deleted ? null : new Decoration(pos - offset, pos - offset, this)
};

WidgetType.prototype.valid = function valid () { return true };

WidgetType.prototype.eq = function eq (other) {
  return this == other ||
    (other instanceof WidgetType &&
     (this.spec.key && this.spec.key == other.spec.key ||
      this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)))
};

var InlineType = function InlineType(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};

InlineType.prototype.map = function map (mapping, span, offset, oldOffset) {
  var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
  var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
  return from >= to ? null : new Decoration(from, to, this)
};

InlineType.prototype.valid = function valid (_, span) { return span.from < span.to };

InlineType.prototype.eq = function eq (other) {
  return this == other ||
    (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&
     compareObjs(this.spec, other.spec))
};

InlineType.is = function is (span) { return span.type instanceof InlineType };

var NodeType = function NodeType(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};

NodeType.prototype.map = function map (mapping, span, offset, oldOffset) {
  var from = mapping.mapResult(span.from + oldOffset, 1);
  if (from.deleted) { return null }
  var to = mapping.mapResult(span.to + oldOffset, -1);
  if (to.deleted || to.pos <= from.pos) { return null }
  return new Decoration(from.pos - offset, to.pos - offset, this)
};

NodeType.prototype.valid = function valid (node, span) {
  var ref = node.content.findIndex(span.from);
    var index = ref.index;
    var offset = ref.offset;
    var child;
  return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to
};

NodeType.prototype.eq = function eq (other) {
  return this == other ||
    (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&
     compareObjs(this.spec, other.spec))
};

// ::- Decoration objects can be provided to the view through the
// [`decorations` prop](#view.EditorProps.decorations). They come in
// several variants—see the static members of this class for details.
var Decoration = function Decoration(from, to, type) {
  // :: number
  // The start position of the decoration.
  this.from = from;
  // :: number
  // The end position. Will be the same as `from` for [widget
  // decorations](#view.Decoration^widget).
  this.to = to;
  this.type = type;
};

var prototypeAccessors$1 = { spec: { configurable: true },inline: { configurable: true } };

Decoration.prototype.copy = function copy (from, to) {
  return new Decoration(from, to, this.type)
};

Decoration.prototype.eq = function eq (other, offset) {
    if ( offset === void 0 ) offset = 0;

  return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to
};

Decoration.prototype.map = function map (mapping, offset, oldOffset) {
  return this.type.map(mapping, this, offset, oldOffset)
};

// :: (number, union<(view: EditorView, getPos: () → number) → dom.Node, dom.Node>, ?Object) → Decoration
// Creates a widget decoration, which is a DOM node that's shown in
// the document at the given position. It is recommended that you
// delay rendering the widget by passing a function that will be
// called when the widget is actually drawn in a view, but you can
// also directly pass a DOM node. `getPos` can be used to find the
// widget's current document position.
//
// spec::- These options are supported:
//
//   side:: ?number
//   Controls which side of the document position this widget is
//   associated with. When negative, it is drawn before a cursor
//   at its position, and content inserted at that position ends
//   up after the widget. When zero (the default) or positive, the
//   widget is drawn after the cursor and content inserted there
//   ends up before the widget.
//
//   When there are multiple widgets at a given position, their
//   `side` values determine the order in which they appear. Those
//   with lower values appear first. The ordering of widgets with
//   the same `side` value is unspecified.
//
//   When `marks` is null, `side` also determines the marks that
//   the widget is wrapped in—those of the node before when
//   negative, those of the node after when positive.
//
//   marks:: ?[Mark]
//   The precise set of marks to draw around the widget.
//
//   stopEvent:: ?(event: dom.Event) → bool
//   Can be used to control which DOM events, when they bubble out
//   of this widget, the editor view should ignore.
//
//   ignoreSelection:: ?bool
//   When set (defaults to false), selection changes inside the
//   widget are ignored, and don't cause ProseMirror to try and
//   re-sync the selection with its selection state.
//
//   key:: ?string
//   When comparing decorations of this type (in order to decide
//   whether it needs to be redrawn), ProseMirror will by default
//   compare the widget DOM node by identity. If you pass a key,
//   that key will be compared instead, which can be useful when
//   you generate decorations on the fly and don't want to store
//   and reuse DOM nodes. Make sure that any widgets with the same
//   key are interchangeable—if widgets differ in, for example,
//   the behavior of some event handler, they should get
//   different keys.
Decoration.widget = function widget (pos, toDOM, spec) {
  return new Decoration(pos, pos, new WidgetType(toDOM, spec))
};

// :: (number, number, DecorationAttrs, ?Object) → Decoration
// Creates an inline decoration, which adds the given attributes to
// each inline node between `from` and `to`.
//
// spec::- These options are recognized:
//
//   inclusiveStart:: ?bool
//   Determines how the left side of the decoration is
//   [mapped](#transform.Position_Mapping) when content is
//   inserted directly at that position. By default, the decoration
//   won't include the new content, but you can set this to `true`
//   to make it inclusive.
//
//   inclusiveEnd:: ?bool
//   Determines how the right side of the decoration is mapped.
//   See
//   [`inclusiveStart`](#view.Decoration^inline^spec.inclusiveStart).
Decoration.inline = function inline (from, to, attrs, spec) {
  return new Decoration(from, to, new InlineType(attrs, spec))
};

// :: (number, number, DecorationAttrs, ?Object) → Decoration
// Creates a node decoration. `from` and `to` should point precisely
// before and after a node in the document. That node, and only that
// node, will receive the given attributes.
//
// spec::-
//
// Optional information to store with the decoration. It
// is also used when comparing decorators for equality.
Decoration.node = function node (from, to, attrs, spec) {
  return new Decoration(from, to, new NodeType(attrs, spec))
};

// :: Object
// The spec provided when creating this decoration. Can be useful
// if you've stored extra information in that object.
prototypeAccessors$1.spec.get = function () { return this.type.spec };

prototypeAccessors$1.inline.get = function () { return this.type instanceof InlineType };

Object.defineProperties( Decoration.prototype, prototypeAccessors$1 );

// DecorationAttrs:: interface
// A set of attributes to add to a decorated node. Most properties
// simply directly correspond to DOM attributes of the same name,
// which will be set to the property's value. These are exceptions:
//
//   class:: ?string
//   A CSS class name or a space-separated set of class names to be
//   _added_ to the classes that the node already had.
//
//   style:: ?string
//   A string of CSS to be _added_ to the node's existing `style` property.
//
//   nodeName:: ?string
//   When non-null, the target node is wrapped in a DOM element of
//   this type (and the other attributes are applied to this element).

var none = [], noSpec = {};

// :: class extends DecorationSource
// A collection of [decorations](#view.Decoration), organized in
// such a way that the drawing algorithm can efficiently use and
// compare them. This is a persistent data structure—it is not
// modified, updates create a new value.
var DecorationSet = function DecorationSet(local, children) {
  this.local = local && local.length ? local : none;
  this.children = children && children.length ? children : none;
};

// :: (Node, [Decoration]) → DecorationSet
// Create a set of decorations, using the structure of the given
// document.
DecorationSet.create = function create (doc, decorations) {
  return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty
};

// :: (?number, ?number, ?(spec: Object) → bool) → [Decoration]
// Find all decorations in this set which touch the given range
// (including decorations that start or end directly at the
// boundaries) and match the given predicate on their spec. When
// `start` and `end` are omitted, all decorations in the set are
// considered. When `predicate` isn't given, all decorations are
// assumed to match.
DecorationSet.prototype.find = function find (start, end, predicate) {
  var result = [];
  this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
  return result
};

DecorationSet.prototype.findInner = function findInner (start, end, result, offset, predicate) {
  for (var i = 0; i < this.local.length; i++) {
    var span = this.local[i];
    if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
      { result.push(span.copy(span.from + offset, span.to + offset)); }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] < end && this.children[i$1 + 1] > start) {
      var childOff = this.children[i$1] + 1;
      this.children[i$1 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
    }
  }
};

// :: (Mapping, Node, ?Object) → DecorationSet
// Map the set of decorations in response to a change in the
// document.
//
// options::- An optional set of options.
//
//   onRemove:: ?(decorationSpec: Object)
//   When given, this function will be called for each decoration
//   that gets dropped as a result of the mapping, passing the
//   spec of that decoration.
DecorationSet.prototype.map = function map (mapping, doc, options) {
  if (this == empty || mapping.maps.length == 0) { return this }
  return this.mapInner(mapping, doc, 0, 0, options || noSpec)
};

DecorationSet.prototype.mapInner = function mapInner (mapping, node, offset, oldOffset, options) {
  var newLocal;
  for (var i = 0; i < this.local.length; i++) {
    var mapped = this.local[i].map(mapping, offset, oldOffset);
    if (mapped && mapped.type.valid(node, mapped)) { (newLocal || (newLocal = [])).push(mapped); }
    else if (options.onRemove) { options.onRemove(this.local[i].spec); }
  }

  if (this.children.length)
    { return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options) }
  else
    { return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty }
};

// :: (Node, [Decoration]) → DecorationSet
// Add the given array of decorations to the ones in the set,
// producing a new set. Needs access to the current document to
// create the appropriate tree structure.
DecorationSet.prototype.add = function add (doc, decorations) {
  if (!decorations.length) { return this }
  if (this == empty) { return DecorationSet.create(doc, decorations) }
  return this.addInner(doc, decorations, 0)
};

DecorationSet.prototype.addInner = function addInner (doc, decorations, offset) {
    var this$1 = this;

  var children, childIndex = 0;
  doc.forEach(function (childNode, childOffset) {
    var baseOffset = childOffset + offset, found;
    if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) { return }

    if (!children) { children = this$1.children.slice(); }
    while (childIndex < children.length && children[childIndex] < childOffset) { childIndex += 3; }
    if (children[childIndex] == childOffset)
      { children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1); }
    else
      { children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec)); }
    childIndex += 3;
  });

  var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
  for (var i = 0; i < local.length; i++) { if (!local[i].type.valid(doc, local[i])) { local.splice(i--, 1); } }

  return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,
                           children || this.children)
};

// :: ([Decoration]) → DecorationSet
// Create a new set that contains the decorations in this set, minus
// the ones in the given array.
DecorationSet.prototype.remove = function remove (decorations) {
  if (decorations.length == 0 || this == empty) { return this }
  return this.removeInner(decorations, 0)
};

DecorationSet.prototype.removeInner = function removeInner (decorations, offset) {
  var children = this.children, local = this.local;
  for (var i = 0; i < children.length; i += 3) {
    var found = (void 0), from = children[i] + offset, to = children[i + 1] + offset;
    for (var j = 0, span = (void 0); j < decorations.length; j++) { if (span = decorations[j]) {
      if (span.from > from && span.to < to) {
        decorations[j] = null
        ;(found || (found = [])).push(span);
      }
    } }
    if (!found) { continue }
    if (children == this.children) { children = this.children.slice(); }
    var removed = children[i + 2].removeInner(found, from + 1);
    if (removed != empty) {
      children[i + 2] = removed;
    } else {
      children.splice(i, 3);
      i -= 3;
    }
  }
  if (local.length) { for (var i$1 = 0, span$1 = (void 0); i$1 < decorations.length; i$1++) { if (span$1 = decorations[i$1]) {
    for (var j$1 = 0; j$1 < local.length; j$1++) { if (local[j$1].eq(span$1, offset)) {
      if (local == this.local) { local = this.local.slice(); }
      local.splice(j$1--, 1);
    } }
  } } }
  if (children == this.children && local == this.local) { return this }
  return local.length || children.length ? new DecorationSet(local, children) : empty
};

DecorationSet.prototype.forChild = function forChild (offset, node) {
  if (this == empty) { return this }
  if (node.isLeaf) { return DecorationSet.empty }

  var child, local;
  for (var i = 0; i < this.children.length; i += 3) { if (this.children[i] >= offset) {
    if (this.children[i] == offset) { child = this.children[i + 2]; }
    break
  } }
  var start = offset + 1, end = start + node.content.size;
  for (var i$1 = 0; i$1 < this.local.length; i$1++) {
    var dec = this.local[i$1];
    if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {
      var from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
      if (from < to) { (local || (local = [])).push(dec.copy(from, to)); }
    }
  }
  if (local) {
    var localSet = new DecorationSet(local.sort(byPos));
    return child ? new DecorationGroup([localSet, child]) : localSet
  }
  return child || empty
};

DecorationSet.prototype.eq = function eq (other) {
  if (this == other) { return true }
  if (!(other instanceof DecorationSet) ||
      this.local.length != other.local.length ||
      this.children.length != other.children.length) { return false }
  for (var i = 0; i < this.local.length; i++)
    { if (!this.local[i].eq(other.local[i])) { return false } }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3)
    { if (this.children[i$1] != other.children[i$1] ||
        this.children[i$1 + 1] != other.children[i$1 + 1] ||
        !this.children[i$1 + 2].eq(other.children[i$1 + 2])) { return false } }
  return true
};

DecorationSet.prototype.locals = function locals (node) {
  return removeOverlap(this.localsInner(node))
};

DecorationSet.prototype.localsInner = function localsInner (node) {
  if (this == empty) { return none }
  if (node.inlineContent || !this.local.some(InlineType.is)) { return this.local }
  var result = [];
  for (var i = 0; i < this.local.length; i++) {
    if (!(this.local[i].type instanceof InlineType))
      { result.push(this.local[i]); }
  }
  return result
};

// DecorationSource:: interface
// An object that can [provide](#view.EditorProps.decorations)
// decorations. Implemented by [`DecorationSet`](#view.DecorationSet),
// and passed to [node views](#view.EditorProps.nodeViews).
//
//   map:: (Mapping, Node) → DecorationSource
//   Map the set of decorations in response to a change in the
//   document.

var empty = new DecorationSet();

// :: DecorationSet
// The empty set of decorations.
DecorationSet.empty = empty;

DecorationSet.removeOverlap = removeOverlap;

// :- An abstraction that allows the code dealing with decorations to
// treat multiple DecorationSet objects as if it were a single object
// with (a subset of) the same interface.
var DecorationGroup = function DecorationGroup(members) {
  this.members = members;
};

DecorationGroup.prototype.map = function map (mapping, doc) {
  var mappedDecos = this.members.map(
    function (member) { return member.map(mapping, doc, noSpec); }
  );
  return DecorationGroup.from(mappedDecos)
};

DecorationGroup.prototype.forChild = function forChild (offset, child) {
  if (child.isLeaf) { return DecorationSet.empty }
  var found = [];
  for (var i = 0; i < this.members.length; i++) {
    var result = this.members[i].forChild(offset, child);
    if (result == empty) { continue }
    if (result instanceof DecorationGroup) { found = found.concat(result.members); }
    else { found.push(result); }
  }
  return DecorationGroup.from(found)
};

DecorationGroup.prototype.eq = function eq (other) {
  if (!(other instanceof DecorationGroup) ||
      other.members.length != this.members.length) { return false }
  for (var i = 0; i < this.members.length; i++)
    { if (!this.members[i].eq(other.members[i])) { return false } }
  return true
};

DecorationGroup.prototype.locals = function locals (node) {
  var result, sorted = true;
  for (var i = 0; i < this.members.length; i++) {
    var locals = this.members[i].localsInner(node);
    if (!locals.length) { continue }
    if (!result) {
      result = locals;
    } else {
      if (sorted) {
        result = result.slice();
        sorted = false;
      }
      for (var j = 0; j < locals.length; j++) { result.push(locals[j]); }
    }
  }
  return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none
};

// : ([DecorationSet]) → union<DecorationSet, DecorationGroup>
// Create a group for the given array of decoration sets, or return
// a single set when possible.
DecorationGroup.from = function from (members) {
  switch (members.length) {
    case 0: return empty
    case 1: return members[0]
    default: return new DecorationGroup(members)
  }
};

function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
  var children = oldChildren.slice();

  // Mark the children that are directly touched by changes, and
  // move those that are after the changes.
  var shift = function (oldStart, oldEnd, newStart, newEnd) {
    for (var i = 0; i < children.length; i += 3) {
      var end = children[i + 1], dSize = (void 0);
      if (end == -1 || oldStart > end + oldOffset) { continue }
      if (oldEnd >= children[i] + oldOffset) {
        children[i + 1] = -1;
      } else if (newStart >= offset && (dSize = (newEnd - newStart) - (oldEnd - oldStart))) {
        children[i] += dSize;
        children[i + 1] += dSize;
      }
    }
  };
  for (var i = 0; i < mapping.maps.length; i++) { mapping.maps[i].forEach(shift); }

  // Find the child nodes that still correspond to a single node,
  // recursively call mapInner on them and update their positions.
  var mustRebuild = false;
  for (var i$1 = 0; i$1 < children.length; i$1 += 3) { if (children[i$1 + 1] == -1) { // Touched nodes
    var from = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from - offset;
    if (fromLocal < 0 || fromLocal >= node.content.size) {
      mustRebuild = true;
      continue
    }
    // Must read oldChildren because children was tagged with -1
    var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset;
    var ref = node.content.findIndex(fromLocal);
    var index = ref.index;
    var childOffset = ref.offset;
    var childNode = node.maybeChild(index);
    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
      var mapped = children[i$1 + 2].mapInner(mapping, childNode, from + 1, oldChildren[i$1] + oldOffset + 1, options);
      if (mapped != empty) {
        children[i$1] = fromLocal;
        children[i$1 + 1] = toLocal;
        children[i$1 + 2] = mapped;
      } else {
        children[i$1 + 1] = -2;
        mustRebuild = true;
      }
    } else {
      mustRebuild = true;
    }
  } }

  // Remaining children must be collected and rebuilt into the appropriate structure
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping,
                                                       offset, oldOffset, options);
    var built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (var i$2 = 0; i$2 < children.length; i$2 += 3) { if (children[i$2 + 1] < 0) {
      children.splice(i$2, 3);
      i$2 -= 3;
    } }
    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
      var from$1 = built.children[i$3];
      while (j < children.length && children[j] < from$1) { j += 3; }
      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
    }
  }

  return new DecorationSet(newLocal && newLocal.sort(byPos), children)
}

function moveSpans(spans, offset) {
  if (!offset || !spans.length) { return spans }
  var result = [];
  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    result.push(new Decoration(span.from + offset, span.to + offset, span.type));
  }
  return result
}

function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
  // Gather all decorations from the remaining marked children
  function gather(set, oldOffset) {
    for (var i = 0; i < set.local.length; i++) {
      var mapped = set.local[i].map(mapping, offset, oldOffset);
      if (mapped) { decorations.push(mapped); }
      else if (options.onRemove) { options.onRemove(set.local[i].spec); }
    }
    for (var i$1 = 0; i$1 < set.children.length; i$1 += 3)
      { gather(set.children[i$1 + 2], set.children[i$1] + oldOffset + 1); }
  }
  for (var i = 0; i < children.length; i += 3) { if (children[i + 1] == -1)
    { gather(children[i + 2], oldChildren[i] + oldOffset + 1); } }

  return decorations
}

function takeSpansForNode(spans, node, offset) {
  if (node.isLeaf) { return null }
  var end = offset + node.nodeSize, found = null;
  for (var i = 0, span = (void 0); i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset && span.to < end) {
(found || (found = [])).push(span);
      spans[i] = null;
    }
  }
  return found
}

function withoutNulls(array) {
  var result = [];
  for (var i = 0; i < array.length; i++)
    { if (array[i] != null) { result.push(array[i]); } }
  return result
}

// : ([Decoration], Node, number) → DecorationSet
// Build up a tree that corresponds to a set of decorations. `offset`
// is a base offset that should be subtracted from the `from` and `to`
// positions in the spans (so that we don't have to allocate new spans
// for recursive calls).
function buildTree(spans, node, offset, options) {
  var children = [], hasNulls = false;
  node.forEach(function (childNode, localStart) {
    var found = takeSpansForNode(spans, childNode, localStart + offset);
    if (found) {
      hasNulls = true;
      var subtree = buildTree(found, childNode, offset + localStart + 1, options);
      if (subtree != empty)
        { children.push(localStart, localStart + childNode.nodeSize, subtree); }
    }
  });
  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
  for (var i = 0; i < locals.length; i++) { if (!locals[i].type.valid(node, locals[i])) {
    if (options.onRemove) { options.onRemove(locals[i].spec); }
    locals.splice(i--, 1);
  } }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty
}

// : (Decoration, Decoration) → number
// Used to sort decorations so that ones with a low start position
// come first, and within a set with the same start position, those
// with an smaller end position come first.
function byPos(a, b) {
  return a.from - b.from || a.to - b.to
}

// : ([Decoration]) → [Decoration]
// Scan a sorted array of decorations for partially overlapping spans,
// and split those so that only fully overlapping spans are left (to
// make subsequent rendering easier). Will return the input array if
// no partially overlapping spans are found (the common case).
function removeOverlap(spans) {
  var working = spans;
  for (var i = 0; i < working.length - 1; i++) {
    var span = working[i];
    if (span.from != span.to) { for (var j = i + 1; j < working.length; j++) {
      var next = working[j];
      if (next.from == span.from) {
        if (next.to != span.to) {
          if (working == spans) { working = spans.slice(); }
          // Followed by a partially overlapping larger span. Split that
          // span.
          working[j] = next.copy(next.from, span.to);
          insertAhead(working, j + 1, next.copy(span.to, next.to));
        }
        continue
      } else {
        if (next.from < span.to) {
          if (working == spans) { working = spans.slice(); }
          // The end of this one overlaps with a subsequent span. Split
          // this one.
          working[i] = span.copy(span.from, next.from);
          insertAhead(working, j, span.copy(next.from, span.to));
        }
        break
      }
    } }
  }
  return working
}

function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0) { i++; }
  array.splice(i, 0, deco);
}

// : (EditorView) → union<DecorationSet, DecorationGroup>
// Get the decorations associated with the current props of a view.
function viewDecorations(view) {
  var found = [];
  view.someProp("decorations", function (f) {
    var result = f(view.state);
    if (result && result != empty) { found.push(result); }
  });
  if (view.cursorWrapper)
    { found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco])); }
  return DecorationGroup.from(found)
}

// ::- An editor view manages the DOM structure that represents an
// editable document. Its state and behavior are determined by its
// [props](#view.DirectEditorProps).
var EditorView = function EditorView(place, props) {
  this._props = props;
  // :: EditorState
  // The view's current [state](#state.EditorState).
  this.state = props.state;

  this.directPlugins = props.plugins || [];
  this.directPlugins.forEach(checkStateComponent);

  this.dispatch = this.dispatch.bind(this);

  this._root = null;
  this.focused = false;
  // Kludge used to work around a Chrome bug
  this.trackWrites = null;

  // :: dom.Element
  // An editable DOM node containing the document. (You probably
  // should not directly interfere with its content.)
  this.dom = (place && place.mount) || document.createElement("div");
  if (place) {
    if (place.appendChild) { place.appendChild(this.dom); }
    else if (place.apply) { place(this.dom); }
    else if (place.mount) { this.mounted = true; }
  }

  // :: bool
  // Indicates whether the editor is currently [editable](#view.EditorProps.editable).
  this.editable = getEditable(this);
  this.markCursor = null;
  this.cursorWrapper = null;
  updateCursorWrapper(this);
  this.nodeViews = buildNodeViews(this);
  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);

  this.lastSelectedViewDesc = null;
  // :: ?{slice: Slice, move: bool}
  // When editor content is being dragged, this object contains
  // information about the dragged slice and whether it is being
  // copied or moved. At any other time, it is null.
  this.dragging = null;

  initInput(this);

  this.prevDirectPlugins = [];
  this.pluginViews = [];
  this.updatePluginViews();
};

var prototypeAccessors$2 = { props: { configurable: true },root: { configurable: true } };

// composing:: boolean
// Holds `true` when a
// [composition](https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide)
// is active.

// :: DirectEditorProps
// The view's current [props](#view.EditorProps).
prototypeAccessors$2.props.get = function () {
  if (this._props.state != this.state) {
    var prev = this._props;
    this._props = {};
    for (var name in prev) { this._props[name] = prev[name]; }
    this._props.state = this.state;
  }
  return this._props
};

// :: (DirectEditorProps)
// Update the view's props. Will immediately cause an update to
// the DOM.
EditorView.prototype.update = function update (props) {
  if (props.handleDOMEvents != this._props.handleDOMEvents) { ensureListeners(this); }
  this._props = props;
  if (props.plugins) {
    props.plugins.forEach(checkStateComponent);
    this.directPlugins = props.plugins;
  }
  this.updateStateInner(props.state, true);
};

// :: (DirectEditorProps)
// Update the view by updating existing props object with the object
// given as argument. Equivalent to `view.update(Object.assign({},
// view.props, props))`.
EditorView.prototype.setProps = function setProps (props) {
  var updated = {};
  for (var name in this._props) { updated[name] = this._props[name]; }
  updated.state = this.state;
  for (var name$1 in props) { updated[name$1] = props[name$1]; }
  this.update(updated);
};

// :: (EditorState)
// Update the editor's `state` prop, without touching any of the
// other props.
EditorView.prototype.updateState = function updateState (state) {
  this.updateStateInner(state, this.state.plugins != state.plugins);
};

EditorView.prototype.updateStateInner = function updateStateInner (state, reconfigured) {
    var this$1 = this;

  var prev = this.state, redraw = false, updateSel = false;
  // When stored marks are added, stop composition, so that they can
  // be displayed.
  if (state.storedMarks && this.composing) {
    clearComposition(this);
    updateSel = true;
  }
  this.state = state;
  if (reconfigured) {
    var nodeViews = buildNodeViews(this);
    if (changedNodeViews(nodeViews, this.nodeViews)) {
      this.nodeViews = nodeViews;
      redraw = true;
    }
    ensureListeners(this);
  }

  this.editable = getEditable(this);
  updateCursorWrapper(this);
  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);

  var scroll = reconfigured ? "reset"
      : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
  var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
  if (updateDoc || !state.selection.eq(prev.selection)) { updateSel = true; }
  var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);

  if (updateSel) {
    this.domObserver.stop();
    // Work around an issue in Chrome, IE, and Edge where changing
    // the DOM around an active selection puts it into a broken
    // state where the thing the user sees differs from the
    // selection reported by the Selection object (#710, #973,
    // #1011, #1013, #1035).
    var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing &&
        !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
    if (updateDoc) {
      // If the node that the selection points into is written to,
      // Chrome sometimes starts misreporting the selection, so this
      // tracks that and forces a selection reset when our update
      // did write to the node.
      var chromeKludge = result.chrome ? (this.trackWrites = this.root.getSelection().focusNode) : null;
      if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
        this.docView.updateOuterDeco([]);
        this.docView.destroy();
        this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
      }
      if (chromeKludge && !this.trackWrites) { forceSelUpdate = true; }
    }
    // Work around for an issue where an update arriving right between
    // a DOM selection change and the "selectionchange" event for it
    // can cause a spurious DOM selection update, disrupting mouse
    // drag selection.
    if (forceSelUpdate ||
        !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
      selectionToDOM(this, forceSelUpdate);
    } else {
      syncNodeSelection(this, state.selection);
      this.domObserver.setCurSelection();
    }
    this.domObserver.start();
  }

  this.updatePluginViews(prev);

  if (scroll == "reset") {
    this.dom.scrollTop = 0;
  } else if (scroll == "to selection") {
    var startDOM = this.root.getSelection().focusNode;
    if (this.someProp("handleScrollToSelection", function (f) { return f(this$1); }))
      ; // Handled
    else if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection)
      { scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM); }
    else
      { scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM); }
  } else if (oldScrollPos) {
    resetScrollPos(oldScrollPos);
  }
};

EditorView.prototype.destroyPluginViews = function destroyPluginViews () {
  var view;
  while (view = this.pluginViews.pop()) { if (view.destroy) { view.destroy(); } }
};

EditorView.prototype.updatePluginViews = function updatePluginViews (prevState) {
  if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
    this.prevDirectPlugins = this.directPlugins;
    this.destroyPluginViews();
    for (var i = 0; i < this.directPlugins.length; i++) {
      var plugin = this.directPlugins[i];
      if (plugin.spec.view) { this.pluginViews.push(plugin.spec.view(this)); }
    }
    for (var i$1 = 0; i$1 < this.state.plugins.length; i$1++) {
      var plugin$1 = this.state.plugins[i$1];
      if (plugin$1.spec.view) { this.pluginViews.push(plugin$1.spec.view(this)); }
    }
  } else {
    for (var i$2 = 0; i$2 < this.pluginViews.length; i$2++) {
      var pluginView = this.pluginViews[i$2];
      if (pluginView.update) { pluginView.update(this, prevState); }
    }
  }
};

// :: (string, ?(prop: *) → *) → *
// Goes over the values of a prop, first those provided directly,
// then those from plugins given to the view, then from plugins in
// the state (in order), and calls `f` every time a non-undefined
// value is found. When `f` returns a truthy value, that is
// immediately returned. When `f` isn't provided, it is treated as
// the identity function (the prop value is returned directly).
EditorView.prototype.someProp = function someProp (propName, f) {
  var prop = this._props && this._props[propName], value;
  if (prop != null && (value = f ? f(prop) : prop)) { return value }
  for (var i = 0; i < this.directPlugins.length; i++) {
    var prop$1 = this.directPlugins[i].props[propName];
    if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) { return value }
  }
  var plugins = this.state.plugins;
  if (plugins) { for (var i$1 = 0; i$1 < plugins.length; i$1++) {
    var prop$2 = plugins[i$1].props[propName];
    if (prop$2 != null && (value = f ? f(prop$2) : prop$2)) { return value }
  } }
};

// :: () → bool
// Query whether the view has focus.
EditorView.prototype.hasFocus = function hasFocus () {
  return this.root.activeElement == this.dom
};

// :: ()
// Focus the editor.
EditorView.prototype.focus = function focus () {
  this.domObserver.stop();
  if (this.editable) { focusPreventScroll(this.dom); }
  selectionToDOM(this);
  this.domObserver.start();
};

// :: union<dom.Document, dom.DocumentFragment>
// Get the document root in which the editor exists. This will
// usually be the top-level `document`, but might be a [shadow
// DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
// root if the editor is inside one.
prototypeAccessors$2.root.get = function () {
  var cached = this._root;
  if (cached == null) { for (var search = this.dom.parentNode; search; search = search.parentNode) {
    if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {
      if (!search.getSelection) { Object.getPrototypeOf(search).getSelection = function () { return document.getSelection(); }; }
      return this._root = search
    }
  } }
  return cached || document
};

// :: ({left: number, top: number}) → ?{pos: number, inside: number}
// Given a pair of viewport coordinates, return the document
// position that corresponds to them. May return null if the given
// coordinates aren't inside of the editor. When an object is
// returned, its `pos` property is the position nearest to the
// coordinates, and its `inside` property holds the position of the
// inner node that the position falls inside of, or -1 if it is at
// the top level, not in any node.
EditorView.prototype.posAtCoords = function posAtCoords$1 (coords) {
  return posAtCoords(this, coords)
};

// :: (number, number) → {left: number, right: number, top: number, bottom: number}
// Returns the viewport rectangle at a given document position.
// `left` and `right` will be the same number, as this returns a
// flat cursor-ish rectangle. If the position is between two things
// that aren't directly adjacent, `side` determines which element is
// used. When < 0, the element before the position is used,
// otherwise the element after.
EditorView.prototype.coordsAtPos = function coordsAtPos$1 (pos, side) {
    if ( side === void 0 ) side = 1;

  return coordsAtPos(this, pos, side)
};

// :: (number, number) → {node: dom.Node, offset: number}
// Find the DOM position that corresponds to the given document
// position. When `side` is negative, find the position as close as
// possible to the content before the position. When positive,
// prefer positions close to the content after the position. When
// zero, prefer as shallow a position as possible.
//
// Note that you should **not** mutate the editor's internal DOM,
// only inspect it (and even that is usually not necessary).
EditorView.prototype.domAtPos = function domAtPos (pos, side) {
    if ( side === void 0 ) side = 0;

  return this.docView.domFromPos(pos, side)
};

// :: (number) → ?dom.Node
// Find the DOM node that represents the document node after the
// given position. May return `null` when the position doesn't point
// in front of a node or if the node is inside an opaque node view.
//
// This is intended to be able to call things like
// `getBoundingClientRect` on that DOM node. Do **not** mutate the
// editor DOM directly, or add styling this way, since that will be
// immediately overriden by the editor as it redraws the node.
EditorView.prototype.nodeDOM = function nodeDOM (pos) {
  var desc = this.docView.descAt(pos);
  return desc ? desc.nodeDOM : null
};

// :: (dom.Node, number, ?number) → number
// Find the document position that corresponds to a given DOM
// position. (Whenever possible, it is preferable to inspect the
// document structure directly, rather than poking around in the
// DOM, but sometimes—for example when interpreting an event
// target—you don't have a choice.)
//
// The `bias` parameter can be used to influence which side of a DOM
// node to use when the position is inside a leaf node.
EditorView.prototype.posAtDOM = function posAtDOM (node, offset, bias) {
    if ( bias === void 0 ) bias = -1;

  var pos = this.docView.posFromDOM(node, offset, bias);
  if (pos == null) { throw new RangeError("DOM position not inside the editor") }
  return pos
};

// :: (union<"up", "down", "left", "right", "forward", "backward">, ?EditorState) → bool
// Find out whether the selection is at the end of a textblock when
// moving in a given direction. When, for example, given `"left"`,
// it will return true if moving left from the current cursor
// position would leave that position's parent textblock. Will apply
// to the view's current state by default, but it is possible to
// pass a different state.
EditorView.prototype.endOfTextblock = function endOfTextblock$1 (dir, state) {
  return endOfTextblock(this, state || this.state, dir)
};

// :: ()
// Removes the editor from the DOM and destroys all [node
// views](#view.NodeView).
EditorView.prototype.destroy = function destroy () {
  if (!this.docView) { return }
  destroyInput(this);
  this.destroyPluginViews();
  if (this.mounted) {
    this.docView.update(this.state.doc, [], viewDecorations(this), this);
    this.dom.textContent = "";
  } else if (this.dom.parentNode) {
    this.dom.parentNode.removeChild(this.dom);
  }
  this.docView.destroy();
  this.docView = null;
};

// Used for testing.
EditorView.prototype.dispatchEvent = function dispatchEvent$1 (event) {
  return dispatchEvent(this, event)
};

// :: (Transaction)
// Dispatch a transaction. Will call
// [`dispatchTransaction`](#view.DirectEditorProps.dispatchTransaction)
// when given, and otherwise defaults to applying the transaction to
// the current state and calling
// [`updateState`](#view.EditorView.updateState) with the result.
// This method is bound to the view instance, so that it can be
// easily passed around.
EditorView.prototype.dispatch = function dispatch (tr) {
  var dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction) { dispatchTransaction.call(this, tr); }
  else { this.updateState(this.state.apply(tr)); }
};

Object.defineProperties( EditorView.prototype, prototypeAccessors$2 );

function computeDocDeco(view) {
  var attrs = Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  attrs.translate = "no";

  view.someProp("attributes", function (value) {
    if (typeof value == "function") { value = value(view.state); }
    if (value) { for (var attr in value) {
      if (attr == "class")
        { attrs.class += " " + value[attr]; }
      if (attr == "style") {
        attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
      }
      else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
        { attrs[attr] = String(value[attr]); }
    } }
  });

  return [Decoration.node(0, view.state.doc.content.size, attrs)]
}

function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    view.cursorWrapper = {dom: dom, deco: Decoration.widget(view.state.selection.head, dom, {raw: true, marks: view.markCursor})};
  } else {
    view.cursorWrapper = null;
  }
}

function getEditable(view) {
  return !view.someProp("editable", function (value) { return value(view.state) === false; })
}

function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth)
}

function buildNodeViews(view) {
  var result = {};
  view.someProp("nodeViews", function (obj) {
    for (var prop in obj) { if (!Object.prototype.hasOwnProperty.call(result, prop))
      { result[prop] = obj[prop]; } }
  });
  return result
}

function changedNodeViews(a, b) {
  var nA = 0, nB = 0;
  for (var prop in a) {
    if (a[prop] != b[prop]) { return true }
    nA++;
  }
  for (var _ in b) { nB++; }
  return nA != nB
}

function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    { throw new RangeError("Plugins passed directly to the view must not have a state component") }
}

// EditorProps:: interface
//
// Props are configuration values that can be passed to an editor view
// or included in a plugin. This interface lists the supported props.
//
// The various event-handling functions may all return `true` to
// indicate that they handled the given event. The view will then take
// care to call `preventDefault` on the event, except with
// `handleDOMEvents`, where the handler itself is responsible for that.
//
// How a prop is resolved depends on the prop. Handler functions are
// called one at a time, starting with the base props and then
// searching through the plugins (in order of appearance) until one of
// them returns true. For some props, the first plugin that yields a
// value gets precedence.
//
//   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event) → bool>
//   Can be an object mapping DOM event type names to functions that
//   handle them. Such functions will be called before any handling
//   ProseMirror does of events fired on the editable DOM element.
//   Contrary to the other event handling props, when returning true
//   from such a function, you are responsible for calling
//   `preventDefault` yourself (or not, if you want to allow the
//   default behavior).
//
//   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent) → bool
//   Called when the editor receives a `keydown` event.
//
//   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent) → bool
//   Handler for `keypress` events.
//
//   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string) → bool
//   Whenever the user directly input text, this handler is called
//   before the input is applied. If it returns `true`, the default
//   behavior of actually inserting the text is suppressed.
//
//   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool
//   Called for each node around a click, from the inside out. The
//   `direct` flag will be true for the inner node.
//
//   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool
//   Called when the editor is clicked, after `handleClickOn` handlers
//   have been called.
//
//   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool
//   Called for each node around a double click.
//
//   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool
//   Called when the editor is double-clicked, after `handleDoubleClickOn`.
//
//   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool
//   Called for each node around a triple click.
//
//   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool
//   Called when the editor is triple-clicked, after `handleTripleClickOn`.
//
//   handlePaste:: ?(view: EditorView, event: dom.ClipboardEvent, slice: Slice) → bool
//   Can be used to override the behavior of pasting. `slice` is the
//   pasted content parsed by the editor, but you can directly access
//   the event to get at the raw content.
//
//   handleDrop:: ?(view: EditorView, event: dom.Event, slice: Slice, moved: bool) → bool
//   Called when something is dropped on the editor. `moved` will be
//   true if this drop moves from the current selection (which should
//   thus be deleted).
//
//   handleScrollToSelection:: ?(view: EditorView) → bool
//   Called when the view, after updating its state, tries to scroll
//   the selection into view. A handler function may return false to
//   indicate that it did not handle the scrolling and further
//   handlers or the default behavior should be tried.
//
//   createSelectionBetween:: ?(view: EditorView, anchor: ResolvedPos, head: ResolvedPos) → ?Selection
//   Can be used to override the way a selection is created when
//   reading a DOM selection between the given anchor and head.
//
//   domParser:: ?DOMParser
//   The [parser](#model.DOMParser) to use when reading editor changes
//   from the DOM. Defaults to calling
//   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the
//   editor's schema.
//
//   transformPastedHTML:: ?(html: string) → string
//   Can be used to transform pasted HTML text, _before_ it is parsed,
//   for example to clean it up.
//
//   clipboardParser:: ?DOMParser
//   The [parser](#model.DOMParser) to use when reading content from
//   the clipboard. When not given, the value of the
//   [`domParser`](#view.EditorProps.domParser) prop is used.
//
//   transformPastedText:: ?(text: string, plain: bool) → string
//   Transform pasted plain text. The `plain` flag will be true when
//   the text is pasted as plain text.
//
//   clipboardTextParser:: ?(text: string, $context: ResolvedPos, plain: bool) → Slice
//   A function to parse text from the clipboard into a document
//   slice. Called after
//   [`transformPastedText`](#view.EditorProps.transformPastedText).
//   The default behavior is to split the text into lines, wrap them
//   in `<p>` tags, and call
//   [`clipboardParser`](#view.EditorProps.clipboardParser) on it.
//   The `plain` flag will be true when the text is pasted as plain text.
//
//   transformPasted:: ?(Slice) → Slice
//   Can be used to transform pasted content before it is applied to
//   the document.
//
//   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: () → number, decorations: [Decoration], innerDecorations: DecorationSource) → NodeView>
//   Allows you to pass custom rendering and behavior logic for nodes
//   and marks. Should map node and mark names to constructor
//   functions that produce a [`NodeView`](#view.NodeView) object
//   implementing the node's display behavior. For nodes, the third
//   argument `getPos` is a function that can be called to get the
//   node's current position, which can be useful when creating
//   transactions to update it. For marks, the third argument is a
//   boolean that indicates whether the mark's content is inline.
//
//   `decorations` is an array of node or inline decorations that are
//   active around the node. They are automatically drawn in the
//   normal way, and you will usually just want to ignore this, but
//   they can also be used as a way to provide context information to
//   the node view without adding it to the document itself.
//
//   `innerDecorations` holds the decorations for the node's content.
//   You can safely ignore this if your view has no content or a
//   `contentDOM` property, since the editor will draw the decorations
//   on the content. But if you, for example, want to create a nested
//   editor with the content, it may make sense to provide it with the
//   inner decorations.
//
//   clipboardSerializer:: ?DOMSerializer
//   The DOM serializer to use when putting content onto the
//   clipboard. If not given, the result of
//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)
//   will be used.
//
//   clipboardTextSerializer:: ?(Slice) → string
//   A function that will be called to get the text for the current
//   selection when copying text to the clipboard. By default, the
//   editor will use [`textBetween`](#model.Node.textBetween) on the
//   selected range.
//
//   decorations:: ?(state: EditorState) → ?DecorationSource
//   A set of [document decorations](#view.Decoration) to show in the
//   view.
//
//   editable:: ?(state: EditorState) → bool
//   When this returns false, the content of the view is not directly
//   editable.
//
//   attributes:: ?union<Object<string>, (EditorState) → ?Object<string>>
//   Control the DOM attributes of the editable element. May be either
//   an object or a function going from an editor state to an object.
//   By default, the element will get a class `"ProseMirror"`, and
//   will have its `contentEditable` attribute determined by the
//   [`editable` prop](#view.EditorProps.editable). Additional classes
//   provided here will be added to the class. For other attributes,
//   the value provided first (as in
//   [`someProp`](#view.EditorView.someProp)) will be used.
//
//   scrollThreshold:: ?union<number, {top: number, right: number, bottom: number, left: number}>
//   Determines the distance (in pixels) between the cursor and the
//   end of the visible viewport at which point, when scrolling the
//   cursor into view, scrolling takes place. Defaults to 0.
//
//   scrollMargin:: ?union<number, {top: number, right: number, bottom: number, left: number}>
//   Determines the extra space (in pixels) that is left above or
//   below the cursor when it is scrolled into view. Defaults to 5.

// DirectEditorProps:: interface extends EditorProps
//
// The props object given directly to the editor view supports two
// fields that can't be used in plugins:
//
//   state:: EditorState
//   The current state of the editor.
//
//   plugins:: [Plugin]
//   A set of plugins to use in the view, applying their [plugin
//   view](#state.PluginSpec.view) and
//   [props](#state.PluginSpec.props). Passing plugins with a state
//   component (a [state field](#state.PluginSpec.state) field or a
//   [transaction)[#state.PluginSpec.filterTransaction] filter or
//   appender) will result in an error, since such plugins must be
//   present in the state to work.
//
//   dispatchTransaction:: ?(tr: Transaction)
//   The callback over which to send transactions (state updates)
//   produced by the view. If you specify this, you probably want to
//   make sure this ends up calling the view's
//   [`updateState`](#view.EditorView.updateState) method with a new
//   state that has the transaction
//   [applied](#state.EditorState.apply). The callback will be bound to have
//   the view instance as its `this` binding.


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/rope-sequence/dist/index.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/rope-sequence/dist/index.es.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var GOOD_LEAF_SIZE = 200;

// :: class<T> A rope sequence is a persistent sequence data structure
// that supports appending, prepending, and slicing without doing a
// full copy. It is represented as a mostly-balanced tree.
var RopeSequence = function RopeSequence () {};

RopeSequence.prototype.append = function append (other) {
  if (!other.length) { return this }
  other = RopeSequence.from(other);

  return (!this.length && other) ||
    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||
    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||
    this.appendInner(other)
};

// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>
// Prepend an array or other rope to this one, returning a new rope.
RopeSequence.prototype.prepend = function prepend (other) {
  if (!other.length) { return this }
  return RopeSequence.from(other).append(this)
};

RopeSequence.prototype.appendInner = function appendInner (other) {
  return new Append(this, other)
};

// :: (?number, ?number) → RopeSequence<T>
// Create a rope repesenting a sub-sequence of this rope.
RopeSequence.prototype.slice = function slice (from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  if (from >= to) { return RopeSequence.empty }
  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))
};

// :: (number) → T
// Retrieve the element at the given position from this rope.
RopeSequence.prototype.get = function get (i) {
  if (i < 0 || i >= this.length) { return undefined }
  return this.getInner(i)
};

// :: ((element: T, index: number) → ?bool, ?number, ?number)
// Call the given function for each element between the given
// indices. This tends to be more efficient than looping over the
// indices and calling `get`, because it doesn't have to descend the
// tree for every element.
RopeSequence.prototype.forEach = function forEach (f, from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  if (from <= to)
    { this.forEachInner(f, from, to, 0); }
  else
    { this.forEachInvertedInner(f, from, to, 0); }
};

// :: ((element: T, index: number) → U, ?number, ?number) → [U]
// Map the given functions over the elements of the rope, producing
// a flat array.
RopeSequence.prototype.map = function map (f, from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  var result = [];
  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);
  return result
};

// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>
// Create a rope representing the given array, or return the rope
// itself if a rope was given.
RopeSequence.from = function from (values) {
  if (values instanceof RopeSequence) { return values }
  return values && values.length ? new Leaf(values) : RopeSequence.empty
};

var Leaf = /*@__PURE__*/(function (RopeSequence) {
  function Leaf(values) {
    RopeSequence.call(this);
    this.values = values;
  }

  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;
  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );
  Leaf.prototype.constructor = Leaf;

  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };

  Leaf.prototype.flatten = function flatten () {
    return this.values
  };

  Leaf.prototype.sliceInner = function sliceInner (from, to) {
    if (from == 0 && to == this.length) { return this }
    return new Leaf(this.values.slice(from, to))
  };

  Leaf.prototype.getInner = function getInner (i) {
    return this.values[i]
  };

  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {
    for (var i = from; i < to; i++)
      { if (f(this.values[i], start + i) === false) { return false } }
  };

  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
    for (var i = from - 1; i >= to; i--)
      { if (f(this.values[i], start + i) === false) { return false } }
  };

  Leaf.prototype.leafAppend = function leafAppend (other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE)
      { return new Leaf(this.values.concat(other.flatten())) }
  };

  Leaf.prototype.leafPrepend = function leafPrepend (other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE)
      { return new Leaf(other.flatten().concat(this.values)) }
  };

  prototypeAccessors.length.get = function () { return this.values.length };

  prototypeAccessors.depth.get = function () { return 0 };

  Object.defineProperties( Leaf.prototype, prototypeAccessors );

  return Leaf;
}(RopeSequence));

// :: RopeSequence
// The empty rope sequence.
RopeSequence.empty = new Leaf([]);

var Append = /*@__PURE__*/(function (RopeSequence) {
  function Append(left, right) {
    RopeSequence.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }

  if ( RopeSequence ) Append.__proto__ = RopeSequence;
  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );
  Append.prototype.constructor = Append;

  Append.prototype.flatten = function flatten () {
    return this.left.flatten().concat(this.right.flatten())
  };

  Append.prototype.getInner = function getInner (i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)
  };

  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {
    var leftLen = this.left.length;
    if (from < leftLen &&
        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)
      { return false }
    if (to > leftLen &&
        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)
      { return false }
  };

  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
    var leftLen = this.left.length;
    if (from > leftLen &&
        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)
      { return false }
    if (to < leftLen &&
        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)
      { return false }
  };

  Append.prototype.sliceInner = function sliceInner (from, to) {
    if (from == 0 && to == this.length) { return this }
    var leftLen = this.left.length;
    if (to <= leftLen) { return this.left.slice(from, to) }
    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }
    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))
  };

  Append.prototype.leafAppend = function leafAppend (other) {
    var inner = this.right.leafAppend(other);
    if (inner) { return new Append(this.left, inner) }
  };

  Append.prototype.leafPrepend = function leafPrepend (other) {
    var inner = this.left.leafPrepend(other);
    if (inner) { return new Append(inner, this.right) }
  };

  Append.prototype.appendInner = function appendInner (other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)
      { return new Append(this.left, new Append(this.right, other)) }
    return new Append(this, other)
  };

  return Append;
}(RopeSequence));

var ropeSequence = RopeSequence;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ropeSequence);


/***/ }),

/***/ "./demo/index.ts":
/*!***********************!*\
  !*** ./demo/index.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* eslint-disable import/no-extraneous-dependencies */
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
const prosemirror_view_1 = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.es.js");
const prosemirror_model_1 = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");
const prosemirror_schema_basic_1 = __webpack_require__(/*! prosemirror-schema-basic */ "./node_modules/prosemirror-schema-basic/dist/index.es.js");
const prosemirror_example_setup_1 = __webpack_require__(/*! prosemirror-example-setup */ "./node_modules/prosemirror-example-setup/dist/index.es.js");
const src_1 = __importDefault(__webpack_require__(/*! ../src */ "./src/index.ts"));
const editor = document.querySelector('#editor');
const content = document.querySelector('#content');
window.view = new prosemirror_view_1.EditorView(editor, {
    state: prosemirror_state_1.EditorState.create({
        doc: prosemirror_model_1.DOMParser.fromSchema(prosemirror_schema_basic_1.schema).parse(content),
        plugins: [
            ...(0, src_1.default)({ markType: prosemirror_schema_basic_1.schema.marks.code }),
            ...(0, prosemirror_example_setup_1.exampleSetup)({ schema: prosemirror_schema_basic_1.schema, menuBar: false }),
        ],
    }),
});


/***/ }),

/***/ "./src/actions.ts":
/*!************************!*\
  !*** ./src/actions.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stepOutside = exports.onBackspace = exports.onArrowLeft = exports.onArrowRight = exports.onBacktick = exports.stepOutsideNextTrAndPass = void 0;
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
function stepOutsideNextTrAndPass(view, plugin) {
    const meta = { action: 'next' };
    view.dispatch(view.state.tr.setMeta(plugin, meta));
    return false;
}
exports.stepOutsideNextTrAndPass = stepOutsideNextTrAndPass;
function onBacktick(view, plugin, event, markType) {
    if (view.state.selection.empty)
        return false;
    if (event.metaKey || event.shiftKey || event.altKey || event.ctrlKey)
        return false;
    // Create a code mark!
    const { from, to } = view.state.selection;
    if (to - from >= utils_1.MAX_MATCH || view.state.doc.rangeHasMark(from, to, markType))
        return false;
    const tr = view.state.tr.addMark(from, to, markType.create());
    const meta = { action: 'add', pos: to };
    const selected = tr
        .setSelection(prosemirror_state_1.TextSelection.create(tr.doc, to))
        .removeStoredMark(markType)
        .setMeta(plugin, meta);
    view.dispatch(selected);
    return true;
}
exports.onBacktick = onBacktick;
function onArrowRightInside(view, plugin, event, markType) {
    var _a;
    if (event.metaKey)
        return stepOutsideNextTrAndPass(view, plugin);
    if (event.shiftKey || event.altKey || event.ctrlKey)
        return false;
    const { selection, doc } = view.state;
    if (!selection.empty)
        return false;
    const pluginState = plugin.getState(view.state);
    const pos = selection.$from;
    const inCode = !!markType.isInSet(pos.marks());
    const nextCode = !!markType.isInSet((_a = pos.marksAcross(doc.resolve(selection.from + 1))) !== null && _a !== void 0 ? _a : []);
    if (inCode === nextCode && pos.parentOffset !== 0)
        return false;
    if (inCode && !(pluginState === null || pluginState === void 0 ? void 0 : pluginState.decorations) && pos.parentOffset !== 0) {
        // `code|` --> `code`|
        const meta = { action: 'add', pos: selection.from };
        view.dispatch(view.state.tr.removeStoredMark(markType).setMeta(plugin, meta));
        return true;
    }
    if ((nextCode && !(pluginState === null || pluginState === void 0 ? void 0 : pluginState.decorations) && pos.parentOffset !== 0) ||
        (pos.parentOffset === 0 && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.side) === -1)) {
        // |`code` --> `|code`
        const meta = { action: 'add', pos: selection.from };
        view.dispatch(view.state.tr.addStoredMark(markType.create()).setMeta(plugin, meta));
        return true;
    }
    return false;
}
function onArrowRight(view, plugin, event, markType) {
    const handled = onArrowRightInside(view, plugin, event, markType);
    if (handled)
        return true;
    const { selection } = view.state;
    const pos = selection.$from;
    if (selection.empty && pos.parentOffset === pos.parent.nodeSize - 2) {
        return stepOutsideNextTrAndPass(view, plugin);
    }
    return false;
}
exports.onArrowRight = onArrowRight;
function onArrowLeftInside(view, plugin, event, markType) {
    var _a;
    if (event.metaKey)
        return stepOutsideNextTrAndPass(view, plugin);
    if (event.shiftKey || event.altKey || event.ctrlKey)
        return false;
    const { selection, doc } = view.state;
    const pluginState = plugin.getState(view.state);
    const inCode = !!markType.isInSet(selection.$from.marks());
    const nextCode = !!markType.isInSet((_a = doc.resolve(selection.empty ? selection.from - 1 : selection.from + 1).marks()) !== null && _a !== void 0 ? _a : []);
    if (inCode && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.side) === -1) {
        // New line!
        // ^|`code` --> |^`code`
        return false;
    }
    if (inCode && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.decorations)) {
        // `code`| --> `code|`
        const meta = { action: 'remove' };
        view.dispatch(view.state.tr.addStoredMark(markType.create()).setMeta(plugin, meta));
        return true;
    }
    if (!inCode && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.decorations)) {
        // `|code` --> |`code`
        const meta = { action: 'remove' };
        view.dispatch(view.state.tr.removeStoredMark(markType).setMeta(plugin, meta));
        return true;
    }
    if (inCode === nextCode)
        return false;
    if ((nextCode || (!selection.empty && inCode)) && !(pluginState === null || pluginState === void 0 ? void 0 : pluginState.decorations)) {
        // `code`_|_ --> `code`|   nextCode
        // `code`███ --> `code`|   !selection.empty && inCode
        // `██de`___ --> `|code`   !selection.empty && nextCode
        const from = selection.empty ? selection.from - 1 : selection.from;
        const meta = { action: 'add', pos: from };
        const selected = view.state.tr
            .setSelection(prosemirror_state_1.TextSelection.create(doc, from))
            .setMeta(plugin, meta);
        if (!selection.empty && nextCode) {
            view.dispatch(selected.addStoredMark(markType.create()));
        }
        else {
            view.dispatch(selected.removeStoredMark(markType));
        }
        return true;
    }
    if ((nextCode || (!selection.empty && inCode)) && !(pluginState === null || pluginState === void 0 ? void 0 : pluginState.decorations)) {
        // `code`_|_ --> `code`|
        // `code`███ --> `code`|
        const from = selection.empty ? selection.from - 1 : selection.from;
        const meta = { action: 'add', pos: from };
        view.dispatch(view.state.tr
            .setSelection(prosemirror_state_1.TextSelection.create(doc, from))
            .removeStoredMark(markType)
            .setMeta(plugin, meta));
        return true;
    }
    if (inCode && !(pluginState === null || pluginState === void 0 ? void 0 : pluginState.decorations) && selection.$from.parentOffset > 0) {
        // `c|ode` --> `|code`
        const meta = { action: 'add', pos: selection.from - 1 };
        view.dispatch(view.state.tr
            .setSelection(prosemirror_state_1.TextSelection.create(doc, selection.from - 1))
            .addStoredMark(markType.create())
            .setMeta(plugin, meta));
        return true;
    }
    if (inCode && !(pluginState === null || pluginState === void 0 ? void 0 : pluginState.decorations) && selection.$from.parentOffset === 0) {
        // Start of line
        // ^`|code` --> ^|`code`
        const meta = { action: 'add', pos: selection.from, side: -1 };
        view.dispatch(view.state.tr.removeStoredMark(markType).setMeta(plugin, meta));
        return true;
    }
    return false;
}
function onArrowLeft(view, plugin, event, markType) {
    const handled = onArrowLeftInside(view, plugin, event, markType);
    if (handled)
        return true;
    const { selection } = view.state;
    const pos = selection.$from;
    if (selection.empty && pos.parentOffset === 0) {
        return stepOutsideNextTrAndPass(view, plugin);
    }
    return false;
}
exports.onArrowLeft = onArrowLeft;
function onBackspace(view, plugin, event, markType) {
    var _a, _b;
    if (event.metaKey || event.shiftKey || event.altKey || event.ctrlKey)
        return false;
    const { selection, doc } = view.state;
    if (selection.empty && selection.$from.parentOffset === 0) {
        // No override at the start of the line!
        return false;
    }
    const inCode = !!markType.isInSet(selection.$from.marks());
    const nextCode = !!markType.isInSet((_a = doc.resolve(selection.empty ? selection.from - 1 : selection.from + 1).marks()) !== null && _a !== void 0 ? _a : []);
    const plusCode = !!markType.isInSet((_b = doc.resolve(selection.empty ? selection.from + 1 : selection.to + 1).marks()) !== null && _b !== void 0 ? _b : []);
    if (inCode === nextCode && (inCode === plusCode || !plusCode))
        return false;
    let { tr } = view.state;
    if (selection.empty) {
        tr = tr.delete(selection.from - 1, selection.from);
    }
    else {
        tr = tr.delete(selection.from, selection.to);
    }
    if ((nextCode && selection.empty) || (inCode && !selection.empty)) {
        // `code`_|_ --> `code`|     nextCode && selection.empty
        // `code`███ --> `code`|     inCode && !selection.empty
        const meta = { action: 'add', pos: tr.selection.from };
        view.dispatch(tr.removeStoredMark(markType).setMeta(plugin, meta));
        return true;
    }
    if (tr.selection.$from.parentOffset === 0) {
        // ^███`code` --> `|ode`
        const meta = { action: 'add', pos: tr.selection.from, side: -1 };
        view.dispatch(tr.removeStoredMark(markType).setMeta(plugin, meta));
        return true;
    }
    if (inCode || nextCode) {
        // `c|ode` --> `|ode`
        // `██de` --> `|de`
        const meta = { action: 'add', pos: tr.selection.from };
        view.dispatch(tr.addStoredMark(markType.create()).setMeta(plugin, meta));
        return true;
    }
    return false;
}
exports.onBackspace = onBackspace;
function stepOutside(view, plugin, markType) {
    var _a, _b;
    const { selection, doc } = view.state;
    if (!selection.empty)
        return;
    const inCode = !!markType.isInSet(selection.$from.marks());
    if (!inCode)
        return;
    const nextCode = !!markType.isInSet((_a = doc.resolve(selection.from + 1).marks()) !== null && _a !== void 0 ? _a : []);
    const prevCode = !!markType.isInSet((_b = doc.resolve(selection.from - 1).marks()) !== null && _b !== void 0 ? _b : []);
    let meta = null;
    if (!nextCode) {
        // `code|` --> `code`|
        meta = { action: 'add', pos: selection.from };
    }
    else if (!prevCode) {
        // `|code` --> |`code`
        meta = { action: 'add', pos: selection.from, side: -1 };
    }
    if (meta) {
        const tr = view.state.tr.removeStoredMark(markType).setMeta(plugin, meta);
        view.dispatch(tr);
    }
}
exports.stepOutside = stepOutside;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const plugin_1 = __webpack_require__(/*! ./plugin */ "./src/plugin.ts");
__exportStar(__webpack_require__(/*! ./types */ "./src/types.ts"), exports);
exports["default"] = plugin_1.codemark;


/***/ }),

/***/ "./src/inputRules.ts":
/*!***************************!*\
  !*** ./src/inputRules.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createInputRule = void 0;
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
const markBefore = {
    match: /`((?:[^`\w]|[\w])+)`$/,
    handler: (view, text, match, from, to, plugins) => {
        const markType = view.state.schema.marks.code;
        // Don't create it if there is code in between!
        if (view.state.doc.rangeHasMark(from, to, markType))
            return false;
        const code = match[1];
        const mark = markType.create();
        const pos = from + code.length;
        const tr = view.state.tr.delete(from, to).insertText(code).addMark(from, pos, mark);
        const selected = tr
            .setSelection(prosemirror_state_1.TextSelection.create(tr.doc, pos))
            .removeStoredMark(markType)
            .setMeta(plugins.cursor, {
            action: 'add',
            pos,
        });
        const withMeta = selected.setMeta(plugins.input, {
            transform: selected,
            from,
            to,
            text: `\`${code}${text}`,
        });
        view.dispatch(withMeta);
        return true;
    },
};
const markAfter = {
    match: /^`((?:[^`\w]|[\w])+)`/,
    handler: (view, text, match, from, to, plugins) => {
        const markType = view.state.schema.marks.code;
        // Don't create it if there is code in between!
        if (view.state.doc.rangeHasMark(from, to, markType))
            return false;
        const mark = markType.create();
        const code = match[1];
        const pos = from;
        const tr = view.state.tr.delete(from, to).insertText(code).addMark(from, to, mark);
        const selected = tr
            .setSelection(prosemirror_state_1.TextSelection.create(tr.doc, pos))
            .addStoredMark(markType.create())
            .setMeta(plugins.cursor, {
            action: 'add',
            pos,
        });
        const withMeta = selected.setMeta(plugins.input, {
            transform: selected,
            from,
            to,
            text: `\`${code}${text}`,
        });
        view.dispatch(withMeta);
        return true;
    },
};
function run(view, from, to, text, plugins) {
    if (view.composing)
        return false;
    const { state } = view;
    const $from = state.doc.resolve(from);
    if ($from.parent.type.spec.code)
        return false;
    const leafText = '\ufffc';
    const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - utils_1.MAX_MATCH), $from.parentOffset, undefined, leafText) + text;
    const textAfter = text +
        $from.parent.textBetween($from.parentOffset, Math.min($from.parent.nodeSize - 2, $from.parentOffset + utils_1.MAX_MATCH), undefined, leafText);
    const matchB = markBefore.match.exec(textBefore);
    const matchA = markAfter.match.exec(textAfter);
    if (matchB) {
        const handled = markBefore.handler(view, text, matchB, from - matchB[0].length + text.length, to, plugins);
        if (handled)
            return handled;
    }
    if (matchA)
        return markAfter.handler(view, text, matchA, from, to + matchA[0].length - text.length, plugins);
    return false;
}
function createInputRule(cursorPlugin) {
    const plugin = new prosemirror_state_1.Plugin({
        isInputRules: true,
        state: {
            init: () => null,
            apply(tr, prev) {
                const meta = tr.getMeta(plugin);
                if (meta)
                    return meta;
                return tr.selectionSet || tr.docChanged ? null : prev;
            },
        },
        props: {
            handleTextInput(view, from, to, text) {
                return run(view, from, to, text, { input: plugin, cursor: cursorPlugin });
            },
        },
    });
    return plugin;
}
exports.createInputRule = createInputRule;


/***/ }),

/***/ "./src/plugin.ts":
/*!***********************!*\
  !*** ./src/plugin.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.codemark = exports.getDecorationPlugin = void 0;
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
const prosemirror_view_1 = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.es.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
const inputRules_1 = __webpack_require__(/*! ./inputRules */ "./src/inputRules.ts");
const actions_1 = __webpack_require__(/*! ./actions */ "./src/actions.ts");
function toDom() {
    const span = document.createElement('span');
    span.classList.add('fake-cursor');
    return span;
}
function getDecorationPlugin(markType) {
    const plugin = new prosemirror_state_1.Plugin({
        key: utils_1.pluginKey,
        view() {
            return {
                update: (view) => {
                    const state = plugin.getState(view.state);
                    view.dom.classList[(state === null || state === void 0 ? void 0 : state.decorations) ? 'add' : 'remove']('no-cursor');
                    if (state === null || state === void 0 ? void 0 : state.check)
                        (0, actions_1.stepOutside)(view, plugin, markType);
                },
            };
        },
        state: {
            init: () => null,
            apply(tr, value, oldState) {
                var _a;
                const meta = tr.getMeta(plugin);
                const prev = plugin.getState(oldState);
                // If the previous action told us to check, trigger the view to render
                if (prev === null || prev === void 0 ? void 0 : prev.next)
                    return { check: true };
                switch (meta === null || meta === void 0 ? void 0 : meta.action) {
                    case 'add': {
                        const deco = prosemirror_view_1.Decoration.widget(meta.pos, toDom, { side: (_a = meta.side) !== null && _a !== void 0 ? _a : 0 });
                        return {
                            decorations: prosemirror_view_1.DecorationSet.create(tr.doc, [deco]),
                            side: meta.side,
                        };
                    }
                    case 'next':
                        // The transaction puts a flag that we will check next
                        // On the next transaction this turns into { check: true }
                        // Used on complex cursor movements that are not overridden
                        return { next: true };
                    case 'remove':
                    default:
                        return null;
                }
            },
        },
        props: {
            decorations: (state) => { var _a, _b; return (_b = (_a = plugin.getState(state)) === null || _a === void 0 ? void 0 : _a.decorations) !== null && _b !== void 0 ? _b : prosemirror_view_1.DecorationSet.empty; },
            handleKeyDown(view, event) {
                switch (event.key) {
                    case '`':
                        return (0, actions_1.onBacktick)(view, plugin, event, markType);
                    case 'ArrowRight':
                        return (0, actions_1.onArrowRight)(view, plugin, event, markType);
                    case 'ArrowLeft':
                        return (0, actions_1.onArrowLeft)(view, plugin, event, markType);
                    case 'Backspace':
                        return (0, actions_1.onBackspace)(view, plugin, event, markType);
                    case 'ArrowUp':
                    case 'ArrowDown':
                    case 'Home':
                    case 'End':
                        return (0, actions_1.stepOutsideNextTrAndPass)(view, plugin);
                    case 'e':
                    case 'a':
                        if (!event.ctrlKey)
                            return false;
                        return (0, actions_1.stepOutsideNextTrAndPass)(view, plugin);
                    default:
                        return false;
                }
            },
        },
    });
    return plugin;
}
exports.getDecorationPlugin = getDecorationPlugin;
function codemark(opts) {
    const { markType } = opts;
    const cursorPlugin = getDecorationPlugin(markType);
    const inputRule = (0, inputRules_1.createInputRule)(cursorPlugin);
    const rules = [cursorPlugin, inputRule];
    return rules;
}
exports.codemark = codemark;


/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pluginKey = exports.MAX_MATCH = exports.DEFAULT_ID = void 0;
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
exports.DEFAULT_ID = 'codemark';
exports.MAX_MATCH = 100;
exports.pluginKey = new prosemirror_state_1.PluginKey(exports.DEFAULT_ID);


/***/ }),

/***/ "./node_modules/crelt/index.es.js":
/*!****************************************!*\
  !*** ./node_modules/crelt/index.es.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ crelt)
/* harmony export */ });
function crelt() {
  var elt = arguments[0]
  if (typeof elt == "string") elt = document.createElement(elt)
  var i = 1, next = arguments[1]
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
      var value = next[name]
      if (typeof value == "string") elt.setAttribute(name, value)
      else if (value != null) elt[name] = value
    }
    i++
  }
  for (; i < arguments.length; i++) add(elt, arguments[i])
  return elt
}

function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child))
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child)
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add(elt, child[i])
  } else {
    throw new RangeError("Unsupported child node: " + child)
  }
}


/***/ }),

/***/ "./node_modules/w3c-keyname/index.es.js":
/*!**********************************************!*\
  !*** ./node_modules/w3c-keyname/index.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base": () => (/* binding */ base),
/* harmony export */   "keyName": () => (/* binding */ keyName)
/* harmony export */ });
/* unused harmony export shift */
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
}

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\"",
  229: "Q"
}

var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent)
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor)
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent)
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform)
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
var brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32)
  shift[i] = String.fromCharCode(i)
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]

function keyName(event) {
  // Don't trust event.key in Chrome when there are modifiers until
  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||
    (safari || ie) && event.shiftKey && event.key && event.key.length == 1
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified"
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape"
  if (name == "Del") name = "Delete"
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft"
  if (name == "Up") name = "ArrowUp"
  if (name == "Right") name = "ArrowRight"
  if (name == "Down") name = "ArrowDown"
  return name
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./demo/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0IsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEMsTUFBTSwyQkFBMkI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixvQkFBb0IsdURBQWU7QUFDbkMsb0JBQW9CLHVEQUFlOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEIsMkJBQTJCO0FBQzNCLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFFBQVEsb0JBQW9CLFdBQVc7O0FBRXBFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5REFBeUQ7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseURBQXlEO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1MO0FBQ25MOzs7Ozs7Ozs7Ozs7OztBQy96S0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1VFTkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9vcmRlcmVkbWFwL2luZGV4LmVzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzL2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZHJvcGN1cnNvci9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWV4YW1wbGUtc2V0dXAvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1nYXBjdXJzb3IvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1oaXN0b3J5L2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItaW5wdXRydWxlcy9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWtleW1hcC9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLW1lbnUvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1tb2RlbC9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXNjaGVtYS1iYXNpYy9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXNjaGVtYS1saXN0L2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc3RhdGUvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci10cmFuc2Zvcm0vZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci12aWV3L2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9ub2RlX21vZHVsZXMvcm9wZS1zZXF1ZW5jZS9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vZGVtby9pbmRleC50cyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL3NyYy9hY3Rpb25zLnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vc3JjL2lucHV0UnVsZXMudHMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9zcmMvcGx1Z2luLnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vc3JjL3R5cGVzLnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vc3JjL3V0aWxzLnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL2NyZWx0L2luZGV4LmVzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3czYy1rZXluYW1lL2luZGV4LmVzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDo6LSBQZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhbiBvcmRlcmVkIG1hcHBpbmcgZnJvbVxuLy8gc3RyaW5ncyB0byB2YWx1ZXMsIHdpdGggc29tZSBjb252ZW5pZW50IHVwZGF0ZSBtZXRob2RzLlxuZnVuY3Rpb24gT3JkZXJlZE1hcChjb250ZW50KSB7XG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG59XG5cbk9yZGVyZWRNYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogT3JkZXJlZE1hcCxcblxuICBmaW5kOiBmdW5jdGlvbihrZXkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIGlmICh0aGlzLmNvbnRlbnRbaV0gPT09IGtleSkgcmV0dXJuIGlcbiAgICByZXR1cm4gLTFcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nKSDihpIgP2FueVxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWUgc3RvcmVkIHVuZGVyIGBrZXlgLCBvciByZXR1cm4gdW5kZWZpbmVkIHdoZW5cbiAgLy8gbm8gc3VjaCBrZXkgZXhpc3RzLlxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZChrZXkpO1xuICAgIHJldHVybiBmb3VuZCA9PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuY29udGVudFtmb3VuZCArIDFdXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55LCA/c3RyaW5nKSDihpIgT3JkZXJlZE1hcFxuICAvLyBDcmVhdGUgYSBuZXcgbWFwIGJ5IHJlcGxhY2luZyB0aGUgdmFsdWUgb2YgYGtleWAgd2l0aCBhIG5ld1xuICAvLyB2YWx1ZSwgb3IgYWRkaW5nIGEgYmluZGluZyB0byB0aGUgZW5kIG9mIHRoZSBtYXAuIElmIGBuZXdLZXlgIGlzXG4gIC8vIGdpdmVuLCB0aGUga2V5IG9mIHRoZSBiaW5kaW5nIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGF0IGtleS5cbiAgdXBkYXRlOiBmdW5jdGlvbihrZXksIHZhbHVlLCBuZXdLZXkpIHtcbiAgICB2YXIgc2VsZiA9IG5ld0tleSAmJiBuZXdLZXkgIT0ga2V5ID8gdGhpcy5yZW1vdmUobmV3S2V5KSA6IHRoaXM7XG4gICAgdmFyIGZvdW5kID0gc2VsZi5maW5kKGtleSksIGNvbnRlbnQgPSBzZWxmLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBpZiAoZm91bmQgPT0gLTEpIHtcbiAgICAgIGNvbnRlbnQucHVzaChuZXdLZXkgfHwga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRbZm91bmQgKyAxXSA9IHZhbHVlO1xuICAgICAgaWYgKG5ld0tleSkgY29udGVudFtmb3VuZF0gPSBuZXdLZXk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIFJldHVybiBhIG1hcCB3aXRoIHRoZSBnaXZlbiBrZXkgcmVtb3ZlZCwgaWYgaXQgZXhpc3RlZC5cbiAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmZpbmQoa2V5KTtcbiAgICBpZiAoZm91bmQgPT0gLTEpIHJldHVybiB0aGlzXG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBjb250ZW50LnNwbGljZShmb3VuZCwgMik7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55KSDihpIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBuZXcga2V5IHRvIHRoZSBzdGFydCBvZiB0aGUgbWFwLlxuICBhZGRUb1N0YXJ0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKFtrZXksIHZhbHVlXS5jb25jYXQodGhpcy5yZW1vdmUoa2V5KS5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnkpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIG5ldyBrZXkgdG8gdGhlIGVuZCBvZiB0aGUgbWFwLlxuICBhZGRUb0VuZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5yZW1vdmUoa2V5KS5jb250ZW50LnNsaWNlKCk7XG4gICAgY29udGVudC5wdXNoKGtleSwgdmFsdWUpO1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIHN0cmluZywgYW55KSDihpIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBrZXkgYWZ0ZXIgdGhlIGdpdmVuIGtleS4gSWYgYHBsYWNlYCBpcyBub3QgZm91bmQsIHRoZSBuZXdcbiAgLy8ga2V5IGlzIGFkZGVkIHRvIHRoZSBlbmQuXG4gIGFkZEJlZm9yZTogZnVuY3Rpb24ocGxhY2UsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgd2l0aG91dCA9IHRoaXMucmVtb3ZlKGtleSksIGNvbnRlbnQgPSB3aXRob3V0LmNvbnRlbnQuc2xpY2UoKTtcbiAgICB2YXIgZm91bmQgPSB3aXRob3V0LmZpbmQocGxhY2UpO1xuICAgIGNvbnRlbnQuc3BsaWNlKGZvdW5kID09IC0xID8gY29udGVudC5sZW5ndGggOiBmb3VuZCwgMCwga2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkpXG4gIC8vIENhbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIHRoZSBtYXAsIGluXG4gIC8vIG9yZGVyLlxuICBmb3JFYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICBmKHRoaXMuY29udGVudFtpXSwgdGhpcy5jb250ZW50W2kgKyAxXSk7XG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgcHJlcGVuZGluZyB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYCBiZWZvcmUgdGhlIGtleXMgaW4gYG1hcGAuXG4gIHByZXBlbmQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGlmICghbWFwLnNpemUpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKG1hcC5jb250ZW50LmNvbmNhdCh0aGlzLnN1YnRyYWN0KG1hcCkuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgYXBwZW5kaW5nIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgIGFmdGVyIHRoZSBrZXlzIGluIGBtYXBgLlxuICBhcHBlbmQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGlmICghbWFwLnNpemUpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKHRoaXMuc3VidHJhY3QobWFwKS5jb250ZW50LmNvbmNhdChtYXAuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG1hcCBjb250YWluaW5nIGFsbCB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYC5cbiAgc3VidHJhY3Q6IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICByZXN1bHQgPSByZXN1bHQucmVtb3ZlKG1hcC5jb250ZW50W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLy8gOjogbnVtYmVyXG4gIC8vIFRoZSBhbW91bnQgb2Yga2V5cyBpbiB0aGlzIG1hcC5cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPj4gMVxuICB9XG59O1xuXG4vLyA6OiAoP3VuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4vLyBSZXR1cm4gYSBtYXAgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC4gSWYgbnVsbCwgY3JlYXRlIGFuIGVtcHR5XG4vLyBtYXAuIElmIGdpdmVuIGFuIG9yZGVyZWQgbWFwLCByZXR1cm4gdGhhdCBtYXAgaXRzZWxmLiBJZiBnaXZlbiBhblxuLy8gb2JqZWN0LCBjcmVhdGUgYSBtYXAgZnJvbSB0aGUgb2JqZWN0J3MgcHJvcGVydGllcy5cbk9yZGVyZWRNYXAuZnJvbSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9yZGVyZWRNYXApIHJldHVybiB2YWx1ZVxuICB2YXIgY29udGVudCA9IFtdO1xuICBpZiAodmFsdWUpIGZvciAodmFyIHByb3AgaW4gdmFsdWUpIGNvbnRlbnQucHVzaChwcm9wLCB2YWx1ZVtwcm9wXSk7XG4gIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxufTtcblxudmFyIG9yZGVyZWRtYXAgPSBPcmRlcmVkTWFwO1xuXG5leHBvcnQgZGVmYXVsdCBvcmRlcmVkbWFwO1xuIiwiaW1wb3J0IHsgbGlmdFRhcmdldCwgY2FuSm9pbiwgam9pblBvaW50LCBjYW5TcGxpdCwgUmVwbGFjZUFyb3VuZFN0ZXAsIGZpbmRXcmFwcGluZyB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBGcmFnbWVudCwgU2xpY2UgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBTZWxlY3Rpb24sIEFsbFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBEZWxldGUgdGhlIHNlbGVjdGlvbiwgaWYgdGhlcmUgaXMgb25lLlxuZnVuY3Rpb24gZGVsZXRlU2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChkaXNwYXRjaCkgeyBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSwgP0VkaXRvclZpZXcpIOKGkiBib29sXG4vLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHRyeSB0b1xuLy8gcmVkdWNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYmxvY2sgYW5kIHRoZSBvbmUgYmVmb3JlIGl04oCUaWZcbi8vIHRoZXJlJ3MgYSBibG9jayBkaXJlY3RseSBiZWZvcmUgaXQgdGhhdCBjYW4gYmUgam9pbmVkLCBqb2luIHRoZW0uXG4vLyBJZiBub3QsIHRyeSB0byBtb3ZlIHRoZSBzZWxlY3RlZCBibG9jayBjbG9zZXIgdG8gdGhlIG5leHQgb25lIGluXG4vLyB0aGUgZG9jdW1lbnQgc3RydWN0dXJlIGJ5IGxpZnRpbmcgaXQgb3V0IG9mIGl0cyBwYXJlbnQgb3IgbW92aW5nIGl0XG4vLyBpbnRvIGEgcGFyZW50IG9mIHRoZSBwcmV2aW91cyBibG9jay4gV2lsbCB1c2UgdGhlIHZpZXcgZm9yIGFjY3VyYXRlXG4vLyAoYmlkaS1hd2FyZSkgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbmZ1bmN0aW9uIGpvaW5CYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyICRjdXJzb3IgPSByZWYuJGN1cnNvcjtcbiAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPiAwKSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgdmFyICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlIHRoaXMsIHRyeSB0byBsaWZ0XG4gIGlmICghJGN1dCkge1xuICAgIHZhciByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB2YXIgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlO1xuICAvLyBBcHBseSB0aGUgam9pbmluZyBhbGdvcml0aG1cbiAgaWYgKCFiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYmVsb3cgaGFzIG5vIGNvbnRlbnQgYW5kIHRoZSBub2RlIGFib3ZlIGlzXG4gIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBiZWxvdyBhbmQgc2VsZWN0IHRoZSBvbmUgYWJvdmUuXG4gIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJlxuICAgICAgKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikgfHwgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoYmVmb3JlKSkpIHtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIHZhciB0ciA9IHN0YXRlLnRyLmRlbGV0ZVJhbmdlKCRjdXJzb3IuYmVmb3JlKCksICRjdXJzb3IuYWZ0ZXIoKSk7XG4gICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcywgLTEpKSwgLTEpXG4gICAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplKSk7XG4gICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIElmIHRoZSBub2RlIGJlZm9yZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgaWYgKGJlZm9yZS5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgIGlmIChkaXNwYXRjaCkgeyBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRjdXQucG9zKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gdGV4dGJsb2NrQXQobm9kZSwgc2lkZSwgb25seSkge1xuICBmb3IgKDsgbm9kZTsgbm9kZSA9IChzaWRlID09IFwic3RhcnRcIiA/IG5vZGUuZmlyc3RDaGlsZCA6IG5vZGUubGFzdENoaWxkKSkge1xuICAgIGlmIChub2RlLmlzVGV4dGJsb2NrKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAob25seSAmJiBub2RlLmNoaWxkQ291bnQgIT0gMSkgeyByZXR1cm4gZmFsc2UgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSwgP0VkaXRvclZpZXcpIOKGkiBib29sXG4vLyBXaGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG4vLyB0aGUgbm9kZSBiZWZvcmUgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4vLyBib3VuZCB0byBrZXlzIGxpa2UgYmFja3NwYWNlLCBhZnRlclxuLy8gW2Bqb2luQmFja3dhcmRgXSgjY29tbWFuZHMuam9pbkJhY2t3YXJkKSBvciBvdGhlciBkZWxldGluZ1xuLy8gY29tbWFuZHMsIGFzIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0IGFsbG93XG4vLyBkZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG5mdW5jdGlvbiBzZWxlY3ROb2RlQmFja3dhcmQoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIHZhciAkaGVhZCA9IHJlZi4kaGVhZDtcbiAgdmFyIGVtcHR5ID0gcmVmLmVtcHR5O1xuICB2YXIgJGN1dCA9ICRoZWFkO1xuICBpZiAoIWVtcHR5KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPiAwKSB7IHJldHVybiBmYWxzZSB9XG4gICAgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGhlYWQpO1xuICB9XG4gIHZhciBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVCZWZvcmU7XG4gIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKVxuICAgIHsgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MgLSBub2RlLm5vZGVTaXplKSkuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZmluZEN1dEJlZm9yZSgkcG9zKSB7XG4gIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZykgeyBmb3IgKHZhciBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKCRwb3MuaW5kZXgoaSkgPiAwKSB7IHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYmVmb3JlKGkgKyAxKSkgfVxuICAgIGlmICgkcG9zLm5vZGUoaSkudHlwZS5zcGVjLmlzb2xhdGluZykgeyBicmVhayB9XG4gIH0gfVxuICByZXR1cm4gbnVsbFxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSwgP0VkaXRvclZpZXcpIOKGkiBib29sXG4vLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYVxuLy8gdGV4dGJsb2NrLCB0cnkgdG8gcmVkdWNlIG9yIHJlbW92ZSB0aGUgYm91bmRhcnkgYmV0d2VlbiB0aGF0IGJsb2NrXG4vLyBhbmQgdGhlIG9uZSBhZnRlciBpdCwgZWl0aGVyIGJ5IGpvaW5pbmcgdGhlbSBvciBieSBtb3ZpbmcgdGhlIG90aGVyXG4vLyBibG9jayBjbG9zZXIgdG8gdGhpcyBvbmUgaW4gdGhlIHRyZWUgc3RydWN0dXJlLiBXaWxsIHVzZSB0aGUgdmlld1xuLy8gZm9yIGFjY3VyYXRlIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG5mdW5jdGlvbiBqb2luRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyICRjdXJzb3IgPSByZWYuJGN1cnNvcjtcbiAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA8ICRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSkpXG4gICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gIHZhciAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYWZ0ZXIgdGhpcywgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gIGlmICghJGN1dCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIHZhciBhZnRlciA9ICRjdXQubm9kZUFmdGVyO1xuICAvLyBUcnkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gIGlmIChkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpIHsgcmV0dXJuIHRydWUgfVxuXG4gIC8vIElmIHRoZSBub2RlIGFib3ZlIGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBiZWxvdyBpc1xuICAvLyBzZWxlY3RhYmxlLCBkZWxldGUgdGhlIG5vZGUgYWJvdmUgYW5kIHNlbGVjdCB0aGUgb25lIGJlbG93LlxuICBpZiAoJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiZcbiAgICAgICh0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShhZnRlcikpKSB7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICB2YXIgdHIgPSBzdGF0ZS50ci5kZWxldGVSYW5nZSgkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCkpO1xuICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpID8gU2VsZWN0aW9uLmZpbmRGcm9tKHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSksIDEpXG4gICAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSkpO1xuICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICBpZiAoYWZ0ZXIuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbiksID9FZGl0b3JWaWV3KSDihpIgYm9vbFxuLy8gV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLCBzZWxlY3Rcbi8vIHRoZSBub2RlIGNvbWluZyBhZnRlciB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWRcbi8vIHRvIGJlIGJvdW5kIHRvIGtleXMgbGlrZSBkZWxldGUsIGFmdGVyXG4vLyBbYGpvaW5Gb3J3YXJkYF0oI2NvbW1hbmRzLmpvaW5Gb3J3YXJkKSBhbmQgc2ltaWxhciBkZWxldGluZ1xuLy8gY29tbWFuZHMsIHRvIHByb3ZpZGUgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3Rcbi8vIGFsbG93IGRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbmZ1bmN0aW9uIHNlbGVjdE5vZGVGb3J3YXJkKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgJGhlYWQgPSByZWYuJGhlYWQ7XG4gIHZhciBlbXB0eSA9IHJlZi5lbXB0eTtcbiAgdmFyICRjdXQgPSAkaGVhZDtcbiAgaWYgKCFlbXB0eSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKSB7XG4gICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0IDwgJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAkY3V0ID0gZmluZEN1dEFmdGVyKCRoZWFkKTtcbiAgfVxuICB2YXIgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQWZ0ZXI7XG4gIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKVxuICAgIHsgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MpKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaW5kQ3V0QWZ0ZXIoJHBvcykge1xuICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIHsgZm9yICh2YXIgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBwYXJlbnQgPSAkcG9zLm5vZGUoaSk7XG4gICAgaWYgKCRwb3MuaW5kZXgoaSkgKyAxIDwgcGFyZW50LmNoaWxkQ291bnQpIHsgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5hZnRlcihpICsgMSkpIH1cbiAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIHsgYnJlYWsgfVxuICB9IH1cbiAgcmV0dXJuIG51bGxcbn1cblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBKb2luIHRoZSBzZWxlY3RlZCBibG9jayBvciwgaWYgdGhlcmUgaXMgYSB0ZXh0IHNlbGVjdGlvbiwgdGhlXG4vLyBjbG9zZXN0IGFuY2VzdG9yIGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24gdGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoXG4vLyB0aGUgc2libGluZyBhYm92ZSBpdC5cbmZ1bmN0aW9uIGpvaW5VcChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgbm9kZVNlbCA9IHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24sIHBvaW50O1xuICBpZiAobm9kZVNlbCkge1xuICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC5mcm9tKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHBvaW50ID0gc2VsLmZyb207XG4gIH0gZWxzZSB7XG4gICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwuZnJvbSwgLTEpO1xuICAgIGlmIChwb2ludCA9PSBudWxsKSB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdmFyIHRyID0gc3RhdGUudHIuam9pbihwb2ludCk7XG4gICAgaWYgKG5vZGVTZWwpIHsgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9pbnQgLSBzdGF0ZS5kb2MucmVzb2x2ZShwb2ludCkubm9kZUJlZm9yZS5ub2RlU2l6ZSkpOyB9XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBKb2luIHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgdGhlIHNlbGVjdGlvblxuLy8gdGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoIHRoZSBzaWJsaW5nIGFmdGVyIGl0LlxuZnVuY3Rpb24gam9pbkRvd24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHBvaW50O1xuICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC50bykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBwb2ludCA9IHNlbC50bztcbiAgfSBlbHNlIHtcbiAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC50bywgMSk7XG4gICAgaWYgKHBvaW50ID09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgfVxuICBpZiAoZGlzcGF0Y2gpXG4gICAgeyBkaXNwYXRjaChzdGF0ZS50ci5qb2luKHBvaW50KS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIExpZnQgdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGVcbi8vIHNlbGVjdGlvbiB0aGF0IGNhbiBiZSBsaWZ0ZWQsIG91dCBvZiBpdHMgcGFyZW50IG5vZGUuXG5mdW5jdGlvbiBsaWZ0KHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgJGZyb20gPSByZWYuJGZyb207XG4gIHZhciAkdG8gPSByZWYuJHRvO1xuICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKSB7IGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aG9zZSB0eXBlIGhhcyBhIHRydXRoeVxuLy8gW2Bjb2RlYF0oI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCByZXBsYWNlIHRoZVxuLy8gc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIG5ld2xpbmVJbkNvZGUoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIHZhciAkaGVhZCA9IHJlZi4kaGVhZDtcbiAgdmFyICRhbmNob3IgPSByZWYuJGFuY2hvcjtcbiAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKSB7IGRpc3BhdGNoKHN0YXRlLnRyLmluc2VydFRleHQoXCJcXG5cIikuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkrKykge1xuICAgIHZhciByZWYgPSBtYXRjaC5lZGdlKGkpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSB7IHJldHVybiB0eXBlIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIFdoZW4gdGhlIHNlbGVjdGlvbiBpcyBpbiBhIG5vZGUgd2l0aCBhIHRydXRoeVxuLy8gW2Bjb2RlYF0oI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCBjcmVhdGUgYVxuLy8gZGVmYXVsdCBibG9jayBhZnRlciB0aGUgY29kZSBibG9jaywgYW5kIG1vdmUgdGhlIGN1cnNvciB0aGVyZS5cbmZ1bmN0aW9uIGV4aXRDb2RlKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgJGhlYWQgPSByZWYuJGhlYWQ7XG4gIHZhciAkYW5jaG9yID0gcmVmLiRhbmNob3I7XG4gIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBhYm92ZSA9ICRoZWFkLm5vZGUoLTEpLCBhZnRlciA9ICRoZWFkLmluZGV4QWZ0ZXIoLTEpLCB0eXBlID0gZGVmYXVsdEJsb2NrQXQoYWJvdmUuY29udGVudE1hdGNoQXQoYWZ0ZXIpKTtcbiAgaWYgKCFhYm92ZS5jYW5SZXBsYWNlV2l0aChhZnRlciwgYWZ0ZXIsIHR5cGUpKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHZhciBwb3MgPSAkaGVhZC5hZnRlcigpLCB0ciA9IHN0YXRlLnRyLnJlcGxhY2VXaXRoKHBvcywgcG9zLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHBvcyksIDEpKTtcbiAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIElmIGEgYmxvY2sgbm9kZSBpcyBzZWxlY3RlZCwgY3JlYXRlIGFuIGVtcHR5IHBhcmFncmFwaCBiZWZvcmUgKGlmXG4vLyBpdCBpcyBpdHMgcGFyZW50J3MgZmlyc3QgY2hpbGQpIG9yIGFmdGVyIGl0LlxuZnVuY3Rpb24gY3JlYXRlUGFyYWdyYXBoTmVhcihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyICRmcm9tID0gc2VsLiRmcm9tO1xuICB2YXIgJHRvID0gc2VsLiR0bztcbiAgaWYgKHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiB8fCAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIHR5cGUgPSBkZWZhdWx0QmxvY2tBdCgkdG8ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCR0by5pbmRleEFmdGVyKCkpKTtcbiAgaWYgKCF0eXBlIHx8ICF0eXBlLmlzVGV4dGJsb2NrKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHZhciBzaWRlID0gKCEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJHRvLmluZGV4KCkgPCAkdG8ucGFyZW50LmNoaWxkQ291bnQgPyAkZnJvbSA6ICR0bykucG9zO1xuICAgIHZhciB0ciA9IHN0YXRlLnRyLmluc2VydChzaWRlLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgc2lkZSArIDEpKTtcbiAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIElmIHRoZSBjdXJzb3IgaXMgaW4gYW4gZW1wdHkgdGV4dGJsb2NrIHRoYXQgY2FuIGJlIGxpZnRlZCwgbGlmdCB0aGVcbi8vIGJsb2NrLlxuZnVuY3Rpb24gbGlmdEVtcHR5QmxvY2soc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIHZhciAkY3Vyc29yID0gcmVmLiRjdXJzb3I7XG4gIGlmICghJGN1cnNvciB8fCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCRjdXJzb3IuZGVwdGggPiAxICYmICRjdXJzb3IuYWZ0ZXIoKSAhPSAkY3Vyc29yLmVuZCgtMSkpIHtcbiAgICB2YXIgYmVmb3JlID0gJGN1cnNvci5iZWZvcmUoKTtcbiAgICBpZiAoY2FuU3BsaXQoc3RhdGUuZG9jLCBiZWZvcmUpKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoYmVmb3JlKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgdmFyIHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKSB7IGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBTcGxpdCB0aGUgcGFyZW50IGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24uIElmIHRoZSBzZWxlY3Rpb24gaXMgYSB0ZXh0XG4vLyBzZWxlY3Rpb24sIGFsc28gZGVsZXRlIGl0cyBjb250ZW50LlxuZnVuY3Rpb24gc3BsaXRCbG9jayhzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyICRmcm9tID0gcmVmLiRmcm9tO1xuICB2YXIgJHRvID0gcmVmLiR0bztcbiAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc3RhdGUuc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFjYW5TcGxpdChzdGF0ZS5kb2MsICRmcm9tLnBvcykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdmFyIGF0RW5kID0gJHRvLnBhcmVudE9mZnNldCA9PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICB2YXIgdHIgPSBzdGF0ZS50cjtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiB8fCBzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24pIHsgdHIuZGVsZXRlU2VsZWN0aW9uKCk7IH1cbiAgICB2YXIgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PSAwID8gbnVsbCA6IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoLTEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoLTEpKSk7XG4gICAgdmFyIHR5cGVzID0gYXRFbmQgJiYgZGVmbHQgPyBbe3R5cGU6IGRlZmx0fV0gOiBudWxsO1xuICAgIHZhciBjYW4gPSBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICBpZiAoIXR5cGVzICYmICFjYW4gJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCAmJiBbe3R5cGU6IGRlZmx0fV0pKSB7XG4gICAgICB0eXBlcyA9IFt7dHlwZTogZGVmbHR9XTtcbiAgICAgIGNhbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjYW4pIHtcbiAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICAgIGlmICghYXRFbmQgJiYgISRmcm9tLnBhcmVudE9mZnNldCAmJiAkZnJvbS5wYXJlbnQudHlwZSAhPSBkZWZsdCkge1xuICAgICAgICB2YXIgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0KTtcbiAgICAgICAgaWYgKCRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSlcbiAgICAgICAgICB7IHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCBkZWZsdCk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBBY3RzIGxpa2UgW2BzcGxpdEJsb2NrYF0oI2NvbW1hbmRzLnNwbGl0QmxvY2spLCBidXQgd2l0aG91dFxuLy8gcmVzZXR0aW5nIHRoZSBzZXQgb2YgYWN0aXZlIG1hcmtzIGF0IHRoZSBjdXJzb3IuXG5mdW5jdGlvbiBzcGxpdEJsb2NrS2VlcE1hcmtzKHN0YXRlLCBkaXNwYXRjaCkge1xuICByZXR1cm4gc3BsaXRCbG9jayhzdGF0ZSwgZGlzcGF0Y2ggJiYgKGZ1bmN0aW9uICh0cikge1xuICAgIHZhciBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgaWYgKG1hcmtzKSB7IHRyLmVuc3VyZU1hcmtzKG1hcmtzKTsgfVxuICAgIGRpc3BhdGNoKHRyKTtcbiAgfSkpXG59XG5cbi8vIDo6IChFZGl0b3JTdGF0ZSwgPyh0cjogVHJhbnNhY3Rpb24pKSDihpIgYm9vbFxuLy8gTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBub2RlIHdyYXBwaW5nIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgaWZcbi8vIGFueS4gKFdpbGwgbm90IHNlbGVjdCB0aGUgZG9jdW1lbnQgbm9kZS4pXG5mdW5jdGlvbiBzZWxlY3RQYXJlbnROb2RlKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgJGZyb20gPSByZWYuJGZyb207XG4gIHZhciB0byA9IHJlZi50bztcbiAgdmFyIHBvcztcbiAgdmFyIHNhbWUgPSAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gIGlmIChzYW1lID09IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgcG9zID0gJGZyb20uYmVmb3JlKHNhbWUpO1xuICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgcG9zKSkpOyB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIDo6IChFZGl0b3JTdGF0ZSwgPyh0cjogVHJhbnNhY3Rpb24pKSDihpIgYm9vbFxuLy8gU2VsZWN0IHRoZSB3aG9sZSBkb2N1bWVudC5cbmZ1bmN0aW9uIHNlbGVjdEFsbChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKGRpc3BhdGNoKSB7IGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgQWxsU2VsZWN0aW9uKHN0YXRlLmRvYykpKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBqb2luTWF5YmVDbGVhcihzdGF0ZSwgJHBvcywgZGlzcGF0Y2gpIHtcbiAgdmFyIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlciwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCAhYmVmb3JlLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQoYWZ0ZXIudHlwZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCFiZWZvcmUuY29udGVudC5zaXplICYmICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXggLSAxLCBpbmRleCkpIHtcbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRwb3MucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkcG9zLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmICghJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSB8fCAhKGFmdGVyLmlzVGV4dGJsb2NrIHx8IGNhbkpvaW4oc3RhdGUuZG9jLCAkcG9zLnBvcykpKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKVxuICAgIHsgZGlzcGF0Y2goc3RhdGUudHJcbiAgICAgICAgICAgICAuY2xlYXJJbmNvbXBhdGlibGUoJHBvcy5wb3MsIGJlZm9yZS50eXBlLCBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKVxuICAgICAgICAgICAgIC5qb2luKCRwb3MucG9zKVxuICAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICB2YXIgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBhZnRlciA9ICRjdXQubm9kZUFmdGVyLCBjb25uLCBtYXRjaDtcbiAgaWYgKGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpIHsgcmV0dXJuIHRydWUgfVxuXG4gIHZhciBjYW5EZWxBZnRlciA9ICRjdXQucGFyZW50LmNhblJlcGxhY2UoJGN1dC5pbmRleCgpLCAkY3V0LmluZGV4KCkgKyAxKTtcbiAgaWYgKGNhbkRlbEFmdGVyICYmXG4gICAgICAoY29ubiA9IChtYXRjaCA9IGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpLmZpbmRXcmFwcGluZyhhZnRlci50eXBlKSkgJiZcbiAgICAgIG1hdGNoLm1hdGNoVHlwZShjb25uWzBdIHx8IGFmdGVyLnR5cGUpLnZhbGlkRW5kKSB7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICB2YXIgZW5kID0gJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgZm9yICh2YXIgaSA9IGNvbm4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHsgd3JhcCA9IEZyYWdtZW50LmZyb20oY29ubltpXS5jcmVhdGUobnVsbCwgd3JhcCkpOyB9XG4gICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbShiZWZvcmUuY29weSh3cmFwKSk7XG4gICAgICB2YXIgdHIgPSBzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkY3V0LnBvcyAtIDEsIGVuZCwgJGN1dC5wb3MsIGVuZCwgbmV3IFNsaWNlKHdyYXAsIDEsIDApLCBjb25uLmxlbmd0aCwgdHJ1ZSkpO1xuICAgICAgdmFyIGpvaW5BdCA9IGVuZCArIDIgKiBjb25uLmxlbmd0aDtcbiAgICAgIGlmIChjYW5Kb2luKHRyLmRvYywgam9pbkF0KSkgeyB0ci5qb2luKGpvaW5BdCk7IH1cbiAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdmFyIHNlbEFmdGVyID0gU2VsZWN0aW9uLmZpbmRGcm9tKCRjdXQsIDEpO1xuICB2YXIgcmFuZ2UgPSBzZWxBZnRlciAmJiBzZWxBZnRlci4kZnJvbS5ibG9ja1JhbmdlKHNlbEFmdGVyLiR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0ID49ICRjdXQuZGVwdGgpIHtcbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoY2FuRGVsQWZ0ZXIgJiYgdGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIiwgdHJ1ZSkgJiYgdGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSkge1xuICAgIHZhciBhdCA9IGJlZm9yZSwgd3JhcCQxID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgd3JhcCQxLnB1c2goYXQpO1xuICAgICAgaWYgKGF0LmlzVGV4dGJsb2NrKSB7IGJyZWFrIH1cbiAgICAgIGF0ID0gYXQubGFzdENoaWxkO1xuICAgIH1cbiAgICB2YXIgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyRGVwdGggPSAxO1xuICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclRleHQgPSBhZnRlclRleHQuZmlyc3RDaGlsZCkgeyBhZnRlckRlcHRoKys7IH1cbiAgICBpZiAoYXQuY2FuUmVwbGFjZShhdC5jaGlsZENvdW50LCBhdC5jaGlsZENvdW50LCBhZnRlclRleHQuY29udGVudCkpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB2YXIgZW5kJDEgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gd3JhcCQxLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkgeyBlbmQkMSA9IEZyYWdtZW50LmZyb20od3JhcCQxW2kkMV0uY29weShlbmQkMSkpOyB9XG4gICAgICAgIHZhciB0ciQxID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSB3cmFwJDEubGVuZ3RoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY3V0LnBvcyArIGFmdGVyRGVwdGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUgLSBhZnRlckRlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2xpY2UoZW5kJDEsIHdyYXAkMS5sZW5ndGgsIDApLCAwLCB0cnVlKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyJDEuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBQYXJhbWV0ZXJpemVkIGNvbW1hbmRzXG5cbi8vIDo6IChOb2RlVHlwZSwgP09iamVjdCkg4oaSIChzdGF0ZTogRWRpdG9yU3RhdGUsIGRpc3BhdGNoOiA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBXcmFwIHRoZSBzZWxlY3Rpb24gaW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIHdpdGggdGhlIGdpdmVuXG4vLyBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gd3JhcEluKG5vZGVUeXBlLCBhdHRycykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICB2YXIgJGZyb20gPSByZWYuJGZyb207XG4gICAgdmFyICR0byA9IHJlZi4kdG87XG4gICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB3cmFwcGluZyA9IHJhbmdlICYmIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICBpZiAoIXdyYXBwaW5nKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGRpc3BhdGNoKSB7IGRpc3BhdGNoKHN0YXRlLnRyLndyYXAocmFuZ2UsIHdyYXBwaW5nKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuLy8gOjogKE5vZGVUeXBlLCA/T2JqZWN0KSDihpIgKHN0YXRlOiBFZGl0b3JTdGF0ZSwgZGlzcGF0Y2g6ID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIFJldHVybnMgYSBjb21tYW5kIHRoYXQgdHJpZXMgdG8gc2V0IHRoZSBzZWxlY3RlZCB0ZXh0YmxvY2tzIHRvIHRoZVxuLy8gZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG5mdW5jdGlvbiBzZXRCbG9ja1R5cGUobm9kZVR5cGUsIGF0dHJzKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIHZhciBmcm9tID0gcmVmLmZyb207XG4gICAgdmFyIHRvID0gcmVmLnRvO1xuICAgIHZhciBhcHBsaWNhYmxlID0gZmFsc2U7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUsIHBvcykge1xuICAgICAgaWYgKGFwcGxpY2FibGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLmhhc01hcmt1cChub2RlVHlwZSwgYXR0cnMpKSB7IHJldHVybiB9XG4gICAgICBpZiAobm9kZS50eXBlID09IG5vZGVUeXBlKSB7XG4gICAgICAgIGFwcGxpY2FibGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICAgICAgYXBwbGljYWJsZSA9ICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFwcGxpY2FibGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuc2V0QmxvY2tUeXBlKGZyb20sIHRvLCBub2RlVHlwZSwgYXR0cnMpLnNjcm9sbEludG9WaWV3KCkpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQXBwbGllcyhkb2MsIHJhbmdlcywgdHlwZSkge1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICB2YXIgcmVmID0gcmFuZ2VzW2ldO1xuICAgIHZhciAkZnJvbSA9IHJlZi4kZnJvbTtcbiAgICB2YXIgJHRvID0gcmVmLiR0bztcbiAgICB2YXIgY2FuID0gJGZyb20uZGVwdGggPT0gMCA/IGRvYy50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpIDogZmFsc2U7XG4gICAgZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoY2FuKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBjYW4gPSBub2RlLmlubGluZUNvbnRlbnQgJiYgbm9kZS50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpO1xuICAgIH0pO1xuICAgIGlmIChjYW4pIHsgcmV0dXJuIHsgdjogdHJ1ZSB9IH1cbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZXR1cm5lZCA9IGxvb3AoIGkgKTtcblxuICAgIGlmICggcmV0dXJuZWQgKSByZXR1cm4gcmV0dXJuZWQudjtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gOjogKE1hcmtUeXBlLCA/T2JqZWN0KSDihpIgKHN0YXRlOiBFZGl0b3JTdGF0ZSwgZGlzcGF0Y2g6ID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIENyZWF0ZSBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB0b2dnbGVzIHRoZSBnaXZlbiBtYXJrIHdpdGggdGhlXG4vLyBnaXZlbiBhdHRyaWJ1dGVzLiBXaWxsIHJldHVybiBgZmFsc2VgIHdoZW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4vLyBkb2Vzbid0IHN1cHBvcnQgdGhhdCBtYXJrLiBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBtYXJrIGlmIGFueSBtYXJrc1xuLy8gb2YgdGhhdCB0eXBlIGV4aXN0IGluIHRoZSBzZWxlY3Rpb24sIG9yIGFkZCBpdCBvdGhlcndpc2UuIElmIHRoZVxuLy8gc2VsZWN0aW9uIGlzIGVtcHR5LCB0aGlzIGFwcGxpZXMgdG8gdGhlIFtzdG9yZWRcbi8vIG1hcmtzXSgjc3RhdGUuRWRpdG9yU3RhdGUuc3RvcmVkTWFya3MpIGluc3RlYWQgb2YgYSByYW5nZSBvZiB0aGVcbi8vIGRvY3VtZW50LlxuZnVuY3Rpb24gdG9nZ2xlTWFyayhtYXJrVHlwZSwgYXR0cnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgdmFyIGVtcHR5ID0gcmVmLmVtcHR5O1xuICAgIHZhciAkY3Vyc29yID0gcmVmLiRjdXJzb3I7XG4gICAgdmFyIHJhbmdlcyA9IHJlZi5yYW5nZXM7XG4gICAgaWYgKChlbXB0eSAmJiAhJGN1cnNvcikgfHwgIW1hcmtBcHBsaWVzKHN0YXRlLmRvYywgcmFuZ2VzLCBtYXJrVHlwZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgIGlmIChtYXJrVHlwZS5pc0luU2V0KHN0YXRlLnN0b3JlZE1hcmtzIHx8ICRjdXJzb3IubWFya3MoKSkpXG4gICAgICAgICAgeyBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgZGlzcGF0Y2goc3RhdGUudHIuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKSk7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoYXMgPSBmYWxzZSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7ICFoYXMgJiYgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByZWYkMSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICB2YXIgJGZyb20gPSByZWYkMS4kZnJvbTtcbiAgICAgICAgICB2YXIgJHRvID0gcmVmJDEuJHRvO1xuICAgICAgICAgIGhhcyA9IHN0YXRlLmRvYy5yYW5nZUhhc01hcmsoJGZyb20ucG9zLCAkdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcmFuZ2VzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB2YXIgcmVmJDIgPSByYW5nZXNbaSQxXTtcbiAgICAgICAgICB2YXIgJGZyb20kMSA9IHJlZiQyLiRmcm9tO1xuICAgICAgICAgIHZhciAkdG8kMSA9IHJlZiQyLiR0bztcbiAgICAgICAgICBpZiAoaGFzKSB7XG4gICAgICAgICAgICB0ci5yZW1vdmVNYXJrKCRmcm9tJDEucG9zLCAkdG8kMS5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZyb20gPSAkZnJvbSQxLnBvcywgdG8gPSAkdG8kMS5wb3MsIHN0YXJ0ID0gJGZyb20kMS5ub2RlQWZ0ZXIsIGVuZCA9ICR0byQxLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICB2YXIgc3BhY2VTdGFydCA9IHN0YXJ0ICYmIHN0YXJ0LmlzVGV4dCA/IC9eXFxzKi8uZXhlYyhzdGFydC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgdmFyIHNwYWNlRW5kID0gZW5kICYmIGVuZC5pc1RleHQgPyAvXFxzKiQvLmV4ZWMoZW5kLnRleHQpWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBpZiAoZnJvbSArIHNwYWNlU3RhcnQgPCB0bykgeyBmcm9tICs9IHNwYWNlU3RhcnQ7IHRvIC09IHNwYWNlRW5kOyB9XG4gICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgaXNKb2luYWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRyKSB7XG4gICAgaWYgKCF0ci5pc0dlbmVyaWMpIHsgcmV0dXJuIGRpc3BhdGNoKHRyKSB9XG5cbiAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJhbmdlcy5sZW5ndGg7IGorKylcbiAgICAgICAgeyByYW5nZXNbal0gPSBtYXAubWFwKHJhbmdlc1tqXSk7IH1cbiAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uIChfcywgX2UsIGZyb20sIHRvKSB7IHJldHVybiByYW5nZXMucHVzaChmcm9tLCB0byk7IH0pO1xuICAgIH1cblxuICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggam9pbmFibGUgcG9pbnRzIGV4aXN0IGluc2lkZSB0aG9zZSByYW5nZXMsXG4gICAgLy8gYnkgY2hlY2tpbmcgYWxsIG5vZGUgYm91bmRhcmllcyBpbiB0aGVpciBwYXJlbnQgbm9kZXMuXG4gICAgdmFyIGpvaW5hYmxlID0gW107XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcmFuZ2VzLmxlbmd0aDsgaSQxICs9IDIpIHtcbiAgICAgIHZhciBmcm9tID0gcmFuZ2VzW2kkMV0sIHRvID0gcmFuZ2VzW2kkMSArIDFdO1xuICAgICAgdmFyICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksIGRlcHRoID0gJGZyb20uc2hhcmVkRGVwdGgodG8pLCBwYXJlbnQgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gJGZyb20uaW5kZXhBZnRlcihkZXB0aCksIHBvcyA9ICRmcm9tLmFmdGVyKGRlcHRoICsgMSk7IHBvcyA8PSB0bzsgKytpbmRleCkge1xuICAgICAgICB2YXIgYWZ0ZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgIGlmICghYWZ0ZXIpIHsgYnJlYWsgfVxuICAgICAgICBpZiAoaW5kZXggJiYgam9pbmFibGUuaW5kZXhPZihwb3MpID09IC0xKSB7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgIGlmIChiZWZvcmUudHlwZSA9PSBhZnRlci50eXBlICYmIGlzSm9pbmFibGUoYmVmb3JlLCBhZnRlcikpXG4gICAgICAgICAgICB7IGpvaW5hYmxlLnB1c2gocG9zKTsgfVxuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBhZnRlci5ub2RlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSm9pbiB0aGUgam9pbmFibGUgcG9pbnRzXG4gICAgam9pbmFibGUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuICAgIGZvciAodmFyIGkkMiA9IGpvaW5hYmxlLmxlbmd0aCAtIDE7IGkkMiA+PSAwOyBpJDItLSkge1xuICAgICAgaWYgKGNhbkpvaW4odHIuZG9jLCBqb2luYWJsZVtpJDJdKSkgeyB0ci5qb2luKGpvaW5hYmxlW2kkMl0pOyB9XG4gICAgfVxuICAgIGRpc3BhdGNoKHRyKTtcbiAgfVxufVxuXG4vLyA6OiAoKHN0YXRlOiBFZGl0b3JTdGF0ZSwgPyh0cjogVHJhbnNhY3Rpb24pKSDihpIgYm9vbCwgdW5pb248KGJlZm9yZTogTm9kZSwgYWZ0ZXI6IE5vZGUpIOKGkiBib29sLCBbc3RyaW5nXT4pIOKGkiAoc3RhdGU6IEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBXcmFwIGEgY29tbWFuZCBzbyB0aGF0LCB3aGVuIGl0IHByb2R1Y2VzIGEgdHJhbnNmb3JtIHRoYXQgY2F1c2VzXG4vLyB0d28gam9pbmFibGUgbm9kZXMgdG8gZW5kIHVwIG5leHQgdG8gZWFjaCBvdGhlciwgdGhvc2UgYXJlIGpvaW5lZC5cbi8vIE5vZGVzIGFyZSBjb25zaWRlcmVkIGpvaW5hYmxlIHdoZW4gdGhleSBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmRcbi8vIHdoZW4gdGhlIGBpc0pvaW5hYmxlYCBwcmVkaWNhdGUgcmV0dXJucyB0cnVlIGZvciB0aGVtIG9yLCBpZiBhblxuLy8gYXJyYXkgb2Ygc3RyaW5ncyB3YXMgcGFzc2VkLCBpZiB0aGVpciBub2RlIHR5cGUgbmFtZSBpcyBpbiB0aGF0XG4vLyBhcnJheS5cbmZ1bmN0aW9uIGF1dG9Kb2luKGNvbW1hbmQsIGlzSm9pbmFibGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaXNKb2luYWJsZSkpIHtcbiAgICB2YXIgdHlwZXMgPSBpc0pvaW5hYmxlO1xuICAgIGlzSm9pbmFibGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdHlwZXMuaW5kZXhPZihub2RlLnR5cGUubmFtZSkgPiAtMTsgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgeyByZXR1cm4gY29tbWFuZChzdGF0ZSwgZGlzcGF0Y2ggJiYgd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgaXNKb2luYWJsZSksIHZpZXcpOyB9XG59XG5cbi8vIDo6ICguLi5bKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbiksID9FZGl0b3JWaWV3KSDihpIgYm9vbF0pIOKGkiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSwgP0VkaXRvclZpZXcpIOKGkiBib29sXG4vLyBDb21iaW5lIGEgbnVtYmVyIG9mIGNvbW1hbmQgZnVuY3Rpb25zIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gKHdoaWNoXG4vLyBjYWxscyB0aGVtIG9uZSBieSBvbmUgdW50aWwgb25lIHJldHVybnMgdHJ1ZSkuXG5mdW5jdGlvbiBjaGFpbkNvbW1hbmRzKCkge1xuICB2YXIgY29tbWFuZHMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCBsZW4tLSApIGNvbW1hbmRzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspXG4gICAgICB7IGlmIChjb21tYW5kc1tpXShzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbnZhciBiYWNrc3BhY2UgPSBjaGFpbkNvbW1hbmRzKGRlbGV0ZVNlbGVjdGlvbiwgam9pbkJhY2t3YXJkLCBzZWxlY3ROb2RlQmFja3dhcmQpO1xudmFyIGRlbCA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luRm9yd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQpO1xuXG4vLyA6OiBPYmplY3Rcbi8vIEEgYmFzaWMga2V5bWFwIGNvbnRhaW5pbmcgYmluZGluZ3Mgbm90IHNwZWNpZmljIHRvIGFueSBzY2hlbWEuXG4vLyBCaW5kcyB0aGUgZm9sbG93aW5nIGtleXMgKHdoZW4gbXVsdGlwbGUgY29tbWFuZHMgYXJlIGxpc3RlZCwgdGhleVxuLy8gYXJlIGNoYWluZWQgd2l0aCBbYGNoYWluQ29tbWFuZHNgXSgjY29tbWFuZHMuY2hhaW5Db21tYW5kcykpOlxuLy9cbi8vICogKipFbnRlcioqIHRvIGBuZXdsaW5lSW5Db2RlYCwgYGNyZWF0ZVBhcmFncmFwaE5lYXJgLCBgbGlmdEVtcHR5QmxvY2tgLCBgc3BsaXRCbG9ja2Bcbi8vICogKipNb2QtRW50ZXIqKiB0byBgZXhpdENvZGVgXG4vLyAqICoqQmFja3NwYWNlKiogYW5kICoqTW9kLUJhY2tzcGFjZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkJhY2t3YXJkYCwgYHNlbGVjdE5vZGVCYWNrd2FyZGBcbi8vICogKipEZWxldGUqKiBhbmQgKipNb2QtRGVsZXRlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luRm9yd2FyZGAsIGBzZWxlY3ROb2RlRm9yd2FyZGBcbi8vICogKipNb2QtRGVsZXRlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luRm9yd2FyZGAsIGBzZWxlY3ROb2RlRm9yd2FyZGBcbi8vICogKipNb2QtYSoqIHRvIGBzZWxlY3RBbGxgXG52YXIgcGNCYXNlS2V5bWFwID0ge1xuICBcIkVudGVyXCI6IGNoYWluQ29tbWFuZHMobmV3bGluZUluQ29kZSwgY3JlYXRlUGFyYWdyYXBoTmVhciwgbGlmdEVtcHR5QmxvY2ssIHNwbGl0QmxvY2spLFxuICBcIk1vZC1FbnRlclwiOiBleGl0Q29kZSxcbiAgXCJCYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICBcIk1vZC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gIFwiRGVsZXRlXCI6IGRlbCxcbiAgXCJNb2QtRGVsZXRlXCI6IGRlbCxcbiAgXCJNb2QtYVwiOiBzZWxlY3RBbGxcbn07XG5cbi8vIDo6IE9iamVjdFxuLy8gQSBjb3B5IG9mIGBwY0Jhc2VLZXltYXBgIHRoYXQgYWxzbyBiaW5kcyAqKkN0cmwtaCoqIGxpa2UgQmFja3NwYWNlLFxuLy8gKipDdHJsLWQqKiBsaWtlIERlbGV0ZSwgKipBbHQtQmFja3NwYWNlKiogbGlrZSBDdHJsLUJhY2tzcGFjZSwgYW5kXG4vLyAqKkN0cmwtQWx0LUJhY2tzcGFjZSoqLCAqKkFsdC1EZWxldGUqKiwgYW5kICoqQWx0LWQqKiBsaWtlXG4vLyBDdHJsLURlbGV0ZS5cbnZhciBtYWNCYXNlS2V5bWFwID0ge1xuICBcIkN0cmwtaFwiOiBwY0Jhc2VLZXltYXBbXCJCYWNrc3BhY2VcIl0sXG4gIFwiQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtQmFja3NwYWNlXCJdLFxuICBcIkN0cmwtZFwiOiBwY0Jhc2VLZXltYXBbXCJEZWxldGVcIl0sXG4gIFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gIFwiQWx0LURlbGV0ZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICBcIkFsdC1kXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl1cbn07XG5mb3IgKHZhciBrZXkgaW4gcGNCYXNlS2V5bWFwKSB7IG1hY0Jhc2VLZXltYXBba2V5XSA9IHBjQmFzZUtleW1hcFtrZXldOyB9XG5cbi8vIGRlY2xhcmUgZ2xvYmFsOiBvcywgbmF2aWdhdG9yXG52YXIgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gL01hY3xpUChob25lfFtvYV1kKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG4gICAgICAgICAgOiB0eXBlb2Ygb3MgIT0gXCJ1bmRlZmluZWRcIiA/IG9zLnBsYXRmb3JtKCkgPT0gXCJkYXJ3aW5cIiA6IGZhbHNlO1xuXG4vLyA6OiBPYmplY3Rcbi8vIERlcGVuZGluZyBvbiB0aGUgZGV0ZWN0ZWQgcGxhdGZvcm0sIHRoaXMgd2lsbCBob2xkXG4vLyBbYHBjQmFzZWtleW1hcGBdKCNjb21tYW5kcy5wY0Jhc2VLZXltYXApIG9yXG4vLyBbYG1hY0Jhc2VLZXltYXBgXSgjY29tbWFuZHMubWFjQmFzZUtleW1hcCkuXG52YXIgYmFzZUtleW1hcCA9IG1hYyA/IG1hY0Jhc2VLZXltYXAgOiBwY0Jhc2VLZXltYXA7XG5cbmV4cG9ydCB7IGF1dG9Kb2luLCBiYXNlS2V5bWFwLCBjaGFpbkNvbW1hbmRzLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBkZWxldGVTZWxlY3Rpb24sIGV4aXRDb2RlLCBqb2luQmFja3dhcmQsIGpvaW5Eb3duLCBqb2luRm9yd2FyZCwgam9pblVwLCBsaWZ0LCBsaWZ0RW1wdHlCbG9jaywgbWFjQmFzZUtleW1hcCwgbmV3bGluZUluQ29kZSwgcGNCYXNlS2V5bWFwLCBzZWxlY3RBbGwsIHNlbGVjdE5vZGVCYWNrd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQsIHNlbGVjdFBhcmVudE5vZGUsIHNldEJsb2NrVHlwZSwgc3BsaXRCbG9jaywgc3BsaXRCbG9ja0tlZXBNYXJrcywgdG9nZ2xlTWFyaywgd3JhcEluIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IGRyb3BQb2ludCB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbi8vIDo6IChvcHRpb25zOiA/T2JqZWN0KSDihpIgUGx1Z2luXG4vLyBDcmVhdGUgYSBwbHVnaW4gdGhhdCwgd2hlbiBhZGRlZCB0byBhIFByb3NlTWlycm9yIGluc3RhbmNlLFxuLy8gY2F1c2VzIGEgZGVjb3JhdGlvbiB0byBzaG93IHVwIGF0IHRoZSBkcm9wIHBvc2l0aW9uIHdoZW4gc29tZXRoaW5nXG4vLyBpcyBkcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cbi8vXG4vLyAgIG9wdGlvbnM6Oi0gVGhlc2Ugb3B0aW9ucyBhcmUgc3VwcG9ydGVkOlxuLy9cbi8vICAgICBjb2xvcjo6ID9zdHJpbmdcbi8vICAgICBUaGUgY29sb3Igb2YgdGhlIGN1cnNvci4gRGVmYXVsdHMgdG8gYGJsYWNrYC5cbi8vXG4vLyAgICAgd2lkdGg6OiA/bnVtYmVyXG4vLyAgICAgVGhlIHByZWNpc2Ugd2lkdGggb2YgdGhlIGN1cnNvciBpbiBwaXhlbHMuIERlZmF1bHRzIHRvIDEuXG4vL1xuLy8gICAgIGNsYXNzOjogP3N0cmluZ1xuLy8gICAgIEEgQ1NTIGNsYXNzIG5hbWUgdG8gYWRkIHRvIHRoZSBjdXJzb3IgZWxlbWVudC5cbmZ1bmN0aW9uIGRyb3BDdXJzb3Iob3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgdmlldzogZnVuY3Rpb24gdmlldyhlZGl0b3JWaWV3KSB7IHJldHVybiBuZXcgRHJvcEN1cnNvclZpZXcoZWRpdG9yVmlldywgb3B0aW9ucykgfVxuICB9KVxufVxuXG52YXIgRHJvcEN1cnNvclZpZXcgPSBmdW5jdGlvbiBEcm9wQ3Vyc29yVmlldyhlZGl0b3JWaWV3LCBvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuZWRpdG9yVmlldyA9IGVkaXRvclZpZXc7XG4gIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IDE7XG4gIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgdGhpcy5jbGFzcyA9IG9wdGlvbnMuY2xhc3M7XG4gIHRoaXMuY3Vyc29yUG9zID0gbnVsbDtcbiAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgdGhpcy50aW1lb3V0ID0gbnVsbDtcblxuICB0aGlzLmhhbmRsZXJzID0gW1wiZHJhZ292ZXJcIiwgXCJkcmFnZW5kXCIsIFwiZHJvcFwiLCBcImRyYWdsZWF2ZVwiXS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aGlzJDFbbmFtZV0oZSk7IH07XG4gICAgZWRpdG9yVmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICByZXR1cm4ge25hbWU6IG5hbWUsIGhhbmRsZXI6IGhhbmRsZXJ9XG4gIH0pO1xufTtcblxuRHJvcEN1cnNvclZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLmhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICAgIHZhciBoYW5kbGVyID0gcmVmLmhhbmRsZXI7XG5cbiAgICAgIHJldHVybiB0aGlzJDEuZWRpdG9yVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICB9KTtcbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGVkaXRvclZpZXcsIHByZXZTdGF0ZSkge1xuICBpZiAodGhpcy5jdXJzb3JQb3MgIT0gbnVsbCAmJiBwcmV2U3RhdGUuZG9jICE9IGVkaXRvclZpZXcuc3RhdGUuZG9jKSB7XG4gICAgaWYgKHRoaXMuY3Vyc29yUG9zID4gZWRpdG9yVmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplKSB7IHRoaXMuc2V0Q3Vyc29yKG51bGwpOyB9XG4gICAgZWxzZSB7IHRoaXMudXBkYXRlT3ZlcmxheSgpOyB9XG4gIH1cbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS5zZXRDdXJzb3IgPSBmdW5jdGlvbiBzZXRDdXJzb3IgKHBvcykge1xuICBpZiAocG9zID09IHRoaXMuY3Vyc29yUG9zKSB7IHJldHVybiB9XG4gIHRoaXMuY3Vyc29yUG9zID0gcG9zO1xuICBpZiAocG9zID09IG51bGwpIHtcbiAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cGRhdGVPdmVybGF5KCk7XG4gIH1cbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS51cGRhdGVPdmVybGF5ID0gZnVuY3Rpb24gdXBkYXRlT3ZlcmxheSAoKSB7XG4gIHZhciAkcG9zID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYy5yZXNvbHZlKHRoaXMuY3Vyc29yUG9zKSwgcmVjdDtcbiAgaWYgKCEkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgdmFyIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICBpZiAoYmVmb3JlIHx8IGFmdGVyKSB7XG4gICAgICB2YXIgbm9kZVJlY3QgPSB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcyAtIChiZWZvcmUgP2JlZm9yZS5ub2RlU2l6ZSA6IDApKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB0b3AgPSBiZWZvcmUgPyBub2RlUmVjdC5ib3R0b20gOiBub2RlUmVjdC50b3A7XG4gICAgICBpZiAoYmVmb3JlICYmIGFmdGVyKVxuICAgICAgICB7IHRvcCA9ICh0b3AgKyB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSAvIDI7IH1cbiAgICAgIHJlY3QgPSB7bGVmdDogbm9kZVJlY3QubGVmdCwgcmlnaHQ6IG5vZGVSZWN0LnJpZ2h0LCB0b3A6IHRvcCAtIHRoaXMud2lkdGggLyAyLCBib3R0b206IHRvcCArIHRoaXMud2lkdGggLyAyfTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZWN0KSB7XG4gICAgdmFyIGNvb3JkcyA9IHRoaXMuZWRpdG9yVmlldy5jb29yZHNBdFBvcyh0aGlzLmN1cnNvclBvcyk7XG4gICAgcmVjdCA9IHtsZWZ0OiBjb29yZHMubGVmdCAtIHRoaXMud2lkdGggLyAyLCByaWdodDogY29vcmRzLmxlZnQgKyB0aGlzLndpZHRoIC8gMiwgdG9wOiBjb29yZHMudG9wLCBib3R0b206IGNvb3Jkcy5ib3R0b219O1xuICB9XG5cbiAgdmFyIHBhcmVudCA9IHRoaXMuZWRpdG9yVmlldy5kb20ub2Zmc2V0UGFyZW50O1xuICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgIHRoaXMuZWxlbWVudCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICBpZiAodGhpcy5jbGFzcykgeyB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5jbGFzczsgfVxuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHotaW5kZXg6IDUwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgYmFja2dyb3VuZC1jb2xvcjogXCIgKyB0aGlzLmNvbG9yO1xuICB9XG4gIHZhciBwYXJlbnRMZWZ0LCBwYXJlbnRUb3A7XG4gIGlmICghcGFyZW50IHx8IHBhcmVudCA9PSBkb2N1bWVudC5ib2R5ICYmIGdldENvbXB1dGVkU3R5bGUocGFyZW50KS5wb3NpdGlvbiA9PSBcInN0YXRpY1wiKSB7XG4gICAgcGFyZW50TGVmdCA9IC1wYWdlWE9mZnNldDtcbiAgICBwYXJlbnRUb3AgPSAtcGFnZVlPZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlY3QkMSA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBwYXJlbnRMZWZ0ID0gcmVjdCQxLmxlZnQgLSBwYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICBwYXJlbnRUb3AgPSByZWN0JDEudG9wIC0gcGFyZW50LnNjcm9sbFRvcDtcbiAgfVxuICB0aGlzLmVsZW1lbnQuc3R5bGUubGVmdCA9IChyZWN0LmxlZnQgLSBwYXJlbnRMZWZ0KSArIFwicHhcIjtcbiAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IChyZWN0LnRvcCAtIHBhcmVudFRvcCkgKyBcInB4XCI7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSArIFwicHhcIjtcbiAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKSArIFwicHhcIjtcbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS5zY2hlZHVsZVJlbW92YWwgPSBmdW5jdGlvbiBzY2hlZHVsZVJlbW92YWwgKHRpbWVvdXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuc2V0Q3Vyc29yKG51bGwpOyB9LCB0aW1lb3V0KTtcbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS5kcmFnb3ZlciA9IGZ1bmN0aW9uIGRyYWdvdmVyIChldmVudCkge1xuICBpZiAoIXRoaXMuZWRpdG9yVmlldy5lZGl0YWJsZSkgeyByZXR1cm4gfVxuICB2YXIgcG9zID0gdGhpcy5lZGl0b3JWaWV3LnBvc0F0Q29vcmRzKHtsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFl9KTtcbiAgaWYgKHBvcykge1xuICAgIHZhciB0YXJnZXQgPSBwb3MucG9zO1xuICAgIGlmICh0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcgJiYgdGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nLnNsaWNlKSB7XG4gICAgICB0YXJnZXQgPSBkcm9wUG9pbnQodGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYywgdGFyZ2V0LCB0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcuc2xpY2UpO1xuICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7IHJldHVybiB0aGlzLnNldEN1cnNvcihudWxsKSB9XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRhcmdldCk7XG4gICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoNTAwMCk7XG4gIH1cbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS5kcmFnZW5kID0gZnVuY3Rpb24gZHJhZ2VuZCAoKSB7XG4gIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDIwKTtcbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS5kcm9wID0gZnVuY3Rpb24gZHJvcCAoKSB7XG4gIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDIwKTtcbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS5kcmFnbGVhdmUgPSBmdW5jdGlvbiBkcmFnbGVhdmUgKGV2ZW50KSB7XG4gIGlmIChldmVudC50YXJnZXQgPT0gdGhpcy5lZGl0b3JWaWV3LmRvbSB8fCAhdGhpcy5lZGl0b3JWaWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICB7IHRoaXMuc2V0Q3Vyc29yKG51bGwpOyB9XG59O1xuXG5leHBvcnQgeyBkcm9wQ3Vyc29yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCB7IGtleW1hcCB9IGZyb20gJ3Byb3NlbWlycm9yLWtleW1hcCc7XG5pbXBvcnQgeyB1bmRvLCByZWRvLCBoaXN0b3J5IH0gZnJvbSAncHJvc2VtaXJyb3ItaGlzdG9yeSc7XG5pbXBvcnQgeyB0b2dnbGVNYXJrLCB3cmFwSW4sIGNoYWluQ29tbWFuZHMsIGV4aXRDb2RlLCBzZXRCbG9ja1R5cGUsIGpvaW5VcCwgam9pbkRvd24sIGxpZnQsIHNlbGVjdFBhcmVudE5vZGUsIGJhc2VLZXltYXAgfSBmcm9tICdwcm9zZW1pcnJvci1jb21tYW5kcyc7XG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBkcm9wQ3Vyc29yIH0gZnJvbSAncHJvc2VtaXJyb3ItZHJvcGN1cnNvcic7XG5pbXBvcnQgeyBnYXBDdXJzb3IgfSBmcm9tICdwcm9zZW1pcnJvci1nYXBjdXJzb3InO1xuaW1wb3J0IHsgaWNvbnMsIE1lbnVJdGVtLCB3cmFwSXRlbSwgYmxvY2tUeXBlSXRlbSwgRHJvcGRvd24sIERyb3Bkb3duU3VibWVudSwgam9pblVwSXRlbSwgbGlmdEl0ZW0sIHNlbGVjdFBhcmVudE5vZGVJdGVtLCB1bmRvSXRlbSwgcmVkb0l0ZW0sIG1lbnVCYXIgfSBmcm9tICdwcm9zZW1pcnJvci1tZW51JztcbmltcG9ydCB7IHdyYXBJbkxpc3QsIHNwbGl0TGlzdEl0ZW0sIGxpZnRMaXN0SXRlbSwgc2lua0xpc3RJdGVtIH0gZnJvbSAncHJvc2VtaXJyb3Itc2NoZW1hLWxpc3QnO1xuaW1wb3J0IHsgdW5kb0lucHV0UnVsZSwgc21hcnRRdW90ZXMsIGVsbGlwc2lzLCBlbURhc2gsIHdyYXBwaW5nSW5wdXRSdWxlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlLCBpbnB1dFJ1bGVzIH0gZnJvbSAncHJvc2VtaXJyb3ItaW5wdXRydWxlcyc7XG5cbnZhciBwcmVmaXggPSBcIlByb3NlTWlycm9yLXByb21wdFwiO1xuXG5mdW5jdGlvbiBvcGVuUHJvbXB0KG9wdGlvbnMpIHtcbiAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICB3cmFwcGVyLmNsYXNzTmFtZSA9IHByZWZpeDtcblxuICB2YXIgbW91c2VPdXRzaWRlID0gZnVuY3Rpb24gKGUpIHsgaWYgKCF3cmFwcGVyLmNvbnRhaW5zKGUudGFyZ2V0KSkgeyBjbG9zZSgpOyB9IH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VPdXRzaWRlKTsgfSwgNTApO1xuICB2YXIgY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VPdXRzaWRlKTtcbiAgICBpZiAod3JhcHBlci5wYXJlbnROb2RlKSB7IHdyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTsgfVxuICB9O1xuXG4gIHZhciBkb21GaWVsZHMgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zLmZpZWxkcykgeyBkb21GaWVsZHMucHVzaChvcHRpb25zLmZpZWxkc1tuYW1lXS5yZW5kZXIoKSk7IH1cblxuICB2YXIgc3VibWl0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgc3VibWl0QnV0dG9uLnR5cGUgPSBcInN1Ym1pdFwiO1xuICBzdWJtaXRCdXR0b24uY2xhc3NOYW1lID0gcHJlZml4ICsgXCItc3VibWl0XCI7XG4gIHN1Ym1pdEJ1dHRvbi50ZXh0Q29udGVudCA9IFwiT0tcIjtcbiAgdmFyIGNhbmNlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gIGNhbmNlbEJ1dHRvbi50eXBlID0gXCJidXR0b25cIjtcbiAgY2FuY2VsQnV0dG9uLmNsYXNzTmFtZSA9IHByZWZpeCArIFwiLWNhbmNlbFwiO1xuICBjYW5jZWxCdXR0b24udGV4dENvbnRlbnQgPSBcIkNhbmNlbFwiO1xuICBjYW5jZWxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNsb3NlKTtcblxuICB2YXIgZm9ybSA9IHdyYXBwZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIikpO1xuICBpZiAob3B0aW9ucy50aXRsZSkgeyBmb3JtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoNVwiKSkudGV4dENvbnRlbnQgPSBvcHRpb25zLnRpdGxlOyB9XG4gIGRvbUZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuYXBwZW5kQ2hpbGQoZmllbGQpO1xuICB9KTtcbiAgdmFyIGJ1dHRvbnMgPSBmb3JtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICBidXR0b25zLmNsYXNzTmFtZSA9IHByZWZpeCArIFwiLWJ1dHRvbnNcIjtcbiAgYnV0dG9ucy5hcHBlbmRDaGlsZChzdWJtaXRCdXR0b24pO1xuICBidXR0b25zLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSk7XG4gIGJ1dHRvbnMuYXBwZW5kQ2hpbGQoY2FuY2VsQnV0dG9uKTtcblxuICB2YXIgYm94ID0gd3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgd3JhcHBlci5zdHlsZS50b3AgPSAoKHdpbmRvdy5pbm5lckhlaWdodCAtIGJveC5oZWlnaHQpIC8gMikgKyBcInB4XCI7XG4gIHdyYXBwZXIuc3R5bGUubGVmdCA9ICgod2luZG93LmlubmVyV2lkdGggLSBib3gud2lkdGgpIC8gMikgKyBcInB4XCI7XG5cbiAgdmFyIHN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyYW1zID0gZ2V0VmFsdWVzKG9wdGlvbnMuZmllbGRzLCBkb21GaWVsZHMpO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgICBvcHRpb25zLmNhbGxiYWNrKHBhcmFtcyk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBzdWJtaXQoKTtcbiAgfSk7XG5cbiAgZm9ybS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT0gMjcpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNsb3NlKCk7XG4gICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgIShlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdWJtaXQoKTtcbiAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PSA5KSB7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghd3JhcHBlci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkgeyBjbG9zZSgpOyB9XG4gICAgICB9LCA1MDApO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGlucHV0ID0gZm9ybS5lbGVtZW50c1swXTtcbiAgaWYgKGlucHV0KSB7IGlucHV0LmZvY3VzKCk7IH1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKGZpZWxkcywgZG9tRmllbGRzKSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBpID0gMDtcbiAgZm9yICh2YXIgbmFtZSBpbiBmaWVsZHMpIHtcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbbmFtZV0sIGRvbSA9IGRvbUZpZWxkc1tpKytdO1xuICAgIHZhciB2YWx1ZSA9IGZpZWxkLnJlYWQoZG9tKSwgYmFkID0gZmllbGQudmFsaWRhdGUodmFsdWUpO1xuICAgIGlmIChiYWQpIHtcbiAgICAgIHJlcG9ydEludmFsaWQoZG9tLCBiYWQpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmVzdWx0W25hbWVdID0gZmllbGQuY2xlYW4odmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gcmVwb3J0SW52YWxpZChkb20sIG1lc3NhZ2UpIHtcbiAgLy8gRklYTUUgdGhpcyBpcyBhd2Z1bCBhbmQgbmVlZHMgYSBsb3QgbW9yZSB3b3JrXG4gIHZhciBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgdmFyIG1zZyA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgbXNnLnN0eWxlLmxlZnQgPSAoZG9tLm9mZnNldExlZnQgKyBkb20ub2Zmc2V0V2lkdGggKyAyKSArIFwicHhcIjtcbiAgbXNnLnN0eWxlLnRvcCA9IChkb20ub2Zmc2V0VG9wIC0gNSkgKyBcInB4XCI7XG4gIG1zZy5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLWludmFsaWRcIjtcbiAgbXNnLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJlbnQucmVtb3ZlQ2hpbGQobXNnKTsgfSwgMTUwMCk7XG59XG5cbi8vIDo6LSBUaGUgdHlwZSBvZiBmaWVsZCB0aGF0IGBGaWVsZFByb21wdGAgZXhwZWN0cyB0byBiZSBwYXNzZWQgdG8gaXQuXG52YXIgRmllbGQgPSBmdW5jdGlvbiBGaWVsZChvcHRpb25zKSB7IHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7IH07XG5cbi8vIHJlbmRlcjo6IChzdGF0ZTogRWRpdG9yU3RhdGUsIHByb3BzOiBPYmplY3QpIOKGkiBkb20uTm9kZVxuLy8gUmVuZGVyIHRoZSBmaWVsZCB0byB0aGUgRE9NLiBTaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgYWxsIHN1YmNsYXNzZXMuXG5cbi8vIDo6IChkb20uTm9kZSkg4oaSIGFueVxuLy8gUmVhZCB0aGUgZmllbGQncyB2YWx1ZSBmcm9tIGl0cyBET00gbm9kZS5cbkZpZWxkLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gcmVhZCAoZG9tKSB7IHJldHVybiBkb20udmFsdWUgfTtcblxuLy8gOjogKGFueSkg4oaSID9zdHJpbmdcbi8vIEEgZmllbGQtdHlwZS1zcGVjaWZpYyB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuRmllbGQucHJvdG90eXBlLnZhbGlkYXRlVHlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlVHlwZSAoX3ZhbHVlKSB7fTtcblxuRmllbGQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUgKHZhbHVlKSB7XG4gIGlmICghdmFsdWUgJiYgdGhpcy5vcHRpb25zLnJlcXVpcmVkKVxuICAgIHsgcmV0dXJuIFwiUmVxdWlyZWQgZmllbGRcIiB9XG4gIHJldHVybiB0aGlzLnZhbGlkYXRlVHlwZSh2YWx1ZSkgfHwgKHRoaXMub3B0aW9ucy52YWxpZGF0ZSAmJiB0aGlzLm9wdGlvbnMudmFsaWRhdGUodmFsdWUpKVxufTtcblxuRmllbGQucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24gY2xlYW4gKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMuY2xlYW4gPyB0aGlzLm9wdGlvbnMuY2xlYW4odmFsdWUpIDogdmFsdWVcbn07XG5cbi8vIDo6LSBBIGZpZWxkIGNsYXNzIGZvciBzaW5nbGUtbGluZSB0ZXh0IGZpZWxkcy5cbnZhciBUZXh0RmllbGQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChGaWVsZCkge1xuICBmdW5jdGlvbiBUZXh0RmllbGQgKCkge1xuICAgIEZpZWxkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAoIEZpZWxkICkgVGV4dEZpZWxkLl9fcHJvdG9fXyA9IEZpZWxkO1xuICBUZXh0RmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRmllbGQgJiYgRmllbGQucHJvdG90eXBlICk7XG4gIFRleHRGaWVsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0RmllbGQ7XG5cbiAgVGV4dEZpZWxkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLm9wdGlvbnMubGFiZWw7XG4gICAgaW5wdXQudmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWUgfHwgXCJcIjtcbiAgICBpbnB1dC5hdXRvY29tcGxldGUgPSBcIm9mZlwiO1xuICAgIHJldHVybiBpbnB1dFxuICB9O1xuXG4gIHJldHVybiBUZXh0RmllbGQ7XG59KEZpZWxkKSk7XG5cbi8vIEhlbHBlcnMgdG8gY3JlYXRlIHNwZWNpZmljIHR5cGVzIG9mIGl0ZW1zXG5cbmZ1bmN0aW9uIGNhbkluc2VydChzdGF0ZSwgbm9kZVR5cGUpIHtcbiAgdmFyICRmcm9tID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICBmb3IgKHZhciBkID0gJGZyb20uZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgdmFyIGluZGV4ID0gJGZyb20uaW5kZXgoZCk7XG4gICAgaWYgKCRmcm9tLm5vZGUoZCkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBub2RlVHlwZSkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBpbnNlcnRJbWFnZUl0ZW0obm9kZVR5cGUpIHtcbiAgcmV0dXJuIG5ldyBNZW51SXRlbSh7XG4gICAgdGl0bGU6IFwiSW5zZXJ0IGltYWdlXCIsXG4gICAgbGFiZWw6IFwiSW1hZ2VcIixcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkgeyByZXR1cm4gY2FuSW5zZXJ0KHN0YXRlLCBub2RlVHlwZSkgfSxcbiAgICBydW46IGZ1bmN0aW9uIHJ1bihzdGF0ZSwgXywgdmlldykge1xuICAgICAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgIHZhciBmcm9tID0gcmVmLmZyb207XG4gICAgICB2YXIgdG8gPSByZWYudG87XG4gICAgICB2YXIgYXR0cnMgPSBudWxsO1xuICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc3RhdGUuc2VsZWN0aW9uLm5vZGUudHlwZSA9PSBub2RlVHlwZSlcbiAgICAgICAgeyBhdHRycyA9IHN0YXRlLnNlbGVjdGlvbi5ub2RlLmF0dHJzOyB9XG4gICAgICBvcGVuUHJvbXB0KHtcbiAgICAgICAgdGl0bGU6IFwiSW5zZXJ0IGltYWdlXCIsXG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgIHNyYzogbmV3IFRleHRGaWVsZCh7bGFiZWw6IFwiTG9jYXRpb25cIiwgcmVxdWlyZWQ6IHRydWUsIHZhbHVlOiBhdHRycyAmJiBhdHRycy5zcmN9KSxcbiAgICAgICAgICB0aXRsZTogbmV3IFRleHRGaWVsZCh7bGFiZWw6IFwiVGl0bGVcIiwgdmFsdWU6IGF0dHJzICYmIGF0dHJzLnRpdGxlfSksXG4gICAgICAgICAgYWx0OiBuZXcgVGV4dEZpZWxkKHtsYWJlbDogXCJEZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF0dHJzID8gYXR0cnMuYWx0IDogc3RhdGUuZG9jLnRleHRCZXR3ZWVuKGZyb20sIHRvLCBcIiBcIil9KVxuICAgICAgICB9LFxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soYXR0cnMpIHtcbiAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbldpdGgobm9kZVR5cGUuY3JlYXRlQW5kRmlsbChhdHRycykpKTtcbiAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gY21kSXRlbShjbWQsIG9wdGlvbnMpIHtcbiAgdmFyIHBhc3NlZE9wdGlvbnMgPSB7XG4gICAgbGFiZWw6IG9wdGlvbnMudGl0bGUsXG4gICAgcnVuOiBjbWRcbiAgfTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7IHBhc3NlZE9wdGlvbnNbcHJvcF0gPSBvcHRpb25zW3Byb3BdOyB9XG4gIGlmICgoIW9wdGlvbnMuZW5hYmxlIHx8IG9wdGlvbnMuZW5hYmxlID09PSB0cnVlKSAmJiAhb3B0aW9ucy5zZWxlY3QpXG4gICAgeyBwYXNzZWRPcHRpb25zW29wdGlvbnMuZW5hYmxlID8gXCJlbmFibGVcIiA6IFwic2VsZWN0XCJdID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBjbWQoc3RhdGUpOyB9OyB9XG5cbiAgcmV0dXJuIG5ldyBNZW51SXRlbShwYXNzZWRPcHRpb25zKVxufVxuXG5mdW5jdGlvbiBtYXJrQWN0aXZlKHN0YXRlLCB0eXBlKSB7XG4gIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIHZhciBmcm9tID0gcmVmLmZyb207XG4gIHZhciAkZnJvbSA9IHJlZi4kZnJvbTtcbiAgdmFyIHRvID0gcmVmLnRvO1xuICB2YXIgZW1wdHkgPSByZWYuZW1wdHk7XG4gIGlmIChlbXB0eSkgeyByZXR1cm4gdHlwZS5pc0luU2V0KHN0YXRlLnN0b3JlZE1hcmtzIHx8ICRmcm9tLm1hcmtzKCkpIH1cbiAgZWxzZSB7IHJldHVybiBzdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKGZyb20sIHRvLCB0eXBlKSB9XG59XG5cbmZ1bmN0aW9uIG1hcmtJdGVtKG1hcmtUeXBlLCBvcHRpb25zKSB7XG4gIHZhciBwYXNzZWRPcHRpb25zID0ge1xuICAgIGFjdGl2ZTogZnVuY3Rpb24gYWN0aXZlKHN0YXRlKSB7IHJldHVybiBtYXJrQWN0aXZlKHN0YXRlLCBtYXJrVHlwZSkgfSxcbiAgICBlbmFibGU6IHRydWVcbiAgfTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7IHBhc3NlZE9wdGlvbnNbcHJvcF0gPSBvcHRpb25zW3Byb3BdOyB9XG4gIHJldHVybiBjbWRJdGVtKHRvZ2dsZU1hcmsobWFya1R5cGUpLCBwYXNzZWRPcHRpb25zKVxufVxuXG5mdW5jdGlvbiBsaW5rSXRlbShtYXJrVHlwZSkge1xuICByZXR1cm4gbmV3IE1lbnVJdGVtKHtcbiAgICB0aXRsZTogXCJBZGQgb3IgcmVtb3ZlIGxpbmtcIixcbiAgICBpY29uOiBpY29ucy5saW5rLFxuICAgIGFjdGl2ZTogZnVuY3Rpb24gYWN0aXZlKHN0YXRlKSB7IHJldHVybiBtYXJrQWN0aXZlKHN0YXRlLCBtYXJrVHlwZSkgfSxcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkgeyByZXR1cm4gIXN0YXRlLnNlbGVjdGlvbi5lbXB0eSB9LFxuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgaWYgKG1hcmtBY3RpdmUoc3RhdGUsIG1hcmtUeXBlKSkge1xuICAgICAgICB0b2dnbGVNYXJrKG1hcmtUeXBlKShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgb3BlblByb21wdCh7XG4gICAgICAgIHRpdGxlOiBcIkNyZWF0ZSBhIGxpbmtcIixcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgaHJlZjogbmV3IFRleHRGaWVsZCh7XG4gICAgICAgICAgICBsYWJlbDogXCJMaW5rIHRhcmdldFwiLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0aXRsZTogbmV3IFRleHRGaWVsZCh7bGFiZWw6IFwiVGl0bGVcIn0pXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhhdHRycykge1xuICAgICAgICAgIHRvZ2dsZU1hcmsobWFya1R5cGUsIGF0dHJzKSh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoKTtcbiAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gd3JhcExpc3RJdGVtKG5vZGVUeXBlLCBvcHRpb25zKSB7XG4gIHJldHVybiBjbWRJdGVtKHdyYXBJbkxpc3Qobm9kZVR5cGUsIG9wdGlvbnMuYXR0cnMpLCBvcHRpb25zKVxufVxuXG4vLyA6OiAoU2NoZW1hKSDihpIgT2JqZWN0XG4vLyBHaXZlbiBhIHNjaGVtYSwgbG9vayBmb3IgZGVmYXVsdCBtYXJrIGFuZCBub2RlIHR5cGVzIGluIGl0IGFuZFxuLy8gcmV0dXJuIGFuIG9iamVjdCB3aXRoIHJlbGV2YW50IG1lbnUgaXRlbXMgcmVsYXRpbmcgdG8gdGhvc2UgbWFya3M6XG4vL1xuLy8gKipgdG9nZ2xlU3Ryb25nYCoqYDogTWVudUl0ZW1gXG4vLyAgIDogQSBtZW51IGl0ZW0gdG8gdG9nZ2xlIHRoZSBbc3Ryb25nIG1hcmtdKCNzY2hlbWEtYmFzaWMuU3Ryb25nTWFyaykuXG4vL1xuLy8gKipgdG9nZ2xlRW1gKipgOiBNZW51SXRlbWBcbi8vICAgOiBBIG1lbnUgaXRlbSB0byB0b2dnbGUgdGhlIFtlbXBoYXNpcyBtYXJrXSgjc2NoZW1hLWJhc2ljLkVtTWFyaykuXG4vL1xuLy8gKipgdG9nZ2xlQ29kZWAqKmA6IE1lbnVJdGVtYFxuLy8gICA6IEEgbWVudSBpdGVtIHRvIHRvZ2dsZSB0aGUgW2NvZGUgZm9udCBtYXJrXSgjc2NoZW1hLWJhc2ljLkNvZGVNYXJrKS5cbi8vXG4vLyAqKmB0b2dnbGVMaW5rYCoqYDogTWVudUl0ZW1gXG4vLyAgIDogQSBtZW51IGl0ZW0gdG8gdG9nZ2xlIHRoZSBbbGluayBtYXJrXSgjc2NoZW1hLWJhc2ljLkxpbmtNYXJrKS5cbi8vXG4vLyAqKmBpbnNlcnRJbWFnZWAqKmA6IE1lbnVJdGVtYFxuLy8gICA6IEEgbWVudSBpdGVtIHRvIGluc2VydCBhbiBbaW1hZ2VdKCNzY2hlbWEtYmFzaWMuSW1hZ2UpLlxuLy9cbi8vICoqYHdyYXBCdWxsZXRMaXN0YCoqYDogTWVudUl0ZW1gXG4vLyAgIDogQSBtZW51IGl0ZW0gdG8gd3JhcCB0aGUgc2VsZWN0aW9uIGluIGEgW2J1bGxldCBsaXN0XSgjc2NoZW1hLWxpc3QuQnVsbGV0TGlzdCkuXG4vL1xuLy8gKipgd3JhcE9yZGVyZWRMaXN0YCoqYDogTWVudUl0ZW1gXG4vLyAgIDogQSBtZW51IGl0ZW0gdG8gd3JhcCB0aGUgc2VsZWN0aW9uIGluIGFuIFtvcmRlcmVkIGxpc3RdKCNzY2hlbWEtbGlzdC5PcmRlcmVkTGlzdCkuXG4vL1xuLy8gKipgd3JhcEJsb2NrUXVvdGVgKipgOiBNZW51SXRlbWBcbi8vICAgOiBBIG1lbnUgaXRlbSB0byB3cmFwIHRoZSBzZWxlY3Rpb24gaW4gYSBbYmxvY2sgcXVvdGVdKCNzY2hlbWEtYmFzaWMuQmxvY2tRdW90ZSkuXG4vL1xuLy8gKipgbWFrZVBhcmFncmFwaGAqKmA6IE1lbnVJdGVtYFxuLy8gICA6IEEgbWVudSBpdGVtIHRvIHNldCB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gYmUgYSBub3JtYWxcbi8vICAgICBbcGFyYWdyYXBoXSgjc2NoZW1hLWJhc2ljLlBhcmFncmFwaCkuXG4vL1xuLy8gKipgbWFrZUNvZGVCbG9ja2AqKmA6IE1lbnVJdGVtYFxuLy8gICA6IEEgbWVudSBpdGVtIHRvIHNldCB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gYmUgYVxuLy8gICAgIFtjb2RlIGJsb2NrXSgjc2NoZW1hLWJhc2ljLkNvZGVCbG9jaykuXG4vL1xuLy8gKipgbWFrZUhlYWRbTl1gKipgOiBNZW51SXRlbWBcbi8vICAgOiBXaGVyZSBfTl8gaXMgMSB0byA2LiBNZW51IGl0ZW1zIHRvIHNldCB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG9cbi8vICAgICBiZSBhIFtoZWFkaW5nXSgjc2NoZW1hLWJhc2ljLkhlYWRpbmcpIG9mIGxldmVsIF9OXy5cbi8vXG4vLyAqKmBpbnNlcnRIb3Jpem9udGFsUnVsZWAqKmA6IE1lbnVJdGVtYFxuLy8gICA6IEEgbWVudSBpdGVtIHRvIGluc2VydCBhIGhvcml6b250YWwgcnVsZS5cbi8vXG4vLyBUaGUgcmV0dXJuIHZhbHVlIGFsc28gY29udGFpbnMgc29tZSBwcmVmYWJyaWNhdGVkIG1lbnUgZWxlbWVudHMgYW5kXG4vLyBtZW51cywgdGhhdCB5b3UgY2FuIHVzZSBpbnN0ZWFkIG9mIGNvbXBvc2luZyB5b3VyIG93biBtZW51IGZyb21cbi8vIHNjcmF0Y2g6XG4vL1xuLy8gKipgaW5zZXJ0TWVudWAqKmA6IERyb3Bkb3duYFxuLy8gICA6IEEgZHJvcGRvd24gY29udGFpbmluZyB0aGUgYGluc2VydEltYWdlYCBhbmRcbi8vICAgICBgaW5zZXJ0SG9yaXpvbnRhbFJ1bGVgIGl0ZW1zLlxuLy9cbi8vICoqYHR5cGVNZW51YCoqYDogRHJvcGRvd25gXG4vLyAgIDogQSBkcm9wZG93biBjb250YWluaW5nIHRoZSBpdGVtcyBmb3IgbWFraW5nIHRoZSBjdXJyZW50XG4vLyAgICAgdGV4dGJsb2NrIGEgcGFyYWdyYXBoLCBjb2RlIGJsb2NrLCBvciBoZWFkaW5nLlxuLy9cbi8vICoqYGZ1bGxNZW51YCoqYDogW1tNZW51RWxlbWVudF1dYFxuLy8gICA6IEFuIGFycmF5IG9mIGFycmF5cyBvZiBtZW51IGVsZW1lbnRzIGZvciB1c2UgYXMgdGhlIGZ1bGwgbWVudVxuLy8gICAgIGZvciwgZm9yIGV4YW1wbGUgdGhlIFttZW51IGJhcl0oaHR0cHM6Ly9naXRodWIuY29tL3Byb3NlbWlycm9yL3Byb3NlbWlycm9yLW1lbnUjdXNlci1jb250ZW50LW1lbnViYXIpLlxuZnVuY3Rpb24gYnVpbGRNZW51SXRlbXMoc2NoZW1hKSB7XG4gIHZhciByID0ge30sIHR5cGU7XG4gIGlmICh0eXBlID0gc2NoZW1hLm1hcmtzLnN0cm9uZylcbiAgICB7IHIudG9nZ2xlU3Ryb25nID0gbWFya0l0ZW0odHlwZSwge3RpdGxlOiBcIlRvZ2dsZSBzdHJvbmcgc3R5bGVcIiwgaWNvbjogaWNvbnMuc3Ryb25nfSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubWFya3MuZW0pXG4gICAgeyByLnRvZ2dsZUVtID0gbWFya0l0ZW0odHlwZSwge3RpdGxlOiBcIlRvZ2dsZSBlbXBoYXNpc1wiLCBpY29uOiBpY29ucy5lbX0pOyB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm1hcmtzLmNvZGUpXG4gICAgeyByLnRvZ2dsZUNvZGUgPSBtYXJrSXRlbSh0eXBlLCB7dGl0bGU6IFwiVG9nZ2xlIGNvZGUgZm9udFwiLCBpY29uOiBpY29ucy5jb2RlfSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubWFya3MubGluaylcbiAgICB7IHIudG9nZ2xlTGluayA9IGxpbmtJdGVtKHR5cGUpOyB9XG5cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuaW1hZ2UpXG4gICAgeyByLmluc2VydEltYWdlID0gaW5zZXJ0SW1hZ2VJdGVtKHR5cGUpOyB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmJ1bGxldF9saXN0KVxuICAgIHsgci53cmFwQnVsbGV0TGlzdCA9IHdyYXBMaXN0SXRlbSh0eXBlLCB7XG4gICAgICB0aXRsZTogXCJXcmFwIGluIGJ1bGxldCBsaXN0XCIsXG4gICAgICBpY29uOiBpY29ucy5idWxsZXRMaXN0XG4gICAgfSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMub3JkZXJlZF9saXN0KVxuICAgIHsgci53cmFwT3JkZXJlZExpc3QgPSB3cmFwTGlzdEl0ZW0odHlwZSwge1xuICAgICAgdGl0bGU6IFwiV3JhcCBpbiBvcmRlcmVkIGxpc3RcIixcbiAgICAgIGljb246IGljb25zLm9yZGVyZWRMaXN0XG4gICAgfSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuYmxvY2txdW90ZSlcbiAgICB7IHIud3JhcEJsb2NrUXVvdGUgPSB3cmFwSXRlbSh0eXBlLCB7XG4gICAgICB0aXRsZTogXCJXcmFwIGluIGJsb2NrIHF1b3RlXCIsXG4gICAgICBpY29uOiBpY29ucy5ibG9ja3F1b3RlXG4gICAgfSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMucGFyYWdyYXBoKVxuICAgIHsgci5tYWtlUGFyYWdyYXBoID0gYmxvY2tUeXBlSXRlbSh0eXBlLCB7XG4gICAgICB0aXRsZTogXCJDaGFuZ2UgdG8gcGFyYWdyYXBoXCIsXG4gICAgICBsYWJlbDogXCJQbGFpblwiXG4gICAgfSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuY29kZV9ibG9jaylcbiAgICB7IHIubWFrZUNvZGVCbG9jayA9IGJsb2NrVHlwZUl0ZW0odHlwZSwge1xuICAgICAgdGl0bGU6IFwiQ2hhbmdlIHRvIGNvZGUgYmxvY2tcIixcbiAgICAgIGxhYmVsOiBcIkNvZGVcIlxuICAgIH0pOyB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmhlYWRpbmcpXG4gICAgeyBmb3IgKHZhciBpID0gMTsgaSA8PSAxMDsgaSsrKVxuICAgICAgeyByW1wibWFrZUhlYWRcIiArIGldID0gYmxvY2tUeXBlSXRlbSh0eXBlLCB7XG4gICAgICAgIHRpdGxlOiBcIkNoYW5nZSB0byBoZWFkaW5nIFwiICsgaSxcbiAgICAgICAgbGFiZWw6IFwiTGV2ZWwgXCIgKyBpLFxuICAgICAgICBhdHRyczoge2xldmVsOiBpfVxuICAgICAgfSk7IH0gfVxuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5ob3Jpem9udGFsX3J1bGUpIHtcbiAgICB2YXIgaHIgPSB0eXBlO1xuICAgIHIuaW5zZXJ0SG9yaXpvbnRhbFJ1bGUgPSBuZXcgTWVudUl0ZW0oe1xuICAgICAgdGl0bGU6IFwiSW5zZXJ0IGhvcml6b250YWwgcnVsZVwiLFxuICAgICAgbGFiZWw6IFwiSG9yaXpvbnRhbCBydWxlXCIsXG4gICAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkgeyByZXR1cm4gY2FuSW5zZXJ0KHN0YXRlLCBocikgfSxcbiAgICAgIHJ1bjogZnVuY3Rpb24gcnVuKHN0YXRlLCBkaXNwYXRjaCkgeyBkaXNwYXRjaChzdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uV2l0aChoci5jcmVhdGUoKSkpOyB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY3V0ID0gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSk7IH07XG4gIHIuaW5zZXJ0TWVudSA9IG5ldyBEcm9wZG93bihjdXQoW3IuaW5zZXJ0SW1hZ2UsIHIuaW5zZXJ0SG9yaXpvbnRhbFJ1bGVdKSwge2xhYmVsOiBcIkluc2VydFwifSk7XG4gIHIudHlwZU1lbnUgPSBuZXcgRHJvcGRvd24oY3V0KFtyLm1ha2VQYXJhZ3JhcGgsIHIubWFrZUNvZGVCbG9jaywgci5tYWtlSGVhZDEgJiYgbmV3IERyb3Bkb3duU3VibWVudShjdXQoW1xuICAgIHIubWFrZUhlYWQxLCByLm1ha2VIZWFkMiwgci5tYWtlSGVhZDMsIHIubWFrZUhlYWQ0LCByLm1ha2VIZWFkNSwgci5tYWtlSGVhZDZcbiAgXSksIHtsYWJlbDogXCJIZWFkaW5nXCJ9KV0pLCB7bGFiZWw6IFwiVHlwZS4uLlwifSk7XG5cbiAgci5pbmxpbmVNZW51ID0gW2N1dChbci50b2dnbGVTdHJvbmcsIHIudG9nZ2xlRW0sIHIudG9nZ2xlQ29kZSwgci50b2dnbGVMaW5rXSldO1xuICByLmJsb2NrTWVudSA9IFtjdXQoW3Iud3JhcEJ1bGxldExpc3QsIHIud3JhcE9yZGVyZWRMaXN0LCByLndyYXBCbG9ja1F1b3RlLCBqb2luVXBJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgIGxpZnRJdGVtLCBzZWxlY3RQYXJlbnROb2RlSXRlbV0pXTtcbiAgci5mdWxsTWVudSA9IHIuaW5saW5lTWVudS5jb25jYXQoW1tyLmluc2VydE1lbnUsIHIudHlwZU1lbnVdXSwgW1t1bmRvSXRlbSwgcmVkb0l0ZW1dXSwgci5ibG9ja01lbnUpO1xuXG4gIHJldHVybiByXG59XG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcblxuLy8gOjogKFNjaGVtYSwgP09iamVjdCkg4oaSIE9iamVjdFxuLy8gSW5zcGVjdCB0aGUgZ2l2ZW4gc2NoZW1hIGxvb2tpbmcgZm9yIG1hcmtzIGFuZCBub2RlcyBmcm9tIHRoZVxuLy8gYmFzaWMgc2NoZW1hLCBhbmQgaWYgZm91bmQsIGFkZCBrZXkgYmluZGluZ3MgcmVsYXRlZCB0byB0aGVtLlxuLy8gVGhpcyB3aWxsIGFkZDpcbi8vXG4vLyAqICoqTW9kLWIqKiBmb3IgdG9nZ2xpbmcgW3N0cm9uZ10oI3NjaGVtYS1iYXNpYy5TdHJvbmdNYXJrKVxuLy8gKiAqKk1vZC1pKiogZm9yIHRvZ2dsaW5nIFtlbXBoYXNpc10oI3NjaGVtYS1iYXNpYy5FbU1hcmspXG4vLyAqICoqTW9kLWAqKiBmb3IgdG9nZ2xpbmcgW2NvZGUgZm9udF0oI3NjaGVtYS1iYXNpYy5Db2RlTWFyaylcbi8vICogKipDdHJsLVNoaWZ0LTAqKiBmb3IgbWFraW5nIHRoZSBjdXJyZW50IHRleHRibG9jayBhIHBhcmFncmFwaFxuLy8gKiAqKkN0cmwtU2hpZnQtMSoqIHRvICoqQ3RybC1TaGlmdC1EaWdpdDYqKiBmb3IgbWFraW5nIHRoZSBjdXJyZW50XG4vLyAgIHRleHRibG9jayBhIGhlYWRpbmcgb2YgdGhlIGNvcnJlc3BvbmRpbmcgbGV2ZWxcbi8vICogKipDdHJsLVNoaWZ0LUJhY2tzbGFzaCoqIHRvIG1ha2UgdGhlIGN1cnJlbnQgdGV4dGJsb2NrIGEgY29kZSBibG9ja1xuLy8gKiAqKkN0cmwtU2hpZnQtOCoqIHRvIHdyYXAgdGhlIHNlbGVjdGlvbiBpbiBhbiBvcmRlcmVkIGxpc3Rcbi8vICogKipDdHJsLVNoaWZ0LTkqKiB0byB3cmFwIHRoZSBzZWxlY3Rpb24gaW4gYSBidWxsZXQgbGlzdFxuLy8gKiAqKkN0cmwtPioqIHRvIHdyYXAgdGhlIHNlbGVjdGlvbiBpbiBhIGJsb2NrIHF1b3RlXG4vLyAqICoqRW50ZXIqKiB0byBzcGxpdCBhIG5vbi1lbXB0eSB0ZXh0YmxvY2sgaW4gYSBsaXN0IGl0ZW0gd2hpbGUgYXRcbi8vICAgdGhlIHNhbWUgdGltZSBzcGxpdHRpbmcgdGhlIGxpc3QgaXRlbVxuLy8gKiAqKk1vZC1FbnRlcioqIHRvIGluc2VydCBhIGhhcmQgYnJlYWtcbi8vICogKipNb2QtXyoqIHRvIGluc2VydCBhIGhvcml6b250YWwgcnVsZVxuLy8gKiAqKkJhY2tzcGFjZSoqIHRvIHVuZG8gYW4gaW5wdXQgcnVsZVxuLy8gKiAqKkFsdC1BcnJvd1VwKiogdG8gYGpvaW5VcGBcbi8vICogKipBbHQtQXJyb3dEb3duKiogdG8gYGpvaW5Eb3duYFxuLy8gKiAqKk1vZC1CcmFja2V0TGVmdCoqIHRvIGBsaWZ0YFxuLy8gKiAqKkVzY2FwZSoqIHRvIGBzZWxlY3RQYXJlbnROb2RlYFxuLy9cbi8vIFlvdSBjYW4gc3VwcHJlc3Mgb3IgbWFwIHRoZXNlIGJpbmRpbmdzIGJ5IHBhc3NpbmcgYSBgbWFwS2V5c2Bcbi8vIGFyZ3VtZW50LCB3aGljaCBtYXBzIGtleSBuYW1lcyAoc2F5IGBcIk1vZC1CXCJgIHRvIGVpdGhlciBgZmFsc2VgLCB0b1xuLy8gcmVtb3ZlIHRoZSBiaW5kaW5nLCBvciBhIG5ldyBrZXkgbmFtZSBzdHJpbmcuXG5mdW5jdGlvbiBidWlsZEtleW1hcChzY2hlbWEsIG1hcEtleXMpIHtcbiAgdmFyIGtleXMgPSB7fSwgdHlwZTtcbiAgZnVuY3Rpb24gYmluZChrZXksIGNtZCkge1xuICAgIGlmIChtYXBLZXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gbWFwS2V5c1trZXldO1xuICAgICAgaWYgKG1hcHBlZCA9PT0gZmFsc2UpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChtYXBwZWQpIHsga2V5ID0gbWFwcGVkOyB9XG4gICAgfVxuICAgIGtleXNba2V5XSA9IGNtZDtcbiAgfVxuXG5cbiAgYmluZChcIk1vZC16XCIsIHVuZG8pO1xuICBiaW5kKFwiU2hpZnQtTW9kLXpcIiwgcmVkbyk7XG4gIGJpbmQoXCJCYWNrc3BhY2VcIiwgdW5kb0lucHV0UnVsZSk7XG4gIGlmICghbWFjKSB7IGJpbmQoXCJNb2QteVwiLCByZWRvKTsgfVxuXG4gIGJpbmQoXCJBbHQtQXJyb3dVcFwiLCBqb2luVXApO1xuICBiaW5kKFwiQWx0LUFycm93RG93blwiLCBqb2luRG93bik7XG4gIGJpbmQoXCJNb2QtQnJhY2tldExlZnRcIiwgbGlmdCk7XG4gIGJpbmQoXCJFc2NhcGVcIiwgc2VsZWN0UGFyZW50Tm9kZSk7XG5cbiAgaWYgKHR5cGUgPSBzY2hlbWEubWFya3Muc3Ryb25nKSB7XG4gICAgYmluZChcIk1vZC1iXCIsIHRvZ2dsZU1hcmsodHlwZSkpO1xuICAgIGJpbmQoXCJNb2QtQlwiLCB0b2dnbGVNYXJrKHR5cGUpKTtcbiAgfVxuICBpZiAodHlwZSA9IHNjaGVtYS5tYXJrcy5lbSkge1xuICAgIGJpbmQoXCJNb2QtaVwiLCB0b2dnbGVNYXJrKHR5cGUpKTtcbiAgICBiaW5kKFwiTW9kLUlcIiwgdG9nZ2xlTWFyayh0eXBlKSk7XG4gIH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubWFya3MuY29kZSlcbiAgICB7IGJpbmQoXCJNb2QtYFwiLCB0b2dnbGVNYXJrKHR5cGUpKTsgfVxuXG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmJ1bGxldF9saXN0KVxuICAgIHsgYmluZChcIlNoaWZ0LUN0cmwtOFwiLCB3cmFwSW5MaXN0KHR5cGUpKTsgfVxuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5vcmRlcmVkX2xpc3QpXG4gICAgeyBiaW5kKFwiU2hpZnQtQ3RybC05XCIsIHdyYXBJbkxpc3QodHlwZSkpOyB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmJsb2NrcXVvdGUpXG4gICAgeyBiaW5kKFwiQ3RybC0+XCIsIHdyYXBJbih0eXBlKSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuaGFyZF9icmVhaykge1xuICAgIHZhciBiciA9IHR5cGUsIGNtZCA9IGNoYWluQ29tbWFuZHMoZXhpdENvZGUsIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKGJyLmNyZWF0ZSgpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSk7XG4gICAgYmluZChcIk1vZC1FbnRlclwiLCBjbWQpO1xuICAgIGJpbmQoXCJTaGlmdC1FbnRlclwiLCBjbWQpO1xuICAgIGlmIChtYWMpIHsgYmluZChcIkN0cmwtRW50ZXJcIiwgY21kKTsgfVxuICB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmxpc3RfaXRlbSkge1xuICAgIGJpbmQoXCJFbnRlclwiLCBzcGxpdExpc3RJdGVtKHR5cGUpKTtcbiAgICBiaW5kKFwiTW9kLVtcIiwgbGlmdExpc3RJdGVtKHR5cGUpKTtcbiAgICBiaW5kKFwiTW9kLV1cIiwgc2lua0xpc3RJdGVtKHR5cGUpKTtcbiAgfVxuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5wYXJhZ3JhcGgpXG4gICAgeyBiaW5kKFwiU2hpZnQtQ3RybC0wXCIsIHNldEJsb2NrVHlwZSh0eXBlKSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuY29kZV9ibG9jaylcbiAgICB7IGJpbmQoXCJTaGlmdC1DdHJsLVxcXFxcIiwgc2V0QmxvY2tUeXBlKHR5cGUpKTsgfVxuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5oZWFkaW5nKVxuICAgIHsgZm9yICh2YXIgaSA9IDE7IGkgPD0gNjsgaSsrKSB7IGJpbmQoXCJTaGlmdC1DdHJsLVwiICsgaSwgc2V0QmxvY2tUeXBlKHR5cGUsIHtsZXZlbDogaX0pKTsgfSB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmhvcml6b250YWxfcnVsZSkge1xuICAgIHZhciBociA9IHR5cGU7XG4gICAgYmluZChcIk1vZC1fXCIsIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKGhyLmNyZWF0ZSgpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ga2V5c1xufVxuXG4vLyA6IChOb2RlVHlwZSkg4oaSIElucHV0UnVsZVxuLy8gR2l2ZW4gYSBibG9ja3F1b3RlIG5vZGUgdHlwZSwgcmV0dXJucyBhbiBpbnB1dCBydWxlIHRoYXQgdHVybnMgYFwiPiBcImBcbi8vIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBpbnRvIGEgYmxvY2txdW90ZS5cbmZ1bmN0aW9uIGJsb2NrUXVvdGVSdWxlKG5vZGVUeXBlKSB7XG4gIHJldHVybiB3cmFwcGluZ0lucHV0UnVsZSgvXlxccyo+XFxzJC8sIG5vZGVUeXBlKVxufVxuXG4vLyA6IChOb2RlVHlwZSkg4oaSIElucHV0UnVsZVxuLy8gR2l2ZW4gYSBsaXN0IG5vZGUgdHlwZSwgcmV0dXJucyBhbiBpbnB1dCBydWxlIHRoYXQgdHVybnMgYSBudW1iZXJcbi8vIGZvbGxvd2VkIGJ5IGEgZG90IGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBpbnRvIGFuIG9yZGVyZWQgbGlzdC5cbmZ1bmN0aW9uIG9yZGVyZWRMaXN0UnVsZShub2RlVHlwZSkge1xuICByZXR1cm4gd3JhcHBpbmdJbnB1dFJ1bGUoL14oXFxkKylcXC5cXHMkLywgbm9kZVR5cGUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gKHtvcmRlcjogK21hdGNoWzFdfSk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobWF0Y2gsIG5vZGUpIHsgcmV0dXJuIG5vZGUuY2hpbGRDb3VudCArIG5vZGUuYXR0cnMub3JkZXIgPT0gK21hdGNoWzFdOyB9KVxufVxuXG4vLyA6IChOb2RlVHlwZSkg4oaSIElucHV0UnVsZVxuLy8gR2l2ZW4gYSBsaXN0IG5vZGUgdHlwZSwgcmV0dXJucyBhbiBpbnB1dCBydWxlIHRoYXQgdHVybnMgYSBidWxsZXRcbi8vIChkYXNoLCBwbHVzaCwgb3IgYXN0ZXJpc2spIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBpbnRvIGFcbi8vIGJ1bGxldCBsaXN0LlxuZnVuY3Rpb24gYnVsbGV0TGlzdFJ1bGUobm9kZVR5cGUpIHtcbiAgcmV0dXJuIHdyYXBwaW5nSW5wdXRSdWxlKC9eXFxzKihbLSsqXSlcXHMkLywgbm9kZVR5cGUpXG59XG5cbi8vIDogKE5vZGVUeXBlKSDihpIgSW5wdXRSdWxlXG4vLyBHaXZlbiBhIGNvZGUgYmxvY2sgbm9kZSB0eXBlLCByZXR1cm5zIGFuIGlucHV0IHJ1bGUgdGhhdCB0dXJucyBhXG4vLyB0ZXh0YmxvY2sgc3RhcnRpbmcgd2l0aCB0aHJlZSBiYWNrdGlja3MgaW50byBhIGNvZGUgYmxvY2suXG5mdW5jdGlvbiBjb2RlQmxvY2tSdWxlKG5vZGVUeXBlKSB7XG4gIHJldHVybiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKC9eYGBgJC8sIG5vZGVUeXBlKVxufVxuXG4vLyA6IChOb2RlVHlwZSwgbnVtYmVyKSDihpIgSW5wdXRSdWxlXG4vLyBHaXZlbiBhIG5vZGUgdHlwZSBhbmQgYSBtYXhpbXVtIGxldmVsLCBjcmVhdGVzIGFuIGlucHV0IHJ1bGUgdGhhdFxuLy8gdHVybnMgdXAgdG8gdGhhdCBudW1iZXIgb2YgYCNgIGNoYXJhY3RlcnMgZm9sbG93ZWQgYnkgYSBzcGFjZSBhdFxuLy8gdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrIGludG8gYSBoZWFkaW5nIHdob3NlIGxldmVsIGNvcnJlc3BvbmRzIHRvXG4vLyB0aGUgbnVtYmVyIG9mIGAjYCBzaWducy5cbmZ1bmN0aW9uIGhlYWRpbmdSdWxlKG5vZGVUeXBlLCBtYXhMZXZlbCkge1xuICByZXR1cm4gdGV4dGJsb2NrVHlwZUlucHV0UnVsZShuZXcgUmVnRXhwKFwiXigjezEsXCIgKyBtYXhMZXZlbCArIFwifSlcXFxccyRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuICh7bGV2ZWw6IG1hdGNoWzFdLmxlbmd0aH0pOyB9KVxufVxuXG4vLyA6IChTY2hlbWEpIOKGkiBQbHVnaW5cbi8vIEEgc2V0IG9mIGlucHV0IHJ1bGVzIGZvciBjcmVhdGluZyB0aGUgYmFzaWMgYmxvY2sgcXVvdGVzLCBsaXN0cyxcbi8vIGNvZGUgYmxvY2tzLCBhbmQgaGVhZGluZy5cbmZ1bmN0aW9uIGJ1aWxkSW5wdXRSdWxlcyhzY2hlbWEpIHtcbiAgdmFyIHJ1bGVzID0gc21hcnRRdW90ZXMuY29uY2F0KGVsbGlwc2lzLCBlbURhc2gpLCB0eXBlO1xuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5ibG9ja3F1b3RlKSB7IHJ1bGVzLnB1c2goYmxvY2tRdW90ZVJ1bGUodHlwZSkpOyB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLm9yZGVyZWRfbGlzdCkgeyBydWxlcy5wdXNoKG9yZGVyZWRMaXN0UnVsZSh0eXBlKSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuYnVsbGV0X2xpc3QpIHsgcnVsZXMucHVzaChidWxsZXRMaXN0UnVsZSh0eXBlKSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuY29kZV9ibG9jaykgeyBydWxlcy5wdXNoKGNvZGVCbG9ja1J1bGUodHlwZSkpOyB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmhlYWRpbmcpIHsgcnVsZXMucHVzaChoZWFkaW5nUnVsZSh0eXBlLCA2KSk7IH1cbiAgcmV0dXJuIGlucHV0UnVsZXMoe3J1bGVzOiBydWxlc30pXG59XG5cbi8vICEhIFRoaXMgbW9kdWxlIGV4cG9ydHMgaGVscGVyIGZ1bmN0aW9ucyBmb3IgZGVyaXZpbmcgYSBzZXQgb2YgYmFzaWNcbi8vIG1lbnUgaXRlbXMsIGlucHV0IHJ1bGVzLCBvciBrZXkgYmluZGluZ3MgZnJvbSBhIHNjaGVtYS4gVGhlc2Vcbi8vIHZhbHVlcyBuZWVkIHRvIGtub3cgYWJvdXQgdGhlIHNjaGVtYSBmb3IgdHdvIHJlYXNvbnPigJR0aGV5IG5lZWRcbi8vIGFjY2VzcyB0byBzcGVjaWZpYyBpbnN0YW5jZXMgb2Ygbm9kZSBhbmQgbWFyayB0eXBlcywgYW5kIHRoZXkgbmVlZFxuLy8gdG8ga25vdyB3aGljaCBvZiB0aGUgbm9kZSBhbmQgbWFyayB0eXBlcyB0aGF0IHRoZXkga25vdyBhYm91dCBhcmVcbi8vIGFjdHVhbGx5IHByZXNlbnQgaW4gdGhlIHNjaGVtYS5cbi8vXG4vLyBUaGUgYGV4YW1wbGVTZXR1cGAgcGx1Z2luIHRpZXMgdGhlc2UgdG9nZXRoZXIgaW50byBhIHBsdWdpbiB0aGF0XG4vLyB3aWxsIGF1dG9tYXRpY2FsbHkgZW5hYmxlIHRoaXMgYmFzaWMgZnVuY3Rpb25hbGl0eSBpbiBhbiBlZGl0b3IuXG5cbi8vIDo6IChPYmplY3QpIOKGkiBbUGx1Z2luXVxuLy8gQSBjb252ZW5pZW5jZSBwbHVnaW4gdGhhdCBidW5kbGVzIHRvZ2V0aGVyIGEgc2ltcGxlIG1lbnUgd2l0aCBiYXNpY1xuLy8ga2V5IGJpbmRpbmdzLCBpbnB1dCBydWxlcywgYW5kIHN0eWxpbmcgZm9yIHRoZSBleGFtcGxlIHNjaGVtYS5cbi8vIFByb2JhYmx5IG9ubHkgdXNlZnVsIGZvciBxdWlja2x5IHNldHRpbmcgdXAgYSBwYXNzYWJsZVxuLy8gZWRpdG9y4oCUeW91J2xsIG5lZWQgbW9yZSBjb250cm9sIG92ZXIgeW91ciBzZXR0aW5ncyBpbiBtb3N0XG4vLyByZWFsLXdvcmxkIHNpdHVhdGlvbnMuXG4vL1xuLy8gICBvcHRpb25zOjotIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgcmVjb2duaXplZDpcbi8vXG4vLyAgICAgc2NoZW1hOjogU2NoZW1hXG4vLyAgICAgVGhlIHNjaGVtYSB0byBnZW5lcmF0ZSBrZXkgYmluZGluZ3MgYW5kIG1lbnUgaXRlbXMgZm9yLlxuLy9cbi8vICAgICBtYXBLZXlzOjogP09iamVjdFxuLy8gICAgIENhbiBiZSB1c2VkIHRvIFthZGp1c3RdKCNleGFtcGxlLXNldHVwLmJ1aWxkS2V5bWFwKSB0aGUga2V5IGJpbmRpbmdzIGNyZWF0ZWQuXG4vL1xuLy8gICAgIG1lbnVCYXI6OiA/Ym9vbFxuLy8gICAgIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoZSBtZW51IGJhci5cbi8vXG4vLyAgICAgaGlzdG9yeTo6ID9ib29sXG4vLyAgICAgU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhlIGhpc3RvcnkgcGx1Z2luLlxuLy9cbi8vICAgICBmbG9hdGluZ01lbnU6OiA/Ym9vbFxuLy8gICAgIFNldCB0byBmYWxzZSB0byBtYWtlIHRoZSBtZW51IGJhciBub24tZmxvYXRpbmcuXG4vL1xuLy8gICAgIG1lbnVDb250ZW50OjogW1tNZW51SXRlbV1dXG4vLyAgICAgQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIG1lbnUgY29udGVudC5cbmZ1bmN0aW9uIGV4YW1wbGVTZXR1cChvcHRpb25zKSB7XG4gIHZhciBwbHVnaW5zID0gW1xuICAgIGJ1aWxkSW5wdXRSdWxlcyhvcHRpb25zLnNjaGVtYSksXG4gICAga2V5bWFwKGJ1aWxkS2V5bWFwKG9wdGlvbnMuc2NoZW1hLCBvcHRpb25zLm1hcEtleXMpKSxcbiAgICBrZXltYXAoYmFzZUtleW1hcCksXG4gICAgZHJvcEN1cnNvcigpLFxuICAgIGdhcEN1cnNvcigpXG4gIF07XG4gIGlmIChvcHRpb25zLm1lbnVCYXIgIT09IGZhbHNlKVxuICAgIHsgcGx1Z2lucy5wdXNoKG1lbnVCYXIoe2Zsb2F0aW5nOiBvcHRpb25zLmZsb2F0aW5nTWVudSAhPT0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9wdGlvbnMubWVudUNvbnRlbnQgfHwgYnVpbGRNZW51SXRlbXMob3B0aW9ucy5zY2hlbWEpLmZ1bGxNZW51fSkpOyB9XG4gIGlmIChvcHRpb25zLmhpc3RvcnkgIT09IGZhbHNlKVxuICAgIHsgcGx1Z2lucy5wdXNoKGhpc3RvcnkoKSk7IH1cblxuICByZXR1cm4gcGx1Z2lucy5jb25jYXQobmV3IFBsdWdpbih7XG4gICAgcHJvcHM6IHtcbiAgICAgIGF0dHJpYnV0ZXM6IHtjbGFzczogXCJQcm9zZU1pcnJvci1leGFtcGxlLXNldHVwLXN0eWxlXCJ9XG4gICAgfVxuICB9KSlcbn1cblxuZXhwb3J0IHsgYnVpbGRJbnB1dFJ1bGVzLCBidWlsZEtleW1hcCwgYnVpbGRNZW51SXRlbXMsIGV4YW1wbGVTZXR1cCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJpbXBvcnQgeyBrZXlkb3duSGFuZGxlciB9IGZyb20gJ3Byb3NlbWlycm9yLWtleW1hcCc7XG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBTZWxlY3Rpb24sIFBsdWdpbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IERlY29yYXRpb25TZXQsIERlY29yYXRpb24gfSBmcm9tICdwcm9zZW1pcnJvci12aWV3JztcbmltcG9ydCB7IFNsaWNlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG4vLyA6Oi0gR2FwIGN1cnNvciBzZWxlY3Rpb25zIGFyZSByZXByZXNlbnRlZCB1c2luZyB0aGlzIGNsYXNzLiBJdHNcbi8vIGAkYW5jaG9yYCBhbmQgYCRoZWFkYCBwcm9wZXJ0aWVzIGJvdGggcG9pbnQgYXQgdGhlIGN1cnNvciBwb3NpdGlvbi5cbnZhciBHYXBDdXJzb3IgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZWxlY3Rpb24pIHtcbiAgZnVuY3Rpb24gR2FwQ3Vyc29yKCRwb3MpIHtcbiAgICBTZWxlY3Rpb24uY2FsbCh0aGlzLCAkcG9zLCAkcG9zKTtcbiAgfVxuXG4gIGlmICggU2VsZWN0aW9uICkgR2FwQ3Vyc29yLl9fcHJvdG9fXyA9IFNlbGVjdGlvbjtcbiAgR2FwQ3Vyc29yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNlbGVjdGlvbiAmJiBTZWxlY3Rpb24ucHJvdG90eXBlICk7XG4gIEdhcEN1cnNvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHYXBDdXJzb3I7XG5cbiAgR2FwQ3Vyc29yLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKGRvYywgbWFwcGluZykge1xuICAgIHZhciAkcG9zID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gICAgcmV0dXJuIEdhcEN1cnNvci52YWxpZCgkcG9zKSA/IG5ldyBHYXBDdXJzb3IoJHBvcykgOiBTZWxlY3Rpb24ubmVhcigkcG9zKVxuICB9O1xuXG4gIEdhcEN1cnNvci5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQgKCkgeyByZXR1cm4gU2xpY2UuZW1wdHkgfTtcblxuICBHYXBDdXJzb3IucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgR2FwQ3Vyc29yICYmIG90aGVyLmhlYWQgPT0gdGhpcy5oZWFkXG4gIH07XG5cbiAgR2FwQ3Vyc29yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB7dHlwZTogXCJnYXBjdXJzb3JcIiwgcG9zOiB0aGlzLmhlYWR9XG4gIH07XG5cbiAgR2FwQ3Vyc29yLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04gKGRvYywganNvbikge1xuICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIikgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEdhcEN1cnNvci5mcm9tSlNPTlwiKSB9XG4gICAgcmV0dXJuIG5ldyBHYXBDdXJzb3IoZG9jLnJlc29sdmUoanNvbi5wb3MpKVxuICB9O1xuXG4gIEdhcEN1cnNvci5wcm90b3R5cGUuZ2V0Qm9va21hcmsgPSBmdW5jdGlvbiBnZXRCb29rbWFyayAoKSB7IHJldHVybiBuZXcgR2FwQm9va21hcmsodGhpcy5hbmNob3IpIH07XG5cbiAgR2FwQ3Vyc29yLnZhbGlkID0gZnVuY3Rpb24gdmFsaWQgKCRwb3MpIHtcbiAgICB2YXIgcGFyZW50ID0gJHBvcy5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudC5pc1RleHRibG9jayB8fCAhY2xvc2VkQmVmb3JlKCRwb3MpIHx8ICFjbG9zZWRBZnRlcigkcG9zKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBvdmVycmlkZSA9IHBhcmVudC50eXBlLnNwZWMuYWxsb3dHYXBDdXJzb3I7XG4gICAgaWYgKG92ZXJyaWRlICE9IG51bGwpIHsgcmV0dXJuIG92ZXJyaWRlIH1cbiAgICB2YXIgZGVmbHQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoJHBvcy5pbmRleCgpKS5kZWZhdWx0VHlwZTtcbiAgICByZXR1cm4gZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2tcbiAgfTtcblxuICBHYXBDdXJzb3IuZmluZEZyb20gPSBmdW5jdGlvbiBmaW5kRnJvbSAoJHBvcywgZGlyLCBtdXN0TW92ZSkge1xuICAgIHNlYXJjaDogZm9yICg7Oykge1xuICAgICAgaWYgKCFtdXN0TW92ZSAmJiBHYXBDdXJzb3IudmFsaWQoJHBvcykpIHsgcmV0dXJuICRwb3MgfVxuICAgICAgdmFyIHBvcyA9ICRwb3MucG9zLCBuZXh0ID0gbnVsbDtcbiAgICAgIC8vIFNjYW4gdXAgZnJvbSB0aGlzIHBvc2l0aW9uXG4gICAgICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aDs7IGQtLSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gJHBvcy5ub2RlKGQpO1xuICAgICAgICBpZiAoZGlyID4gMCA/ICRwb3MuaW5kZXhBZnRlcihkKSA8IHBhcmVudC5jaGlsZENvdW50IDogJHBvcy5pbmRleChkKSA+IDApIHtcbiAgICAgICAgICBuZXh0ID0gcGFyZW50LmNoaWxkKGRpciA+IDAgPyAkcG9zLmluZGV4QWZ0ZXIoZCkgOiAkcG9zLmluZGV4KGQpIC0gMSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmIChkID09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgIHZhciAkY3VyID0gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICBpZiAoR2FwQ3Vyc29yLnZhbGlkKCRjdXIpKSB7IHJldHVybiAkY3VyIH1cbiAgICAgIH1cblxuICAgICAgLy8gQW5kIHRoZW4gZG93biBpbnRvIHRoZSBuZXh0IG5vZGVcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIGluc2lkZSA9IGRpciA+IDAgPyBuZXh0LmZpcnN0Q2hpbGQgOiBuZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFpbnNpZGUpIHtcbiAgICAgICAgICBpZiAobmV4dC5pc0F0b20gJiYgIW5leHQuaXNUZXh0ICYmICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZXh0KSkge1xuICAgICAgICAgICAgJHBvcyA9ICRwb3MuZG9jLnJlc29sdmUocG9zICsgbmV4dC5ub2RlU2l6ZSAqIGRpcik7XG4gICAgICAgICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGludWUgc2VhcmNoXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgbmV4dCA9IGluc2lkZTtcbiAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgdmFyICRjdXIkMSA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgaWYgKEdhcEN1cnNvci52YWxpZCgkY3VyJDEpKSB7IHJldHVybiAkY3VyJDEgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gR2FwQ3Vyc29yO1xufShTZWxlY3Rpb24pKTtcblxuR2FwQ3Vyc29yLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5cblNlbGVjdGlvbi5qc29uSUQoXCJnYXBjdXJzb3JcIiwgR2FwQ3Vyc29yKTtcblxudmFyIEdhcEJvb2ttYXJrID0gZnVuY3Rpb24gR2FwQm9va21hcmsocG9zKSB7XG4gIHRoaXMucG9zID0gcG9zO1xufTtcbkdhcEJvb2ttYXJrLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBpbmcpIHtcbiAgcmV0dXJuIG5ldyBHYXBCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLnBvcykpXG59O1xuR2FwQm9va21hcmsucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChkb2MpIHtcbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLnBvcyk7XG4gIHJldHVybiBHYXBDdXJzb3IudmFsaWQoJHBvcykgPyBuZXcgR2FwQ3Vyc29yKCRwb3MpIDogU2VsZWN0aW9uLm5lYXIoJHBvcylcbn07XG5cbmZ1bmN0aW9uIGNsb3NlZEJlZm9yZSgkcG9zKSB7XG4gIGZvciAodmFyIGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgIHZhciBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgLy8gQXQgdGhlIHN0YXJ0IG9mIHRoaXMgcGFyZW50LCBsb29rIGF0IG5leHQgb25lXG4gICAgaWYgKGluZGV4ID09IDApIHsgY29udGludWUgfVxuICAgIC8vIFNlZSBpZiB0aGUgbm9kZSBiZWZvcmUgKG9yIGl0cyBmaXJzdCBhbmNlc3RvcikgaXMgY2xvc2VkXG4gICAgZm9yICh2YXIgYmVmb3JlID0gJHBvcy5ub2RlKGQpLmNoaWxkKGluZGV4IC0gMSk7OyBiZWZvcmUgPSBiZWZvcmUubGFzdENoaWxkKSB7XG4gICAgICBpZiAoKGJlZm9yZS5jaGlsZENvdW50ID09IDAgJiYgIWJlZm9yZS5pbmxpbmVDb250ZW50KSB8fCBiZWZvcmUuaXNBdG9tIHx8IGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmIChiZWZvcmUuaW5saW5lQ29udGVudCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgfVxuICAvLyBIaXQgc3RhcnQgb2YgZG9jdW1lbnRcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gY2xvc2VkQWZ0ZXIoJHBvcykge1xuICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICB2YXIgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoZCksIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpIHsgY29udGludWUgfVxuICAgIGZvciAodmFyIGFmdGVyID0gcGFyZW50LmNoaWxkKGluZGV4KTs7IGFmdGVyID0gYWZ0ZXIuZmlyc3RDaGlsZCkge1xuICAgICAgaWYgKChhZnRlci5jaGlsZENvdW50ID09IDAgJiYgIWFmdGVyLmlubGluZUNvbnRlbnQpIHx8IGFmdGVyLmlzQXRvbSB8fCBhZnRlci50eXBlLnNwZWMuaXNvbGF0aW5nKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmIChhZnRlci5pbmxpbmVDb250ZW50KSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIDo6ICgpIOKGkiBQbHVnaW5cbi8vIENyZWF0ZSBhIGdhcCBjdXJzb3IgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIHRoaXMgd2lsbCBjYXB0dXJlIGNsaWNrc1xuLy8gbmVhciBhbmQgYXJyb3cta2V5LW1vdGlvbiBwYXN0IHBsYWNlcyB0aGF0IGRvbid0IGhhdmUgYSBub3JtYWxseVxuLy8gc2VsZWN0YWJsZSBwb3NpdGlvbiBuZWFyYnksIGFuZCBjcmVhdGUgYSBnYXAgY3Vyc29yIHNlbGVjdGlvbiBmb3Jcbi8vIHRoZW0uIFRoZSBjdXJzb3IgaXMgZHJhd24gYXMgYW4gZWxlbWVudCB3aXRoIGNsYXNzXG4vLyBgUHJvc2VNaXJyb3ItZ2FwY3Vyc29yYC4gWW91IGNhbiBlaXRoZXIgaW5jbHVkZVxuLy8gYHN0eWxlL2dhcGN1cnNvci5jc3NgIGZyb20gdGhlIHBhY2thZ2UncyBkaXJlY3Rvcnkgb3IgYWRkIHlvdXIgb3duXG4vLyBzdHlsZXMgdG8gbWFrZSBpdCB2aXNpYmxlLlxudmFyIGdhcEN1cnNvciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgcHJvcHM6IHtcbiAgICAgIGRlY29yYXRpb25zOiBkcmF3R2FwQ3Vyc29yLFxuXG4gICAgICBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuOiBmdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuKF92aWV3LCAkYW5jaG9yLCAkaGVhZCkge1xuICAgICAgICBpZiAoJGFuY2hvci5wb3MgPT0gJGhlYWQucG9zICYmIEdhcEN1cnNvci52YWxpZCgkaGVhZCkpIHsgcmV0dXJuIG5ldyBHYXBDdXJzb3IoJGhlYWQpIH1cbiAgICAgIH0sXG5cbiAgICAgIGhhbmRsZUNsaWNrOiBoYW5kbGVDbGljayxcbiAgICAgIGhhbmRsZUtleURvd246IGhhbmRsZUtleURvd25cbiAgICB9XG4gIH0pXG59O1xuXG52YXIgaGFuZGxlS2V5RG93biA9IGtleWRvd25IYW5kbGVyKHtcbiAgXCJBcnJvd0xlZnRcIjogYXJyb3coXCJob3JpelwiLCAtMSksXG4gIFwiQXJyb3dSaWdodFwiOiBhcnJvdyhcImhvcml6XCIsIDEpLFxuICBcIkFycm93VXBcIjogYXJyb3coXCJ2ZXJ0XCIsIC0xKSxcbiAgXCJBcnJvd0Rvd25cIjogYXJyb3coXCJ2ZXJ0XCIsIDEpXG59KTtcblxuZnVuY3Rpb24gYXJyb3coYXhpcywgZGlyKSB7XG4gIHZhciBkaXJTdHIgPSBheGlzID09IFwidmVydFwiID8gKGRpciA+IDAgPyBcImRvd25cIiA6IFwidXBcIikgOiAoZGlyID4gMCA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgIHZhciBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgdmFyICRzdGFydCA9IGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tLCBtdXN0TW92ZSA9IHNlbC5lbXB0eTtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgaWYgKCF2aWV3LmVuZE9mVGV4dGJsb2NrKGRpclN0cikgfHwgJHN0YXJ0LmRlcHRoID09IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHN0YXJ0LmFmdGVyKCkgOiAkc3RhcnQuYmVmb3JlKCkpO1xuICAgIH1cbiAgICB2YXIgJGZvdW5kID0gR2FwQ3Vyc29yLmZpbmRGcm9tKCRzdGFydCwgZGlyLCBtdXN0TW92ZSk7XG4gICAgaWYgKCEkZm91bmQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJGZvdW5kKSkpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDbGljayh2aWV3LCBwb3MsIGV2ZW50KSB7XG4gIGlmICghdmlldy5lZGl0YWJsZSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgaWYgKCFHYXBDdXJzb3IudmFsaWQoJHBvcykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIHJlZiA9IHZpZXcucG9zQXRDb29yZHMoe2xlZnQ6IGV2ZW50LmNsaWVudFgsIHRvcDogZXZlbnQuY2xpZW50WX0pO1xuICB2YXIgaW5zaWRlID0gcmVmLmluc2lkZTtcbiAgaWYgKGluc2lkZSA+IC0xICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHZpZXcuc3RhdGUuZG9jLm5vZGVBdChpbnNpZGUpKSkgeyByZXR1cm4gZmFsc2UgfVxuICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJHBvcykpKTtcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZHJhd0dhcEN1cnNvcihzdGF0ZSkge1xuICBpZiAoIShzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBHYXBDdXJzb3IpKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBub2RlLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItZ2FwY3Vyc29yXCI7XG4gIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtEZWNvcmF0aW9uLndpZGdldChzdGF0ZS5zZWxlY3Rpb24uaGVhZCwgbm9kZSwge2tleTogXCJnYXBjdXJzb3JcIn0pXSlcbn1cblxuZXhwb3J0IHsgR2FwQ3Vyc29yLCBnYXBDdXJzb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIiwiaW1wb3J0IFJvcGVTZXF1ZW5jZSBmcm9tICdyb3BlLXNlcXVlbmNlJztcbmltcG9ydCB7IE1hcHBpbmcgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgUGx1Z2luS2V5LCBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbi8vIFByb3NlTWlycm9yJ3MgaGlzdG9yeSBpc24ndCBzaW1wbHkgYSB3YXkgdG8gcm9sbCBiYWNrIHRvIGEgcHJldmlvdXNcbi8vIHN0YXRlLCBiZWNhdXNlIFByb3NlTWlycm9yIHN1cHBvcnRzIGFwcGx5aW5nIGNoYW5nZXMgd2l0aG91dCBhZGRpbmdcbi8vIHRoZW0gdG8gdGhlIGhpc3RvcnkgKGZvciBleGFtcGxlIGR1cmluZyBjb2xsYWJvcmF0aW9uKS5cbi8vXG4vLyBUbyB0aGlzIGVuZCwgZWFjaCAnQnJhbmNoJyAob25lIGZvciB0aGUgdW5kbyBoaXN0b3J5IGFuZCBvbmUgZm9yXG4vLyB0aGUgcmVkbyBoaXN0b3J5KSBrZWVwcyBhbiBhcnJheSBvZiAnSXRlbXMnLCB3aGljaCBjYW4gb3B0aW9uYWxseVxuLy8gaG9sZCBhIHN0ZXAgKGFuIGFjdHVhbCB1bmRvYWJsZSBjaGFuZ2UpLCBhbmQgYWx3YXlzIGhvbGQgYSBwb3NpdGlvblxuLy8gbWFwICh3aGljaCBpcyBuZWVkZWQgdG8gbW92ZSBjaGFuZ2VzIGJlbG93IHRoZW0gdG8gYXBwbHkgdG8gdGhlXG4vLyBjdXJyZW50IGRvY3VtZW50KS5cbi8vXG4vLyBBbiBpdGVtIHRoYXQgaGFzIGJvdGggYSBzdGVwIGFuZCBhIHNlbGVjdGlvbiBib29rbWFyayBpcyB0aGUgc3RhcnRcbi8vIG9mIGFuICdldmVudCcg4oCUIGEgZ3JvdXAgb2YgY2hhbmdlcyB0aGF0IHdpbGwgYmUgdW5kb25lIG9yIHJlZG9uZSBhdFxuLy8gb25jZS4gKEl0IHN0b3JlcyBvbmx5IHRoZSBib29rbWFyaywgc2luY2UgdGhhdCB3YXkgd2UgZG9uJ3QgaGF2ZSB0b1xuLy8gcHJvdmlkZSBhIGRvY3VtZW50IHVudGlsIHRoZSBzZWxlY3Rpb24gaXMgYWN0dWFsbHkgYXBwbGllZCwgd2hpY2hcbi8vIGlzIHVzZWZ1bCB3aGVuIGNvbXByZXNzaW5nLilcblxuLy8gVXNlZCB0byBzY2hlZHVsZSBoaXN0b3J5IGNvbXByZXNzaW9uXG52YXIgbWF4X2VtcHR5X2l0ZW1zID0gNTAwO1xuXG52YXIgQnJhbmNoID0gZnVuY3Rpb24gQnJhbmNoKGl0ZW1zLCBldmVudENvdW50KSB7XG4gIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgdGhpcy5ldmVudENvdW50ID0gZXZlbnRDb3VudDtcbn07XG5cbi8vIDogKEVkaXRvclN0YXRlLCBib29sKSDihpIgP3t0cmFuc2Zvcm06IFRyYW5zZm9ybSwgc2VsZWN0aW9uOiA/U2VsZWN0aW9uQm9va21hcmssIHJlbWFpbmluZzogQnJhbmNofVxuLy8gUG9wIHRoZSBsYXRlc3QgZXZlbnQgb2ZmIHRoZSBicmFuY2gncyBoaXN0b3J5IGFuZCBhcHBseSBpdFxuLy8gdG8gYSBkb2N1bWVudCB0cmFuc2Zvcm0uXG5CcmFuY2gucHJvdG90eXBlLnBvcEV2ZW50ID0gZnVuY3Rpb24gcG9wRXZlbnQgKHN0YXRlLCBwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKSB7IHJldHVybiBudWxsIH1cblxuICB2YXIgZW5kID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIGZvciAoOzsgZW5kLS0pIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuaXRlbXMuZ2V0KGVuZCAtIDEpO1xuICAgIGlmIChuZXh0LnNlbGVjdGlvbikgeyAtLWVuZDsgYnJlYWsgfVxuICB9XG5cbiAgdmFyIHJlbWFwLCBtYXBGcm9tO1xuICBpZiAocHJlc2VydmVJdGVtcykge1xuICAgIHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoZW5kLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICB9XG4gIHZhciB0cmFuc2Zvcm0gPSBzdGF0ZS50cjtcbiAgdmFyIHNlbGVjdGlvbiwgcmVtYWluaW5nO1xuICB2YXIgYWRkQWZ0ZXIgPSBbXSwgYWRkQmVmb3JlID0gW107XG5cbiAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgaWYgKCFpdGVtLnN0ZXApIHtcbiAgICAgIGlmICghcmVtYXApIHtcbiAgICAgICAgcmVtYXAgPSB0aGlzJDEucmVtYXBwaW5nKGVuZCwgaSArIDEpO1xuICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBtYXBGcm9tLS07XG4gICAgICBhZGRCZWZvcmUucHVzaChpdGVtKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChyZW1hcCkge1xuICAgICAgYWRkQmVmb3JlLnB1c2gobmV3IEl0ZW0oaXRlbS5tYXApKTtcbiAgICAgIHZhciBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksIG1hcDtcblxuICAgICAgaWYgKHN0ZXAgJiYgdHJhbnNmb3JtLm1heWJlU3RlcChzdGVwKS5kb2MpIHtcbiAgICAgICAgbWFwID0gdHJhbnNmb3JtLm1hcHBpbmcubWFwc1t0cmFuc2Zvcm0ubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICBhZGRBZnRlci5wdXNoKG5ldyBJdGVtKG1hcCwgbnVsbCwgbnVsbCwgYWRkQWZ0ZXIubGVuZ3RoICsgYWRkQmVmb3JlLmxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgbWFwRnJvbS0tO1xuICAgICAgaWYgKG1hcCkgeyByZW1hcC5hcHBlbmRNYXAobWFwLCBtYXBGcm9tKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm0ubWF5YmVTdGVwKGl0ZW0uc3RlcCk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0uc2VsZWN0aW9uKSB7XG4gICAgICBzZWxlY3Rpb24gPSByZW1hcCA/IGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSkgOiBpdGVtLnNlbGVjdGlvbjtcbiAgICAgIHJlbWFpbmluZyA9IG5ldyBCcmFuY2godGhpcyQxLml0ZW1zLnNsaWNlKDAsIGVuZCkuYXBwZW5kKGFkZEJlZm9yZS5yZXZlcnNlKCkuY29uY2F0KGFkZEFmdGVyKSksIHRoaXMkMS5ldmVudENvdW50IC0gMSk7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0sIHRoaXMuaXRlbXMubGVuZ3RoLCAwKTtcblxuICByZXR1cm4ge3JlbWFpbmluZzogcmVtYWluaW5nLCB0cmFuc2Zvcm06IHRyYW5zZm9ybSwgc2VsZWN0aW9uOiBzZWxlY3Rpb259XG59O1xuXG4vLyA6IChUcmFuc2Zvcm0sID9TZWxlY3Rpb25Cb29rbWFyaywgT2JqZWN0KSDihpIgQnJhbmNoXG4vLyBDcmVhdGUgYSBuZXcgYnJhbmNoIHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybSBhZGRlZC5cbkJyYW5jaC5wcm90b3R5cGUuYWRkVHJhbnNmb3JtID0gZnVuY3Rpb24gYWRkVHJhbnNmb3JtICh0cmFuc2Zvcm0sIHNlbGVjdGlvbiwgaGlzdE9wdGlvbnMsIHByZXNlcnZlSXRlbXMpIHtcbiAgdmFyIG5ld0l0ZW1zID0gW10sIGV2ZW50Q291bnQgPSB0aGlzLmV2ZW50Q291bnQ7XG4gIHZhciBvbGRJdGVtcyA9IHRoaXMuaXRlbXMsIGxhc3RJdGVtID0gIXByZXNlcnZlSXRlbXMgJiYgb2xkSXRlbXMubGVuZ3RoID8gb2xkSXRlbXMuZ2V0KG9sZEl0ZW1zLmxlbmd0aCAtIDEpIDogbnVsbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGVwID0gdHJhbnNmb3JtLnN0ZXBzW2ldLmludmVydCh0cmFuc2Zvcm0uZG9jc1tpXSk7XG4gICAgdmFyIGl0ZW0gPSBuZXcgSXRlbSh0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW2ldLCBzdGVwLCBzZWxlY3Rpb24pLCBtZXJnZWQgPSAodm9pZCAwKTtcbiAgICBpZiAobWVyZ2VkID0gbGFzdEl0ZW0gJiYgbGFzdEl0ZW0ubWVyZ2UoaXRlbSkpIHtcbiAgICAgIGl0ZW0gPSBtZXJnZWQ7XG4gICAgICBpZiAoaSkgeyBuZXdJdGVtcy5wb3AoKTsgfVxuICAgICAgZWxzZSB7IG9sZEl0ZW1zID0gb2xkSXRlbXMuc2xpY2UoMCwgb2xkSXRlbXMubGVuZ3RoIC0gMSk7IH1cbiAgICB9XG4gICAgbmV3SXRlbXMucHVzaChpdGVtKTtcbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBldmVudENvdW50Kys7XG4gICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIXByZXNlcnZlSXRlbXMpIHsgbGFzdEl0ZW0gPSBpdGVtOyB9XG4gIH1cbiAgdmFyIG92ZXJmbG93ID0gZXZlbnRDb3VudCAtIGhpc3RPcHRpb25zLmRlcHRoO1xuICBpZiAob3ZlcmZsb3cgPiBERVBUSF9PVkVSRkxPVykge1xuICAgIG9sZEl0ZW1zID0gY3V0T2ZmRXZlbnRzKG9sZEl0ZW1zLCBvdmVyZmxvdyk7XG4gICAgZXZlbnRDb3VudCAtPSBvdmVyZmxvdztcbiAgfVxuICByZXR1cm4gbmV3IEJyYW5jaChvbGRJdGVtcy5hcHBlbmQobmV3SXRlbXMpLCBldmVudENvdW50KVxufTtcblxuQnJhbmNoLnByb3RvdHlwZS5yZW1hcHBpbmcgPSBmdW5jdGlvbiByZW1hcHBpbmcgKGZyb20sIHRvKSB7XG4gIHZhciBtYXBzID0gbmV3IE1hcHBpbmc7XG4gIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIHZhciBtaXJyb3JQb3MgPSBpdGVtLm1pcnJvck9mZnNldCAhPSBudWxsICYmIGkgLSBpdGVtLm1pcnJvck9mZnNldCA+PSBmcm9tXG4gICAgICAgID8gbWFwcy5tYXBzLmxlbmd0aCAtIGl0ZW0ubWlycm9yT2Zmc2V0IDogbnVsbDtcbiAgICBtYXBzLmFwcGVuZE1hcChpdGVtLm1hcCwgbWlycm9yUG9zKTtcbiAgfSwgZnJvbSwgdG8pO1xuICByZXR1cm4gbWFwc1xufTtcblxuQnJhbmNoLnByb3RvdHlwZS5hZGRNYXBzID0gZnVuY3Rpb24gYWRkTWFwcyAoYXJyYXkpIHtcbiAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKSB7IHJldHVybiB0aGlzIH1cbiAgcmV0dXJuIG5ldyBCcmFuY2godGhpcy5pdGVtcy5hcHBlbmQoYXJyYXkubWFwKGZ1bmN0aW9uIChtYXApIHsgcmV0dXJuIG5ldyBJdGVtKG1hcCk7IH0pKSwgdGhpcy5ldmVudENvdW50KVxufTtcblxuLy8gOiAoVHJhbnNmb3JtLCBudW1iZXIpXG4vLyBXaGVuIHRoZSBjb2xsYWIgbW9kdWxlIHJlY2VpdmVzIHJlbW90ZSBjaGFuZ2VzLCB0aGUgaGlzdG9yeSBoYXNcbi8vIHRvIGtub3cgYWJvdXQgdGhvc2UsIHNvIHRoYXQgaXQgY2FuIGFkanVzdCB0aGUgc3RlcHMgdGhhdCB3ZXJlXG4vLyByZWJhc2VkIG9uIHRvcCBvZiB0aGUgcmVtb3RlIGNoYW5nZXMsIGFuZCBpbmNsdWRlIHRoZSBwb3NpdGlvblxuLy8gbWFwcyBmb3IgdGhlIHJlbW90ZSBjaGFuZ2VzIGluIGl0cyBhcnJheSBvZiBpdGVtcy5cbkJyYW5jaC5wcm90b3R5cGUucmViYXNlZCA9IGZ1bmN0aW9uIHJlYmFzZWQgKHJlYmFzZWRUcmFuc2Zvcm0sIHJlYmFzZWRDb3VudCkge1xuICBpZiAoIXRoaXMuZXZlbnRDb3VudCkgeyByZXR1cm4gdGhpcyB9XG5cbiAgdmFyIHJlYmFzZWRJdGVtcyA9IFtdLCBzdGFydCA9IE1hdGgubWF4KDAsIHRoaXMuaXRlbXMubGVuZ3RoIC0gcmViYXNlZENvdW50KTtcblxuICB2YXIgbWFwcGluZyA9IHJlYmFzZWRUcmFuc2Zvcm0ubWFwcGluZztcbiAgdmFyIG5ld1VudGlsID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7XG4gIHZhciBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgaWYgKGl0ZW0uc2VsZWN0aW9uKSB7IGV2ZW50Q291bnQtLTsgfSB9LCBzdGFydCk7XG5cbiAgdmFyIGlSZWJhc2VkID0gcmViYXNlZENvdW50O1xuICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgcG9zID0gbWFwcGluZy5nZXRNaXJyb3IoLS1pUmViYXNlZCk7XG4gICAgaWYgKHBvcyA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgbmV3VW50aWwgPSBNYXRoLm1pbihuZXdVbnRpbCwgcG9zKTtcbiAgICB2YXIgbWFwID0gbWFwcGluZy5tYXBzW3Bvc107XG4gICAgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgdmFyIHN0ZXAgPSByZWJhc2VkVHJhbnNmb3JtLnN0ZXBzW3Bvc10uaW52ZXJ0KHJlYmFzZWRUcmFuc2Zvcm0uZG9jc1twb3NdKTtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBpdGVtLnNlbGVjdGlvbiAmJiBpdGVtLnNlbGVjdGlvbi5tYXAobWFwcGluZy5zbGljZShpUmViYXNlZCArIDEsIHBvcykpO1xuICAgICAgaWYgKHNlbGVjdGlvbikgeyBldmVudENvdW50Kys7IH1cbiAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCwgc3RlcCwgc2VsZWN0aW9uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCkpO1xuICAgIH1cbiAgfSwgc3RhcnQpO1xuXG4gIHZhciBuZXdNYXBzID0gW107XG4gIGZvciAodmFyIGkgPSByZWJhc2VkQ291bnQ7IGkgPCBuZXdVbnRpbDsgaSsrKVxuICAgIHsgbmV3TWFwcy5wdXNoKG5ldyBJdGVtKG1hcHBpbmcubWFwc1tpXSkpOyB9XG4gIHZhciBpdGVtcyA9IHRoaXMuaXRlbXMuc2xpY2UoMCwgc3RhcnQpLmFwcGVuZChuZXdNYXBzKS5hcHBlbmQocmViYXNlZEl0ZW1zKTtcbiAgdmFyIGJyYW5jaCA9IG5ldyBCcmFuY2goaXRlbXMsIGV2ZW50Q291bnQpO1xuXG4gIGlmIChicmFuY2guZW1wdHlJdGVtQ291bnQoKSA+IG1heF9lbXB0eV9pdGVtcylcbiAgICB7IGJyYW5jaCA9IGJyYW5jaC5jb21wcmVzcyh0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRJdGVtcy5sZW5ndGgpOyB9XG4gIHJldHVybiBicmFuY2hcbn07XG5cbkJyYW5jaC5wcm90b3R5cGUuZW1wdHlJdGVtQ291bnQgPSBmdW5jdGlvbiBlbXB0eUl0ZW1Db3VudCAoKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyBpZiAoIWl0ZW0uc3RlcCkgeyBjb3VudCsrOyB9IH0pO1xuICByZXR1cm4gY291bnRcbn07XG5cbi8vIENvbXByZXNzaW5nIGEgYnJhbmNoIG1lYW5zIHJld3JpdGluZyBpdCB0byBwdXNoIHRoZSBhaXIgKG1hcC1vbmx5XG4vLyBpdGVtcykgb3V0LiBEdXJpbmcgY29sbGFib3JhdGlvbiwgdGhlc2UgbmF0dXJhbGx5IGFjY3VtdWxhdGVcbi8vIGJlY2F1c2UgZWFjaCByZW1vdGUgY2hhbmdlIGFkZHMgb25lLiBUaGUgYHVwdG9gIGFyZ3VtZW50IGlzIHVzZWRcbi8vIHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGl0ZW1zIGJlbG93IGEgZ2l2ZW4gbGV2ZWwgYXJlIGNvbXByZXNzZWQsXG4vLyBiZWNhdXNlIGByZWJhc2VkYCByZWxpZXMgb24gYSBjbGVhbiwgdW50b3VjaGVkIHNldCBvZiBpdGVtcyBpblxuLy8gb3JkZXIgdG8gYXNzb2NpYXRlIG9sZCBpdGVtcyB3aXRoIHJlYmFzZWQgc3RlcHMuXG5CcmFuY2gucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gY29tcHJlc3MgKHVwdG8pIHtcbiAgICBpZiAoIHVwdG8gPT09IHZvaWQgMCApIHVwdG8gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblxuICB2YXIgcmVtYXAgPSB0aGlzLnJlbWFwcGluZygwLCB1cHRvKSwgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICB2YXIgaXRlbXMgPSBbXSwgZXZlbnRzID0gMDtcbiAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgaWYgKGkgPj0gdXB0bykge1xuICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIGlmIChpdGVtLnNlbGVjdGlvbikgeyBldmVudHMrKzsgfVxuICAgIH0gZWxzZSBpZiAoaXRlbS5zdGVwKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZW0uc3RlcC5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpLCBtYXAgPSBzdGVwICYmIHN0ZXAuZ2V0TWFwKCk7XG4gICAgICBtYXBGcm9tLS07XG4gICAgICBpZiAobWFwKSB7IHJlbWFwLmFwcGVuZE1hcChtYXAsIG1hcEZyb20pOyB9XG4gICAgICBpZiAoc3RlcCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gaXRlbS5zZWxlY3Rpb24gJiYgaXRlbS5zZWxlY3Rpb24ubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikgeyBldmVudHMrKzsgfVxuICAgICAgICB2YXIgbmV3SXRlbSA9IG5ldyBJdGVtKG1hcC5pbnZlcnQoKSwgc3RlcCwgc2VsZWN0aW9uKSwgbWVyZ2VkLCBsYXN0ID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKG1lcmdlZCA9IGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1tsYXN0XS5tZXJnZShuZXdJdGVtKSlcbiAgICAgICAgICB7IGl0ZW1zW2xhc3RdID0gbWVyZ2VkOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IGl0ZW1zLnB1c2gobmV3SXRlbSk7IH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGl0ZW0ubWFwKSB7XG4gICAgICBtYXBGcm9tLS07XG4gICAgfVxuICB9LCB0aGlzLml0ZW1zLmxlbmd0aCwgMCk7XG4gIHJldHVybiBuZXcgQnJhbmNoKFJvcGVTZXF1ZW5jZS5mcm9tKGl0ZW1zLnJldmVyc2UoKSksIGV2ZW50cylcbn07XG5cbkJyYW5jaC5lbXB0eSA9IG5ldyBCcmFuY2goUm9wZVNlcXVlbmNlLmVtcHR5LCAwKTtcblxuZnVuY3Rpb24gY3V0T2ZmRXZlbnRzKGl0ZW1zLCBuKSB7XG4gIHZhciBjdXRQb2ludDtcbiAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIGlmIChpdGVtLnNlbGVjdGlvbiAmJiAobi0tID09IDApKSB7XG4gICAgICBjdXRQb2ludCA9IGk7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaXRlbXMuc2xpY2UoY3V0UG9pbnQpXG59XG5cbnZhciBJdGVtID0gZnVuY3Rpb24gSXRlbShtYXAsIHN0ZXAsIHNlbGVjdGlvbiwgbWlycm9yT2Zmc2V0KSB7XG4gIC8vIFRoZSAoZm9yd2FyZCkgc3RlcCBtYXAgZm9yIHRoaXMgaXRlbS5cbiAgdGhpcy5tYXAgPSBtYXA7XG4gIC8vIFRoZSBpbnZlcnRlZCBzdGVwXG4gIHRoaXMuc3RlcCA9IHN0ZXA7XG4gIC8vIElmIHRoaXMgaXMgbm9uLW51bGwsIHRoaXMgaXRlbSBpcyB0aGUgc3RhcnQgb2YgYSBncm91cCwgYW5kXG4gIC8vIHRoaXMgc2VsZWN0aW9uIGlzIHRoZSBzdGFydGluZyBzZWxlY3Rpb24gZm9yIHRoZSBncm91cCAodGhlIG9uZVxuICAvLyB0aGF0IHdhcyBhY3RpdmUgYmVmb3JlIHRoZSBmaXJzdCBzdGVwIHdhcyBhcHBsaWVkKVxuICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgLy8gSWYgdGhpcyBpdGVtIGlzIHRoZSBpbnZlcnNlIG9mIGEgcHJldmlvdXMgbWFwcGluZyBvbiB0aGUgc3RhY2ssXG4gIC8vIHRoaXMgcG9pbnRzIGF0IHRoZSBpbnZlcnNlJ3Mgb2Zmc2V0XG4gIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xufTtcblxuSXRlbS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSAob3RoZXIpIHtcbiAgaWYgKHRoaXMuc3RlcCAmJiBvdGhlci5zdGVwICYmICFvdGhlci5zZWxlY3Rpb24pIHtcbiAgICB2YXIgc3RlcCA9IG90aGVyLnN0ZXAubWVyZ2UodGhpcy5zdGVwKTtcbiAgICBpZiAoc3RlcCkgeyByZXR1cm4gbmV3IEl0ZW0oc3RlcC5nZXRNYXAoKS5pbnZlcnQoKSwgc3RlcCwgdGhpcy5zZWxlY3Rpb24pIH1cbiAgfVxufTtcblxuLy8gVGhlIHZhbHVlIG9mIHRoZSBzdGF0ZSBmaWVsZCB0aGF0IHRyYWNrcyB1bmRvL3JlZG8gaGlzdG9yeSBmb3IgdGhhdFxuLy8gc3RhdGUuIFdpbGwgYmUgc3RvcmVkIGluIHRoZSBwbHVnaW4gc3RhdGUgd2hlbiB0aGUgaGlzdG9yeSBwbHVnaW5cbi8vIGlzIGFjdGl2ZS5cbnZhciBIaXN0b3J5U3RhdGUgPSBmdW5jdGlvbiBIaXN0b3J5U3RhdGUoZG9uZSwgdW5kb25lLCBwcmV2UmFuZ2VzLCBwcmV2VGltZSkge1xuICB0aGlzLmRvbmUgPSBkb25lO1xuICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcbiAgdGhpcy5wcmV2UmFuZ2VzID0gcHJldlJhbmdlcztcbiAgdGhpcy5wcmV2VGltZSA9IHByZXZUaW1lO1xufTtcblxudmFyIERFUFRIX09WRVJGTE9XID0gMjA7XG5cbi8vIDogKEhpc3RvcnlTdGF0ZSwgRWRpdG9yU3RhdGUsIFRyYW5zYWN0aW9uLCBPYmplY3QpXG4vLyBSZWNvcmQgYSB0cmFuc2Zvcm1hdGlvbiBpbiB1bmRvIGhpc3RvcnkuXG5mdW5jdGlvbiBhcHBseVRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCB0ciwgb3B0aW9ucykge1xuICB2YXIgaGlzdG9yeVRyID0gdHIuZ2V0TWV0YShoaXN0b3J5S2V5KSwgcmViYXNlZDtcbiAgaWYgKGhpc3RvcnlUcikgeyByZXR1cm4gaGlzdG9yeVRyLmhpc3RvcnlTdGF0ZSB9XG5cbiAgaWYgKHRyLmdldE1ldGEoY2xvc2VIaXN0b3J5S2V5KSkgeyBoaXN0b3J5ID0gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUsIGhpc3RvcnkudW5kb25lLCBudWxsLCAwKTsgfVxuXG4gIHZhciBhcHBlbmRlZCA9IHRyLmdldE1ldGEoXCJhcHBlbmRlZFRyYW5zYWN0aW9uXCIpO1xuXG4gIGlmICh0ci5zdGVwcy5sZW5ndGggPT0gMCkge1xuICAgIHJldHVybiBoaXN0b3J5XG4gIH0gZWxzZSBpZiAoYXBwZW5kZWQgJiYgYXBwZW5kZWQuZ2V0TWV0YShoaXN0b3J5S2V5KSkge1xuICAgIGlmIChhcHBlbmRlZC5nZXRNZXRhKGhpc3RvcnlLZXkpLnJlZG8pXG4gICAgICB7IHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIG51bGwsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3J5LnVuZG9uZSwgcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwc1t0ci5zdGVwcy5sZW5ndGggLSAxXSksIGhpc3RvcnkucHJldlRpbWUpIH1cbiAgICBlbHNlXG4gICAgICB7IHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUuYWRkVHJhbnNmb3JtKHRyLCBudWxsLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgaGlzdG9yeS5wcmV2VGltZSkgfVxuICB9IGVsc2UgaWYgKHRyLmdldE1ldGEoXCJhZGRUb0hpc3RvcnlcIikgIT09IGZhbHNlICYmICEoYXBwZW5kZWQgJiYgYXBwZW5kZWQuZ2V0TWV0YShcImFkZFRvSGlzdG9yeVwiKSA9PT0gZmFsc2UpKSB7XG4gICAgLy8gR3JvdXAgdHJhbnNmb3JtcyB0aGF0IG9jY3VyIGluIHF1aWNrIHN1Y2Nlc3Npb24gaW50byBvbmUgZXZlbnQuXG4gICAgdmFyIG5ld0dyb3VwID0gaGlzdG9yeS5wcmV2VGltZSA9PSAwIHx8ICFhcHBlbmRlZCAmJiAoaGlzdG9yeS5wcmV2VGltZSA8ICh0ci50aW1lIHx8IDApIC0gb3B0aW9ucy5uZXdHcm91cERlbGF5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzQWRqYWNlbnRUbyh0ciwgaGlzdG9yeS5wcmV2UmFuZ2VzKSk7XG4gICAgdmFyIHByZXZSYW5nZXMgPSBhcHBlbmRlZCA/IG1hcFJhbmdlcyhoaXN0b3J5LnByZXZSYW5nZXMsIHRyLm1hcHBpbmcpIDogcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwc1t0ci5zdGVwcy5sZW5ndGggLSAxXSk7XG4gICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZFRyYW5zZm9ybSh0ciwgbmV3R3JvdXAgPyBzdGF0ZS5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJyYW5jaC5lbXB0eSwgcHJldlJhbmdlcywgdHIudGltZSlcbiAgfSBlbHNlIGlmIChyZWJhc2VkID0gdHIuZ2V0TWV0YShcInJlYmFzZWRcIikpIHtcbiAgICAvLyBVc2VkIGJ5IHRoZSBjb2xsYWIgbW9kdWxlIHRvIHRlbGwgdGhlIGhpc3RvcnkgdGhhdCBzb21lIG9mIGl0c1xuICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gcmViYXNlZC5cbiAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUucmViYXNlZCh0ciwgcmViYXNlZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yeS51bmRvbmUucmViYXNlZCh0ciwgcmViYXNlZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3J5LnVuZG9uZS5hZGRNYXBzKHRyLm1hcHBpbmcubWFwcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBZGphY2VudFRvKHRyYW5zZm9ybSwgcHJldlJhbmdlcykge1xuICBpZiAoIXByZXZSYW5nZXMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCF0cmFuc2Zvcm0uZG9jQ2hhbmdlZCkgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBhZGphY2VudCA9IGZhbHNlO1xuICB0cmFuc2Zvcm0ubWFwcGluZy5tYXBzWzBdLmZvckVhY2goZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZSYW5nZXMubGVuZ3RoOyBpICs9IDIpXG4gICAgICB7IGlmIChzdGFydCA8PSBwcmV2UmFuZ2VzW2kgKyAxXSAmJiBlbmQgPj0gcHJldlJhbmdlc1tpXSlcbiAgICAgICAgeyBhZGphY2VudCA9IHRydWU7IH0gfVxuICB9KTtcbiAgcmV0dXJuIGFkamFjZW50XG59XG5cbmZ1bmN0aW9uIHJhbmdlc0ZvcihtYXApIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAoX2Zyb20sIF90bywgZnJvbSwgdG8pIHsgcmV0dXJuIHJlc3VsdC5wdXNoKGZyb20sIHRvKTsgfSk7XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gbWFwUmFuZ2VzKHJhbmdlcywgbWFwcGluZykge1xuICBpZiAoIXJhbmdlcykgeyByZXR1cm4gbnVsbCB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgZnJvbSA9IG1hcHBpbmcubWFwKHJhbmdlc1tpXSwgMSksIHRvID0gbWFwcGluZy5tYXAocmFuZ2VzW2kgKyAxXSwgLTEpO1xuICAgIGlmIChmcm9tIDw9IHRvKSB7IHJlc3VsdC5wdXNoKGZyb20sIHRvKTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gOiAoSGlzdG9yeVN0YXRlLCBFZGl0b3JTdGF0ZSwgKHRyOiBUcmFuc2FjdGlvbiksIGJvb2wpXG4vLyBBcHBseSB0aGUgbGF0ZXN0IGV2ZW50IGZyb20gb25lIGJyYW5jaCB0byB0aGUgZG9jdW1lbnQgYW5kIHNoaWZ0IHRoZSBldmVudFxuLy8gb250byB0aGUgb3RoZXIgYnJhbmNoLlxuZnVuY3Rpb24gaGlzdFRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCBkaXNwYXRjaCwgcmVkbykge1xuICB2YXIgcHJlc2VydmVJdGVtcyA9IG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSwgaGlzdE9wdGlvbnMgPSBoaXN0b3J5S2V5LmdldChzdGF0ZSkuc3BlYy5jb25maWc7XG4gIHZhciBwb3AgPSAocmVkbyA/IGhpc3RvcnkudW5kb25lIDogaGlzdG9yeS5kb25lKS5wb3BFdmVudChzdGF0ZSwgcHJlc2VydmVJdGVtcyk7XG4gIGlmICghcG9wKSB7IHJldHVybiB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHBvcC5zZWxlY3Rpb24ucmVzb2x2ZShwb3AudHJhbnNmb3JtLmRvYyk7XG4gIHZhciBhZGRlZCA9IChyZWRvID8gaGlzdG9yeS5kb25lIDogaGlzdG9yeS51bmRvbmUpLmFkZFRyYW5zZm9ybShwb3AudHJhbnNmb3JtLCBzdGF0ZS5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKTtcblxuICB2YXIgbmV3SGlzdCA9IG5ldyBIaXN0b3J5U3RhdGUocmVkbyA/IGFkZGVkIDogcG9wLnJlbWFpbmluZywgcmVkbyA/IHBvcC5yZW1haW5pbmcgOiBhZGRlZCwgbnVsbCwgMCk7XG4gIGRpc3BhdGNoKHBvcC50cmFuc2Zvcm0uc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikuc2V0TWV0YShoaXN0b3J5S2V5LCB7cmVkbzogcmVkbywgaGlzdG9yeVN0YXRlOiBuZXdIaXN0fSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG59XG5cbnZhciBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gZmFsc2UsIGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zID0gbnVsbDtcbi8vIENoZWNrIHdoZXRoZXIgYW55IHBsdWdpbiBpbiB0aGUgZ2l2ZW4gc3RhdGUgaGFzIGFcbi8vIGBoaXN0b3J5UHJlc2VydmVJdGVtc2AgcHJvcGVydHkgaW4gaXRzIHNwZWMsIGluIHdoaWNoIGNhc2Ugd2UgbXVzdFxuLy8gcHJlc2VydmUgc3RlcHMgZXhhY3RseSBhcyB0aGV5IGNhbWUgaW4sIHNvIHRoYXQgdGhleSBjYW4gYmVcbi8vIHJlYmFzZWQuXG5mdW5jdGlvbiBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkge1xuICB2YXIgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XG4gIGlmIChjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyAhPSBwbHVnaW5zKSB7XG4gICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlO1xuICAgIGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zID0gcGx1Z2lucztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHsgaWYgKHBsdWdpbnNbaV0uc3BlYy5oaXN0b3J5UHJlc2VydmVJdGVtcykge1xuICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IHRydWU7XG4gICAgICBicmVha1xuICAgIH0gfVxuICB9XG4gIHJldHVybiBjYWNoZWRQcmVzZXJ2ZUl0ZW1zXG59XG5cbi8vIDo6IChUcmFuc2FjdGlvbikg4oaSIFRyYW5zYWN0aW9uXG4vLyBTZXQgYSBmbGFnIG9uIHRoZSBnaXZlbiB0cmFuc2FjdGlvbiB0aGF0IHdpbGwgcHJldmVudCBmdXJ0aGVyIHN0ZXBzXG4vLyBmcm9tIGJlaW5nIGFwcGVuZGVkIHRvIGFuIGV4aXN0aW5nIGhpc3RvcnkgZXZlbnQgKHNvIHRoYXQgdGhleVxuLy8gcmVxdWlyZSBhIHNlcGFyYXRlIHVuZG8gY29tbWFuZCB0byB1bmRvKS5cbmZ1bmN0aW9uIGNsb3NlSGlzdG9yeSh0cikge1xuICByZXR1cm4gdHIuc2V0TWV0YShjbG9zZUhpc3RvcnlLZXksIHRydWUpXG59XG5cbnZhciBoaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImhpc3RvcnlcIik7XG52YXIgY2xvc2VIaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImNsb3NlSGlzdG9yeVwiKTtcblxuLy8gOjogKD9PYmplY3QpIOKGkiBQbHVnaW5cbi8vIFJldHVybnMgYSBwbHVnaW4gdGhhdCBlbmFibGVzIHRoZSB1bmRvIGhpc3RvcnkgZm9yIGFuIGVkaXRvci4gVGhlXG4vLyBwbHVnaW4gd2lsbCB0cmFjayB1bmRvIGFuZCByZWRvIHN0YWNrcywgd2hpY2ggY2FuIGJlIHVzZWQgd2l0aCB0aGVcbi8vIFtgdW5kb2BdKCNoaXN0b3J5LnVuZG8pIGFuZCBbYHJlZG9gXSgjaGlzdG9yeS5yZWRvKSBjb21tYW5kcy5cbi8vXG4vLyBZb3UgY2FuIHNldCBhbiBgXCJhZGRUb0hpc3RvcnlcImAgW21ldGFkYXRhXG4vLyBwcm9wZXJ0eV0oI3N0YXRlLlRyYW5zYWN0aW9uLnNldE1ldGEpIG9mIGBmYWxzZWAgb24gYSB0cmFuc2FjdGlvblxuLy8gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJvbGxlZCBiYWNrIGJ5IHVuZG8uXG4vL1xuLy8gICBjb25maWc6Oi1cbi8vICAgU3VwcG9ydHMgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uIG9wdGlvbnM6XG4vL1xuLy8gICAgIGRlcHRoOjogP251bWJlclxuLy8gICAgIFRoZSBhbW91bnQgb2YgaGlzdG9yeSBldmVudHMgdGhhdCBhcmUgY29sbGVjdGVkIGJlZm9yZSB0aGVcbi8vICAgICBvbGRlc3QgZXZlbnRzIGFyZSBkaXNjYXJkZWQuIERlZmF1bHRzIHRvIDEwMC5cbi8vXG4vLyAgICAgbmV3R3JvdXBEZWxheTo6ID9udW1iZXJcbi8vICAgICBUaGUgZGVsYXkgYmV0d2VlbiBjaGFuZ2VzIGFmdGVyIHdoaWNoIGEgbmV3IGdyb3VwIHNob3VsZCBiZVxuLy8gICAgIHN0YXJ0ZWQuIERlZmF1bHRzIHRvIDUwMCAobWlsbGlzZWNvbmRzKS4gTm90ZSB0aGF0IHdoZW4gY2hhbmdlc1xuLy8gICAgIGFyZW4ndCBhZGphY2VudCwgYSBuZXcgZ3JvdXAgaXMgYWx3YXlzIHN0YXJ0ZWQuXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZykge1xuICBjb25maWcgPSB7ZGVwdGg6IGNvbmZpZyAmJiBjb25maWcuZGVwdGggfHwgMTAwLFxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogY29uZmlnICYmIGNvbmZpZy5uZXdHcm91cERlbGF5IHx8IDUwMH07XG4gIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IGhpc3RvcnlLZXksXG5cbiAgICBzdGF0ZToge1xuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoQnJhbmNoLmVtcHR5LCBCcmFuY2guZW1wdHksIG51bGwsIDApXG4gICAgICB9LFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRyLCBoaXN0LCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gYXBwbHlUcmFuc2FjdGlvbihoaXN0LCBzdGF0ZSwgdHIsIGNvbmZpZylcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29uZmlnOiBjb25maWcsXG5cbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgIGJlZm9yZWlucHV0OiBmdW5jdGlvbiBiZWZvcmVpbnB1dCh2aWV3LCBlKSB7XG4gICAgICAgICAgdmFyIGhhbmRsZWQgPSBlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlVbmRvXCIgPyB1bmRvKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gpIDpcbiAgICAgICAgICAgICAgZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5UmVkb1wiID8gcmVkbyh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoKSA6IGZhbHNlO1xuICAgICAgICAgIGlmIChoYW5kbGVkKSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgICAgICAgIHJldHVybiBoYW5kbGVkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbi8vIDo6IChFZGl0b3JTdGF0ZSwgPyh0cjogVHJhbnNhY3Rpb24pKSDihpIgYm9vbFxuLy8gQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdW5kb2VzIHRoZSBsYXN0IGNoYW5nZSwgaWYgYW55LlxuZnVuY3Rpb24gdW5kbyhzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgaWYgKCFoaXN0IHx8IGhpc3QuZG9uZS5ldmVudENvdW50ID09IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKSB7IGhpc3RUcmFuc2FjdGlvbihoaXN0LCBzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIEEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHJlZG9lcyB0aGUgbGFzdCB1bmRvbmUgY2hhbmdlLCBpZiBhbnkuXG5mdW5jdGlvbiByZWRvKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICBpZiAoIWhpc3QgfHwgaGlzdC51bmRvbmUuZXZlbnRDb3VudCA9PSAwKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChkaXNwYXRjaCkgeyBoaXN0VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUpIOKGkiBudW1iZXJcbi8vIFRoZSBhbW91bnQgb2YgdW5kb2FibGUgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuZnVuY3Rpb24gdW5kb0RlcHRoKHN0YXRlKSB7XG4gIHZhciBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gIHJldHVybiBoaXN0ID8gaGlzdC5kb25lLmV2ZW50Q291bnQgOiAwXG59XG5cbi8vIDo6IChFZGl0b3JTdGF0ZSkg4oaSIG51bWJlclxuLy8gVGhlIGFtb3VudCBvZiByZWRvYWJsZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gZWRpdG9yIHN0YXRlLlxuZnVuY3Rpb24gcmVkb0RlcHRoKHN0YXRlKSB7XG4gIHZhciBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gIHJldHVybiBoaXN0ID8gaGlzdC51bmRvbmUuZXZlbnRDb3VudCA6IDBcbn1cblxuZXhwb3J0IHsgSGlzdG9yeVN0YXRlLCBjbG9zZUhpc3RvcnksIGhpc3RvcnksIHJlZG8sIHJlZG9EZXB0aCwgdW5kbywgdW5kb0RlcHRoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IGZpbmRXcmFwcGluZywgY2FuSm9pbiB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbi8vIDo6LSBJbnB1dCBydWxlcyBhcmUgcmVndWxhciBleHByZXNzaW9ucyBkZXNjcmliaW5nIGEgcGllY2Ugb2YgdGV4dFxuLy8gdGhhdCwgd2hlbiB0eXBlZCwgY2F1c2VzIHNvbWV0aGluZyB0byBoYXBwZW4uIFRoaXMgbWlnaHQgYmVcbi8vIGNoYW5naW5nIHR3byBkYXNoZXMgaW50byBhbiBlbWRhc2gsIHdyYXBwaW5nIGEgcGFyYWdyYXBoIHN0YXJ0aW5nXG4vLyB3aXRoIGBcIj4gXCJgIGludG8gYSBibG9ja3F1b3RlLCBvciBzb21ldGhpbmcgZW50aXJlbHkgZGlmZmVyZW50LlxudmFyIElucHV0UnVsZSA9IGZ1bmN0aW9uIElucHV0UnVsZShtYXRjaCwgaGFuZGxlcikge1xuICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gIHRoaXMuaGFuZGxlciA9IHR5cGVvZiBoYW5kbGVyID09IFwic3RyaW5nXCIgPyBzdHJpbmdIYW5kbGVyKGhhbmRsZXIpIDogaGFuZGxlcjtcbn07XG5cbmZ1bmN0aW9uIHN0cmluZ0hhbmRsZXIoc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgbWF0Y2gsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaW5zZXJ0ID0gc3RyaW5nO1xuICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgdmFyIG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpO1xuICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgdmFyIGN1dE9mZiA9IHN0YXJ0IC0gZW5kO1xuICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgaW5zZXJ0ID0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0IC0gY3V0T2ZmLCBvZmZzZXQpICsgaW5zZXJ0O1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKVxuICB9XG59XG5cbnZhciBNQVhfTUFUQ0ggPSA1MDA7XG5cbi8vIDo6IChjb25maWc6IHtydWxlczogW0lucHV0UnVsZV19KSDihpIgUGx1Z2luXG4vLyBDcmVhdGUgYW4gaW5wdXQgcnVsZXMgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIGl0IHdpbGwgY2F1c2UgdGV4dFxuLy8gaW5wdXQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZSdzXG4vLyBhY3Rpb24uXG5mdW5jdGlvbiBpbnB1dFJ1bGVzKHJlZikge1xuICB2YXIgcnVsZXMgPSByZWYucnVsZXM7XG5cbiAgdmFyIHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgIHN0YXRlOiB7XG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkgeyByZXR1cm4gbnVsbCB9LFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRyLCBwcmV2KSB7XG4gICAgICAgIHZhciBzdG9yZWQgPSB0ci5nZXRNZXRhKHRoaXMpO1xuICAgICAgICBpZiAoc3RvcmVkKSB7IHJldHVybiBzdG9yZWQgfVxuICAgICAgICByZXR1cm4gdHIuc2VsZWN0aW9uU2V0IHx8IHRyLmRvY0NoYW5nZWQgPyBudWxsIDogcHJldlxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlVGV4dElucHV0OiBmdW5jdGlvbiBoYW5kbGVUZXh0SW5wdXQodmlldywgZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJ1bih2aWV3LCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbilcbiAgICAgIH0sXG4gICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgY29tcG9zaXRpb25lbmQ6IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICB2YXIgJGN1cnNvciA9IHJlZi4kY3Vyc29yO1xuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHsgcnVuKHZpZXcsICRjdXJzb3IucG9zLCAkY3Vyc29yLnBvcywgXCJcIiwgcnVsZXMsIHBsdWdpbik7IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc0lucHV0UnVsZXM6IHRydWVcbiAgfSk7XG4gIHJldHVybiBwbHVnaW5cbn1cblxuZnVuY3Rpb24gcnVuKHZpZXcsIGZyb20sIHRvLCB0ZXh0LCBydWxlcywgcGx1Z2luKSB7XG4gIGlmICh2aWV3LmNvbXBvc2luZykgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgc3RhdGUgPSB2aWV3LnN0YXRlLCAkZnJvbSA9IHN0YXRlLmRvYy5yZXNvbHZlKGZyb20pO1xuICBpZiAoJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciB0ZXh0QmVmb3JlID0gJGZyb20ucGFyZW50LnRleHRCZXR3ZWVuKE1hdGgubWF4KDAsICRmcm9tLnBhcmVudE9mZnNldCAtIE1BWF9NQVRDSCksICRmcm9tLnBhcmVudE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgXCJcXHVmZmZjXCIpICsgdGV4dDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXRjaCA9IHJ1bGVzW2ldLm1hdGNoLmV4ZWModGV4dEJlZm9yZSk7XG4gICAgdmFyIHRyID0gbWF0Y2ggJiYgcnVsZXNbaV0uaGFuZGxlcihzdGF0ZSwgbWF0Y2gsIGZyb20gLSAobWF0Y2hbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgpLCB0byk7XG4gICAgaWYgKCF0cikgeyBjb250aW51ZSB9XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zZXRNZXRhKHBsdWdpbiwge3RyYW5zZm9ybTogdHIsIGZyb206IGZyb20sIHRvOiB0bywgdGV4dDogdGV4dH0pKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8oVHJhbnNhY3Rpb24pKSDihpIgYm9vbFxuLy8gVGhpcyBpcyBhIGNvbW1hbmQgdGhhdCB3aWxsIHVuZG8gYW4gaW5wdXQgcnVsZSwgaWYgYXBwbHlpbmcgc3VjaCBhXG4vLyBydWxlIHdhcyB0aGUgbGFzdCB0aGluZyB0aGF0IHRoZSB1c2VyIGRpZC5cbmZ1bmN0aW9uIHVuZG9JbnB1dFJ1bGUoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciBwbHVnaW5zID0gc3RhdGUucGx1Z2lucztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbaV0sIHVuZG9hYmxlID0gKHZvaWQgMCk7XG4gICAgaWYgKHBsdWdpbi5zcGVjLmlzSW5wdXRSdWxlcyAmJiAodW5kb2FibGUgPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpKSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciB0ciA9IHN0YXRlLnRyLCB0b1VuZG8gPSB1bmRvYWJsZS50cmFuc2Zvcm07XG4gICAgICAgIGZvciAodmFyIGogPSB0b1VuZG8uc3RlcHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgeyB0ci5zdGVwKHRvVW5kby5zdGVwc1tqXS5pbnZlcnQodG9VbmRvLmRvY3Nbal0pKTsgfVxuICAgICAgICBpZiAodW5kb2FibGUudGV4dCkge1xuICAgICAgICAgIHZhciBtYXJrcyA9IHRyLmRvYy5yZXNvbHZlKHVuZG9hYmxlLmZyb20pLm1hcmtzKCk7XG4gICAgICAgICAgdHIucmVwbGFjZVdpdGgodW5kb2FibGUuZnJvbSwgdW5kb2FibGUudG8sIHN0YXRlLnNjaGVtYS50ZXh0KHVuZG9hYmxlLnRleHQsIG1hcmtzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gOjogSW5wdXRSdWxlIENvbnZlcnRzIGRvdWJsZSBkYXNoZXMgdG8gYW4gZW1kYXNoLlxudmFyIGVtRGFzaCA9IG5ldyBJbnB1dFJ1bGUoLy0tJC8sIFwi4oCUXCIpO1xuLy8gOjogSW5wdXRSdWxlIENvbnZlcnRzIHRocmVlIGRvdHMgdG8gYW4gZWxsaXBzaXMgY2hhcmFjdGVyLlxudmFyIGVsbGlwc2lzID0gbmV3IElucHV0UnVsZSgvXFwuXFwuXFwuJC8sIFwi4oCmXCIpO1xuLy8gOjogSW5wdXRSdWxlIOKAnFNtYXJ04oCdIG9wZW5pbmcgZG91YmxlIHF1b3Rlcy5cbnZhciBvcGVuRG91YmxlUXVvdGUgPSBuZXcgSW5wdXRSdWxlKC8oPzpefFtcXHNcXHtcXFtcXChcXDwnXCJcXHUyMDE4XFx1MjAxQ10pKFwiKSQvLCBcIuKAnFwiKTtcbi8vIDo6IElucHV0UnVsZSDigJxTbWFydOKAnSBjbG9zaW5nIGRvdWJsZSBxdW90ZXMuXG52YXIgY2xvc2VEb3VibGVRdW90ZSA9IG5ldyBJbnB1dFJ1bGUoL1wiJC8sIFwi4oCdXCIpO1xuLy8gOjogSW5wdXRSdWxlIOKAnFNtYXJ04oCdIG9wZW5pbmcgc2luZ2xlIHF1b3Rlcy5cbnZhciBvcGVuU2luZ2xlUXVvdGUgPSBuZXcgSW5wdXRSdWxlKC8oPzpefFtcXHNcXHtcXFtcXChcXDwnXCJcXHUyMDE4XFx1MjAxQ10pKCcpJC8sIFwi4oCYXCIpO1xuLy8gOjogSW5wdXRSdWxlIOKAnFNtYXJ04oCdIGNsb3Npbmcgc2luZ2xlIHF1b3Rlcy5cbnZhciBjbG9zZVNpbmdsZVF1b3RlID0gbmV3IElucHV0UnVsZSgvJyQvLCBcIuKAmVwiKTtcblxuLy8gOjogW0lucHV0UnVsZV0gU21hcnQtcXVvdGUgcmVsYXRlZCBpbnB1dCBydWxlcy5cbnZhciBzbWFydFF1b3RlcyA9IFtvcGVuRG91YmxlUXVvdGUsIGNsb3NlRG91YmxlUXVvdGUsIG9wZW5TaW5nbGVRdW90ZSwgY2xvc2VTaW5nbGVRdW90ZV07XG5cbi8vIDo6IChSZWdFeHAsIE5vZGVUeXBlLCA/dW5pb248T2JqZWN0LCAoW3N0cmluZ10pIOKGkiA/T2JqZWN0PiwgPyhbc3RyaW5nXSwgTm9kZSkg4oaSIGJvb2wpIOKGkiBJbnB1dFJ1bGVcbi8vIEJ1aWxkIGFuIGlucHV0IHJ1bGUgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgYSB0ZXh0YmxvY2sgd2hlbiBhXG4vLyBnaXZlbiBzdHJpbmcgaXMgdHlwZWQuIFRoZSBgcmVnZXhwYCBhcmd1bWVudCBpc1xuLy8gZGlyZWN0bHkgcGFzc2VkIHRocm91Z2ggdG8gdGhlIGBJbnB1dFJ1bGVgIGNvbnN0cnVjdG9yLiBZb3UnbGxcbi8vIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbi8vIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuLy9cbi8vIGBub2RlVHlwZWAgaXMgdGhlIHR5cGUgb2Ygbm9kZSB0byB3cmFwIGluLiBJZiBpdCBuZWVkcyBhdHRyaWJ1dGVzLFxuLy8geW91IGNhbiBlaXRoZXIgcGFzcyB0aGVtIGRpcmVjdGx5LCBvciBwYXNzIGEgZnVuY3Rpb24gdGhhdCB3aWxsXG4vLyBjb21wdXRlIHRoZW0gZnJvbSB0aGUgcmVndWxhciBleHByZXNzaW9uIG1hdGNoLlxuLy9cbi8vIEJ5IGRlZmF1bHQsIGlmIHRoZXJlJ3MgYSBub2RlIHdpdGggdGhlIHNhbWUgdHlwZSBhYm92ZSB0aGUgbmV3bHlcbi8vIHdyYXBwZWQgbm9kZSwgdGhlIHJ1bGUgd2lsbCB0cnkgdG8gW2pvaW5dKCN0cmFuc2Zvcm0uVHJhbnNmb3JtLmpvaW4pIHRob3NlXG4vLyB0d28gbm9kZXMuIFlvdSBjYW4gcGFzcyBhIGpvaW4gcHJlZGljYXRlLCB3aGljaCB0YWtlcyBhIHJlZ3VsYXJcbi8vIGV4cHJlc3Npb24gbWF0Y2ggYW5kIHRoZSBub2RlIGJlZm9yZSB0aGUgd3JhcHBlZCBub2RlLCBhbmQgY2FuXG4vLyByZXR1cm4gYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgYSBqb2luIHNob3VsZCBoYXBwZW4uXG5mdW5jdGlvbiB3cmFwcGluZ0lucHV0UnVsZShyZWdleHAsIG5vZGVUeXBlLCBnZXRBdHRycywgam9pblByZWRpY2F0ZSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZShyZWdleHAsIGZ1bmN0aW9uIChzdGF0ZSwgbWF0Y2gsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgYXR0cnMgPSBnZXRBdHRycyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZ2V0QXR0cnMobWF0Y2gpIDogZ2V0QXR0cnM7XG4gICAgdmFyIHRyID0gc3RhdGUudHIuZGVsZXRlKHN0YXJ0LCBlbmQpO1xuICAgIHZhciAkc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShzdGFydCksIHJhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKSwgd3JhcHBpbmcgPSByYW5nZSAmJiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgaWYgKCF3cmFwcGluZykgeyByZXR1cm4gbnVsbCB9XG4gICAgdHIud3JhcChyYW5nZSwgd3JhcHBpbmcpO1xuICAgIHZhciBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShzdGFydCAtIDEpLm5vZGVCZWZvcmU7XG4gICAgaWYgKGJlZm9yZSAmJiBiZWZvcmUudHlwZSA9PSBub2RlVHlwZSAmJiBjYW5Kb2luKHRyLmRvYywgc3RhcnQgLSAxKSAmJlxuICAgICAgICAoIWpvaW5QcmVkaWNhdGUgfHwgam9pblByZWRpY2F0ZShtYXRjaCwgYmVmb3JlKSkpXG4gICAgICB7IHRyLmpvaW4oc3RhcnQgLSAxKTsgfVxuICAgIHJldHVybiB0clxuICB9KVxufVxuXG4vLyA6OiAoUmVnRXhwLCBOb2RlVHlwZSwgP3VuaW9uPE9iamVjdCwgKFtzdHJpbmddKSDihpIgP09iamVjdD4pIOKGkiBJbnB1dFJ1bGVcbi8vIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBjaGFuZ2VzIHRoZSB0eXBlIG9mIGEgdGV4dGJsb2NrIHdoZW4gdGhlXG4vLyBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC4gWW91J2xsIHVzdWFsbHkgd2FudCB0byBzdGFydCB5b3VyXG4vLyByZWdleHAgd2l0aCBgXmAgdG8gdGhhdCBpdCBpcyBvbmx5IG1hdGNoZWQgYXQgdGhlIHN0YXJ0IG9mIGFcbi8vIHRleHRibG9jay4gVGhlIG9wdGlvbmFsIGBnZXRBdHRyc2AgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIGNvbXB1dGVcbi8vIHRoZSBuZXcgbm9kZSdzIGF0dHJpYnV0ZXMsIGFuZCB3b3JrcyB0aGUgc2FtZSBhcyBpbiB0aGVcbi8vIGB3cmFwcGluZ0lucHV0UnVsZWAgZnVuY3Rpb24uXG5mdW5jdGlvbiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHJlZ2V4cCwgbm9kZVR5cGUsIGdldEF0dHJzKSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHJlZ2V4cCwgZnVuY3Rpb24gKHN0YXRlLCBtYXRjaCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShzdGFydCk7XG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGdldEF0dHJzKG1hdGNoKSA6IGdldEF0dHJzO1xuICAgIGlmICghJHN0YXJ0Lm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRzdGFydC5pbmRleCgtMSksICRzdGFydC5pbmRleEFmdGVyKC0xKSwgbm9kZVR5cGUpKSB7IHJldHVybiBudWxsIH1cbiAgICByZXR1cm4gc3RhdGUudHJcbiAgICAgIC5kZWxldGUoc3RhcnQsIGVuZClcbiAgICAgIC5zZXRCbG9ja1R5cGUoc3RhcnQsIHN0YXJ0LCBub2RlVHlwZSwgYXR0cnMpXG4gIH0pXG59XG5cbmV4cG9ydCB7IElucHV0UnVsZSwgY2xvc2VEb3VibGVRdW90ZSwgY2xvc2VTaW5nbGVRdW90ZSwgZWxsaXBzaXMsIGVtRGFzaCwgaW5wdXRSdWxlcywgb3BlbkRvdWJsZVF1b3RlLCBvcGVuU2luZ2xlUXVvdGUsIHNtYXJ0UXVvdGVzLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlLCB1bmRvSW5wdXRSdWxlLCB3cmFwcGluZ0lucHV0UnVsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJpbXBvcnQgeyBrZXlOYW1lLCBiYXNlIH0gZnJvbSAndzNjLWtleW5hbWUnO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vLyBkZWNsYXJlIGdsb2JhbDogbmF2aWdhdG9yXG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pLCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpIHsgcmVzdWx0ID0gXCIgXCI7IH1cbiAgdmFyIGFsdCwgY3RybCwgc2hpZnQsIG1ldGE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdmFyIG1vZCA9IHBhcnRzW2ldO1xuICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpIHsgbWV0YSA9IHRydWU7IH1cbiAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHsgYWx0ID0gdHJ1ZTsgfVxuICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIHsgY3RybCA9IHRydWU7IH1cbiAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSkgeyBzaGlmdCA9IHRydWU7IH1cbiAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHsgaWYgKG1hYykgeyBtZXRhID0gdHJ1ZTsgfSBlbHNlIHsgY3RybCA9IHRydWU7IH0gfVxuICAgIGVsc2UgeyB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpIH1cbiAgfVxuICBpZiAoYWx0KSB7IHJlc3VsdCA9IFwiQWx0LVwiICsgcmVzdWx0OyB9XG4gIGlmIChjdHJsKSB7IHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDsgfVxuICBpZiAobWV0YSkgeyByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7IH1cbiAgaWYgKHNoaWZ0KSB7IHJlc3VsdCA9IFwiU2hpZnQtXCIgKyByZXN1bHQ7IH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemUobWFwKSB7XG4gIHZhciBjb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yICh2YXIgcHJvcCBpbiBtYXApIHsgY29weVtub3JtYWxpemVLZXlOYW1lKHByb3ApXSA9IG1hcFtwcm9wXTsgfVxuICByZXR1cm4gY29weVxufVxuXG5mdW5jdGlvbiBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHNoaWZ0KSB7XG4gIGlmIChldmVudC5hbHRLZXkpIHsgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTsgfVxuICBpZiAoZXZlbnQuY3RybEtleSkgeyBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTsgfVxuICBpZiAoZXZlbnQubWV0YUtleSkgeyBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTsgfVxuICBpZiAoc2hpZnQgIT09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5KSB7IG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTsgfVxuICByZXR1cm4gbmFtZVxufVxuXG4vLyA6OiAoT2JqZWN0KSDihpIgUGx1Z2luXG4vLyBDcmVhdGUgYSBrZXltYXAgcGx1Z2luIGZvciB0aGUgZ2l2ZW4gc2V0IG9mIGJpbmRpbmdzLlxuLy9cbi8vIEJpbmRpbmdzIHNob3VsZCBtYXAga2V5IG5hbWVzIHRvIFtjb21tYW5kXSgjY29tbWFuZHMpLXN0eWxlXG4vLyBmdW5jdGlvbnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYChFZGl0b3JTdGF0ZSwgZGlzcGF0Y2gsXG4vLyBFZGl0b3JWaWV3KWAgYXJndW1lbnRzLCBhbmQgc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gdGhleSd2ZSBoYW5kbGVkXG4vLyB0aGUga2V5LiBOb3RlIHRoYXQgdGhlIHZpZXcgYXJndW1lbnQgaXNuJ3QgcGFydCBvZiB0aGUgY29tbWFuZFxuLy8gcHJvdG9jb2wsIGJ1dCBjYW4gYmUgdXNlZCBhcyBhbiBlc2NhcGUgaGF0Y2ggaWYgYSBiaW5kaW5nIG5lZWRzIHRvXG4vLyBkaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZSBVSS5cbi8vXG4vLyBLZXkgbmFtZXMgbWF5IGJlIHN0cmluZ3MgbGlrZSBgXCJTaGlmdC1DdHJsLUVudGVyXCJg4oCUYSBrZXlcbi8vIGlkZW50aWZpZXIgcHJlZml4ZWQgd2l0aCB6ZXJvIG9yIG1vcmUgbW9kaWZpZXJzLiBLZXkgaWRlbnRpZmllcnNcbi8vIGFyZSBiYXNlZCBvbiB0aGUgc3RyaW5ncyB0aGF0IGNhbiBhcHBlYXIgaW5cbi8vIFtgS2V5RXZlbnQua2V5YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5KS5cbi8vIFVzZSBsb3dlcmNhc2UgbGV0dGVycyB0byByZWZlciB0byBsZXR0ZXIga2V5cyAob3IgdXBwZXJjYXNlIGxldHRlcnNcbi8vIGlmIHlvdSB3YW50IHNoaWZ0IHRvIGJlIGhlbGQpLiBZb3UgbWF5IHVzZSBgXCJTcGFjZVwiYCBhcyBhbiBhbGlhc1xuLy8gZm9yIHRoZSBgXCIgXCJgIG5hbWUuXG4vL1xuLy8gTW9kaWZpZXJzIGNhbiBiZSBnaXZlbiBpbiBhbnkgb3JkZXIuIGBTaGlmdC1gIChvciBgcy1gKSwgYEFsdC1gIChvclxuLy8gYGEtYCksIGBDdHJsLWAgKG9yIGBjLWAgb3IgYENvbnRyb2wtYCkgYW5kIGBDbWQtYCAob3IgYG0tYCBvclxuLy8gYE1ldGEtYCkgYXJlIHJlY29nbml6ZWQuIEZvciBjaGFyYWN0ZXJzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgaG9sZGluZ1xuLy8gc2hpZnQsIHRoZSBgU2hpZnQtYCBwcmVmaXggaXMgaW1wbGllZCwgYW5kIHNob3VsZCBub3QgYmUgYWRkZWRcbi8vIGV4cGxpY2l0bHkuXG4vL1xuLy8gWW91IGNhbiB1c2UgYE1vZC1gIGFzIGEgc2hvcnRoYW5kIGZvciBgQ21kLWAgb24gTWFjIGFuZCBgQ3RybC1gIG9uXG4vLyBvdGhlciBwbGF0Zm9ybXMuXG4vL1xuLy8gWW91IGNhbiBhZGQgbXVsdGlwbGUga2V5bWFwIHBsdWdpbnMgdG8gYW4gZWRpdG9yLiBUaGUgb3JkZXIgaW5cbi8vIHdoaWNoIHRoZXkgYXBwZWFyIGRldGVybWluZXMgdGhlaXIgcHJlY2VkZW5jZSAodGhlIG9uZXMgZWFybHkgaW5cbi8vIHRoZSBhcnJheSBnZXQgdG8gZGlzcGF0Y2ggZmlyc3QpLlxuZnVuY3Rpb24ga2V5bWFwKGJpbmRpbmdzKSB7XG4gIHJldHVybiBuZXcgUGx1Z2luKHtwcm9wczoge2hhbmRsZUtleURvd246IGtleWRvd25IYW5kbGVyKGJpbmRpbmdzKX19KVxufVxuXG4vLyA6OiAoT2JqZWN0KSDihpIgKHZpZXc6IEVkaXRvclZpZXcsIGV2ZW50OiBkb20uRXZlbnQpIOKGkiBib29sXG4vLyBHaXZlbiBhIHNldCBvZiBiaW5kaW5ncyAodXNpbmcgdGhlIHNhbWUgZm9ybWF0IGFzXG4vLyBbYGtleW1hcGBdKCNrZXltYXAua2V5bWFwKSksIHJldHVybiBhIFtrZXlkb3duXG4vLyBoYW5kbGVyXSgjdmlldy5FZGl0b3JQcm9wcy5oYW5kbGVLZXlEb3duKSB0aGF0IGhhbmRsZXMgdGhlbS5cbmZ1bmN0aW9uIGtleWRvd25IYW5kbGVyKGJpbmRpbmdzKSB7XG4gIHZhciBtYXAgPSBub3JtYWxpemUoYmluZGluZ3MpO1xuICByZXR1cm4gZnVuY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGtleU5hbWUoZXZlbnQpLCBpc0NoYXIgPSBuYW1lLmxlbmd0aCA9PSAxICYmIG5hbWUgIT0gXCIgXCIsIGJhc2VOYW1lO1xuICAgIHZhciBkaXJlY3QgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCAhaXNDaGFyKV07XG4gICAgaWYgKGRpcmVjdCAmJiBkaXJlY3Qodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChpc0NoYXIgJiYgKGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5IHx8IG5hbWUuY2hhckNvZGVBdCgwKSA+IDEyNykgJiZcbiAgICAgICAgKGJhc2VOYW1lID0gYmFzZVtldmVudC5rZXlDb2RlXSkgJiYgYmFzZU5hbWUgIT0gbmFtZSkge1xuICAgICAgLy8gVHJ5IGZhbGxpbmcgYmFjayB0byB0aGUga2V5Q29kZSB3aGVuIHRoZXJlJ3MgYSBtb2RpZmllclxuICAgICAgLy8gYWN0aXZlIG9yIHRoZSBjaGFyYWN0ZXIgcHJvZHVjZWQgaXNuJ3QgQVNDSUksIGFuZCBvdXIgdGFibGVcbiAgICAgIC8vIHByb2R1Y2VzIGEgZGlmZmVyZW50IG5hbWUgZnJvbSB0aGUgdGhlIGtleUNvZGUuIFNlZSAjNjY4LFxuICAgICAgLy8gIzEwNjBcbiAgICAgIHZhciBmcm9tQ29kZSA9IG1hcFttb2RpZmllcnMoYmFzZU5hbWUsIGV2ZW50LCB0cnVlKV07XG4gICAgICBpZiAoZnJvbUNvZGUgJiYgZnJvbUNvZGUodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpIHsgcmV0dXJuIHRydWUgfVxuICAgIH0gZWxzZSBpZiAoaXNDaGFyICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAvLyBPdGhlcndpc2UsIGlmIHNoaWZ0IGlzIGFjdGl2ZSwgYWxzbyB0cnkgdGhlIGJpbmRpbmcgd2l0aCB0aGVcbiAgICAgIC8vIFNoaWZ0LSBwcmVmaXggZW5hYmxlZC4gU2VlICM5OTdcbiAgICAgIHZhciB3aXRoU2hpZnQgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCB0cnVlKV07XG4gICAgICBpZiAod2l0aFNoaWZ0ICYmIHdpdGhTaGlmdCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmV4cG9ydCB7IGtleWRvd25IYW5kbGVyLCBrZXltYXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIiwiaW1wb3J0IGNyZWwgZnJvbSAnY3JlbHQnO1xuaW1wb3J0IHsgam9pblVwLCBsaWZ0LCBzZWxlY3RQYXJlbnROb2RlLCBzZXRCbG9ja1R5cGUsIHdyYXBJbiB9IGZyb20gJ3Byb3NlbWlycm9yLWNvbW1hbmRzJztcbmltcG9ydCB7IHVuZG8sIHJlZG8gfSBmcm9tICdwcm9zZW1pcnJvci1oaXN0b3J5JztcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxudmFyIFNWRyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbnZhciBYTElOSyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xuXG52YXIgcHJlZml4ID0gXCJQcm9zZU1pcnJvci1pY29uXCI7XG5cbmZ1bmN0aW9uIGhhc2hQYXRoKHBhdGgpIHtcbiAgdmFyIGhhc2ggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspXG4gICAgeyBoYXNoID0gKCgoaGFzaCA8PCA1KSAtIGhhc2gpICsgcGF0aC5jaGFyQ29kZUF0KGkpKSB8IDA7IH1cbiAgcmV0dXJuIGhhc2hcbn1cblxuZnVuY3Rpb24gZ2V0SWNvbihpY29uKSB7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbm9kZS5jbGFzc05hbWUgPSBwcmVmaXg7XG4gIGlmIChpY29uLnBhdGgpIHtcbiAgICB2YXIgbmFtZSA9IFwicG0taWNvbi1cIiArIGhhc2hQYXRoKGljb24ucGF0aCkudG9TdHJpbmcoMTYpO1xuICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobmFtZSkpIHsgYnVpbGRTVkcobmFtZSwgaWNvbik7IH1cbiAgICB2YXIgc3ZnID0gbm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHLCBcInN2Z1wiKSk7XG4gICAgc3ZnLnN0eWxlLndpZHRoID0gKGljb24ud2lkdGggLyBpY29uLmhlaWdodCkgKyBcImVtXCI7XG4gICAgdmFyIHVzZSA9IHN2Zy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHLCBcInVzZVwiKSk7XG4gICAgdXNlLnNldEF0dHJpYnV0ZU5TKFhMSU5LLCBcImhyZWZcIiwgLyhbXiNdKikvLmV4ZWMoZG9jdW1lbnQubG9jYXRpb24pWzFdICsgXCIjXCIgKyBuYW1lKTtcbiAgfSBlbHNlIGlmIChpY29uLmRvbSkge1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoaWNvbi5kb20uY2xvbmVOb2RlKHRydWUpKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKS50ZXh0Q29udGVudCA9IGljb24udGV4dCB8fCAnJztcbiAgICBpZiAoaWNvbi5jc3MpIHsgbm9kZS5maXJzdENoaWxkLnN0eWxlLmNzc1RleHQgPSBpY29uLmNzczsgfVxuICB9XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIGJ1aWxkU1ZHKG5hbWUsIGRhdGEpIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXggKyBcIi1jb2xsZWN0aW9uXCIpO1xuICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWRywgXCJzdmdcIik7XG4gICAgY29sbGVjdGlvbi5pZCA9IHByZWZpeCArIFwiLWNvbGxlY3Rpb25cIjtcbiAgICBjb2xsZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShjb2xsZWN0aW9uLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICB9XG4gIHZhciBzeW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHLCBcInN5bWJvbFwiKTtcbiAgc3ltLmlkID0gbmFtZTtcbiAgc3ltLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgXCIwIDAgXCIgKyBkYXRhLndpZHRoICsgXCIgXCIgKyBkYXRhLmhlaWdodCk7XG4gIHZhciBwYXRoID0gc3ltLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkcsIFwicGF0aFwiKSk7XG4gIHBhdGguc2V0QXR0cmlidXRlKFwiZFwiLCBkYXRhLnBhdGgpO1xuICBjb2xsZWN0aW9uLmFwcGVuZENoaWxkKHN5bSk7XG59XG5cbnZhciBwcmVmaXgkMSA9IFwiUHJvc2VNaXJyb3ItbWVudVwiO1xuXG4vLyA6Oi0gQW4gaWNvbiBvciBsYWJlbCB0aGF0LCB3aGVuIGNsaWNrZWQsIGV4ZWN1dGVzIGEgY29tbWFuZC5cbnZhciBNZW51SXRlbSA9IGZ1bmN0aW9uIE1lbnVJdGVtKHNwZWMpIHtcbiAgLy8gOjogTWVudUl0ZW1TcGVjXG4gIC8vIFRoZSBzcGVjIHVzZWQgdG8gY3JlYXRlIHRoZSBtZW51IGl0ZW0uXG4gIHRoaXMuc3BlYyA9IHNwZWM7XG59O1xuXG4vLyA6OiAoRWRpdG9yVmlldykg4oaSIHtkb206IGRvbS5Ob2RlLCB1cGRhdGU6IChFZGl0b3JTdGF0ZSkg4oaSIGJvb2x9XG4vLyBSZW5kZXJzIHRoZSBpY29uIGFjY29yZGluZyB0byBpdHMgW2Rpc3BsYXlcbi8vIHNwZWNdKCNtZW51Lk1lbnVJdGVtU3BlYy5kaXNwbGF5KSwgYW5kIGFkZHMgYW4gZXZlbnQgaGFuZGxlciB3aGljaFxuLy8gZXhlY3V0ZXMgdGhlIGNvbW1hbmQgd2hlbiB0aGUgcmVwcmVzZW50YXRpb24gaXMgY2xpY2tlZC5cbk1lbnVJdGVtLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHZpZXcpIHtcbiAgdmFyIHNwZWMgPSB0aGlzLnNwZWM7XG4gIHZhciBkb20gPSBzcGVjLnJlbmRlciA/IHNwZWMucmVuZGVyKHZpZXcpXG4gICAgICA6IHNwZWMuaWNvbiA/IGdldEljb24oc3BlYy5pY29uKVxuICAgICAgOiBzcGVjLmxhYmVsID8gY3JlbChcImRpdlwiLCBudWxsLCB0cmFuc2xhdGUodmlldywgc3BlYy5sYWJlbCkpXG4gICAgICA6IG51bGw7XG4gIGlmICghZG9tKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWVudUl0ZW0gd2l0aG91dCBpY29uIG9yIGxhYmVsIHByb3BlcnR5XCIpIH1cbiAgaWYgKHNwZWMudGl0bGUpIHtcbiAgICB2YXIgdGl0bGUgPSAodHlwZW9mIHNwZWMudGl0bGUgPT09IFwiZnVuY3Rpb25cIiA/IHNwZWMudGl0bGUodmlldy5zdGF0ZSkgOiBzcGVjLnRpdGxlKTtcbiAgICBkb20uc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgdHJhbnNsYXRlKHZpZXcsIHRpdGxlKSk7XG4gIH1cbiAgaWYgKHNwZWMuY2xhc3MpIHsgZG9tLmNsYXNzTGlzdC5hZGQoc3BlYy5jbGFzcyk7IH1cbiAgaWYgKHNwZWMuY3NzKSB7IGRvbS5zdHlsZS5jc3NUZXh0ICs9IHNwZWMuY3NzOyB9XG5cbiAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCFkb20uY2xhc3NMaXN0LmNvbnRhaW5zKHByZWZpeCQxICsgXCItZGlzYWJsZWRcIikpXG4gICAgICB7IHNwZWMucnVuKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcsIGUpOyB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZShzdGF0ZSkge1xuICAgIGlmIChzcGVjLnNlbGVjdCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc3BlYy5zZWxlY3Qoc3RhdGUpO1xuICAgICAgZG9tLnN0eWxlLmRpc3BsYXkgPSBzZWxlY3RlZCA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICAgIGlmICghc2VsZWN0ZWQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gICAgdmFyIGVuYWJsZWQgPSB0cnVlO1xuICAgIGlmIChzcGVjLmVuYWJsZSkge1xuICAgICAgZW5hYmxlZCA9IHNwZWMuZW5hYmxlKHN0YXRlKSB8fCBmYWxzZTtcbiAgICAgIHNldENsYXNzKGRvbSwgcHJlZml4JDEgKyBcIi1kaXNhYmxlZFwiLCAhZW5hYmxlZCk7XG4gICAgfVxuICAgIGlmIChzcGVjLmFjdGl2ZSkge1xuICAgICAgdmFyIGFjdGl2ZSA9IGVuYWJsZWQgJiYgc3BlYy5hY3RpdmUoc3RhdGUpIHx8IGZhbHNlO1xuICAgICAgc2V0Q2xhc3MoZG9tLCBwcmVmaXgkMSArIFwiLWFjdGl2ZVwiLCBhY3RpdmUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIHtkb206IGRvbSwgdXBkYXRlOiB1cGRhdGV9XG59O1xuXG5mdW5jdGlvbiB0cmFuc2xhdGUodmlldywgdGV4dCkge1xuICByZXR1cm4gdmlldy5fcHJvcHMudHJhbnNsYXRlID8gdmlldy5fcHJvcHMudHJhbnNsYXRlKHRleHQpIDogdGV4dFxufVxuXG4vLyBNZW51SXRlbVNwZWM6OiBpbnRlcmZhY2Vcbi8vIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBwYXNzZWQgdG8gdGhlIGBNZW51SXRlbWAgY29uc3RydWN0b3IuXG4vL1xuLy8gICBydW46OiAoRWRpdG9yU3RhdGUsIChUcmFuc2FjdGlvbiksIEVkaXRvclZpZXcsIGRvbS5FdmVudClcbi8vICAgVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgbWVudSBpdGVtIGlzIGFjdGl2YXRlZC5cbi8vXG4vLyAgIHNlbGVjdDo6ID8oRWRpdG9yU3RhdGUpIOKGkiBib29sXG4vLyAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgaXRlbSBpc1xuLy8gICBhcHByb3ByaWF0ZSBhdCB0aGUgbW9tZW50LiBEZXNlbGVjdGVkIGl0ZW1zIHdpbGwgYmUgaGlkZGVuLlxuLy9cbi8vICAgZW5hYmxlOjogPyhFZGl0b3JTdGF0ZSkg4oaSIGJvb2xcbi8vICAgRnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgaXRlbSBpcyBlbmFibGVkLiBJZlxuLy8gICBnaXZlbiBhbmQgcmV0dXJuaW5nIGZhbHNlLCB0aGUgaXRlbSB3aWxsIGJlIGdpdmVuIGEgZGlzYWJsZWRcbi8vICAgc3R5bGluZy5cbi8vXG4vLyAgIGFjdGl2ZTo6ID8oRWRpdG9yU3RhdGUpIOKGkiBib29sXG4vLyAgIEEgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBpdGVtIGlzICdhY3RpdmUnIChmb3Jcbi8vICAgZXhhbXBsZSwgdGhlIGl0ZW0gZm9yIHRvZ2dsaW5nIHRoZSBzdHJvbmcgbWFyayBtaWdodCBiZSBhY3RpdmUgdGhlblxuLy8gICB0aGUgY3Vyc29yIGlzIGluIHN0cm9uZyB0ZXh0KS5cbi8vXG4vLyAgIHJlbmRlcjo6ID8oRWRpdG9yVmlldykg4oaSIGRvbS5Ob2RlXG4vLyAgIEEgZnVuY3Rpb24gdGhhdCByZW5kZXJzIHRoZSBpdGVtLiBZb3UgbXVzdCBwcm92aWRlIGVpdGhlciB0aGlzLFxuLy8gICBbYGljb25gXSgjbWVudS5NZW51SXRlbVNwZWMuaWNvbiksIG9yIFtgbGFiZWxgXSgjTWVudUl0ZW1TcGVjLmxhYmVsKS5cbi8vXG4vLyAgIGljb246OiA/T2JqZWN0XG4vLyAgIERlc2NyaWJlcyBhbiBpY29uIHRvIHNob3cgZm9yIHRoaXMgaXRlbS4gVGhlIG9iamVjdCBtYXkgc3BlY2lmeVxuLy8gICBhbiBTVkcgaWNvbiwgaW4gd2hpY2ggY2FzZSBpdHMgYHBhdGhgIHByb3BlcnR5IHNob3VsZCBiZSBhbiBbU1ZHXG4vLyAgIHBhdGhcbi8vICAgc3BlY10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9kKSxcbi8vICAgYW5kIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHNob3VsZCBwcm92aWRlIHRoZSB2aWV3Ym94IGluIHdoaWNoIHRoYXRcbi8vICAgcGF0aCBleGlzdHMuIEFsdGVybmF0aXZlbHksIGl0IG1heSBoYXZlIGEgYHRleHRgIHByb3BlcnR5XG4vLyAgIHNwZWNpZnlpbmcgYSBzdHJpbmcgb2YgdGV4dCB0aGF0IG1ha2VzIHVwIHRoZSBpY29uLCB3aXRoIGFuXG4vLyAgIG9wdGlvbmFsIGBjc3NgIHByb3BlcnR5IGdpdmluZyBhZGRpdGlvbmFsIENTUyBzdHlsaW5nIGZvciB0aGVcbi8vICAgdGV4dC4gX09yXyBpdCBtYXkgY29udGFpbiBgZG9tYCBwcm9wZXJ0eSBjb250YWluaW5nIGEgRE9NIG5vZGUuXG4vL1xuLy8gICBsYWJlbDo6ID9zdHJpbmdcbi8vICAgTWFrZXMgdGhlIGl0ZW0gc2hvdyB1cCBhcyBhIHRleHQgbGFiZWwuIE1vc3RseSB1c2VmdWwgZm9yIGl0ZW1zXG4vLyAgIHdyYXBwZWQgaW4gYSBbZHJvcC1kb3duXSgjbWVudS5Ecm9wZG93bikgb3Igc2ltaWxhciBtZW51LiBUaGUgb2JqZWN0XG4vLyAgIHNob3VsZCBoYXZlIGEgYGxhYmVsYCBwcm9wZXJ0eSBwcm92aWRpbmcgdGhlIHRleHQgdG8gZGlzcGxheS5cbi8vXG4vLyAgIHRpdGxlOjogP3VuaW9uPHN0cmluZywgKEVkaXRvclN0YXRlKSDihpIgc3RyaW5nPlxuLy8gICBEZWZpbmVzIERPTSB0aXRsZSAobW91c2VvdmVyKSB0ZXh0IGZvciB0aGUgaXRlbS5cbi8vXG4vLyAgIGNsYXNzOjogP3N0cmluZ1xuLy8gICBPcHRpb25hbGx5IGFkZHMgYSBDU1MgY2xhc3MgdG8gdGhlIGl0ZW0ncyBET00gcmVwcmVzZW50YXRpb24uXG4vL1xuLy8gICBjc3M6OiA/c3RyaW5nXG4vLyAgIE9wdGlvbmFsbHkgYWRkcyBhIHN0cmluZyBvZiBpbmxpbmUgQ1NTIHRvIHRoZSBpdGVtJ3MgRE9NXG4vLyAgIHJlcHJlc2VudGF0aW9uLlxuXG52YXIgbGFzdE1lbnVFdmVudCA9IHt0aW1lOiAwLCBub2RlOiBudWxsfTtcbmZ1bmN0aW9uIG1hcmtNZW51RXZlbnQoZSkge1xuICBsYXN0TWVudUV2ZW50LnRpbWUgPSBEYXRlLm5vdygpO1xuICBsYXN0TWVudUV2ZW50Lm5vZGUgPSBlLnRhcmdldDtcbn1cbmZ1bmN0aW9uIGlzTWVudUV2ZW50KHdyYXBwZXIpIHtcbiAgcmV0dXJuIERhdGUubm93KCkgLSAxMDAgPCBsYXN0TWVudUV2ZW50LnRpbWUgJiZcbiAgICBsYXN0TWVudUV2ZW50Lm5vZGUgJiYgd3JhcHBlci5jb250YWlucyhsYXN0TWVudUV2ZW50Lm5vZGUpXG59XG5cbi8vIDo6LSBBIGRyb3AtZG93biBtZW51LCBkaXNwbGF5ZWQgYXMgYSBsYWJlbCB3aXRoIGEgZG93bndhcmRzLXBvaW50aW5nXG4vLyB0cmlhbmdsZSB0byB0aGUgcmlnaHQgb2YgaXQuXG52YXIgRHJvcGRvd24gPSBmdW5jdGlvbiBEcm9wZG93bihjb250ZW50LCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuY29udGVudCA9IEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdO1xufTtcblxuLy8gOjogKEVkaXRvclZpZXcpIOKGkiB7ZG9tOiBkb20uTm9kZSwgdXBkYXRlOiAoRWRpdG9yU3RhdGUpfVxuLy8gUmVuZGVyIHRoZSBkcm9wZG93biBtZW51IGFuZCBzdWItaXRlbXMuXG5Ecm9wZG93bi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh2aWV3KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNvbnRlbnQgPSByZW5kZXJEcm9wZG93bkl0ZW1zKHRoaXMuY29udGVudCwgdmlldyk7XG5cbiAgdmFyIGxhYmVsID0gY3JlbChcImRpdlwiLCB7Y2xhc3M6IHByZWZpeCQxICsgXCItZHJvcGRvd24gXCIgKyAodGhpcy5vcHRpb25zLmNsYXNzIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5jc3N9LFxuICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSh2aWV3LCB0aGlzLm9wdGlvbnMubGFiZWwpKTtcbiAgaWYgKHRoaXMub3B0aW9ucy50aXRsZSkgeyBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCB0cmFuc2xhdGUodmlldywgdGhpcy5vcHRpb25zLnRpdGxlKSk7IH1cbiAgdmFyIHdyYXAgPSBjcmVsKFwiZGl2XCIsIHtjbGFzczogcHJlZml4JDEgKyBcIi1kcm9wZG93bi13cmFwXCJ9LCBsYWJlbCk7XG4gIHZhciBvcGVuID0gbnVsbCwgbGlzdGVuaW5nT25DbG9zZSA9IG51bGw7XG4gIHZhciBjbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAob3BlbiAmJiBvcGVuLmNsb3NlKCkpIHtcbiAgICAgIG9wZW4gPSBudWxsO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbGlzdGVuaW5nT25DbG9zZSk7XG4gICAgfVxuICB9O1xuICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIG1hcmtNZW51RXZlbnQoZSk7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wZW4gPSB0aGlzJDEuZXhwYW5kKHdyYXAsIGNvbnRlbnQuZG9tKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGxpc3RlbmluZ09uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNNZW51RXZlbnQod3JhcCkpIHsgY2xvc2UoKTsgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiB1cGRhdGUoc3RhdGUpIHtcbiAgICB2YXIgaW5uZXIgPSBjb250ZW50LnVwZGF0ZShzdGF0ZSk7XG4gICAgd3JhcC5zdHlsZS5kaXNwbGF5ID0gaW5uZXIgPyBcIlwiIDogXCJub25lXCI7XG4gICAgcmV0dXJuIGlubmVyXG4gIH1cblxuICByZXR1cm4ge2RvbTogd3JhcCwgdXBkYXRlOiB1cGRhdGV9XG59O1xuXG5Ecm9wZG93bi5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kIChkb20sIGl0ZW1zKSB7XG4gIHZhciBtZW51RE9NID0gY3JlbChcImRpdlwiLCB7Y2xhc3M6IHByZWZpeCQxICsgXCItZHJvcGRvd24tbWVudSBcIiArICh0aGlzLm9wdGlvbnMuY2xhc3MgfHwgXCJcIil9LCBpdGVtcyk7XG5cbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKGRvbmUpIHsgcmV0dXJuIH1cbiAgICBkb25lID0gdHJ1ZTtcbiAgICBkb20ucmVtb3ZlQ2hpbGQobWVudURPTSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBkb20uYXBwZW5kQ2hpbGQobWVudURPTSk7XG4gIHJldHVybiB7Y2xvc2U6IGNsb3NlLCBub2RlOiBtZW51RE9NfVxufTtcblxuZnVuY3Rpb24gcmVuZGVyRHJvcGRvd25JdGVtcyhpdGVtcywgdmlldykge1xuICB2YXIgcmVuZGVyZWQgPSBbXSwgdXBkYXRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlZiA9IGl0ZW1zW2ldLnJlbmRlcih2aWV3KTtcbiAgICB2YXIgZG9tID0gcmVmLmRvbTtcbiAgICB2YXIgdXBkYXRlID0gcmVmLnVwZGF0ZTtcbiAgICByZW5kZXJlZC5wdXNoKGNyZWwoXCJkaXZcIiwge2NsYXNzOiBwcmVmaXgkMSArIFwiLWRyb3Bkb3duLWl0ZW1cIn0sIGRvbSkpO1xuICAgIHVwZGF0ZXMucHVzaCh1cGRhdGUpO1xuICB9XG4gIHJldHVybiB7ZG9tOiByZW5kZXJlZCwgdXBkYXRlOiBjb21iaW5lVXBkYXRlcyh1cGRhdGVzLCByZW5kZXJlZCl9XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVVcGRhdGVzKHVwZGF0ZXMsIG5vZGVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgc29tZXRoaW5nID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdXAgPSB1cGRhdGVzW2ldKHN0YXRlKTtcbiAgICAgIG5vZGVzW2ldLnN0eWxlLmRpc3BsYXkgPSB1cCA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICAgIGlmICh1cCkgeyBzb21ldGhpbmcgPSB0cnVlOyB9XG4gICAgfVxuICAgIHJldHVybiBzb21ldGhpbmdcbiAgfVxufVxuXG4vLyA6Oi0gUmVwcmVzZW50cyBhIHN1Ym1lbnUgd3JhcHBpbmcgYSBncm91cCBvZiBlbGVtZW50cyB0aGF0IHN0YXJ0XG4vLyBoaWRkZW4gYW5kIGV4cGFuZCB0byB0aGUgcmlnaHQgd2hlbiBob3ZlcmVkIG92ZXIgb3IgdGFwcGVkLlxudmFyIERyb3Bkb3duU3VibWVudSA9IGZ1bmN0aW9uIERyb3Bkb3duU3VibWVudShjb250ZW50LCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuY29udGVudCA9IEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdO1xufTtcblxuLy8gOjogKEVkaXRvclZpZXcpIOKGkiB7ZG9tOiBkb20uTm9kZSwgdXBkYXRlOiAoRWRpdG9yU3RhdGUpIOKGkiBib29sfVxuLy8gUmVuZGVycyB0aGUgc3VibWVudS5cbkRyb3Bkb3duU3VibWVudS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh2aWV3KSB7XG4gIHZhciBpdGVtcyA9IHJlbmRlckRyb3Bkb3duSXRlbXModGhpcy5jb250ZW50LCB2aWV3KTtcblxuICB2YXIgbGFiZWwgPSBjcmVsKFwiZGl2XCIsIHtjbGFzczogcHJlZml4JDEgKyBcIi1zdWJtZW51LWxhYmVsXCJ9LCB0cmFuc2xhdGUodmlldywgdGhpcy5vcHRpb25zLmxhYmVsKSk7XG4gIHZhciB3cmFwID0gY3JlbChcImRpdlwiLCB7Y2xhc3M6IHByZWZpeCQxICsgXCItc3VibWVudS13cmFwXCJ9LCBsYWJlbCxcbiAgICAgICAgICAgICAgICAgY3JlbChcImRpdlwiLCB7Y2xhc3M6IHByZWZpeCQxICsgXCItc3VibWVudVwifSwgaXRlbXMuZG9tKSk7XG4gIHZhciBsaXN0ZW5pbmdPbkNsb3NlID0gbnVsbDtcbiAgbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBtYXJrTWVudUV2ZW50KGUpO1xuICAgIHNldENsYXNzKHdyYXAsIHByZWZpeCQxICsgXCItc3VibWVudS13cmFwLWFjdGl2ZVwiKTtcbiAgICBpZiAoIWxpc3RlbmluZ09uQ2xvc2UpXG4gICAgICB7IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGxpc3RlbmluZ09uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNNZW51RXZlbnQod3JhcCkpIHtcbiAgICAgICAgICB3cmFwLmNsYXNzTGlzdC5yZW1vdmUocHJlZml4JDEgKyBcIi1zdWJtZW51LXdyYXAtYWN0aXZlXCIpO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGxpc3RlbmluZ09uQ2xvc2UpO1xuICAgICAgICAgIGxpc3RlbmluZ09uQ2xvc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTsgfVxuICB9KTtcblxuICBmdW5jdGlvbiB1cGRhdGUoc3RhdGUpIHtcbiAgICB2YXIgaW5uZXIgPSBpdGVtcy51cGRhdGUoc3RhdGUpO1xuICAgIHdyYXAuc3R5bGUuZGlzcGxheSA9IGlubmVyID8gXCJcIiA6IFwibm9uZVwiO1xuICAgIHJldHVybiBpbm5lclxuICB9XG4gIHJldHVybiB7ZG9tOiB3cmFwLCB1cGRhdGU6IHVwZGF0ZX1cbn07XG5cbi8vIDo6IChFZGl0b3JWaWV3LCBbdW5pb248TWVudUVsZW1lbnQsIFtNZW51RWxlbWVudF0+XSkg4oaSIHtkb206ID9kb20uRG9jdW1lbnRGcmFnbWVudCwgdXBkYXRlOiAoRWRpdG9yU3RhdGUpIOKGkiBib29sfVxuLy8gUmVuZGVyIHRoZSBnaXZlbiwgcG9zc2libHkgbmVzdGVkLCBhcnJheSBvZiBtZW51IGVsZW1lbnRzIGludG8gYVxuLy8gZG9jdW1lbnQgZnJhZ21lbnQsIHBsYWNpbmcgc2VwYXJhdG9ycyBiZXR3ZWVuIHRoZW0gKGFuZCBlbnN1cmluZyBub1xuLy8gc3VwZXJmbHVvdXMgc2VwYXJhdG9ycyBhcHBlYXIgd2hlbiBzb21lIG9mIHRoZSBncm91cHMgdHVybiBvdXQgdG9cbi8vIGJlIGVtcHR5KS5cbmZ1bmN0aW9uIHJlbmRlckdyb3VwZWQodmlldywgY29udGVudCkge1xuICB2YXIgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgdXBkYXRlcyA9IFtdLCBzZXBhcmF0b3JzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtcyA9IGNvbnRlbnRbaV0sIGxvY2FsVXBkYXRlcyA9IFtdLCBsb2NhbE5vZGVzID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHJlZiA9IGl0ZW1zW2pdLnJlbmRlcih2aWV3KTtcbiAgICAgIHZhciBkb20gPSByZWYuZG9tO1xuICAgICAgdmFyIHVwZGF0ZSQxID0gcmVmLnVwZGF0ZTtcbiAgICAgIHZhciBzcGFuID0gY3JlbChcInNwYW5cIiwge2NsYXNzOiBwcmVmaXgkMSArIFwiaXRlbVwifSwgZG9tKTtcbiAgICAgIHJlc3VsdC5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgIGxvY2FsTm9kZXMucHVzaChzcGFuKTtcbiAgICAgIGxvY2FsVXBkYXRlcy5wdXNoKHVwZGF0ZSQxKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsVXBkYXRlcy5sZW5ndGgpIHtcbiAgICAgIHVwZGF0ZXMucHVzaChjb21iaW5lVXBkYXRlcyhsb2NhbFVwZGF0ZXMsIGxvY2FsTm9kZXMpKTtcbiAgICAgIGlmIChpIDwgY29udGVudC5sZW5ndGggLSAxKVxuICAgICAgICB7IHNlcGFyYXRvcnMucHVzaChyZXN1bHQuYXBwZW5kQ2hpbGQoc2VwYXJhdG9yKCkpKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShzdGF0ZSkge1xuICAgIHZhciBzb21ldGhpbmcgPSBmYWxzZSwgbmVlZFNlcCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhhc0NvbnRlbnQgPSB1cGRhdGVzW2ldKHN0YXRlKTtcbiAgICAgIGlmIChpKSB7IHNlcGFyYXRvcnNbaSAtIDFdLnN0eWxlLmRpc3BsYXkgPSBuZWVkU2VwICYmIGhhc0NvbnRlbnQgPyBcIlwiIDogXCJub25lXCI7IH1cbiAgICAgIG5lZWRTZXAgPSBoYXNDb250ZW50O1xuICAgICAgaWYgKGhhc0NvbnRlbnQpIHsgc29tZXRoaW5nID0gdHJ1ZTsgfVxuICAgIH1cbiAgICByZXR1cm4gc29tZXRoaW5nXG4gIH1cbiAgcmV0dXJuIHtkb206IHJlc3VsdCwgdXBkYXRlOiB1cGRhdGV9XG59XG5cbmZ1bmN0aW9uIHNlcGFyYXRvcigpIHtcbiAgcmV0dXJuIGNyZWwoXCJzcGFuXCIsIHtjbGFzczogcHJlZml4JDEgKyBcInNlcGFyYXRvclwifSlcbn1cblxuLy8gOjogT2JqZWN0XG4vLyBBIHNldCBvZiBiYXNpYyBlZGl0b3ItcmVsYXRlZCBpY29ucy4gQ29udGFpbnMgdGhlIHByb3BlcnRpZXNcbi8vIGBqb2luYCwgYGxpZnRgLCBgc2VsZWN0UGFyZW50Tm9kZWAsIGB1bmRvYCwgYHJlZG9gLCBgc3Ryb25nYCwgYGVtYCxcbi8vIGBjb2RlYCwgYGxpbmtgLCBgYnVsbGV0TGlzdGAsIGBvcmRlcmVkTGlzdGAsIGFuZCBgYmxvY2txdW90ZWAsIGVhY2hcbi8vIGhvbGRpbmcgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgdGhlIGBpY29uYCBvcHRpb24gdG9cbi8vIGBNZW51SXRlbWAuXG52YXIgaWNvbnMgPSB7XG4gIGpvaW46IHtcbiAgICB3aWR0aDogODAwLCBoZWlnaHQ6IDkwMCxcbiAgICBwYXRoOiBcIk0wIDc1aDgwMHYxMjVoLTgwMHogTTAgODI1aDgwMHYtMTI1aC04MDB6IE0yNTAgNDAwaDEwMHYtMTAwaDEwMHYxMDBoMTAwdjEwMGgtMTAwdjEwMGgtMTAwdi0xMDBoLTEwMHpcIlxuICB9LFxuICBsaWZ0OiB7XG4gICAgd2lkdGg6IDEwMjQsIGhlaWdodDogMTAyNCxcbiAgICBwYXRoOiBcIk0yMTkgMzEwdjMyOXEwIDctNSAxMnQtMTIgNXEtOCAwLTEzLTVsLTE2NC0xNjRxLTUtNS01LTEzdDUtMTNsMTY0LTE2NHE1LTUgMTMtNSA3IDAgMTIgNXQ1IDEyek0xMDI0IDc0OXYxMDlxMCA3LTUgMTJ0LTEyIDVoLTk4N3EtNyAwLTEyLTV0LTUtMTJ2LTEwOXEwLTcgNS0xMnQxMi01aDk4N3E3IDAgMTIgNXQ1IDEyek0xMDI0IDUzMHYxMDlxMCA3LTUgMTJ0LTEyIDVoLTYyMXEtNyAwLTEyLTV0LTUtMTJ2LTEwOXEwLTcgNS0xMnQxMi01aDYyMXE3IDAgMTIgNXQ1IDEyek0xMDI0IDMxMHYxMDlxMCA3LTUgMTJ0LTEyIDVoLTYyMXEtNyAwLTEyLTV0LTUtMTJ2LTEwOXEwLTcgNS0xMnQxMi01aDYyMXE3IDAgMTIgNXQ1IDEyek0xMDI0IDkxdjEwOXEwIDctNSAxMnQtMTIgNWgtOTg3cS03IDAtMTItNXQtNS0xMnYtMTA5cTAtNyA1LTEydDEyLTVoOTg3cTcgMCAxMiA1dDUgMTJ6XCJcbiAgfSxcbiAgc2VsZWN0UGFyZW50Tm9kZToge3RleHQ6IFwiXFx1MmIxYVwiLCBjc3M6IFwiZm9udC13ZWlnaHQ6IGJvbGRcIn0sXG4gIHVuZG86IHtcbiAgICB3aWR0aDogMTAyNCwgaGVpZ2h0OiAxMDI0LFxuICAgIHBhdGg6IFwiTTc2MSAxMDI0YzExMy0yMDYgMTMyLTUyMC0zMTMtNTA5djI1M2wtMzg0LTM4NCAzODQtMzg0djI0OGM1MzQtMTMgNTk0IDQ3MiAzMTMgNzc1elwiXG4gIH0sXG4gIHJlZG86IHtcbiAgICB3aWR0aDogMTAyNCwgaGVpZ2h0OiAxMDI0LFxuICAgIHBhdGg6IFwiTTU3NiAyNDh2LTI0OGwzODQgMzg0LTM4NCAzODR2LTI1M2MtNDQ2LTEwLTQyNyAzMDMtMzEzIDUwOS0yODAtMzAzLTIyMS03ODkgMzEzLTc3NXpcIlxuICB9LFxuICBzdHJvbmc6IHtcbiAgICB3aWR0aDogODA1LCBoZWlnaHQ6IDEwMjQsXG4gICAgcGF0aDogXCJNMzE3IDg2OXE0MiAxOCA4MCAxOCAyMTQgMCAyMTQtMTkxIDAtNjUtMjMtMTAyLTE1LTI1LTM1LTQydC0zOC0yNi00Ni0xNC00OC02LTU0LTFxLTQxIDAtNTcgNSAwIDMwLTAgOTB0LTAgOTBxMCA0LTAgMzh0LTAgNTUgMiA0NyA2IDM4ek0zMDkgNDQycTI0IDQgNjIgNCA0NiAwIDgxLTd0NjItMjUgNDItNTEgMTQtODFxMC00MC0xNi03MHQtNDUtNDYtNjEtMjQtNzAtOHEtMjggMC03NCA3IDAgMjggMiA4NnQyIDg2cTAgMTUtMCA0NXQtMCA0NXEwIDI2IDAgMzl6TTAgOTUwbDEtNTNxOC0yIDQ4LTl0NjAtMTVxNC02IDctMTV0NC0xOSAzLTE4IDEtMjEgMC0xOXYtMzdxMC01NjEtMTItNTg1LTItNC0xMi04dC0yNS02LTI4LTQtMjctMi0xNy0xbC0yLTQ3cTU2LTEgMTk0LTZ0MjEzLTVxMTMgMCAzOSAwdDM4IDBxNDAgMCA3OCA3dDczIDI0IDYxIDQwIDQyIDU5IDE2IDc4cTAgMjktOSA1NHQtMjIgNDEtMzYgMzItNDEgMjUtNDggMjJxODggMjAgMTQ2IDc2dDU4IDE0MXEwIDU3LTIwIDEwMnQtNTMgNzQtNzggNDgtOTMgMjctMTAwIDhxLTI1IDAtNzUtMXQtNzUtMXEtNjAgMC0xNzUgNnQtMTMyIDZ6XCJcbiAgfSxcbiAgZW06IHtcbiAgICB3aWR0aDogNTg1LCBoZWlnaHQ6IDEwMjQsXG4gICAgcGF0aDogXCJNMCA5NDlsOS00OHEzLTEgNDYtMTJ0NjMtMjFxMTYtMjAgMjMtNTcgMC00IDM1LTE2NXQ2NS0zMTAgMjktMTY5di0xNHEtMTMtNy0zMS0xMHQtMzktNC0zMy0zbDEwLTU4cTE4IDEgNjggM3Q4NSA0IDY4IDFxMjcgMCA1Ni0xdDY5LTQgNTYtM3EtMiAyMi0xMCA1MC0xNyA1LTU4IDE2dC02MiAxOXEtNCAxMC04IDI0dC01IDIyLTQgMjYtMyAyNHEtMTUgODQtNTAgMjM5dC00NCAyMDNxLTEgNS03IDMzdC0xMSA1MS05IDQ3LTMgMzJsMCAxMHE5IDIgMTA1IDE3LTEgMjUtOSA1Ni02IDAtMTggMHQtMTggMHEtMTYgMC00OS01dC00OS01cS03OC0xLTExNy0xLTI5IDAtODEgNXQtNjkgNnpcIlxuICB9LFxuICBjb2RlOiB7XG4gICAgd2lkdGg6IDg5NiwgaGVpZ2h0OiAxMDI0LFxuICAgIHBhdGg6IFwiTTYwOCAxOTJsLTk2IDk2IDIyNCAyMjQtMjI0IDIyNCA5NiA5NiAyODgtMzIwLTI4OC0zMjB6TTI4OCAxOTJsLTI4OCAzMjAgMjg4IDMyMCA5Ni05Ni0yMjQtMjI0IDIyNC0yMjQtOTYtOTZ6XCJcbiAgfSxcbiAgbGluazoge1xuICAgIHdpZHRoOiA5NTEsIGhlaWdodDogMTAyNCxcbiAgICBwYXRoOiBcIk04MzIgNjk0cTAtMjItMTYtMzhsLTExOC0xMThxLTE2LTE2LTM4LTE2LTI0IDAtNDEgMTggMSAxIDEwIDEwdDEyIDEyIDggMTAgNyAxNCAyIDE1cTAgMjItMTYgMzh0LTM4IDE2cS04IDAtMTUtMnQtMTQtNy0xMC04LTEyLTEyLTEwLTEwcS0xOCAxNy0xOCA0MSAwIDIyIDE2IDM4bDExNyAxMThxMTUgMTUgMzggMTUgMjIgMCAzOC0xNGw4NC04M3ExNi0xNiAxNi0zOHpNNDMwIDI5MnEwLTIyLTE2LTM4bC0xMTctMTE4cS0xNi0xNi0zOC0xNi0yMiAwLTM4IDE1bC04NCA4M3EtMTYgMTYtMTYgMzggMCAyMiAxNiAzOGwxMTggMTE4cTE1IDE1IDM4IDE1IDI0IDAgNDEtMTctMS0xLTEwLTEwdC0xMi0xMi04LTEwLTctMTQtMi0xNXEwLTIyIDE2LTM4dDM4LTE2cTggMCAxNSAydDE0IDcgMTAgOCAxMiAxMiAxMCAxMHExOC0xNyAxOC00MXpNOTQxIDY5NHEwIDY4LTQ4IDExNmwtODQgODNxLTQ3IDQ3LTExNiA0Ny02OSAwLTExNi00OGwtMTE3LTExOHEtNDctNDctNDctMTE2IDAtNzAgNTAtMTE5bC01MC01MHEtNDkgNTAtMTE4IDUwLTY4IDAtMTE2LTQ4bC0xMTgtMTE4cS00OC00OC00OC0xMTZ0NDgtMTE2bDg0LTgzcTQ3LTQ3IDExNi00NyA2OSAwIDExNiA0OGwxMTcgMTE4cTQ3IDQ3IDQ3IDExNiAwIDcwLTUwIDExOWw1MCA1MHE0OS01MCAxMTgtNTAgNjggMCAxMTYgNDhsMTE4IDExOHE0OCA0OCA0OCAxMTZ6XCJcbiAgfSxcbiAgYnVsbGV0TGlzdDoge1xuICAgIHdpZHRoOiA3NjgsIGhlaWdodDogODk2LFxuICAgIHBhdGg6IFwiTTAgNTEyaDEyOHYtMTI4aC0xMjh2MTI4ek0wIDI1NmgxMjh2LTEyOGgtMTI4djEyOHpNMCA3NjhoMTI4di0xMjhoLTEyOHYxMjh6TTI1NiA1MTJoNTEydi0xMjhoLTUxMnYxMjh6TTI1NiAyNTZoNTEydi0xMjhoLTUxMnYxMjh6TTI1NiA3NjhoNTEydi0xMjhoLTUxMnYxMjh6XCJcbiAgfSxcbiAgb3JkZXJlZExpc3Q6IHtcbiAgICB3aWR0aDogNzY4LCBoZWlnaHQ6IDg5NixcbiAgICBwYXRoOiBcIk0zMjAgNTEyaDQ0OHYtMTI4aC00NDh2MTI4ek0zMjAgNzY4aDQ0OHYtMTI4aC00NDh2MTI4ek0zMjAgMTI4djEyOGg0NDh2LTEyOGgtNDQ4ek03OSAzODRoNzh2LTI1NmgtMzZsLTg1IDIzdjUwbDQzLTJ2MTg1ek0xODkgNTkwYzAtMzYtMTItNzgtOTYtNzgtMzMgMC02NCA2LTgzIDE2bDEgNjZjMjEtMTAgNDItMTUgNjctMTVzMzIgMTEgMzIgMjhjMCAyNi0zMCA1OC0xMTAgMTEydjUwaDE5MnYtNjdsLTkxIDJjNDktMzAgODctNjYgODctMTEzbDEtMXpcIlxuICB9LFxuICBibG9ja3F1b3RlOiB7XG4gICAgd2lkdGg6IDY0MCwgaGVpZ2h0OiA4OTYsXG4gICAgcGF0aDogXCJNMCA0NDh2MjU2aDI1NnYtMjU2aC0xMjhjMCAwIDAtMTI4IDEyOC0xMjh2LTEyOGMwIDAtMjU2IDAtMjU2IDI1NnpNNjQwIDMyMHYtMTI4YzAgMC0yNTYgMC0yNTYgMjU2djI1NmgyNTZ2LTI1NmgtMTI4YzAgMCAwLTEyOCAxMjgtMTI4elwiXG4gIH1cbn07XG5cbi8vIDo6IE1lbnVJdGVtXG4vLyBNZW51IGl0ZW0gZm9yIHRoZSBgam9pblVwYCBjb21tYW5kLlxudmFyIGpvaW5VcEl0ZW0gPSBuZXcgTWVudUl0ZW0oe1xuICB0aXRsZTogXCJKb2luIHdpdGggYWJvdmUgYmxvY2tcIixcbiAgcnVuOiBqb2luVXAsXG4gIHNlbGVjdDogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBqb2luVXAoc3RhdGUpOyB9LFxuICBpY29uOiBpY29ucy5qb2luXG59KTtcblxuLy8gOjogTWVudUl0ZW1cbi8vIE1lbnUgaXRlbSBmb3IgdGhlIGBsaWZ0YCBjb21tYW5kLlxudmFyIGxpZnRJdGVtID0gbmV3IE1lbnVJdGVtKHtcbiAgdGl0bGU6IFwiTGlmdCBvdXQgb2YgZW5jbG9zaW5nIGJsb2NrXCIsXG4gIHJ1bjogbGlmdCxcbiAgc2VsZWN0OiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGxpZnQoc3RhdGUpOyB9LFxuICBpY29uOiBpY29ucy5saWZ0XG59KTtcblxuLy8gOjogTWVudUl0ZW1cbi8vIE1lbnUgaXRlbSBmb3IgdGhlIGBzZWxlY3RQYXJlbnROb2RlYCBjb21tYW5kLlxudmFyIHNlbGVjdFBhcmVudE5vZGVJdGVtID0gbmV3IE1lbnVJdGVtKHtcbiAgdGl0bGU6IFwiU2VsZWN0IHBhcmVudCBub2RlXCIsXG4gIHJ1bjogc2VsZWN0UGFyZW50Tm9kZSxcbiAgc2VsZWN0OiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHNlbGVjdFBhcmVudE5vZGUoc3RhdGUpOyB9LFxuICBpY29uOiBpY29ucy5zZWxlY3RQYXJlbnROb2RlXG59KTtcblxuLy8gOjogTWVudUl0ZW1cbi8vIE1lbnUgaXRlbSBmb3IgdGhlIGB1bmRvYCBjb21tYW5kLlxudmFyIHVuZG9JdGVtID0gbmV3IE1lbnVJdGVtKHtcbiAgdGl0bGU6IFwiVW5kbyBsYXN0IGNoYW5nZVwiLFxuICBydW46IHVuZG8sXG4gIGVuYWJsZTogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiB1bmRvKHN0YXRlKTsgfSxcbiAgaWNvbjogaWNvbnMudW5kb1xufSk7XG5cbi8vIDo6IE1lbnVJdGVtXG4vLyBNZW51IGl0ZW0gZm9yIHRoZSBgcmVkb2AgY29tbWFuZC5cbnZhciByZWRvSXRlbSA9IG5ldyBNZW51SXRlbSh7XG4gIHRpdGxlOiBcIlJlZG8gbGFzdCB1bmRvbmUgY2hhbmdlXCIsXG4gIHJ1bjogcmVkbyxcbiAgZW5hYmxlOiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHJlZG8oc3RhdGUpOyB9LFxuICBpY29uOiBpY29ucy5yZWRvXG59KTtcblxuLy8gOjogKE5vZGVUeXBlLCBPYmplY3QpIOKGkiBNZW51SXRlbVxuLy8gQnVpbGQgYSBtZW51IGl0ZW0gZm9yIHdyYXBwaW5nIHRoZSBzZWxlY3Rpb24gaW4gYSBnaXZlbiBub2RlIHR5cGUuXG4vLyBBZGRzIGBydW5gIGFuZCBgc2VsZWN0YCBwcm9wZXJ0aWVzIHRvIHRoZSBvbmVzIHByZXNlbnQgaW5cbi8vIGBvcHRpb25zYC4gYG9wdGlvbnMuYXR0cnNgIG1heSBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbi5cbmZ1bmN0aW9uIHdyYXBJdGVtKG5vZGVUeXBlLCBvcHRpb25zKSB7XG4gIHZhciBwYXNzZWRPcHRpb25zID0ge1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgLy8gRklYTUUgaWYgKG9wdGlvbnMuYXR0cnMgaW5zdGFuY2VvZiBGdW5jdGlvbikgb3B0aW9ucy5hdHRycyhzdGF0ZSwgYXR0cnMgPT4gd3JhcEluKG5vZGVUeXBlLCBhdHRycykoc3RhdGUpKVxuICAgICAgcmV0dXJuIHdyYXBJbihub2RlVHlwZSwgb3B0aW9ucy5hdHRycykoc3RhdGUsIGRpc3BhdGNoKVxuICAgIH0sXG4gICAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3Qoc3RhdGUpIHtcbiAgICAgIHJldHVybiB3cmFwSW4obm9kZVR5cGUsIG9wdGlvbnMuYXR0cnMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IG51bGwgOiBvcHRpb25zLmF0dHJzKShzdGF0ZSlcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykgeyBwYXNzZWRPcHRpb25zW3Byb3BdID0gb3B0aW9uc1twcm9wXTsgfVxuICByZXR1cm4gbmV3IE1lbnVJdGVtKHBhc3NlZE9wdGlvbnMpXG59XG5cbi8vIDo6IChOb2RlVHlwZSwgT2JqZWN0KSDihpIgTWVudUl0ZW1cbi8vIEJ1aWxkIGEgbWVudSBpdGVtIGZvciBjaGFuZ2luZyB0aGUgdHlwZSBvZiB0aGUgdGV4dGJsb2NrIGFyb3VuZCB0aGVcbi8vIHNlbGVjdGlvbiB0byB0aGUgZ2l2ZW4gdHlwZS4gUHJvdmlkZXMgYHJ1bmAsIGBhY3RpdmVgLCBhbmQgYHNlbGVjdGBcbi8vIHByb3BlcnRpZXMuIE90aGVycyBtdXN0IGJlIGdpdmVuIGluIGBvcHRpb25zYC4gYG9wdGlvbnMuYXR0cnNgIG1heVxuLy8gYmUgYW4gb2JqZWN0IHRvIHByb3ZpZGUgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSB0ZXh0YmxvY2sgbm9kZS5cbmZ1bmN0aW9uIGJsb2NrVHlwZUl0ZW0obm9kZVR5cGUsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbW1hbmQgPSBzZXRCbG9ja1R5cGUobm9kZVR5cGUsIG9wdGlvbnMuYXR0cnMpO1xuICB2YXIgcGFzc2VkT3B0aW9ucyA9IHtcbiAgICBydW46IGNvbW1hbmQsXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoc3RhdGUpIHsgcmV0dXJuIGNvbW1hbmQoc3RhdGUpIH0sXG4gICAgYWN0aXZlOiBmdW5jdGlvbiBhY3RpdmUoc3RhdGUpIHtcbiAgICAgIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICB2YXIgJGZyb20gPSByZWYuJGZyb207XG4gICAgICB2YXIgdG8gPSByZWYudG87XG4gICAgICB2YXIgbm9kZSA9IHJlZi5ub2RlO1xuICAgICAgaWYgKG5vZGUpIHsgcmV0dXJuIG5vZGUuaGFzTWFya3VwKG5vZGVUeXBlLCBvcHRpb25zLmF0dHJzKSB9XG4gICAgICByZXR1cm4gdG8gPD0gJGZyb20uZW5kKCkgJiYgJGZyb20ucGFyZW50Lmhhc01hcmt1cChub2RlVHlwZSwgb3B0aW9ucy5hdHRycylcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykgeyBwYXNzZWRPcHRpb25zW3Byb3BdID0gb3B0aW9uc1twcm9wXTsgfVxuICByZXR1cm4gbmV3IE1lbnVJdGVtKHBhc3NlZE9wdGlvbnMpXG59XG5cbi8vIFdvcmsgYXJvdW5kIGNsYXNzTGlzdC50b2dnbGUgYmVpbmcgYnJva2VuIGluIElFMTFcbmZ1bmN0aW9uIHNldENsYXNzKGRvbSwgY2xzLCBvbikge1xuICBpZiAob24pIHsgZG9tLmNsYXNzTGlzdC5hZGQoY2xzKTsgfVxuICBlbHNlIHsgZG9tLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTsgfVxufVxuXG52YXIgcHJlZml4JDIgPSBcIlByb3NlTWlycm9yLW1lbnViYXJcIjtcblxuZnVuY3Rpb24gaXNJT1MoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09IFwidW5kZWZpbmVkXCIpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgcmV0dXJuICEvRWRnZVxcL1xcZC8udGVzdChhZ2VudCkgJiYgL0FwcGxlV2ViS2l0Ly50ZXN0KGFnZW50KSAmJiAvTW9iaWxlXFwvXFx3Ky8udGVzdChhZ2VudClcbn1cblxuLy8gOjogKE9iamVjdCkg4oaSIFBsdWdpblxuLy8gQSBwbHVnaW4gdGhhdCB3aWxsIHBsYWNlIGEgbWVudSBiYXIgYWJvdmUgdGhlIGVkaXRvci4gTm90ZSB0aGF0XG4vLyB0aGlzIGludm9sdmVzIHdyYXBwaW5nIHRoZSBlZGl0b3IgaW4gYW4gYWRkaXRpb25hbCBgPGRpdj5gLlxuLy9cbi8vICAgb3B0aW9uczo6LVxuLy8gICBTdXBwb3J0cyB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG4vL1xuLy8gICAgIGNvbnRlbnQ6OiBbW01lbnVFbGVtZW50XV1cbi8vICAgICBQcm92aWRlcyB0aGUgY29udGVudCBvZiB0aGUgbWVudSwgYXMgYSBuZXN0ZWQgYXJyYXkgdG8gYmVcbi8vICAgICBwYXNzZWQgdG8gYHJlbmRlckdyb3VwZWRgLlxuLy9cbi8vICAgICBmbG9hdGluZzo6ID9ib29sXG4vLyAgICAgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtZW51IGZsb2F0cywgaS5lLiB3aGV0aGVyIGl0IHN0aWNrcyB0b1xuLy8gICAgIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0IHdoZW4gdGhlIGVkaXRvciBpcyBwYXJ0aWFsbHkgc2Nyb2xsZWRcbi8vICAgICBvdXQgb2Ygdmlldy5cbmZ1bmN0aW9uIG1lbnVCYXIob3B0aW9ucykge1xuICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgdmlldzogZnVuY3Rpb24gdmlldyhlZGl0b3JWaWV3KSB7IHJldHVybiBuZXcgTWVudUJhclZpZXcoZWRpdG9yVmlldywgb3B0aW9ucykgfVxuICB9KVxufVxuXG52YXIgTWVudUJhclZpZXcgPSBmdW5jdGlvbiBNZW51QmFyVmlldyhlZGl0b3JWaWV3LCBvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuZWRpdG9yVmlldyA9IGVkaXRvclZpZXc7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgdGhpcy53cmFwcGVyID0gY3JlbChcImRpdlwiLCB7Y2xhc3M6IHByZWZpeCQyICsgXCItd3JhcHBlclwifSk7XG4gIHRoaXMubWVudSA9IHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChjcmVsKFwiZGl2XCIsIHtjbGFzczogcHJlZml4JDJ9KSk7XG4gIHRoaXMubWVudS5jbGFzc05hbWUgPSBwcmVmaXgkMjtcbiAgdGhpcy5zcGFjZXIgPSBudWxsO1xuXG4gIGVkaXRvclZpZXcuZG9tLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRoaXMud3JhcHBlciwgZWRpdG9yVmlldy5kb20pO1xuICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQoZWRpdG9yVmlldy5kb20pO1xuXG4gIHRoaXMubWF4SGVpZ2h0ID0gMDtcbiAgdGhpcy53aWR0aEZvck1heEhlaWdodCA9IDA7XG4gIHRoaXMuZmxvYXRpbmcgPSBmYWxzZTtcblxuICB2YXIgcmVmID0gcmVuZGVyR3JvdXBlZCh0aGlzLmVkaXRvclZpZXcsIHRoaXMub3B0aW9ucy5jb250ZW50KTtcbiAgdmFyIGRvbSA9IHJlZi5kb207XG4gIHZhciB1cGRhdGUgPSByZWYudXBkYXRlO1xuICB0aGlzLmNvbnRlbnRVcGRhdGUgPSB1cGRhdGU7XG4gIHRoaXMubWVudS5hcHBlbmRDaGlsZChkb20pO1xuICB0aGlzLnVwZGF0ZSgpO1xuXG4gIGlmIChvcHRpb25zLmZsb2F0aW5nICYmICFpc0lPUygpKSB7XG4gICAgdGhpcy51cGRhdGVGbG9hdCgpO1xuICAgIHZhciBwb3RlbnRpYWxTY3JvbGxlcnMgPSBnZXRBbGxXcmFwcGluZyh0aGlzLndyYXBwZXIpO1xuICAgIHRoaXMuc2Nyb2xsRnVuYyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgcm9vdCA9IHRoaXMkMS5lZGl0b3JWaWV3LnJvb3Q7XG4gICAgICBpZiAoIShyb290LmJvZHkgfHwgcm9vdCkuY29udGFpbnModGhpcyQxLndyYXBwZXIpKSB7XG4gICAgICAgICAgcG90ZW50aWFsU2Nyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMkMS5zY3JvbGxGdW5jKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMkMS51cGRhdGVGbG9hdChlLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZS50YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgcG90ZW50aWFsU2Nyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzJDEuc2Nyb2xsRnVuYyk7IH0pO1xuICB9XG59O1xuXG5NZW51QmFyVmlldy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgdGhpcy5jb250ZW50VXBkYXRlKHRoaXMuZWRpdG9yVmlldy5zdGF0ZSk7XG5cbiAgaWYgKHRoaXMuZmxvYXRpbmcpIHtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbEN1cnNvcigpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLm1lbnUub2Zmc2V0V2lkdGggIT0gdGhpcy53aWR0aEZvck1heEhlaWdodCkge1xuICAgICAgdGhpcy53aWR0aEZvck1heEhlaWdodCA9IHRoaXMubWVudS5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMubWF4SGVpZ2h0ID0gMDtcbiAgICB9XG4gICAgaWYgKHRoaXMubWVudS5vZmZzZXRIZWlnaHQgPiB0aGlzLm1heEhlaWdodCkge1xuICAgICAgdGhpcy5tYXhIZWlnaHQgPSB0aGlzLm1lbnUub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5tZW51LnN0eWxlLm1pbkhlaWdodCA9IHRoaXMubWF4SGVpZ2h0ICsgXCJweFwiO1xuICAgIH1cbiAgfVxufTtcblxuTWVudUJhclZpZXcucHJvdG90eXBlLnVwZGF0ZVNjcm9sbEN1cnNvciA9IGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbEN1cnNvciAoKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB0aGlzLmVkaXRvclZpZXcucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCFzZWxlY3Rpb24uZm9jdXNOb2RlKSB7IHJldHVybiB9XG4gIHZhciByZWN0cyA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApLmdldENsaWVudFJlY3RzKCk7XG4gIHZhciBzZWxSZWN0ID0gcmVjdHNbc2VsZWN0aW9uSXNJbnZlcnRlZChzZWxlY3Rpb24pID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xuICBpZiAoIXNlbFJlY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG1lbnVSZWN0ID0gdGhpcy5tZW51LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAoc2VsUmVjdC50b3AgPCBtZW51UmVjdC5ib3R0b20gJiYgc2VsUmVjdC5ib3R0b20gPiBtZW51UmVjdC50b3ApIHtcbiAgICB2YXIgc2Nyb2xsYWJsZSA9IGZpbmRXcmFwcGluZ1Njcm9sbGFibGUodGhpcy53cmFwcGVyKTtcbiAgICBpZiAoc2Nyb2xsYWJsZSkgeyBzY3JvbGxhYmxlLnNjcm9sbFRvcCAtPSAobWVudVJlY3QuYm90dG9tIC0gc2VsUmVjdC50b3ApOyB9XG4gIH1cbn07XG5cbk1lbnVCYXJWaWV3LnByb3RvdHlwZS51cGRhdGVGbG9hdCA9IGZ1bmN0aW9uIHVwZGF0ZUZsb2F0IChzY3JvbGxBbmNlc3Rvcikge1xuICB2YXIgcGFyZW50ID0gdGhpcy53cmFwcGVyLCBlZGl0b3JSZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgdG9wID0gc2Nyb2xsQW5jZXN0b3IgPyBNYXRoLm1heCgwLCBzY3JvbGxBbmNlc3Rvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIDogMDtcblxuICBpZiAodGhpcy5mbG9hdGluZykge1xuICAgIGlmIChlZGl0b3JSZWN0LnRvcCA+PSB0b3AgfHwgZWRpdG9yUmVjdC5ib3R0b20gPCB0aGlzLm1lbnUub2Zmc2V0SGVpZ2h0ICsgMTApIHtcbiAgICAgIHRoaXMuZmxvYXRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMubWVudS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMubWVudS5zdHlsZS5sZWZ0ID0gdGhpcy5tZW51LnN0eWxlLnRvcCA9IHRoaXMubWVudS5zdHlsZS53aWR0aCA9IFwiXCI7XG4gICAgICB0aGlzLm1lbnUuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICB0aGlzLnNwYWNlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc3BhY2VyKTtcbiAgICAgIHRoaXMuc3BhY2VyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJvcmRlciA9IChwYXJlbnQub2Zmc2V0V2lkdGggLSBwYXJlbnQuY2xpZW50V2lkdGgpIC8gMjtcbiAgICAgIHRoaXMubWVudS5zdHlsZS5sZWZ0ID0gKGVkaXRvclJlY3QubGVmdCArIGJvcmRlcikgKyBcInB4XCI7XG4gICAgICB0aGlzLm1lbnUuc3R5bGUuZGlzcGxheSA9IChlZGl0b3JSZWN0LnRvcCA+IHdpbmRvdy5pbm5lckhlaWdodCA/IFwibm9uZVwiIDogXCJcIik7XG4gICAgICBpZiAoc2Nyb2xsQW5jZXN0b3IpIHsgdGhpcy5tZW51LnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZWRpdG9yUmVjdC50b3AgPCB0b3AgJiYgZWRpdG9yUmVjdC5ib3R0b20gPj0gdGhpcy5tZW51Lm9mZnNldEhlaWdodCArIDEwKSB7XG4gICAgICB0aGlzLmZsb2F0aW5nID0gdHJ1ZTtcbiAgICAgIHZhciBtZW51UmVjdCA9IHRoaXMubWVudS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMubWVudS5zdHlsZS5sZWZ0ID0gbWVudVJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgIHRoaXMubWVudS5zdHlsZS53aWR0aCA9IG1lbnVSZWN0LndpZHRoICsgXCJweFwiO1xuICAgICAgaWYgKHNjcm9sbEFuY2VzdG9yKSB7IHRoaXMubWVudS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7IH1cbiAgICAgIHRoaXMubWVudS5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICAgIHRoaXMuc3BhY2VyID0gY3JlbChcImRpdlwiLCB7Y2xhc3M6IHByZWZpeCQyICsgXCItc3BhY2VyXCIsIHN0eWxlOiAoXCJoZWlnaHQ6IFwiICsgKG1lbnVSZWN0LmhlaWdodCkgKyBcInB4XCIpfSk7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuc3BhY2VyLCB0aGlzLm1lbnUpO1xuICAgIH1cbiAgfVxufTtcblxuTWVudUJhclZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgaWYgKHRoaXMud3JhcHBlci5wYXJlbnROb2RlKVxuICAgIHsgdGhpcy53cmFwcGVyLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRoaXMuZWRpdG9yVmlldy5kb20sIHRoaXMud3JhcHBlcik7IH1cbn07XG5cbi8vIE5vdCBwcmVjaXNlLCBidXQgY2xvc2UgZW5vdWdoXG5mdW5jdGlvbiBzZWxlY3Rpb25Jc0ludmVydGVkKHNlbGVjdGlvbikge1xuICBpZiAoc2VsZWN0aW9uLmFuY2hvck5vZGUgPT0gc2VsZWN0aW9uLmZvY3VzTm9kZSkgeyByZXR1cm4gc2VsZWN0aW9uLmFuY2hvck9mZnNldCA+IHNlbGVjdGlvbi5mb2N1c09mZnNldCB9XG4gIHJldHVybiBzZWxlY3Rpb24uYW5jaG9yTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihzZWxlY3Rpb24uZm9jdXNOb2RlKSA9PSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lOR1xufVxuXG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdTY3JvbGxhYmxlKG5vZGUpIHtcbiAgZm9yICh2YXIgY3VyID0gbm9kZS5wYXJlbnROb2RlOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKVxuICAgIHsgaWYgKGN1ci5zY3JvbGxIZWlnaHQgPiBjdXIuY2xpZW50SGVpZ2h0KSB7IHJldHVybiBjdXIgfSB9XG59XG5cbmZ1bmN0aW9uIGdldEFsbFdyYXBwaW5nKG5vZGUpIHtcbiAgICB2YXIgcmVzID0gW3dpbmRvd107XG4gICAgZm9yICh2YXIgY3VyID0gbm9kZS5wYXJlbnROb2RlOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKVxuICAgICAgICB7IHJlcy5wdXNoKGN1cik7IH1cbiAgICByZXR1cm4gcmVzXG59XG5cbmV4cG9ydCB7IERyb3Bkb3duLCBEcm9wZG93blN1Ym1lbnUsIE1lbnVJdGVtLCBibG9ja1R5cGVJdGVtLCBpY29ucywgam9pblVwSXRlbSwgbGlmdEl0ZW0sIG1lbnVCYXIsIHJlZG9JdGVtLCByZW5kZXJHcm91cGVkLCBzZWxlY3RQYXJlbnROb2RlSXRlbSwgdW5kb0l0ZW0sIHdyYXBJdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCBPcmRlcmVkTWFwIGZyb20gJ29yZGVyZWRtYXAnO1xuXG5mdW5jdGlvbiBmaW5kRGlmZlN0YXJ0KGEsIGIsIHBvcykge1xuICBmb3IgKHZhciBpID0gMDs7IGkrKykge1xuICAgIGlmIChpID09IGEuY2hpbGRDb3VudCB8fCBpID09IGIuY2hpbGRDb3VudClcbiAgICAgIHsgcmV0dXJuIGEuY2hpbGRDb3VudCA9PSBiLmNoaWxkQ291bnQgPyBudWxsIDogcG9zIH1cblxuICAgIHZhciBjaGlsZEEgPSBhLmNoaWxkKGkpLCBjaGlsZEIgPSBiLmNoaWxkKGkpO1xuICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7IHBvcyArPSBjaGlsZEEubm9kZVNpemU7IGNvbnRpbnVlIH1cblxuICAgIGlmICghY2hpbGRBLnNhbWVNYXJrdXAoY2hpbGRCKSkgeyByZXR1cm4gcG9zIH1cblxuICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgY2hpbGRBLnRleHRbal0gPT0gY2hpbGRCLnRleHRbal07IGorKylcbiAgICAgICAgeyBwb3MrKzsgfVxuICAgICAgcmV0dXJuIHBvc1xuICAgIH1cbiAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICB2YXIgaW5uZXIgPSBmaW5kRGlmZlN0YXJ0KGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zICsgMSk7XG4gICAgICBpZiAoaW5uZXIgIT0gbnVsbCkgeyByZXR1cm4gaW5uZXIgfVxuICAgIH1cbiAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmREaWZmRW5kKGEsIGIsIHBvc0EsIHBvc0IpIHtcbiAgZm9yICh2YXIgaUEgPSBhLmNoaWxkQ291bnQsIGlCID0gYi5jaGlsZENvdW50OzspIHtcbiAgICBpZiAoaUEgPT0gMCB8fCBpQiA9PSAwKVxuICAgICAgeyByZXR1cm4gaUEgPT0gaUIgPyBudWxsIDoge2E6IHBvc0EsIGI6IHBvc0J9IH1cblxuICAgIHZhciBjaGlsZEEgPSBhLmNoaWxkKC0taUEpLCBjaGlsZEIgPSBiLmNoaWxkKC0taUIpLCBzaXplID0gY2hpbGRBLm5vZGVTaXplO1xuICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICBwb3NBIC09IHNpemU7IHBvc0IgLT0gc2l6ZTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKSB7IHJldHVybiB7YTogcG9zQSwgYjogcG9zQn0gfVxuXG4gICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgIHZhciBzYW1lID0gMCwgbWluU2l6ZSA9IE1hdGgubWluKGNoaWxkQS50ZXh0Lmxlbmd0aCwgY2hpbGRCLnRleHQubGVuZ3RoKTtcbiAgICAgIHdoaWxlIChzYW1lIDwgbWluU2l6ZSAmJiBjaGlsZEEudGV4dFtjaGlsZEEudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0gPT0gY2hpbGRCLnRleHRbY2hpbGRCLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdKSB7XG4gICAgICAgIHNhbWUrKzsgcG9zQS0tOyBwb3NCLS07XG4gICAgICB9XG4gICAgICByZXR1cm4ge2E6IHBvc0EsIGI6IHBvc0J9XG4gICAgfVxuICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgIHZhciBpbm5lciA9IGZpbmREaWZmRW5kKGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zQSAtIDEsIHBvc0IgLSAxKTtcbiAgICAgIGlmIChpbm5lcikgeyByZXR1cm4gaW5uZXIgfVxuICAgIH1cbiAgICBwb3NBIC09IHNpemU7IHBvc0IgLT0gc2l6ZTtcbiAgfVxufVxuXG4vLyA6Oi0gQSBmcmFnbWVudCByZXByZXNlbnRzIGEgbm9kZSdzIGNvbGxlY3Rpb24gb2YgY2hpbGQgbm9kZXMuXG4vL1xuLy8gTGlrZSBub2RlcywgZnJhZ21lbnRzIGFyZSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlcywgYW5kIHlvdVxuLy8gc2hvdWxkIG5vdCBtdXRhdGUgdGhlbSBvciB0aGVpciBjb250ZW50LiBSYXRoZXIsIHlvdSBjcmVhdGUgbmV3XG4vLyBpbnN0YW5jZXMgd2hlbmV2ZXIgbmVlZGVkLiBUaGUgQVBJIHRyaWVzIHRvIG1ha2UgdGhpcyBlYXN5LlxudmFyIEZyYWdtZW50ID0gZnVuY3Rpb24gRnJhZ21lbnQoY29udGVudCwgc2l6ZSkge1xuICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAvLyA6OiBudW1iZXJcbiAgLy8gVGhlIHNpemUgb2YgdGhlIGZyYWdtZW50LCB3aGljaCBpcyB0aGUgdG90YWwgb2YgdGhlIHNpemUgb2YgaXRzXG4gIC8vIGNvbnRlbnQgbm9kZXMuXG4gIHRoaXMuc2l6ZSA9IHNpemUgfHwgMDtcbiAgaWYgKHNpemUgPT0gbnVsbCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgeyB0aGlzLnNpemUgKz0gY29udGVudFtpXS5ub2RlU2l6ZTsgfSB9XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBmaXJzdENoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGxhc3RDaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSxjaGlsZENvdW50OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlciwgKG5vZGU6IE5vZGUsIHN0YXJ0OiBudW1iZXIsIHBhcmVudDogTm9kZSwgaW5kZXg6IG51bWJlcikg4oaSID9ib29sLCA/bnVtYmVyKVxuLy8gSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIGJldHdlZW4gdGhlIGdpdmVuIHR3b1xuLy8gcG9zaXRpb25zIChyZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzIGZyYWdtZW50KS4gRG9lc24ndCBkZXNjZW5kXG4vLyBpbnRvIGEgbm9kZSB3aGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAuXG5GcmFnbWVudC5wcm90b3R5cGUubm9kZXNCZXR3ZWVuID0gZnVuY3Rpb24gbm9kZXNCZXR3ZWVuIChmcm9tLCB0bywgZiwgbm9kZVN0YXJ0LCBwYXJlbnQpIHtcbiAgICBpZiAoIG5vZGVTdGFydCA9PT0gdm9pZCAwICkgbm9kZVN0YXJ0ID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuY29udGVudFtpXSwgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgaWYgKGVuZCA+IGZyb20gJiYgZihjaGlsZCwgbm9kZVN0YXJ0ICsgcG9zLCBwYXJlbnQsIGkpICE9PSBmYWxzZSAmJiBjaGlsZC5jb250ZW50LnNpemUpIHtcbiAgICAgIHZhciBzdGFydCA9IHBvcyArIDE7XG4gICAgICBjaGlsZC5ub2Rlc0JldHdlZW4oTWF0aC5tYXgoMCwgZnJvbSAtIHN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gc3RhcnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGYsIG5vZGVTdGFydCArIHN0YXJ0KTtcbiAgICB9XG4gICAgcG9zID0gZW5kO1xuICB9XG59O1xuXG4vLyA6OiAoKG5vZGU6IE5vZGUsIHBvczogbnVtYmVyLCBwYXJlbnQ6IE5vZGUpIOKGkiA/Ym9vbClcbi8vIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBldmVyeSBkZXNjZW5kYW50IG5vZGUuIFRoZSBjYWxsYmFja1xuLy8gbWF5IHJldHVybiBgZmFsc2VgIHRvIHByZXZlbnQgdHJhdmVyc2FsIG9mIGEgZ2l2ZW4gbm9kZSdzIGNoaWxkcmVuLlxuRnJhZ21lbnQucHJvdG90eXBlLmRlc2NlbmRhbnRzID0gZnVuY3Rpb24gZGVzY2VuZGFudHMgKGYpIHtcbiAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5zaXplLCBmKTtcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlciwgP3N0cmluZywgP3N0cmluZyB8ID8obGVhZk5vZGU6IE5vZGUpIC0+IHN0cmluZykg4oaSIHN0cmluZ1xuLy8gRXh0cmFjdCB0aGUgdGV4dCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC4gU2VlIHRoZSBzYW1lIG1ldGhvZCBvblxuLy8gW2BOb2RlYF0oI21vZGVsLk5vZGUudGV4dEJldHdlZW4pLlxuRnJhZ21lbnQucHJvdG90eXBlLnRleHRCZXR3ZWVuID0gZnVuY3Rpb24gdGV4dEJldHdlZW4gKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgdmFyIHRleHQgPSBcIlwiLCBzZXBhcmF0ZWQgPSB0cnVlO1xuICB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUsIHBvcykge1xuICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgdGV4dCArPSBub2RlLnRleHQuc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpO1xuICAgICAgc2VwYXJhdGVkID0gIWJsb2NrU2VwYXJhdG9yO1xuICAgIH0gZWxzZSBpZiAobm9kZS5pc0xlYWYgJiYgbGVhZlRleHQpIHtcbiAgICAgIHRleHQgKz0gdHlwZW9mIGxlYWZUZXh0ID09PSAnZnVuY3Rpb24nID8gbGVhZlRleHQobm9kZSk6IGxlYWZUZXh0O1xuICAgICAgc2VwYXJhdGVkID0gIWJsb2NrU2VwYXJhdG9yO1xuICAgIH0gZWxzZSBpZiAoIXNlcGFyYXRlZCAmJiBub2RlLmlzQmxvY2spIHtcbiAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3I7XG4gICAgICBzZXBhcmF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwgMCk7XG4gIHJldHVybiB0ZXh0XG59O1xuXG4vLyA6OiAoRnJhZ21lbnQpIOKGkiBGcmFnbWVudFxuLy8gQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGNvbWJpbmVkIGNvbnRlbnQgb2YgdGhpc1xuLy8gZnJhZ21lbnQgYW5kIHRoZSBvdGhlci5cbkZyYWdtZW50LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKG90aGVyKSB7XG4gIGlmICghb3RoZXIuc2l6ZSkgeyByZXR1cm4gdGhpcyB9XG4gIGlmICghdGhpcy5zaXplKSB7IHJldHVybiBvdGhlciB9XG4gIHZhciBsYXN0ID0gdGhpcy5sYXN0Q2hpbGQsIGZpcnN0ID0gb3RoZXIuZmlyc3RDaGlsZCwgY29udGVudCA9IHRoaXMuY29udGVudC5zbGljZSgpLCBpID0gMDtcbiAgaWYgKGxhc3QuaXNUZXh0ICYmIGxhc3Quc2FtZU1hcmt1cChmaXJzdCkpIHtcbiAgICBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPSBsYXN0LndpdGhUZXh0KGxhc3QudGV4dCArIGZpcnN0LnRleHQpO1xuICAgIGkgPSAxO1xuICB9XG4gIGZvciAoOyBpIDwgb3RoZXIuY29udGVudC5sZW5ndGg7IGkrKykgeyBjb250ZW50LnB1c2gob3RoZXIuY29udGVudFtpXSk7IH1cbiAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50LCB0aGlzLnNpemUgKyBvdGhlci5zaXplKVxufTtcblxuLy8gOjogKG51bWJlciwgP251bWJlcikg4oaSIEZyYWdtZW50XG4vLyBDdXQgb3V0IHRoZSBzdWItZnJhZ21lbnQgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHBvc2l0aW9ucy5cbkZyYWdtZW50LnByb3RvdHlwZS5jdXQgPSBmdW5jdGlvbiBjdXQgKGZyb20sIHRvKSB7XG4gIGlmICh0byA9PSBudWxsKSB7IHRvID0gdGhpcy5zaXplOyB9XG4gIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5zaXplKSB7IHJldHVybiB0aGlzIH1cbiAgdmFyIHJlc3VsdCA9IFtdLCBzaXplID0gMDtcbiAgaWYgKHRvID4gZnJvbSkgeyBmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuY29udGVudFtpXSwgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgaWYgKGVuZCA+IGZyb20pIHtcbiAgICAgIGlmIChwb3MgPCBmcm9tIHx8IGVuZCA+IHRvKSB7XG4gICAgICAgIGlmIChjaGlsZC5pc1RleHQpXG4gICAgICAgICAgeyBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgTWF0aC5taW4oY2hpbGQudGV4dC5sZW5ndGgsIHRvIC0gcG9zKSk7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgY2hpbGQgPSBjaGlsZC5jdXQoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyAtIDEpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gcG9zIC0gMSkpOyB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICBzaXplICs9IGNoaWxkLm5vZGVTaXplO1xuICAgIH1cbiAgICBwb3MgPSBlbmQ7XG4gIH0gfVxuICByZXR1cm4gbmV3IEZyYWdtZW50KHJlc3VsdCwgc2l6ZSlcbn07XG5cbkZyYWdtZW50LnByb3RvdHlwZS5jdXRCeUluZGV4ID0gZnVuY3Rpb24gY3V0QnlJbmRleCAoZnJvbSwgdG8pIHtcbiAgaWYgKGZyb20gPT0gdG8pIHsgcmV0dXJuIEZyYWdtZW50LmVtcHR5IH1cbiAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuc2xpY2UoZnJvbSwgdG8pKVxufTtcblxuLy8gOjogKG51bWJlciwgTm9kZSkg4oaSIEZyYWdtZW50XG4vLyBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgaW4gd2hpY2ggdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4IGlzXG4vLyByZXBsYWNlZCBieSB0aGUgZ2l2ZW4gbm9kZS5cbkZyYWdtZW50LnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQgPSBmdW5jdGlvbiByZXBsYWNlQ2hpbGQgKGluZGV4LCBub2RlKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgaWYgKGN1cnJlbnQgPT0gbm9kZSkgeyByZXR1cm4gdGhpcyB9XG4gIHZhciBjb3B5ID0gdGhpcy5jb250ZW50LnNsaWNlKCk7XG4gIHZhciBzaXplID0gdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSAtIGN1cnJlbnQubm9kZVNpemU7XG4gIGNvcHlbaW5kZXhdID0gbm9kZTtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudChjb3B5LCBzaXplKVxufTtcblxuLy8gOiAoTm9kZSkg4oaSIEZyYWdtZW50XG4vLyBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgcHJlcGVuZGluZyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGlzXG4vLyBmcmFnbWVudC5cbkZyYWdtZW50LnByb3RvdHlwZS5hZGRUb1N0YXJ0ID0gZnVuY3Rpb24gYWRkVG9TdGFydCAobm9kZSkge1xuICByZXR1cm4gbmV3IEZyYWdtZW50KFtub2RlXS5jb25jYXQodGhpcy5jb250ZW50KSwgdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSlcbn07XG5cbi8vIDogKE5vZGUpIOKGkiBGcmFnbWVudFxuLy8gQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGJ5IGFwcGVuZGluZyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGlzXG4vLyBmcmFnbWVudC5cbkZyYWdtZW50LnByb3RvdHlwZS5hZGRUb0VuZCA9IGZ1bmN0aW9uIGFkZFRvRW5kIChub2RlKSB7XG4gIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LmNvbmNhdChub2RlKSwgdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSlcbn07XG5cbi8vIDo6IChGcmFnbWVudCkg4oaSIGJvb2xcbi8vIENvbXBhcmUgdGhpcyBmcmFnbWVudCB0byBhbm90aGVyIG9uZS5cbkZyYWdtZW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCAhPSBvdGhlci5jb250ZW50Lmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKylcbiAgICB7IGlmICghdGhpcy5jb250ZW50W2ldLmVxKG90aGVyLmNvbnRlbnRbaV0pKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIDo6ID9Ob2RlXG4vLyBUaGUgZmlyc3QgY2hpbGQgb2YgdGhlIGZyYWdtZW50LCBvciBgbnVsbGAgaWYgaXQgaXMgZW1wdHkuXG5wcm90b3R5cGVBY2Nlc3NvcnMuZmlyc3RDaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50WzBdIDogbnVsbCB9O1xuXG4vLyA6OiA/Tm9kZVxuLy8gVGhlIGxhc3QgY2hpbGQgb2YgdGhlIGZyYWdtZW50LCBvciBgbnVsbGAgaWYgaXQgaXMgZW1wdHkuXG5wcm90b3R5cGVBY2Nlc3NvcnMubGFzdENoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdIDogbnVsbCB9O1xuXG4vLyA6OiBudW1iZXJcbi8vIFRoZSBudW1iZXIgb2YgY2hpbGQgbm9kZXMgaW4gdGhpcyBmcmFnbWVudC5cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZENvdW50LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggfTtcblxuLy8gOjogKG51bWJlcikg4oaSIE5vZGVcbi8vIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlIGFuIGVycm9yIHdoZW4gdGhlXG4vLyBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG5GcmFnbWVudC5wcm90b3R5cGUuY2hpbGQgPSBmdW5jdGlvbiBjaGlsZCAoaW5kZXgpIHtcbiAgdmFyIGZvdW5kID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgaWYgKCFmb3VuZCkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IFwiICsgaW5kZXggKyBcIiBvdXQgb2YgcmFuZ2UgZm9yIFwiICsgdGhpcykgfVxuICByZXR1cm4gZm91bmRcbn07XG5cbi8vIDo6IChudW1iZXIpIOKGkiA/Tm9kZVxuLy8gR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgaXQgZXhpc3RzLlxuRnJhZ21lbnQucHJvdG90eXBlLm1heWJlQ2hpbGQgPSBmdW5jdGlvbiBtYXliZUNoaWxkIChpbmRleCkge1xuICByZXR1cm4gdGhpcy5jb250ZW50W2luZGV4XVxufTtcblxuLy8gOjogKChub2RlOiBOb2RlLCBvZmZzZXQ6IG51bWJlciwgaW5kZXg6IG51bWJlcikpXG4vLyBDYWxsIGBmYCBmb3IgZXZlcnkgY2hpbGQgbm9kZSwgcGFzc2luZyB0aGUgbm9kZSwgaXRzIG9mZnNldFxuLy8gaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuRnJhZ21lbnQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBwID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuY29udGVudFtpXTtcbiAgICBmKGNoaWxkLCBwLCBpKTtcbiAgICBwICs9IGNoaWxkLm5vZGVTaXplO1xuICB9XG59O1xuXG4vLyA6OiAoRnJhZ21lbnQpIOKGkiA/bnVtYmVyXG4vLyBGaW5kIHRoZSBmaXJzdCBwb3NpdGlvbiBhdCB3aGljaCB0aGlzIGZyYWdtZW50IGFuZCBhbm90aGVyXG4vLyBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZSB0aGUgc2FtZS5cbkZyYWdtZW50LnByb3RvdHlwZS5maW5kRGlmZlN0YXJ0ID0gZnVuY3Rpb24gZmluZERpZmZTdGFydCQxIChvdGhlciwgcG9zKSB7XG4gICAgaWYgKCBwb3MgPT09IHZvaWQgMCApIHBvcyA9IDA7XG5cbiAgcmV0dXJuIGZpbmREaWZmU3RhcnQodGhpcywgb3RoZXIsIHBvcylcbn07XG5cbi8vIDo6IChGcmFnbWVudCkg4oaSID97YTogbnVtYmVyLCBiOiBudW1iZXJ9XG4vLyBGaW5kIHRoZSBmaXJzdCBwb3NpdGlvbiwgc2VhcmNoaW5nIGZyb20gdGhlIGVuZCwgYXQgd2hpY2ggdGhpc1xuLy8gZnJhZ21lbnQgYW5kIHRoZSBnaXZlbiBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZSB0aGVcbi8vIHNhbWUuIFNpbmNlIHRoaXMgcG9zaXRpb24gd2lsbCBub3QgYmUgdGhlIHNhbWUgaW4gYm90aCBub2RlcywgYW5cbi8vIG9iamVjdCB3aXRoIHR3byBzZXBhcmF0ZSBwb3NpdGlvbnMgaXMgcmV0dXJuZWQuXG5GcmFnbWVudC5wcm90b3R5cGUuZmluZERpZmZFbmQgPSBmdW5jdGlvbiBmaW5kRGlmZkVuZCQxIChvdGhlciwgcG9zLCBvdGhlclBvcykge1xuICAgIGlmICggcG9zID09PSB2b2lkIDAgKSBwb3MgPSB0aGlzLnNpemU7XG4gICAgaWYgKCBvdGhlclBvcyA9PT0gdm9pZCAwICkgb3RoZXJQb3MgPSBvdGhlci5zaXplO1xuXG4gIHJldHVybiBmaW5kRGlmZkVuZCh0aGlzLCBvdGhlciwgcG9zLCBvdGhlclBvcylcbn07XG5cbi8vIDogKG51bWJlciwgP251bWJlcikg4oaSIHtpbmRleDogbnVtYmVyLCBvZmZzZXQ6IG51bWJlcn1cbi8vIEZpbmQgdGhlIGluZGV4IGFuZCBpbm5lciBvZmZzZXQgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIHJlbGF0aXZlXG4vLyBwb3NpdGlvbiBpbiB0aGlzIGZyYWdtZW50LiBUaGUgcmVzdWx0IG9iamVjdCB3aWxsIGJlIHJldXNlZFxuLy8gKG92ZXJ3cml0dGVuKSB0aGUgbmV4dCB0aW1lIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQuIChOb3QgcHVibGljLilcbkZyYWdtZW50LnByb3RvdHlwZS5maW5kSW5kZXggPSBmdW5jdGlvbiBmaW5kSW5kZXggKHBvcywgcm91bmQpIHtcbiAgICBpZiAoIHJvdW5kID09PSB2b2lkIDAgKSByb3VuZCA9IC0xO1xuXG4gIGlmIChwb3MgPT0gMCkgeyByZXR1cm4gcmV0SW5kZXgoMCwgcG9zKSB9XG4gIGlmIChwb3MgPT0gdGhpcy5zaXplKSB7IHJldHVybiByZXRJbmRleCh0aGlzLmNvbnRlbnQubGVuZ3RoLCBwb3MpIH1cbiAgaWYgKHBvcyA+IHRoaXMuc2l6ZSB8fCBwb3MgPCAwKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKChcIlBvc2l0aW9uIFwiICsgcG9zICsgXCIgb3V0c2lkZSBvZiBmcmFnbWVudCAoXCIgKyAodGhpcykgKyBcIilcIikpIH1cbiAgZm9yICh2YXIgaSA9IDAsIGN1clBvcyA9IDA7OyBpKyspIHtcbiAgICB2YXIgY3VyID0gdGhpcy5jaGlsZChpKSwgZW5kID0gY3VyUG9zICsgY3VyLm5vZGVTaXplO1xuICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICBpZiAoZW5kID09IHBvcyB8fCByb3VuZCA+IDApIHsgcmV0dXJuIHJldEluZGV4KGkgKyAxLCBlbmQpIH1cbiAgICAgIHJldHVybiByZXRJbmRleChpLCBjdXJQb3MpXG4gICAgfVxuICAgIGN1clBvcyA9IGVuZDtcbiAgfVxufTtcblxuLy8gOjogKCkg4oaSIHN0cmluZ1xuLy8gUmV0dXJuIGEgZGVidWdnaW5nIHN0cmluZyB0aGF0IGRlc2NyaWJlcyB0aGlzIGZyYWdtZW50LlxuRnJhZ21lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkgeyByZXR1cm4gXCI8XCIgKyB0aGlzLnRvU3RyaW5nSW5uZXIoKSArIFwiPlwiIH07XG5cbkZyYWdtZW50LnByb3RvdHlwZS50b1N0cmluZ0lubmVyID0gZnVuY3Rpb24gdG9TdHJpbmdJbm5lciAoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuam9pbihcIiwgXCIpIH07XG5cbi8vIDo6ICgpIOKGkiA/T2JqZWN0XG4vLyBDcmVhdGUgYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmcmFnbWVudC5cbkZyYWdtZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudC5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udG9KU09OKCk7IH0pIDogbnVsbFxufTtcblxuLy8gOjogKFNjaGVtYSwgP09iamVjdCkg4oaSIEZyYWdtZW50XG4vLyBEZXNlcmlhbGl6ZSBhIGZyYWdtZW50IGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG5GcmFnbWVudC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OIChzY2hlbWEsIHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHsgcmV0dXJuIEZyYWdtZW50LmVtcHR5IH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEZyYWdtZW50LmZyb21KU09OXCIpIH1cbiAgcmV0dXJuIG5ldyBGcmFnbWVudCh2YWx1ZS5tYXAoc2NoZW1hLm5vZGVGcm9tSlNPTikpXG59O1xuXG4vLyA6OiAoW05vZGVdKSDihpIgRnJhZ21lbnRcbi8vIEJ1aWxkIGEgZnJhZ21lbnQgZnJvbSBhbiBhcnJheSBvZiBub2Rlcy4gRW5zdXJlcyB0aGF0IGFkamFjZW50XG4vLyB0ZXh0IG5vZGVzIHdpdGggdGhlIHNhbWUgbWFya3MgYXJlIGpvaW5lZCB0b2dldGhlci5cbkZyYWdtZW50LmZyb21BcnJheSA9IGZ1bmN0aW9uIGZyb21BcnJheSAoYXJyYXkpIHtcbiAgaWYgKCFhcnJheS5sZW5ndGgpIHsgcmV0dXJuIEZyYWdtZW50LmVtcHR5IH1cbiAgdmFyIGpvaW5lZCwgc2l6ZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGFycmF5W2ldO1xuICAgIHNpemUgKz0gbm9kZS5ub2RlU2l6ZTtcbiAgICBpZiAoaSAmJiBub2RlLmlzVGV4dCAmJiBhcnJheVtpIC0gMV0uc2FtZU1hcmt1cChub2RlKSkge1xuICAgICAgaWYgKCFqb2luZWQpIHsgam9pbmVkID0gYXJyYXkuc2xpY2UoMCwgaSk7IH1cbiAgICAgIGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0gPSBub2RlLndpdGhUZXh0KGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0udGV4dCArIG5vZGUudGV4dCk7XG4gICAgfSBlbHNlIGlmIChqb2luZWQpIHtcbiAgICAgIGpvaW5lZC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEZyYWdtZW50KGpvaW5lZCB8fCBhcnJheSwgc2l6ZSlcbn07XG5cbi8vIDo6ICg/dW5pb248RnJhZ21lbnQsIE5vZGUsIFtOb2RlXT4pIOKGkiBGcmFnbWVudFxuLy8gQ3JlYXRlIGEgZnJhZ21lbnQgZnJvbSBzb21ldGhpbmcgdGhhdCBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzZXRcbi8vIG9mIG5vZGVzLiBGb3IgYG51bGxgLCBpdCByZXR1cm5zIHRoZSBlbXB0eSBmcmFnbWVudC4gRm9yIGFcbi8vIGZyYWdtZW50LCB0aGUgZnJhZ21lbnQgaXRzZWxmLiBGb3IgYSBub2RlIG9yIGFycmF5IG9mIG5vZGVzLCBhXG4vLyBmcmFnbWVudCBjb250YWluaW5nIHRob3NlIG5vZGVzLlxuRnJhZ21lbnQuZnJvbSA9IGZ1bmN0aW9uIGZyb20gKG5vZGVzKSB7XG4gIGlmICghbm9kZXMpIHsgcmV0dXJuIEZyYWdtZW50LmVtcHR5IH1cbiAgaWYgKG5vZGVzIGluc3RhbmNlb2YgRnJhZ21lbnQpIHsgcmV0dXJuIG5vZGVzIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSB7IHJldHVybiB0aGlzLmZyb21BcnJheShub2RlcykgfVxuICBpZiAobm9kZXMuYXR0cnMpIHsgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZXNdLCBub2Rlcy5ub2RlU2l6ZSkgfVxuICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbiBub3QgY29udmVydCBcIiArIG5vZGVzICsgXCIgdG8gYSBGcmFnbWVudFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVzLm5vZGVzQmV0d2VlbiA/IFwiIChsb29rcyBsaWtlIG11bHRpcGxlIHZlcnNpb25zIG9mIHByb3NlbWlycm9yLW1vZGVsIHdlcmUgbG9hZGVkKVwiIDogXCJcIikpXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggRnJhZ21lbnQucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGZvdW5kID0ge2luZGV4OiAwLCBvZmZzZXQ6IDB9O1xuZnVuY3Rpb24gcmV0SW5kZXgoaW5kZXgsIG9mZnNldCkge1xuICBmb3VuZC5pbmRleCA9IGluZGV4O1xuICBmb3VuZC5vZmZzZXQgPSBvZmZzZXQ7XG4gIHJldHVybiBmb3VuZFxufVxuXG4vLyA6OiBGcmFnbWVudFxuLy8gQW4gZW1wdHkgZnJhZ21lbnQuIEludGVuZGVkIHRvIGJlIHJldXNlZCB3aGVuZXZlciBhIG5vZGUgZG9lc24ndFxuLy8gY29udGFpbiBhbnl0aGluZyAocmF0aGVyIHRoYW4gYWxsb2NhdGluZyBhIG5ldyBlbXB0eSBmcmFnbWVudCBmb3Jcbi8vIGVhY2ggbGVhZiBub2RlKS5cbkZyYWdtZW50LmVtcHR5ID0gbmV3IEZyYWdtZW50KFtdLCAwKTtcblxuZnVuY3Rpb24gY29tcGFyZURlZXAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmICghKGEgJiYgdHlwZW9mIGEgPT0gXCJvYmplY3RcIikgfHxcbiAgICAgICEoYiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgYXJyYXkgPSBBcnJheS5pc0FycmF5KGEpO1xuICBpZiAoQXJyYXkuaXNBcnJheShiKSAhPSBhcnJheSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoYXJyYXkpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHsgaWYgKCFjb21wYXJlRGVlcChhW2ldLCBiW2ldKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgcCBpbiBhKSB7IGlmICghKHAgaW4gYikgfHwgIWNvbXBhcmVEZWVwKGFbcF0sIGJbcF0pKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgICBmb3IgKHZhciBwJDEgaW4gYikgeyBpZiAoIShwJDEgaW4gYSkpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIDo6LSBBIG1hcmsgaXMgYSBwaWVjZSBvZiBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIG5vZGUsXG4vLyBzdWNoIGFzIGl0IGJlaW5nIGVtcGhhc2l6ZWQsIGluIGNvZGUgZm9udCwgb3IgYSBsaW5rLiBJdCBoYXMgYSB0eXBlXG4vLyBhbmQgb3B0aW9uYWxseSBhIHNldCBvZiBhdHRyaWJ1dGVzIHRoYXQgcHJvdmlkZSBmdXJ0aGVyIGluZm9ybWF0aW9uXG4vLyAoc3VjaCBhcyB0aGUgdGFyZ2V0IG9mIHRoZSBsaW5rKS4gTWFya3MgYXJlIGNyZWF0ZWQgdGhyb3VnaCBhXG4vLyBgU2NoZW1hYCwgd2hpY2ggY29udHJvbHMgd2hpY2ggdHlwZXMgZXhpc3QgYW5kIHdoaWNoXG4vLyBhdHRyaWJ1dGVzIHRoZXkgaGF2ZS5cbnZhciBNYXJrID0gZnVuY3Rpb24gTWFyayh0eXBlLCBhdHRycykge1xuICAvLyA6OiBNYXJrVHlwZVxuICAvLyBUaGUgdHlwZSBvZiB0aGlzIG1hcmsuXG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIC8vIDo6IE9iamVjdFxuICAvLyBUaGUgYXR0cmlidXRlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYXJrLlxuICB0aGlzLmF0dHJzID0gYXR0cnM7XG59O1xuXG4vLyA6OiAoW01hcmtdKSDihpIgW01hcmtdXG4vLyBHaXZlbiBhIHNldCBvZiBtYXJrcywgY3JlYXRlIGEgbmV3IHNldCB3aGljaCBjb250YWlucyB0aGlzIG9uZSBhc1xuLy8gd2VsbCwgaW4gdGhlIHJpZ2h0IHBvc2l0aW9uLiBJZiB0aGlzIG1hcmsgaXMgYWxyZWFkeSBpbiB0aGUgc2V0LFxuLy8gdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuIElmIGFueSBtYXJrcyB0aGF0IGFyZSBzZXQgdG8gYmVcbi8vIFtleGNsdXNpdmVdKCNtb2RlbC5NYXJrU3BlYy5leGNsdWRlcykgd2l0aCB0aGlzIG1hcmsgYXJlIHByZXNlbnQsXG4vLyB0aG9zZSBhcmUgcmVwbGFjZWQgYnkgdGhpcyBvbmUuXG5NYXJrLnByb3RvdHlwZS5hZGRUb1NldCA9IGZ1bmN0aW9uIGFkZFRvU2V0IChzZXQpIHtcbiAgdmFyIGNvcHksIHBsYWNlZCA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvdGhlciA9IHNldFtpXTtcbiAgICBpZiAodGhpcy5lcShvdGhlcikpIHsgcmV0dXJuIHNldCB9XG4gICAgaWYgKHRoaXMudHlwZS5leGNsdWRlcyhvdGhlci50eXBlKSkge1xuICAgICAgaWYgKCFjb3B5KSB7IGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7IH1cbiAgICB9IGVsc2UgaWYgKG90aGVyLnR5cGUuZXhjbHVkZXModGhpcy50eXBlKSkge1xuICAgICAgcmV0dXJuIHNldFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXBsYWNlZCAmJiBvdGhlci50eXBlLnJhbmsgPiB0aGlzLnR5cGUucmFuaykge1xuICAgICAgICBpZiAoIWNvcHkpIHsgY29weSA9IHNldC5zbGljZSgwLCBpKTsgfVxuICAgICAgICBjb3B5LnB1c2godGhpcyk7XG4gICAgICAgIHBsYWNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY29weSkgeyBjb3B5LnB1c2gob3RoZXIpOyB9XG4gICAgfVxuICB9XG4gIGlmICghY29weSkgeyBjb3B5ID0gc2V0LnNsaWNlKCk7IH1cbiAgaWYgKCFwbGFjZWQpIHsgY29weS5wdXNoKHRoaXMpOyB9XG4gIHJldHVybiBjb3B5XG59O1xuXG4vLyA6OiAoW01hcmtdKSDihpIgW01hcmtdXG4vLyBSZW1vdmUgdGhpcyBtYXJrIGZyb20gdGhlIGdpdmVuIHNldCwgcmV0dXJuaW5nIGEgbmV3IHNldC4gSWYgdGhpc1xuLy8gbWFyayBpcyBub3QgaW4gdGhlIHNldCwgdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuXG5NYXJrLnByb3RvdHlwZS5yZW1vdmVGcm9tU2V0ID0gZnVuY3Rpb24gcmVtb3ZlRnJvbVNldCAoc2V0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgIHsgaWYgKHRoaXMuZXEoc2V0W2ldKSlcbiAgICAgIHsgcmV0dXJuIHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSkgfSB9XG4gIHJldHVybiBzZXRcbn07XG5cbi8vIDo6IChbTWFya10pIOKGkiBib29sXG4vLyBUZXN0IHdoZXRoZXIgdGhpcyBtYXJrIGlzIGluIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MuXG5NYXJrLnByb3RvdHlwZS5pc0luU2V0ID0gZnVuY3Rpb24gaXNJblNldCAoc2V0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgIHsgaWYgKHRoaXMuZXEoc2V0W2ldKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyA6OiAoTWFyaykg4oaSIGJvb2xcbi8vIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaGFzIHRoZSBzYW1lIHR5cGUgYW5kIGF0dHJpYnV0ZXMgYXNcbi8vIGFub3RoZXIgbWFyay5cbk1hcmsucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyKSB7XG4gIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgKHRoaXMudHlwZSA9PSBvdGhlci50eXBlICYmIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSlcbn07XG5cbi8vIDo6ICgpIOKGkiBPYmplY3Rcbi8vIENvbnZlcnQgdGhpcyBtYXJrIHRvIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uLlxuTWFyay5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgdmFyIG9iaiA9IHt0eXBlOiB0aGlzLnR5cGUubmFtZX07XG4gIGZvciAodmFyIF8gaW4gdGhpcy5hdHRycykge1xuICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgYnJlYWtcbiAgfVxuICByZXR1cm4gb2JqXG59O1xuXG4vLyA6OiAoU2NoZW1hLCBPYmplY3QpIOKGkiBNYXJrXG5NYXJrLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04gKHNjaGVtYSwganNvbikge1xuICBpZiAoIWpzb24pIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBNYXJrLmZyb21KU09OXCIpIH1cbiAgdmFyIHR5cGUgPSBzY2hlbWEubWFya3NbanNvbi50eXBlXTtcbiAgaWYgKCF0eXBlKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKChcIlRoZXJlIGlzIG5vIG1hcmsgdHlwZSBcIiArIChqc29uLnR5cGUpICsgXCIgaW4gdGhpcyBzY2hlbWFcIikpIH1cbiAgcmV0dXJuIHR5cGUuY3JlYXRlKGpzb24uYXR0cnMpXG59O1xuXG4vLyA6OiAoW01hcmtdLCBbTWFya10pIOKGkiBib29sXG4vLyBUZXN0IHdoZXRoZXIgdHdvIHNldHMgb2YgbWFya3MgYXJlIGlkZW50aWNhbC5cbk1hcmsuc2FtZVNldCA9IGZ1bmN0aW9uIHNhbWVTZXQgKGEsIGIpIHtcbiAgaWYgKGEgPT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgeyBpZiAoIWFbaV0uZXEoYltpXSkpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gOjogKD91bmlvbjxNYXJrLCBbTWFya10+KSDihpIgW01hcmtdXG4vLyBDcmVhdGUgYSBwcm9wZXJseSBzb3J0ZWQgbWFyayBzZXQgZnJvbSBudWxsLCBhIHNpbmdsZSBtYXJrLCBvciBhblxuLy8gdW5zb3J0ZWQgYXJyYXkgb2YgbWFya3MuXG5NYXJrLnNldEZyb20gPSBmdW5jdGlvbiBzZXRGcm9tIChtYXJrcykge1xuICBpZiAoIW1hcmtzIHx8IG1hcmtzLmxlbmd0aCA9PSAwKSB7IHJldHVybiBNYXJrLm5vbmUgfVxuICBpZiAobWFya3MgaW5zdGFuY2VvZiBNYXJrKSB7IHJldHVybiBbbWFya3NdIH1cbiAgdmFyIGNvcHkgPSBtYXJrcy5zbGljZSgpO1xuICBjb3B5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEudHlwZS5yYW5rIC0gYi50eXBlLnJhbms7IH0pO1xuICByZXR1cm4gY29weVxufTtcblxuLy8gOjogW01hcmtdIFRoZSBlbXB0eSBzZXQgb2YgbWFya3MuXG5NYXJrLm5vbmUgPSBbXTtcblxuLy8gUmVwbGFjZUVycm9yOjogY2xhc3MgZXh0ZW5kcyBFcnJvclxuLy8gRXJyb3IgdHlwZSByYWlzZWQgYnkgW2BOb2RlLnJlcGxhY2VgXSgjbW9kZWwuTm9kZS5yZXBsYWNlKSB3aGVuXG4vLyBnaXZlbiBhbiBpbnZhbGlkIHJlcGxhY2VtZW50LlxuXG5mdW5jdGlvbiBSZXBsYWNlRXJyb3IobWVzc2FnZSkge1xuICB2YXIgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgZXJyLl9fcHJvdG9fXyA9IFJlcGxhY2VFcnJvci5wcm90b3R5cGU7XG4gIHJldHVybiBlcnJcbn1cblxuUmVwbGFjZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblJlcGxhY2VFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXBsYWNlRXJyb3I7XG5SZXBsYWNlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlJlcGxhY2VFcnJvclwiO1xuXG4vLyA6Oi0gQSBzbGljZSByZXByZXNlbnRzIGEgcGllY2UgY3V0IG91dCBvZiBhIGxhcmdlciBkb2N1bWVudC4gSXRcbi8vIHN0b3JlcyBub3Qgb25seSBhIGZyYWdtZW50LCBidXQgYWxzbyB0aGUgZGVwdGggdXAgdG8gd2hpY2ggbm9kZXMgb25cbi8vIGJvdGggc2lkZSBhcmUg4oCYb3BlbuKAmSAoY3V0IHRocm91Z2gpLlxudmFyIFNsaWNlID0gZnVuY3Rpb24gU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gIC8vIDo6IEZyYWdtZW50IFRoZSBzbGljZSdzIGNvbnRlbnQuXG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIC8vIDo6IG51bWJlciBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgc3RhcnQuXG4gIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAvLyA6OiBudW1iZXIgVGhlIG9wZW4gZGVwdGggYXQgdGhlIGVuZC5cbiAgdGhpcy5vcGVuRW5kID0gb3BlbkVuZDtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgc2l6ZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyA6OiBudW1iZXJcbi8vIFRoZSBzaXplIHRoaXMgc2xpY2Ugd291bGQgYWRkIHdoZW4gaW5zZXJ0ZWQgaW50byBhIGRvY3VtZW50LlxucHJvdG90eXBlQWNjZXNzb3JzJDEuc2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbnRlbnQuc2l6ZSAtIHRoaXMub3BlblN0YXJ0IC0gdGhpcy5vcGVuRW5kXG59O1xuXG5TbGljZS5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiBpbnNlcnRBdCAocG9zLCBmcmFnbWVudCkge1xuICB2YXIgY29udGVudCA9IGluc2VydEludG8odGhpcy5jb250ZW50LCBwb3MgKyB0aGlzLm9wZW5TdGFydCwgZnJhZ21lbnQsIG51bGwpO1xuICByZXR1cm4gY29udGVudCAmJiBuZXcgU2xpY2UoY29udGVudCwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZClcbn07XG5cblNsaWNlLnByb3RvdHlwZS5yZW1vdmVCZXR3ZWVuID0gZnVuY3Rpb24gcmVtb3ZlQmV0d2VlbiAoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIG5ldyBTbGljZShyZW1vdmVSYW5nZSh0aGlzLmNvbnRlbnQsIGZyb20gKyB0aGlzLm9wZW5TdGFydCwgdG8gKyB0aGlzLm9wZW5TdGFydCksIHRoaXMub3BlblN0YXJ0LCB0aGlzLm9wZW5FbmQpXG59O1xuXG4vLyA6OiAoU2xpY2UpIOKGkiBib29sXG4vLyBUZXN0cyB3aGV0aGVyIHRoaXMgc2xpY2UgaXMgZXF1YWwgdG8gYW5vdGhlciBzbGljZS5cblNsaWNlLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICByZXR1cm4gdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpICYmIHRoaXMub3BlblN0YXJ0ID09IG90aGVyLm9wZW5TdGFydCAmJiB0aGlzLm9wZW5FbmQgPT0gb3RoZXIub3BlbkVuZFxufTtcblxuU2xpY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gdGhpcy5jb250ZW50ICsgXCIoXCIgKyB0aGlzLm9wZW5TdGFydCArIFwiLFwiICsgdGhpcy5vcGVuRW5kICsgXCIpXCJcbn07XG5cbi8vIDo6ICgpIOKGkiA/T2JqZWN0XG4vLyBDb252ZXJ0IGEgc2xpY2UgdG8gYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbi5cblNsaWNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICBpZiAoIXRoaXMuY29udGVudC5zaXplKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGpzb24gPSB7Y29udGVudDogdGhpcy5jb250ZW50LnRvSlNPTigpfTtcbiAgaWYgKHRoaXMub3BlblN0YXJ0ID4gMCkgeyBqc29uLm9wZW5TdGFydCA9IHRoaXMub3BlblN0YXJ0OyB9XG4gIGlmICh0aGlzLm9wZW5FbmQgPiAwKSB7IGpzb24ub3BlbkVuZCA9IHRoaXMub3BlbkVuZDsgfVxuICByZXR1cm4ganNvblxufTtcblxuLy8gOjogKFNjaGVtYSwgP09iamVjdCkg4oaSIFNsaWNlXG4vLyBEZXNlcmlhbGl6ZSBhIHNsaWNlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG5TbGljZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OIChzY2hlbWEsIGpzb24pIHtcbiAgaWYgKCFqc29uKSB7IHJldHVybiBTbGljZS5lbXB0eSB9XG4gIHZhciBvcGVuU3RhcnQgPSBqc29uLm9wZW5TdGFydCB8fCAwLCBvcGVuRW5kID0ganNvbi5vcGVuRW5kIHx8IDA7XG4gIGlmICh0eXBlb2Ygb3BlblN0YXJ0ICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIG9wZW5FbmQgIT0gXCJudW1iZXJcIilcbiAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU2xpY2UuZnJvbUpTT05cIikgfVxuICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KSwgb3BlblN0YXJ0LCBvcGVuRW5kKVxufTtcblxuLy8gOjogKEZyYWdtZW50LCA/Ym9vbCkg4oaSIFNsaWNlXG4vLyBDcmVhdGUgYSBzbGljZSBmcm9tIGEgZnJhZ21lbnQgYnkgdGFraW5nIHRoZSBtYXhpbXVtIHBvc3NpYmxlXG4vLyBvcGVuIHZhbHVlIG9uIGJvdGggc2lkZSBvZiB0aGUgZnJhZ21lbnQuXG5TbGljZS5tYXhPcGVuID0gZnVuY3Rpb24gbWF4T3BlbiAoZnJhZ21lbnQsIG9wZW5Jc29sYXRpbmcpIHtcbiAgICBpZiAoIG9wZW5Jc29sYXRpbmcgPT09IHZvaWQgMCApIG9wZW5Jc29sYXRpbmc9dHJ1ZTtcblxuICB2YXIgb3BlblN0YXJ0ID0gMCwgb3BlbkVuZCA9IDA7XG4gIGZvciAodmFyIG4gPSBmcmFnbWVudC5maXJzdENoaWxkOyBuICYmICFuLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgbiA9IG4uZmlyc3RDaGlsZCkgeyBvcGVuU3RhcnQrKzsgfVxuICBmb3IgKHZhciBuJDEgPSBmcmFnbWVudC5sYXN0Q2hpbGQ7IG4kMSAmJiAhbiQxLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbiQxLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBuJDEgPSBuJDEubGFzdENoaWxkKSB7IG9wZW5FbmQrKzsgfVxuICByZXR1cm4gbmV3IFNsaWNlKGZyYWdtZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggU2xpY2UucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG5mdW5jdGlvbiByZW1vdmVSYW5nZShjb250ZW50LCBmcm9tLCB0bykge1xuICB2YXIgcmVmID0gY29udGVudC5maW5kSW5kZXgoZnJvbSk7XG4gIHZhciBpbmRleCA9IHJlZi5pbmRleDtcbiAgdmFyIG9mZnNldCA9IHJlZi5vZmZzZXQ7XG4gIHZhciBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gIHZhciByZWYkMSA9IGNvbnRlbnQuZmluZEluZGV4KHRvKTtcbiAgdmFyIGluZGV4VG8gPSByZWYkMS5pbmRleDtcbiAgdmFyIG9mZnNldFRvID0gcmVmJDEub2Zmc2V0O1xuICBpZiAob2Zmc2V0ID09IGZyb20gfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgaWYgKG9mZnNldFRvICE9IHRvICYmICFjb250ZW50LmNoaWxkKGluZGV4VG8pLmlzVGV4dCkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpIH1cbiAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZnJvbSkuYXBwZW5kKGNvbnRlbnQuY3V0KHRvKSlcbiAgfVxuICBpZiAoaW5kZXggIT0gaW5kZXhUbykgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpIH1cbiAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KHJlbW92ZVJhbmdlKGNoaWxkLmNvbnRlbnQsIGZyb20gLSBvZmZzZXQgLSAxLCB0byAtIG9mZnNldCAtIDEpKSlcbn1cblxuZnVuY3Rpb24gaW5zZXJ0SW50byhjb250ZW50LCBkaXN0LCBpbnNlcnQsIHBhcmVudCkge1xuICB2YXIgcmVmID0gY29udGVudC5maW5kSW5kZXgoZGlzdCk7XG4gIHZhciBpbmRleCA9IHJlZi5pbmRleDtcbiAgdmFyIG9mZnNldCA9IHJlZi5vZmZzZXQ7XG4gIHZhciBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gIGlmIChvZmZzZXQgPT0gZGlzdCB8fCBjaGlsZC5pc1RleHQpIHtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXgsIGluc2VydCkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHJldHVybiBjb250ZW50LmN1dCgwLCBkaXN0KS5hcHBlbmQoaW5zZXJ0KS5hcHBlbmQoY29udGVudC5jdXQoZGlzdCkpXG4gIH1cbiAgdmFyIGlubmVyID0gaW5zZXJ0SW50byhjaGlsZC5jb250ZW50LCBkaXN0IC0gb2Zmc2V0IC0gMSwgaW5zZXJ0KTtcbiAgcmV0dXJuIGlubmVyICYmIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KGlubmVyKSlcbn1cblxuLy8gOjogU2xpY2Vcbi8vIFRoZSBlbXB0eSBzbGljZS5cblNsaWNlLmVtcHR5ID0gbmV3IFNsaWNlKEZyYWdtZW50LmVtcHR5LCAwLCAwKTtcblxuZnVuY3Rpb24gcmVwbGFjZSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICBpZiAoc2xpY2Uub3BlblN0YXJ0ID4gJGZyb20uZGVwdGgpXG4gICAgeyB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW5zZXJ0ZWQgY29udGVudCBkZWVwZXIgdGhhbiBpbnNlcnRpb24gcG9zaXRpb25cIikgfVxuICBpZiAoJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQgIT0gJHRvLmRlcHRoIC0gc2xpY2Uub3BlbkVuZClcbiAgICB7IHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbmNvbnNpc3RlbnQgb3BlbiBkZXB0aHNcIikgfVxuICByZXR1cm4gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCAwKVxufVxuXG5mdW5jdGlvbiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoKSB7XG4gIHZhciBpbmRleCA9ICRmcm9tLmluZGV4KGRlcHRoKSwgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICBpZiAoaW5kZXggPT0gJHRvLmluZGV4KGRlcHRoKSAmJiBkZXB0aCA8ICRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgdmFyIGlubmVyID0gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCArIDEpO1xuICAgIHJldHVybiBub2RlLmNvcHkobm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgaW5uZXIpKVxuICB9IGVsc2UgaWYgKCFzbGljZS5jb250ZW50LnNpemUpIHtcbiAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkpXG4gIH0gZWxzZSBpZiAoIXNsaWNlLm9wZW5TdGFydCAmJiAhc2xpY2Uub3BlbkVuZCAmJiAkZnJvbS5kZXB0aCA9PSBkZXB0aCAmJiAkdG8uZGVwdGggPT0gZGVwdGgpIHsgLy8gU2ltcGxlLCBmbGF0IGNhc2VcbiAgICB2YXIgcGFyZW50ID0gJGZyb20ucGFyZW50LCBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgcmV0dXJuIGNsb3NlKHBhcmVudCwgY29udGVudC5jdXQoMCwgJGZyb20ucGFyZW50T2Zmc2V0KS5hcHBlbmQoc2xpY2UuY29udGVudCkuYXBwZW5kKGNvbnRlbnQuY3V0KCR0by5wYXJlbnRPZmZzZXQpKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVmID0gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGZyb20pO1xuICAgIHZhciBzdGFydCA9IHJlZi5zdGFydDtcbiAgICB2YXIgZW5kID0gcmVmLmVuZDtcbiAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCBzdGFydCwgZW5kLCAkdG8sIGRlcHRoKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0pvaW4obWFpbiwgc3ViKSB7XG4gIGlmICghc3ViLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobWFpbi50eXBlKSlcbiAgICB7IHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJDYW5ub3Qgam9pbiBcIiArIHN1Yi50eXBlLm5hbWUgKyBcIiBvbnRvIFwiICsgbWFpbi50eXBlLm5hbWUpIH1cbn1cblxuZnVuY3Rpb24gam9pbmFibGUoJGJlZm9yZSwgJGFmdGVyLCBkZXB0aCkge1xuICB2YXIgbm9kZSA9ICRiZWZvcmUubm9kZShkZXB0aCk7XG4gIGNoZWNrSm9pbihub2RlLCAkYWZ0ZXIubm9kZShkZXB0aCkpO1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiBhZGROb2RlKGNoaWxkLCB0YXJnZXQpIHtcbiAgdmFyIGxhc3QgPSB0YXJnZXQubGVuZ3RoIC0gMTtcbiAgaWYgKGxhc3QgPj0gMCAmJiBjaGlsZC5pc1RleHQgJiYgY2hpbGQuc2FtZU1hcmt1cCh0YXJnZXRbbGFzdF0pKVxuICAgIHsgdGFyZ2V0W2xhc3RdID0gY2hpbGQud2l0aFRleHQodGFyZ2V0W2xhc3RdLnRleHQgKyBjaGlsZC50ZXh0KTsgfVxuICBlbHNlXG4gICAgeyB0YXJnZXQucHVzaChjaGlsZCk7IH1cbn1cblxuZnVuY3Rpb24gYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgdGFyZ2V0KSB7XG4gIHZhciBub2RlID0gKCRlbmQgfHwgJHN0YXJ0KS5ub2RlKGRlcHRoKTtcbiAgdmFyIHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCA9ICRlbmQgPyAkZW5kLmluZGV4KGRlcHRoKSA6IG5vZGUuY2hpbGRDb3VudDtcbiAgaWYgKCRzdGFydCkge1xuICAgIHN0YXJ0SW5kZXggPSAkc3RhcnQuaW5kZXgoZGVwdGgpO1xuICAgIGlmICgkc3RhcnQuZGVwdGggPiBkZXB0aCkge1xuICAgICAgc3RhcnRJbmRleCsrO1xuICAgIH0gZWxzZSBpZiAoJHN0YXJ0LnRleHRPZmZzZXQpIHtcbiAgICAgIGFkZE5vZGUoJHN0YXJ0Lm5vZGVBZnRlciwgdGFyZ2V0KTtcbiAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7IGFkZE5vZGUobm9kZS5jaGlsZChpKSwgdGFyZ2V0KTsgfVxuICBpZiAoJGVuZCAmJiAkZW5kLmRlcHRoID09IGRlcHRoICYmICRlbmQudGV4dE9mZnNldClcbiAgICB7IGFkZE5vZGUoJGVuZC5ub2RlQmVmb3JlLCB0YXJnZXQpOyB9XG59XG5cbmZ1bmN0aW9uIGNsb3NlKG5vZGUsIGNvbnRlbnQpIHtcbiAgaWYgKCFub2RlLnR5cGUudmFsaWRDb250ZW50KGNvbnRlbnQpKVxuICAgIHsgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkludmFsaWQgY29udGVudCBmb3Igbm9kZSBcIiArIG5vZGUudHlwZS5uYW1lKSB9XG4gIHJldHVybiBub2RlLmNvcHkoY29udGVudClcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGgpIHtcbiAgdmFyIG9wZW5TdGFydCA9ICRmcm9tLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKTtcbiAgdmFyIG9wZW5FbmQgPSAkdG8uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZW5kLCAkdG8sIGRlcHRoICsgMSk7XG5cbiAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgaWYgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmICRzdGFydC5pbmRleChkZXB0aCkgPT0gJGVuZC5pbmRleChkZXB0aCkpIHtcbiAgICBjaGVja0pvaW4ob3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcGVuU3RhcnQpXG4gICAgICB7IGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSkpLCBjb250ZW50KTsgfVxuICAgIGFkZFJhbmdlKCRzdGFydCwgJGVuZCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmIChvcGVuRW5kKVxuICAgICAgeyBhZGROb2RlKGNsb3NlKG9wZW5FbmQsIHJlcGxhY2VUd29XYXkoJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7IH1cbiAgfVxuICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KVxufVxuXG5mdW5jdGlvbiByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSB7XG4gIHZhciBjb250ZW50ID0gW107XG4gIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG4gIGlmICgkZnJvbS5kZXB0aCA+IGRlcHRoKSB7XG4gICAgdmFyIHR5cGUgPSBqb2luYWJsZSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpO1xuICAgIGFkZE5vZGUoY2xvc2UodHlwZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gIH1cbiAgYWRkUmFuZ2UoJHRvLCBudWxsLCBkZXB0aCwgY29udGVudCk7XG4gIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudClcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGFsb25nKSB7XG4gIHZhciBleHRyYSA9ICRhbG9uZy5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCwgcGFyZW50ID0gJGFsb25nLm5vZGUoZXh0cmEpO1xuICB2YXIgbm9kZSA9IHBhcmVudC5jb3B5KHNsaWNlLmNvbnRlbnQpO1xuICBmb3IgKHZhciBpID0gZXh0cmEgLSAxOyBpID49IDA7IGktLSlcbiAgICB7IG5vZGUgPSAkYWxvbmcubm9kZShpKS5jb3B5KEZyYWdtZW50LmZyb20obm9kZSkpOyB9XG4gIHJldHVybiB7c3RhcnQ6IG5vZGUucmVzb2x2ZU5vQ2FjaGUoc2xpY2Uub3BlblN0YXJ0ICsgZXh0cmEpLFxuICAgICAgICAgIGVuZDogbm9kZS5yZXNvbHZlTm9DYWNoZShub2RlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQgLSBleHRyYSl9XG59XG5cbi8vIDo6LSBZb3UgY2FuIFtfcmVzb2x2ZV9dKCNtb2RlbC5Ob2RlLnJlc29sdmUpIGEgcG9zaXRpb24gdG8gZ2V0IG1vcmVcbi8vIGluZm9ybWF0aW9uIGFib3V0IGl0LiBPYmplY3RzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IHN1Y2ggYVxuLy8gcmVzb2x2ZWQgcG9zaXRpb24sIHByb3ZpZGluZyB2YXJpb3VzIHBpZWNlcyBvZiBjb250ZXh0IGluZm9ybWF0aW9uLFxuLy8gYW5kIHNvbWUgaGVscGVyIG1ldGhvZHMuXG4vL1xuLy8gVGhyb3VnaG91dCB0aGlzIGludGVyZmFjZSwgbWV0aG9kcyB0aGF0IHRha2UgYW4gb3B0aW9uYWwgYGRlcHRoYFxuLy8gcGFyYW1ldGVyIHdpbGwgaW50ZXJwcmV0IHVuZGVmaW5lZCBhcyBgdGhpcy5kZXB0aGAgYW5kIG5lZ2F0aXZlXG4vLyBudW1iZXJzIGFzIGB0aGlzLmRlcHRoICsgdmFsdWVgLlxudmFyIFJlc29sdmVkUG9zID0gZnVuY3Rpb24gUmVzb2x2ZWRQb3MocG9zLCBwYXRoLCBwYXJlbnRPZmZzZXQpIHtcbiAgLy8gOjogbnVtYmVyIFRoZSBwb3NpdGlvbiB0aGF0IHdhcyByZXNvbHZlZC5cbiAgdGhpcy5wb3MgPSBwb3M7XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgbnVtYmVyIG9mIGxldmVscyB0aGUgcGFyZW50IG5vZGUgaXMgZnJvbSB0aGUgcm9vdC4gSWYgdGhpc1xuICAvLyBwb3NpdGlvbiBwb2ludHMgZGlyZWN0bHkgaW50byB0aGUgcm9vdCBub2RlLCBpdCBpcyAwLiBJZiBpdFxuICAvLyBwb2ludHMgaW50byBhIHRvcC1sZXZlbCBwYXJhZ3JhcGgsIDEsIGFuZCBzbyBvbi5cbiAgdGhpcy5kZXB0aCA9IHBhdGgubGVuZ3RoIC8gMyAtIDE7XG4gIC8vIDo6IG51bWJlciBUaGUgb2Zmc2V0IHRoaXMgcG9zaXRpb24gaGFzIGludG8gaXRzIHBhcmVudCBub2RlLlxuICB0aGlzLnBhcmVudE9mZnNldCA9IHBhcmVudE9mZnNldDtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMiA9IHsgcGFyZW50OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGRvYzogeyBjb25maWd1cmFibGU6IHRydWUgfSx0ZXh0T2Zmc2V0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LG5vZGVBZnRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxub2RlQmVmb3JlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5yZXNvbHZlRGVwdGggPSBmdW5jdGlvbiByZXNvbHZlRGVwdGggKHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHsgcmV0dXJuIHRoaXMuZGVwdGggfVxuICBpZiAodmFsIDwgMCkgeyByZXR1cm4gdGhpcy5kZXB0aCArIHZhbCB9XG4gIHJldHVybiB2YWxcbn07XG5cbi8vIDo6IE5vZGVcbi8vIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSBwb3NpdGlvbiBwb2ludHMgaW50by4gTm90ZSB0aGF0IGV2ZW4gaWZcbi8vIGEgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIHRoYXQgbm9kZSBpcyBub3QgY29uc2lkZXJlZFxuLy8gdGhlIHBhcmVudOKAlHRleHQgbm9kZXMgYXJlIOKAmGZsYXTigJkgaW4gdGhpcyBtb2RlbCwgYW5kIGhhdmUgbm8gY29udGVudC5cbnByb3RvdHlwZUFjY2Vzc29ycyQyLnBhcmVudC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5vZGUodGhpcy5kZXB0aCkgfTtcblxuLy8gOjogTm9kZVxuLy8gVGhlIHJvb3Qgbm9kZSBpbiB3aGljaCB0aGUgcG9zaXRpb24gd2FzIHJlc29sdmVkLlxucHJvdG90eXBlQWNjZXNzb3JzJDIuZG9jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubm9kZSgwKSB9O1xuXG4vLyA6OiAoP251bWJlcikg4oaSIE5vZGVcbi8vIFRoZSBhbmNlc3RvciBub2RlIGF0IHRoZSBnaXZlbiBsZXZlbC4gYHAubm9kZShwLmRlcHRoKWAgaXMgdGhlXG4vLyBzYW1lIGFzIGBwLnBhcmVudGAuXG5SZXNvbHZlZFBvcy5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uIG5vZGUgKGRlcHRoKSB7IHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogM10gfTtcblxuLy8gOjogKD9udW1iZXIpIOKGkiBudW1iZXJcbi8vIFRoZSBpbmRleCBpbnRvIHRoZSBhbmNlc3RvciBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIElmIHRoaXMgcG9pbnRzIGF0XG4vLyB0aGUgM3JkIG5vZGUgaW4gdGhlIDJuZCBwYXJhZ3JhcGggb24gdGhlIHRvcCBsZXZlbCwgZm9yIGV4YW1wbGUsXG4vLyBgcC5pbmRleCgwKWAgaXMgMSBhbmQgYHAuaW5kZXgoMSlgIGlzIDIuXG5SZXNvbHZlZFBvcy5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbiBpbmRleCAoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzICsgMV0gfTtcblxuLy8gOjogKD9udW1iZXIpIOKGkiBudW1iZXJcbi8vIFRoZSBpbmRleCBwb2ludGluZyBhZnRlciB0aGlzIHBvc2l0aW9uIGludG8gdGhlIGFuY2VzdG9yIGF0IHRoZVxuLy8gZ2l2ZW4gbGV2ZWwuXG5SZXNvbHZlZFBvcy5wcm90b3R5cGUuaW5kZXhBZnRlciA9IGZ1bmN0aW9uIGluZGV4QWZ0ZXIgKGRlcHRoKSB7XG4gIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICByZXR1cm4gdGhpcy5pbmRleChkZXB0aCkgKyAoZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAhdGhpcy50ZXh0T2Zmc2V0ID8gMCA6IDEpXG59O1xuXG4vLyA6OiAoP251bWJlcikg4oaSIG51bWJlclxuLy8gVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlblxuLy8gbGV2ZWwuXG5SZXNvbHZlZFBvcy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCAoZGVwdGgpIHtcbiAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gIHJldHVybiBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDFcbn07XG5cbi8vIDo6ICg/bnVtYmVyKSDihpIgbnVtYmVyXG4vLyBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlblxuLy8gbGV2ZWwuXG5SZXNvbHZlZFBvcy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kIChkZXB0aCkge1xuICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgcmV0dXJuIHRoaXMuc3RhcnQoZGVwdGgpICsgdGhpcy5ub2RlKGRlcHRoKS5jb250ZW50LnNpemVcbn07XG5cbi8vIDo6ICg/bnVtYmVyKSDihpIgbnVtYmVyXG4vLyBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBkaXJlY3RseSBiZWZvcmUgdGhlIHdyYXBwaW5nIG5vZGUgYXQgdGhlXG4vLyBnaXZlbiBsZXZlbCwgb3IsIHdoZW4gYGRlcHRoYCBpcyBgdGhpcy5kZXB0aCArIDFgLCB0aGUgb3JpZ2luYWxcbi8vIHBvc2l0aW9uLlxuUmVzb2x2ZWRQb3MucHJvdG90eXBlLmJlZm9yZSA9IGZ1bmN0aW9uIGJlZm9yZSAoZGVwdGgpIHtcbiAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gIGlmICghZGVwdGgpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBiZWZvcmUgdGhlIHRvcC1sZXZlbCBub2RlXCIpIH1cbiAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV1cbn07XG5cbi8vIDo6ICg/bnVtYmVyKSDihpIgbnVtYmVyXG4vLyBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciB0aGUgd3JhcHBpbmcgbm9kZSBhdCB0aGVcbi8vIGdpdmVuIGxldmVsLCBvciB0aGUgb3JpZ2luYWwgcG9zaXRpb24gd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAuXG5SZXNvbHZlZFBvcy5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiBhZnRlciAoZGVwdGgpIHtcbiAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gIGlmICghZGVwdGgpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBhZnRlciB0aGUgdG9wLWxldmVsIG5vZGVcIikgfVxuICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIHRoaXMucGF0aFtkZXB0aCAqIDNdLm5vZGVTaXplXG59O1xuXG4vLyA6OiBudW1iZXJcbi8vIFdoZW4gdGhpcyBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgdGhpcyByZXR1cm5zIHRoZVxuLy8gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9zaXRpb24gYW5kIHRoZSBzdGFydCBvZiB0aGUgdGV4dCBub2RlLlxuLy8gV2lsbCBiZSB6ZXJvIGZvciBwb3NpdGlvbnMgdGhhdCBwb2ludCBiZXR3ZWVuIG5vZGVzLlxucHJvdG90eXBlQWNjZXNzb3JzJDIudGV4dE9mZnNldC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV0gfTtcblxuLy8gOjogP05vZGVcbi8vIEdldCB0aGUgbm9kZSBkaXJlY3RseSBhZnRlciB0aGUgcG9zaXRpb24sIGlmIGFueS4gSWYgdGhlIHBvc2l0aW9uXG4vLyBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgb25seSB0aGUgcGFydCBvZiB0aGF0IG5vZGUgYWZ0ZXIgdGhlXG4vLyBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbnByb3RvdHlwZUFjY2Vzc29ycyQyLm5vZGVBZnRlci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCwgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSwgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaW5kZXgpO1xuICByZXR1cm4gZE9mZiA/IHBhcmVudC5jaGlsZChpbmRleCkuY3V0KGRPZmYpIDogY2hpbGRcbn07XG5cbi8vIDo6ID9Ob2RlXG4vLyBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYmVmb3JlIHRoZSBwb3NpdGlvbiwgaWYgYW55LiBJZiB0aGVcbi8vIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZVxuLy8gYmVmb3JlIHRoZSBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbnByb3RvdHlwZUFjY2Vzc29ycyQyLm5vZGVCZWZvcmUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICB2YXIgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTtcbiAgaWYgKGRPZmYpIHsgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkKGluZGV4KS5jdXQoMCwgZE9mZikgfVxuICByZXR1cm4gaW5kZXggPT0gMCA/IG51bGwgOiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCAtIDEpXG59O1xuXG4vLyA6OiAobnVtYmVyLCA/bnVtYmVyKSDihpIgbnVtYmVyXG4vLyBHZXQgdGhlIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgcGFyZW50IG5vZGUgYXQgdGhlXG4vLyBnaXZlbiBkZXB0aCAod2hpY2ggZGVmYXVsdHMgdG8gYHRoaXMuZGVwdGhgKS5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5wb3NBdEluZGV4ID0gZnVuY3Rpb24gcG9zQXRJbmRleCAoaW5kZXgsIGRlcHRoKSB7XG4gIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICB2YXIgbm9kZSA9IHRoaXMucGF0aFtkZXB0aCAqIDNdLCBwb3MgPSBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykgeyBwb3MgKz0gbm9kZS5jaGlsZChpKS5ub2RlU2l6ZTsgfVxuICByZXR1cm4gcG9zXG59O1xuXG4vLyA6OiAoKSDihpIgW01hcmtdXG4vLyBHZXQgdGhlIG1hcmtzIGF0IHRoaXMgcG9zaXRpb24sIGZhY3RvcmluZyBpbiB0aGUgc3Vycm91bmRpbmdcbi8vIG1hcmtzJyBbYGluY2x1c2l2ZWBdKCNtb2RlbC5NYXJrU3BlYy5pbmNsdXNpdmUpIHByb3BlcnR5LiBJZiB0aGVcbi8vIHBvc2l0aW9uIGlzIGF0IHRoZSBzdGFydCBvZiBhIG5vbi1lbXB0eSBub2RlLCB0aGUgbWFya3Mgb2YgdGhlXG4vLyBub2RlIGFmdGVyIGl0IChpZiBhbnkpIGFyZSByZXR1cm5lZC5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5tYXJrcyA9IGZ1bmN0aW9uIG1hcmtzICgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgoKTtcblxuICAvLyBJbiBhbiBlbXB0eSBwYXJlbnQsIHJldHVybiB0aGUgZW1wdHkgYXJyYXlcbiAgaWYgKHBhcmVudC5jb250ZW50LnNpemUgPT0gMCkgeyByZXR1cm4gTWFyay5ub25lIH1cblxuICAvLyBXaGVuIGluc2lkZSBhIHRleHQgbm9kZSwganVzdCByZXR1cm4gdGhlIHRleHQgbm9kZSdzIG1hcmtzXG4gIGlmICh0aGlzLnRleHRPZmZzZXQpIHsgcmV0dXJuIHBhcmVudC5jaGlsZChpbmRleCkubWFya3MgfVxuXG4gIHZhciBtYWluID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXggLSAxKSwgb3RoZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gIC8vIElmIHRoZSBgYWZ0ZXJgIGZsYWcgaXMgdHJ1ZSBvZiB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSwgbWFrZVxuICAvLyB0aGUgbm9kZSBhZnRlciB0aGlzIHBvc2l0aW9uIHRoZSBtYWluIHJlZmVyZW5jZS5cbiAgaWYgKCFtYWluKSB7IHZhciB0bXAgPSBtYWluOyBtYWluID0gb3RoZXI7IG90aGVyID0gdG1wOyB9XG5cbiAgLy8gVXNlIGFsbCBtYXJrcyBpbiB0aGUgbWFpbiBub2RlLCBleGNlcHQgdGhvc2UgdGhhdCBoYXZlXG4gIC8vIGBpbmNsdXNpdmVgIHNldCB0byBmYWxzZSBhbmQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBvdGhlciBub2RlLlxuICB2YXIgbWFya3MgPSBtYWluLm1hcmtzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgIHsgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghb3RoZXIgfHwgIW1hcmtzW2ldLmlzSW5TZXQob3RoZXIubWFya3MpKSlcbiAgICAgIHsgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpOyB9IH1cblxuICByZXR1cm4gbWFya3Ncbn07XG5cbi8vIDo6IChSZXNvbHZlZFBvcykg4oaSID9bTWFya11cbi8vIEdldCB0aGUgbWFya3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGlmIGFueSwgZXhjZXB0IHRob3NlXG4vLyB0aGF0IGFyZSBub24taW5jbHVzaXZlIGFuZCBub3QgcHJlc2VudCBhdCBwb3NpdGlvbiBgJGVuZGAuIFRoaXNcbi8vIGlzIG1vc3RseSB1c2VmdWwgZm9yIGdldHRpbmcgdGhlIHNldCBvZiBtYXJrcyB0byBwcmVzZXJ2ZSBhZnRlciBhXG4vLyBkZWxldGlvbi4gV2lsbCByZXR1cm4gYG51bGxgIGlmIHRoaXMgcG9zaXRpb24gaXMgYXQgdGhlIGVuZCBvZlxuLy8gaXRzIHBhcmVudCBub2RlIG9yIGl0cyBwYXJlbnQgbm9kZSBpc24ndCBhIHRleHRibG9jayAoaW4gd2hpY2hcbi8vIGNhc2Ugbm8gbWFya3Mgc2hvdWxkIGJlIHByZXNlcnZlZCkuXG5SZXNvbHZlZFBvcy5wcm90b3R5cGUubWFya3NBY3Jvc3MgPSBmdW5jdGlvbiBtYXJrc0Fjcm9zcyAoJGVuZCkge1xuICB2YXIgYWZ0ZXIgPSB0aGlzLnBhcmVudC5tYXliZUNoaWxkKHRoaXMuaW5kZXgoKSk7XG4gIGlmICghYWZ0ZXIgfHwgIWFmdGVyLmlzSW5saW5lKSB7IHJldHVybiBudWxsIH1cblxuICB2YXIgbWFya3MgPSBhZnRlci5tYXJrcywgbmV4dCA9ICRlbmQucGFyZW50Lm1heWJlQ2hpbGQoJGVuZC5pbmRleCgpKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICB7IGlmIChtYXJrc1tpXS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSAmJiAoIW5leHQgfHwgIW1hcmtzW2ldLmlzSW5TZXQobmV4dC5tYXJrcykpKVxuICAgICAgeyBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7IH0gfVxuICByZXR1cm4gbWFya3Ncbn07XG5cbi8vIDo6IChudW1iZXIpIOKGkiBudW1iZXJcbi8vIFRoZSBkZXB0aCB1cCB0byB3aGljaCB0aGlzIHBvc2l0aW9uIGFuZCB0aGUgZ2l2ZW4gKG5vbi1yZXNvbHZlZClcbi8vIHBvc2l0aW9uIHNoYXJlIHRoZSBzYW1lIHBhcmVudCBub2Rlcy5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5zaGFyZWREZXB0aCA9IGZ1bmN0aW9uIHNoYXJlZERlcHRoIChwb3MpIHtcbiAgZm9yICh2YXIgZGVwdGggPSB0aGlzLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoLS0pXG4gICAgeyBpZiAodGhpcy5zdGFydChkZXB0aCkgPD0gcG9zICYmIHRoaXMuZW5kKGRlcHRoKSA+PSBwb3MpIHsgcmV0dXJuIGRlcHRoIH0gfVxuICByZXR1cm4gMFxufTtcblxuLy8gOjogKD9SZXNvbHZlZFBvcywgPyhOb2RlKSDihpIgYm9vbCkg4oaSID9Ob2RlUmFuZ2Vcbi8vIFJldHVybnMgYSByYW5nZSBiYXNlZCBvbiB0aGUgcGxhY2Ugd2hlcmUgdGhpcyBwb3NpdGlvbiBhbmQgdGhlXG4vLyBnaXZlbiBwb3NpdGlvbiBkaXZlcmdlIGFyb3VuZCBibG9jayBjb250ZW50LiBJZiBib3RoIHBvaW50IGludG9cbi8vIHRoZSBzYW1lIHRleHRibG9jaywgZm9yIGV4YW1wbGUsIGEgcmFuZ2UgYXJvdW5kIHRoYXQgdGV4dGJsb2NrXG4vLyB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGV5IHBvaW50IGludG8gZGlmZmVyZW50IGJsb2NrcywgdGhlIHJhbmdlXG4vLyBhcm91bmQgdGhvc2UgYmxvY2tzIGluIHRoZWlyIHNoYXJlZCBhbmNlc3RvciBpcyByZXR1cm5lZC4gWW91IGNhblxuLy8gcGFzcyBpbiBhbiBvcHRpb25hbCBwcmVkaWNhdGUgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgcGFyZW50XG4vLyBub2RlIHRvIHNlZSBpZiBhIHJhbmdlIGludG8gdGhhdCBwYXJlbnQgaXMgYWNjZXB0YWJsZS5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5ibG9ja1JhbmdlID0gZnVuY3Rpb24gYmxvY2tSYW5nZSAob3RoZXIsIHByZWQpIHtcbiAgICBpZiAoIG90aGVyID09PSB2b2lkIDAgKSBvdGhlciA9IHRoaXM7XG5cbiAgaWYgKG90aGVyLnBvcyA8IHRoaXMucG9zKSB7IHJldHVybiBvdGhlci5ibG9ja1JhbmdlKHRoaXMpIH1cbiAgZm9yICh2YXIgZCA9IHRoaXMuZGVwdGggLSAodGhpcy5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB0aGlzLnBvcyA9PSBvdGhlci5wb3MgPyAxIDogMCk7IGQgPj0gMDsgZC0tKVxuICAgIHsgaWYgKG90aGVyLnBvcyA8PSB0aGlzLmVuZChkKSAmJiAoIXByZWQgfHwgcHJlZCh0aGlzLm5vZGUoZCkpKSlcbiAgICAgIHsgcmV0dXJuIG5ldyBOb2RlUmFuZ2UodGhpcywgb3RoZXIsIGQpIH0gfVxufTtcblxuLy8gOjogKFJlc29sdmVkUG9zKSDihpIgYm9vbFxuLy8gUXVlcnkgd2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gc2hhcmVzIHRoZSBzYW1lIHBhcmVudCBub2RlLlxuUmVzb2x2ZWRQb3MucHJvdG90eXBlLnNhbWVQYXJlbnQgPSBmdW5jdGlvbiBzYW1lUGFyZW50IChvdGhlcikge1xuICByZXR1cm4gdGhpcy5wb3MgLSB0aGlzLnBhcmVudE9mZnNldCA9PSBvdGhlci5wb3MgLSBvdGhlci5wYXJlbnRPZmZzZXRcbn07XG5cbi8vIDo6IChSZXNvbHZlZFBvcykg4oaSIFJlc29sdmVkUG9zXG4vLyBSZXR1cm4gdGhlIGdyZWF0ZXIgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuUmVzb2x2ZWRQb3MucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIG1heCAob3RoZXIpIHtcbiAgcmV0dXJuIG90aGVyLnBvcyA+IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzXG59O1xuXG4vLyA6OiAoUmVzb2x2ZWRQb3MpIOKGkiBSZXNvbHZlZFBvc1xuLy8gUmV0dXJuIHRoZSBzbWFsbGVyIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiBtaW4gKG90aGVyKSB7XG4gIHJldHVybiBvdGhlci5wb3MgPCB0aGlzLnBvcyA/IG90aGVyIDogdGhpc1xufTtcblxuUmVzb2x2ZWRQb3MucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdGhpcy5kZXB0aDsgaSsrKVxuICAgIHsgc3RyICs9IChzdHIgPyBcIi9cIiA6IFwiXCIpICsgdGhpcy5ub2RlKGkpLnR5cGUubmFtZSArIFwiX1wiICsgdGhpcy5pbmRleChpIC0gMSk7IH1cbiAgcmV0dXJuIHN0ciArIFwiOlwiICsgdGhpcy5wYXJlbnRPZmZzZXRcbn07XG5cblJlc29sdmVkUG9zLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChkb2MsIHBvcykge1xuICBpZiAoIShwb3MgPj0gMCAmJiBwb3MgPD0gZG9jLmNvbnRlbnQuc2l6ZSkpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQb3NpdGlvbiBcIiArIHBvcyArIFwiIG91dCBvZiByYW5nZVwiKSB9XG4gIHZhciBwYXRoID0gW107XG4gIHZhciBzdGFydCA9IDAsIHBhcmVudE9mZnNldCA9IHBvcztcbiAgZm9yICh2YXIgbm9kZSA9IGRvYzs7KSB7XG4gICAgdmFyIHJlZiA9IG5vZGUuY29udGVudC5maW5kSW5kZXgocGFyZW50T2Zmc2V0KTtcbiAgICAgIHZhciBpbmRleCA9IHJlZi5pbmRleDtcbiAgICAgIHZhciBvZmZzZXQgPSByZWYub2Zmc2V0O1xuICAgIHZhciByZW0gPSBwYXJlbnRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgcGF0aC5wdXNoKG5vZGUsIGluZGV4LCBzdGFydCArIG9mZnNldCk7XG4gICAgaWYgKCFyZW0pIHsgYnJlYWsgfVxuICAgIG5vZGUgPSBub2RlLmNoaWxkKGluZGV4KTtcbiAgICBpZiAobm9kZS5pc1RleHQpIHsgYnJlYWsgfVxuICAgIHBhcmVudE9mZnNldCA9IHJlbSAtIDE7XG4gICAgc3RhcnQgKz0gb2Zmc2V0ICsgMTtcbiAgfVxuICByZXR1cm4gbmV3IFJlc29sdmVkUG9zKHBvcywgcGF0aCwgcGFyZW50T2Zmc2V0KVxufTtcblxuUmVzb2x2ZWRQb3MucmVzb2x2ZUNhY2hlZCA9IGZ1bmN0aW9uIHJlc29sdmVDYWNoZWQgKGRvYywgcG9zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb2x2ZUNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNhY2hlZCA9IHJlc29sdmVDYWNoZVtpXTtcbiAgICBpZiAoY2FjaGVkLnBvcyA9PSBwb3MgJiYgY2FjaGVkLmRvYyA9PSBkb2MpIHsgcmV0dXJuIGNhY2hlZCB9XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVDYWNoZVtyZXNvbHZlQ2FjaGVQb3NdID0gUmVzb2x2ZWRQb3MucmVzb2x2ZShkb2MsIHBvcyk7XG4gIHJlc29sdmVDYWNoZVBvcyA9IChyZXNvbHZlQ2FjaGVQb3MgKyAxKSAlIHJlc29sdmVDYWNoZVNpemU7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBSZXNvbHZlZFBvcy5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQyICk7XG5cbnZhciByZXNvbHZlQ2FjaGUgPSBbXSwgcmVzb2x2ZUNhY2hlUG9zID0gMCwgcmVzb2x2ZUNhY2hlU2l6ZSA9IDEyO1xuXG4vLyA6Oi0gUmVwcmVzZW50cyBhIGZsYXQgcmFuZ2Ugb2YgY29udGVudCwgaS5lLiBvbmUgdGhhdCBzdGFydHMgYW5kXG4vLyBlbmRzIGluIHRoZSBzYW1lIG5vZGUuXG52YXIgTm9kZVJhbmdlID0gZnVuY3Rpb24gTm9kZVJhbmdlKCRmcm9tLCAkdG8sIGRlcHRoKSB7XG4gIC8vIDo6IFJlc29sdmVkUG9zIEEgcmVzb2x2ZWQgcG9zaXRpb24gYWxvbmcgdGhlIHN0YXJ0IG9mIHRoZVxuICAvLyBjb250ZW50LiBNYXkgaGF2ZSBhIGBkZXB0aGAgZ3JlYXRlciB0aGFuIHRoaXMgb2JqZWN0J3MgYGRlcHRoYFxuICAvLyBwcm9wZXJ0eSwgc2luY2UgdGhlc2UgYXJlIHRoZSBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVzZWQgdG9cbiAgLy8gY29tcHV0ZSB0aGUgcmFuZ2UsIG5vdCByZS1yZXNvbHZlZCBwb3NpdGlvbnMgZGlyZWN0bHkgYXQgaXRzXG4gIC8vIGJvdW5kYXJpZXMuXG4gIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgLy8gOjogUmVzb2x2ZWRQb3MgQSBwb3NpdGlvbiBhbG9uZyB0aGUgZW5kIG9mIHRoZSBjb250ZW50LiBTZWVcbiAgLy8gY2F2ZWF0IGZvciBbYCRmcm9tYF0oI21vZGVsLk5vZGVSYW5nZS4kZnJvbSkuXG4gIHRoaXMuJHRvID0gJHRvO1xuICAvLyA6OiBudW1iZXIgVGhlIGRlcHRoIG9mIHRoZSBub2RlIHRoYXQgdGhpcyByYW5nZSBwb2ludHMgaW50by5cbiAgdGhpcy5kZXB0aCA9IGRlcHRoO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxJDEgPSB7IHN0YXJ0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGVuZDogeyBjb25maWd1cmFibGU6IHRydWUgfSxwYXJlbnQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sc3RhcnRJbmRleDogeyBjb25maWd1cmFibGU6IHRydWUgfSxlbmRJbmRleDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyA6OiBudW1iZXIgVGhlIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMSQxLnN0YXJ0LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJGZyb20uYmVmb3JlKHRoaXMuZGVwdGggKyAxKSB9O1xuLy8gOjogbnVtYmVyIFRoZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSByYW5nZS5cbnByb3RvdHlwZUFjY2Vzc29ycyQxJDEuZW5kLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJHRvLmFmdGVyKHRoaXMuZGVwdGggKyAxKSB9O1xuXG4vLyA6OiBOb2RlIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSByYW5nZSBwb2ludHMgaW50by5cbnByb3RvdHlwZUFjY2Vzc29ycyQxJDEucGFyZW50LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJGZyb20ubm9kZSh0aGlzLmRlcHRoKSB9O1xuLy8gOjogbnVtYmVyIFRoZSBzdGFydCBpbmRleCBvZiB0aGUgcmFuZ2UgaW4gdGhlIHBhcmVudCBub2RlLlxucHJvdG90eXBlQWNjZXNzb3JzJDEkMS5zdGFydEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJGZyb20uaW5kZXgodGhpcy5kZXB0aCkgfTtcbi8vIDo6IG51bWJlciBUaGUgZW5kIGluZGV4IG9mIHRoZSByYW5nZSBpbiB0aGUgcGFyZW50IG5vZGUuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMSQxLmVuZEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJHRvLmluZGV4QWZ0ZXIodGhpcy5kZXB0aCkgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE5vZGVSYW5nZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxJDEgKTtcblxudmFyIGVtcHR5QXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vLyA6Oi0gVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgbm9kZSBpbiB0aGUgdHJlZSB0aGF0IG1ha2VzIHVwIGFcbi8vIFByb3NlTWlycm9yIGRvY3VtZW50LiBTbyBhIGRvY3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIGBOb2RlYCwgd2l0aFxuLy8gY2hpbGRyZW4gdGhhdCBhcmUgYWxzbyBpbnN0YW5jZXMgb2YgYE5vZGVgLlxuLy9cbi8vIE5vZGVzIGFyZSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlcy4gSW5zdGVhZCBvZiBjaGFuZ2luZyB0aGVtLCB5b3Vcbi8vIGNyZWF0ZSBuZXcgb25lcyB3aXRoIHRoZSBjb250ZW50IHlvdSB3YW50LiBPbGQgb25lcyBrZWVwIHBvaW50aW5nXG4vLyBhdCB0aGUgb2xkIGRvY3VtZW50IHNoYXBlLiBUaGlzIGlzIG1hZGUgY2hlYXBlciBieSBzaGFyaW5nXG4vLyBzdHJ1Y3R1cmUgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXcgZGF0YSBhcyBtdWNoIGFzIHBvc3NpYmxlLCB3aGljaCBhXG4vLyB0cmVlIHNoYXBlIGxpa2UgdGhpcyAod2l0aG91dCBiYWNrIHBvaW50ZXJzKSBtYWtlcyBlYXN5LlxuLy9cbi8vICoqRG8gbm90KiogZGlyZWN0bHkgbXV0YXRlIHRoZSBwcm9wZXJ0aWVzIG9mIGEgYE5vZGVgIG9iamVjdC4gU2VlXG4vLyBbdGhlIGd1aWRlXSgvZG9jcy9ndWlkZS8jZG9jKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbnZhciBOb2RlID0gZnVuY3Rpb24gTm9kZSh0eXBlLCBhdHRycywgY29udGVudCwgbWFya3MpIHtcbiAgLy8gOjogTm9kZVR5cGVcbiAgLy8gVGhlIHR5cGUgb2Ygbm9kZSB0aGF0IHRoaXMgaXMuXG4gIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgLy8gOjogT2JqZWN0XG4gIC8vIEFuIG9iamVjdCBtYXBwaW5nIGF0dHJpYnV0ZSBuYW1lcyB0byB2YWx1ZXMuIFRoZSBraW5kIG9mXG4gIC8vIGF0dHJpYnV0ZXMgYWxsb3dlZCBhbmQgcmVxdWlyZWQgYXJlXG4gIC8vIFtkZXRlcm1pbmVkXSgjbW9kZWwuTm9kZVNwZWMuYXR0cnMpIGJ5IHRoZSBub2RlIHR5cGUuXG4gIHRoaXMuYXR0cnMgPSBhdHRycztcblxuICAvLyA6OiBGcmFnbWVudFxuICAvLyBBIGNvbnRhaW5lciBob2xkaW5nIHRoZSBub2RlJ3MgY2hpbGRyZW4uXG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnQgfHwgRnJhZ21lbnQuZW1wdHk7XG5cbiAgLy8gOjogW01hcmtdXG4gIC8vIFRoZSBtYXJrcyAodGhpbmdzIGxpa2Ugd2hldGhlciBpdCBpcyBlbXBoYXNpemVkIG9yIHBhcnQgb2YgYVxuICAvLyBsaW5rKSBhcHBsaWVkIHRvIHRoaXMgbm9kZS5cbiAgdGhpcy5tYXJrcyA9IG1hcmtzIHx8IE1hcmsubm9uZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMyA9IHsgbm9kZVNpemU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sY2hpbGRDb3VudDogeyBjb25maWd1cmFibGU6IHRydWUgfSx0ZXh0Q29udGVudDogeyBjb25maWd1cmFibGU6IHRydWUgfSxmaXJzdENoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGxhc3RDaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSxpc0Jsb2NrOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlzVGV4dGJsb2NrOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlubGluZUNvbnRlbnQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saXNJbmxpbmU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saXNUZXh0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlzTGVhZjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpc0F0b206IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuLy8gdGV4dDo6ID9zdHJpbmdcbi8vIEZvciB0ZXh0IG5vZGVzLCB0aGlzIGNvbnRhaW5zIHRoZSBub2RlJ3MgdGV4dCBjb250ZW50LlxuXG4vLyA6OiBudW1iZXJcbi8vIFRoZSBzaXplIG9mIHRoaXMgbm9kZSwgYXMgZGVmaW5lZCBieSB0aGUgaW50ZWdlci1iYXNlZCBbaW5kZXhpbmdcbi8vIHNjaGVtZV0oL2RvY3MvZ3VpZGUvI2RvYy5pbmRleGluZykuIEZvciB0ZXh0IG5vZGVzLCB0aGlzIGlzIHRoZVxuLy8gYW1vdW50IG9mIGNoYXJhY3RlcnMuIEZvciBvdGhlciBsZWFmIG5vZGVzLCBpdCBpcyBvbmUuIEZvclxuLy8gbm9uLWxlYWYgbm9kZXMsIGl0IGlzIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IHBsdXMgdHdvICh0aGUgc3RhcnRcbi8vIGFuZCBlbmQgdG9rZW4pLlxucHJvdG90eXBlQWNjZXNzb3JzJDMubm9kZVNpemUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgPyAxIDogMiArIHRoaXMuY29udGVudC5zaXplIH07XG5cbi8vIDo6IG51bWJlclxuLy8gVGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IHRoZSBub2RlIGhhcy5cbnByb3RvdHlwZUFjY2Vzc29ycyQzLmNoaWxkQ291bnQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkQ291bnQgfTtcblxuLy8gOjogKG51bWJlcikg4oaSIE5vZGVcbi8vIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlcyBhbiBlcnJvciB3aGVuIHRoZVxuLy8gaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuTm9kZS5wcm90b3R5cGUuY2hpbGQgPSBmdW5jdGlvbiBjaGlsZCAoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZChpbmRleCkgfTtcblxuLy8gOjogKG51bWJlcikg4oaSID9Ob2RlXG4vLyBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBpdCBleGlzdHMuXG5Ob2RlLnByb3RvdHlwZS5tYXliZUNoaWxkID0gZnVuY3Rpb24gbWF5YmVDaGlsZCAoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KSB9O1xuXG4vLyA6OiAoKG5vZGU6IE5vZGUsIG9mZnNldDogbnVtYmVyLCBpbmRleDogbnVtYmVyKSlcbi8vIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4vLyBpbnRvIHRoaXMgcGFyZW50IG5vZGUsIGFuZCBpdHMgaW5kZXguXG5Ob2RlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaCAoZikgeyB0aGlzLmNvbnRlbnQuZm9yRWFjaChmKTsgfTtcblxuLy8gOjogKG51bWJlciwgbnVtYmVyLCAobm9kZTogTm9kZSwgcG9zOiBudW1iZXIsIHBhcmVudDogTm9kZSwgaW5kZXg6IG51bWJlcikg4oaSID9ib29sLCA/bnVtYmVyKVxuLy8gSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIHJlY3Vyc2l2ZWx5IGJldHdlZW5cbi8vIHRoZSBnaXZlbiB0d28gcG9zaXRpb25zIHRoYXQgYXJlIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHRoaXMgbm9kZSdzXG4vLyBjb250ZW50LiBUaGUgY2FsbGJhY2sgaXMgaW52b2tlZCB3aXRoIHRoZSBub2RlLCBpdHNcbi8vIHBhcmVudC1yZWxhdGl2ZSBwb3NpdGlvbiwgaXRzIHBhcmVudCBub2RlLCBhbmQgaXRzIGNoaWxkIGluZGV4LlxuLy8gV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBmYWxzZSBmb3IgYSBnaXZlbiBub2RlLCB0aGF0IG5vZGUnc1xuLy8gY2hpbGRyZW4gd2lsbCBub3QgYmUgcmVjdXJzZWQgb3Zlci4gVGhlIGxhc3QgcGFyYW1ldGVyIGNhbiBiZVxuLy8gdXNlZCB0byBzcGVjaWZ5IGEgc3RhcnRpbmcgcG9zaXRpb24gdG8gY291bnQgZnJvbS5cbk5vZGUucHJvdG90eXBlLm5vZGVzQmV0d2VlbiA9IGZ1bmN0aW9uIG5vZGVzQmV0d2VlbiAoZnJvbSwgdG8sIGYsIHN0YXJ0UG9zKSB7XG4gICAgaWYgKCBzdGFydFBvcyA9PT0gdm9pZCAwICkgc3RhcnRQb3MgPSAwO1xuXG4gIHRoaXMuY29udGVudC5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zLCB0aGlzKTtcbn07XG5cbi8vIDo6ICgobm9kZTogTm9kZSwgcG9zOiBudW1iZXIsIHBhcmVudDogTm9kZSkg4oaSID9ib29sKVxuLy8gQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gRG9lc24ndFxuLy8gZGVzY2VuZCBpbnRvIGEgbm9kZSB3aGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAuXG5Ob2RlLnByb3RvdHlwZS5kZXNjZW5kYW50cyA9IGZ1bmN0aW9uIGRlc2NlbmRhbnRzIChmKSB7XG4gIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBmKTtcbn07XG5cbi8vIDo6IHN0cmluZ1xuLy8gQ29uY2F0ZW5hdGVzIGFsbCB0aGUgdGV4dCBub2RlcyBmb3VuZCBpbiB0aGlzIGZyYWdtZW50IGFuZCBpdHNcbi8vIGNoaWxkcmVuLlxucHJvdG90eXBlQWNjZXNzb3JzJDMudGV4dENvbnRlbnQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50ZXh0QmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgXCJcIikgfTtcblxuLy8gOjogKG51bWJlciwgbnVtYmVyLCA/c3RyaW5nLCA/c3RyaW5nIHwgPyhsZWFmTm9kZTogTm9kZSkgLT4gc3RyaW5nKSDihpIgc3RyaW5nXG4vLyBHZXQgYWxsIHRleHQgYmV0d2VlbiBwb3NpdGlvbnMgYGZyb21gIGFuZCBgdG9gLiBXaGVuXG4vLyBgYmxvY2tTZXBhcmF0b3JgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIGluc2VydGVkIHdoZW5ldmVyIGEgbmV3XG4vLyBibG9jayBub2RlIGlzIHN0YXJ0ZWQuIFdoZW4gYGxlYWZUZXh0YCBpcyBnaXZlbiwgaXQnbGwgYmVcbi8vIGluc2VydGVkIGZvciBldmVyeSBub24tdGV4dCBsZWFmIG5vZGUgZW5jb3VudGVyZWQuXG5Ob2RlLnByb3RvdHlwZS50ZXh0QmV0d2VlbiA9IGZ1bmN0aW9uIHRleHRCZXR3ZWVuIChmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gIHJldHVybiB0aGlzLmNvbnRlbnQudGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dClcbn07XG5cbi8vIDo6ID9Ob2RlXG4vLyBSZXR1cm5zIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4vLyBjaGlsZHJlbi5cbnByb3RvdHlwZUFjY2Vzc29ycyQzLmZpcnN0Q2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmZpcnN0Q2hpbGQgfTtcblxuLy8gOjogP05vZGVcbi8vIFJldHVybnMgdGhpcyBub2RlJ3MgbGFzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuLy8gY2hpbGRyZW4uXG5wcm90b3R5cGVBY2Nlc3NvcnMkMy5sYXN0Q2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxhc3RDaGlsZCB9O1xuXG4vLyA6OiAoTm9kZSkg4oaSIGJvb2xcbi8vIFRlc3Qgd2hldGhlciB0d28gbm9kZXMgcmVwcmVzZW50IHRoZSBzYW1lIHBpZWNlIG9mIGRvY3VtZW50LlxuTm9kZS5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgKHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpKVxufTtcblxuLy8gOjogKE5vZGUpIOKGkiBib29sXG4vLyBDb21wYXJlIHRoZSBtYXJrdXAgKHR5cGUsIGF0dHJpYnV0ZXMsIGFuZCBtYXJrcykgb2YgdGhpcyBub2RlIHRvXG4vLyB0aG9zZSBvZiBhbm90aGVyLiBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGhhdmUgdGhlIHNhbWUgbWFya3VwLlxuTm9kZS5wcm90b3R5cGUuc2FtZU1hcmt1cCA9IGZ1bmN0aW9uIHNhbWVNYXJrdXAgKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmhhc01hcmt1cChvdGhlci50eXBlLCBvdGhlci5hdHRycywgb3RoZXIubWFya3MpXG59O1xuXG4vLyA6OiAoTm9kZVR5cGUsID9PYmplY3QsID9bTWFya10pIOKGkiBib29sXG4vLyBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSdzIG1hcmt1cCBjb3JyZXNwb25kIHRvIHRoZSBnaXZlbiB0eXBlLFxuLy8gYXR0cmlidXRlcywgYW5kIG1hcmtzLlxuTm9kZS5wcm90b3R5cGUuaGFzTWFya3VwID0gZnVuY3Rpb24gaGFzTWFya3VwICh0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlICYmXG4gICAgY29tcGFyZURlZXAodGhpcy5hdHRycywgYXR0cnMgfHwgdHlwZS5kZWZhdWx0QXR0cnMgfHwgZW1wdHlBdHRycykgJiZcbiAgICBNYXJrLnNhbWVTZXQodGhpcy5tYXJrcywgbWFya3MgfHwgTWFyay5ub25lKVxufTtcblxuLy8gOjogKD9GcmFnbWVudCkg4oaSIE5vZGVcbi8vIENyZWF0ZSBhIG5ldyBub2RlIHdpdGggdGhlIHNhbWUgbWFya3VwIGFzIHRoaXMgbm9kZSwgY29udGFpbmluZ1xuLy8gdGhlIGdpdmVuIGNvbnRlbnQgKG9yIGVtcHR5LCBpZiBubyBjb250ZW50IGlzIGdpdmVuKS5cbk5vZGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChjb250ZW50KSB7XG4gICAgaWYgKCBjb250ZW50ID09PSB2b2lkIDAgKSBjb250ZW50ID0gbnVsbDtcblxuICBpZiAoY29udGVudCA9PSB0aGlzLmNvbnRlbnQpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy50eXBlLCB0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKVxufTtcblxuLy8gOjogKFtNYXJrXSkg4oaSIE5vZGVcbi8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlLCB3aXRoIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgaW5zdGVhZFxuLy8gb2YgdGhlIG5vZGUncyBvd24gbWFya3MuXG5Ob2RlLnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24gbWFyayAobWFya3MpIHtcbiAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0aGlzLmNvbnRlbnQsIG1hcmtzKVxufTtcblxuLy8gOjogKG51bWJlciwgP251bWJlcikg4oaSIE5vZGVcbi8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlIHdpdGggb25seSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZVxuLy8gZ2l2ZW4gcG9zaXRpb25zLiBJZiBgdG9gIGlzIG5vdCBnaXZlbiwgaXQgZGVmYXVsdHMgdG8gdGhlIGVuZCBvZlxuLy8gdGhlIG5vZGUuXG5Ob2RlLnByb3RvdHlwZS5jdXQgPSBmdW5jdGlvbiBjdXQgKGZyb20sIHRvKSB7XG4gIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5jb250ZW50LnNpemUpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gdGhpcy5jb3B5KHRoaXMuY29udGVudC5jdXQoZnJvbSwgdG8pKVxufTtcblxuLy8gOjogKG51bWJlciwgP251bWJlcikg4oaSIFNsaWNlXG4vLyBDdXQgb3V0IHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMsIGFuZFxuLy8gcmV0dXJuIGl0IGFzIGEgYFNsaWNlYCBvYmplY3QuXG5Ob2RlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChmcm9tLCB0bywgaW5jbHVkZVBhcmVudHMpIHtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMuY29udGVudC5zaXplO1xuICAgIGlmICggaW5jbHVkZVBhcmVudHMgPT09IHZvaWQgMCApIGluY2x1ZGVQYXJlbnRzID0gZmFsc2U7XG5cbiAgaWYgKGZyb20gPT0gdG8pIHsgcmV0dXJuIFNsaWNlLmVtcHR5IH1cblxuICB2YXIgJGZyb20gPSB0aGlzLnJlc29sdmUoZnJvbSksICR0byA9IHRoaXMucmVzb2x2ZSh0byk7XG4gIHZhciBkZXB0aCA9IGluY2x1ZGVQYXJlbnRzID8gMCA6ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgdmFyIHN0YXJ0ID0gJGZyb20uc3RhcnQoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gIHZhciBjb250ZW50ID0gbm9kZS5jb250ZW50LmN1dCgkZnJvbS5wb3MgLSBzdGFydCwgJHRvLnBvcyAtIHN0YXJ0KTtcbiAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCAkZnJvbS5kZXB0aCAtIGRlcHRoLCAkdG8uZGVwdGggLSBkZXB0aClcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlciwgU2xpY2UpIOKGkiBOb2RlXG4vLyBSZXBsYWNlIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMgd2l0aFxuLy8gdGhlIGdpdmVuIHNsaWNlLiBUaGUgc2xpY2UgbXVzdCAnZml0JywgbWVhbmluZyBpdHMgb3BlbiBzaWRlc1xuLy8gbXVzdCBiZSBhYmxlIHRvIGNvbm5lY3QgdG8gdGhlIHN1cnJvdW5kaW5nIGNvbnRlbnQsIGFuZCBpdHNcbi8vIGNvbnRlbnQgbm9kZXMgbXVzdCBiZSB2YWxpZCBjaGlsZHJlbiBmb3IgdGhlIG5vZGUgdGhleSBhcmUgcGxhY2VkXG4vLyBpbnRvLiBJZiBhbnkgb2YgdGhpcyBpcyB2aW9sYXRlZCwgYW4gZXJyb3Igb2YgdHlwZVxuLy8gW2BSZXBsYWNlRXJyb3JgXSgjbW9kZWwuUmVwbGFjZUVycm9yKSBpcyB0aHJvd24uXG5Ob2RlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSQxIChmcm9tLCB0bywgc2xpY2UpIHtcbiAgcmV0dXJuIHJlcGxhY2UodGhpcy5yZXNvbHZlKGZyb20pLCB0aGlzLnJlc29sdmUodG8pLCBzbGljZSlcbn07XG5cbi8vIDo6IChudW1iZXIpIOKGkiA/Tm9kZVxuLy8gRmluZCB0aGUgbm9kZSBkaXJlY3RseSBhZnRlciB0aGUgZ2l2ZW4gcG9zaXRpb24uXG5Ob2RlLnByb3RvdHlwZS5ub2RlQXQgPSBmdW5jdGlvbiBub2RlQXQgKHBvcykge1xuICBmb3IgKHZhciBub2RlID0gdGhpczs7KSB7XG4gICAgdmFyIHJlZiA9IG5vZGUuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgIHZhciBpbmRleCA9IHJlZi5pbmRleDtcbiAgICAgIHZhciBvZmZzZXQgPSByZWYub2Zmc2V0O1xuICAgIG5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgIGlmICghbm9kZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKG9mZnNldCA9PSBwb3MgfHwgbm9kZS5pc1RleHQpIHsgcmV0dXJuIG5vZGUgfVxuICAgIHBvcyAtPSBvZmZzZXQgKyAxO1xuICB9XG59O1xuXG4vLyA6OiAobnVtYmVyKSDihpIge25vZGU6ID9Ob2RlLCBpbmRleDogbnVtYmVyLCBvZmZzZXQ6IG51bWJlcn1cbi8vIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuLy8gYW5kIHJldHVybiBpdCBhbG9uZyB3aXRoIGl0cyBpbmRleCBhbmQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoaXNcbi8vIG5vZGUuXG5Ob2RlLnByb3RvdHlwZS5jaGlsZEFmdGVyID0gZnVuY3Rpb24gY2hpbGRBZnRlciAocG9zKSB7XG4gIHZhciByZWYgPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgdmFyIGluZGV4ID0gcmVmLmluZGV4O1xuICAgIHZhciBvZmZzZXQgPSByZWYub2Zmc2V0O1xuICByZXR1cm4ge25vZGU6IHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KSwgaW5kZXg6IGluZGV4LCBvZmZzZXQ6IG9mZnNldH1cbn07XG5cbi8vIDo6IChudW1iZXIpIOKGkiB7bm9kZTogP05vZGUsIGluZGV4OiBudW1iZXIsIG9mZnNldDogbnVtYmVyfVxuLy8gRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBiZWZvcmUgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuLy8gYW5kIHJldHVybiBpdCBhbG9uZyB3aXRoIGl0cyBpbmRleCBhbmQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoaXNcbi8vIG5vZGUuXG5Ob2RlLnByb3RvdHlwZS5jaGlsZEJlZm9yZSA9IGZ1bmN0aW9uIGNoaWxkQmVmb3JlIChwb3MpIHtcbiAgaWYgKHBvcyA9PSAwKSB7IHJldHVybiB7bm9kZTogbnVsbCwgaW5kZXg6IDAsIG9mZnNldDogMH0gfVxuICB2YXIgcmVmID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgIHZhciBpbmRleCA9IHJlZi5pbmRleDtcbiAgICB2YXIgb2Zmc2V0ID0gcmVmLm9mZnNldDtcbiAgaWYgKG9mZnNldCA8IHBvcykgeyByZXR1cm4ge25vZGU6IHRoaXMuY29udGVudC5jaGlsZChpbmRleCksIGluZGV4OiBpbmRleCwgb2Zmc2V0OiBvZmZzZXR9IH1cbiAgdmFyIG5vZGUgPSB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgcmV0dXJuIHtub2RlOiBub2RlLCBpbmRleDogaW5kZXggLSAxLCBvZmZzZXQ6IG9mZnNldCAtIG5vZGUubm9kZVNpemV9XG59O1xuXG4vLyA6OiAobnVtYmVyKSDihpIgUmVzb2x2ZWRQb3Ncbi8vIFJlc29sdmUgdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCwgcmV0dXJuaW5nIGFuXG4vLyBbb2JqZWN0XSgjbW9kZWwuUmVzb2x2ZWRQb3MpIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgaXRzIGNvbnRleHQuXG5Ob2RlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlQ2FjaGVkKHRoaXMsIHBvcykgfTtcblxuTm9kZS5wcm90b3R5cGUucmVzb2x2ZU5vQ2FjaGUgPSBmdW5jdGlvbiByZXNvbHZlTm9DYWNoZSAocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlKHRoaXMsIHBvcykgfTtcblxuLy8gOjogKG51bWJlciwgbnVtYmVyLCB1bmlvbjxNYXJrLCBNYXJrVHlwZT4pIOKGkiBib29sXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBtYXJrIG9yIG1hcmsgdHlwZSBvY2N1cnMgaW4gdGhpcyBkb2N1bWVudFxuLy8gYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHBvc2l0aW9ucy5cbk5vZGUucHJvdG90eXBlLnJhbmdlSGFzTWFyayA9IGZ1bmN0aW9uIHJhbmdlSGFzTWFyayAoZnJvbSwgdG8sIHR5cGUpIHtcbiAgdmFyIGZvdW5kID0gZmFsc2U7XG4gIGlmICh0byA+IGZyb20pIHsgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKHR5cGUuaXNJblNldChub2RlLm1hcmtzKSkgeyBmb3VuZCA9IHRydWU7IH1cbiAgICByZXR1cm4gIWZvdW5kXG4gIH0pOyB9XG4gIHJldHVybiBmb3VuZFxufTtcblxuLy8gOjogYm9vbFxuLy8gVHJ1ZSB3aGVuIHRoaXMgaXMgYSBibG9jayAobm9uLWlubGluZSBub2RlKVxucHJvdG90eXBlQWNjZXNzb3JzJDMuaXNCbG9jay5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNCbG9jayB9O1xuXG4vLyA6OiBib29sXG4vLyBUcnVlIHdoZW4gdGhpcyBpcyBhIHRleHRibG9jayBub2RlLCBhIGJsb2NrIG5vZGUgd2l0aCBpbmxpbmVcbi8vIGNvbnRlbnQuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMy5pc1RleHRibG9jay5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0YmxvY2sgfTtcblxuLy8gOjogYm9vbFxuLy8gVHJ1ZSB3aGVuIHRoaXMgbm9kZSBhbGxvd3MgaW5saW5lIGNvbnRlbnQuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMy5pbmxpbmVDb250ZW50LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZS5pbmxpbmVDb250ZW50IH07XG5cbi8vIDo6IGJvb2xcbi8vIFRydWUgd2hlbiB0aGlzIGlzIGFuIGlubGluZSBub2RlIChhIHRleHQgbm9kZSBvciBhIG5vZGUgdGhhdCBjYW5cbi8vIGFwcGVhciBhbW9uZyB0ZXh0KS5cbnByb3RvdHlwZUFjY2Vzc29ycyQzLmlzSW5saW5lLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0lubGluZSB9O1xuXG4vLyA6OiBib29sXG4vLyBUcnVlIHdoZW4gdGhpcyBpcyBhIHRleHQgbm9kZS5cbnByb3RvdHlwZUFjY2Vzc29ycyQzLmlzVGV4dC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0IH07XG5cbi8vIDo6IGJvb2xcbi8vIFRydWUgd2hlbiB0aGlzIGlzIGEgbGVhZiBub2RlLlxucHJvdG90eXBlQWNjZXNzb3JzJDMuaXNMZWFmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0xlYWYgfTtcblxuLy8gOjogYm9vbFxuLy8gVHJ1ZSB3aGVuIHRoaXMgaXMgYW4gYXRvbSwgaS5lLiB3aGVuIGl0IGRvZXMgbm90IGhhdmUgZGlyZWN0bHlcbi8vIGVkaXRhYmxlIGNvbnRlbnQuIFRoaXMgaXMgdXN1YWxseSB0aGUgc2FtZSBhcyBgaXNMZWFmYCwgYnV0IGNhblxuLy8gYmUgY29uZmlndXJlZCB3aXRoIHRoZSBbYGF0b21gIHByb3BlcnR5XSgjbW9kZWwuTm9kZVNwZWMuYXRvbSkgb25cbi8vIGEgbm9kZSdzIHNwZWMgKHR5cGljYWxseSB1c2VkIHdoZW4gdGhlIG5vZGUgaXMgZGlzcGxheWVkIGFzIGFuXG4vLyB1bmVkaXRhYmxlIFtub2RlIHZpZXddKCN2aWV3Lk5vZGVWaWV3KSkuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMy5pc0F0b20uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzQXRvbSB9O1xuXG4vLyA6OiAoKSDihpIgc3RyaW5nXG4vLyBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlIGZvciBkZWJ1Z2dpbmdcbi8vIHB1cnBvc2VzLlxuTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKSB7IHJldHVybiB0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKHRoaXMpIH1cbiAgdmFyIG5hbWUgPSB0aGlzLnR5cGUubmFtZTtcbiAgaWYgKHRoaXMuY29udGVudC5zaXplKVxuICAgIHsgbmFtZSArPSBcIihcIiArIHRoaXMuY29udGVudC50b1N0cmluZ0lubmVyKCkgKyBcIilcIjsgfVxuICByZXR1cm4gd3JhcE1hcmtzKHRoaXMubWFya3MsIG5hbWUpXG59O1xuXG4vLyA6OiAobnVtYmVyKSDihpIgQ29udGVudE1hdGNoXG4vLyBHZXQgdGhlIGNvbnRlbnQgbWF0Y2ggaW4gdGhpcyBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cbk5vZGUucHJvdG90eXBlLmNvbnRlbnRNYXRjaEF0ID0gZnVuY3Rpb24gY29udGVudE1hdGNoQXQgKGluZGV4KSB7XG4gIHZhciBtYXRjaCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIDAsIGluZGV4KTtcbiAgaWYgKCFtYXRjaCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgY29udGVudE1hdGNoQXQgb24gYSBub2RlIHdpdGggaW52YWxpZCBjb250ZW50XCIpIH1cbiAgcmV0dXJuIG1hdGNoXG59O1xuXG4vLyA6OiAobnVtYmVyLCBudW1iZXIsID9GcmFnbWVudCwgP251bWJlciwgP251bWJlcikg4oaSIGJvb2xcbi8vIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIChieVxuLy8gY2hpbGQgaW5kZXgpIHdpdGggdGhlIGdpdmVuIHJlcGxhY2VtZW50IGZyYWdtZW50ICh3aGljaCBkZWZhdWx0c1xuLy8gdG8gdGhlIGVtcHR5IGZyYWdtZW50KSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuIFlvdVxuLy8gY2FuIG9wdGlvbmFsbHkgcGFzcyBgc3RhcnRgIGFuZCBgZW5kYCBpbmRpY2VzIGludG8gdGhlXG4vLyByZXBsYWNlbWVudCBmcmFnbWVudC5cbk5vZGUucHJvdG90eXBlLmNhblJlcGxhY2UgPSBmdW5jdGlvbiBjYW5SZXBsYWNlIChmcm9tLCB0bywgcmVwbGFjZW1lbnQsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIHJlcGxhY2VtZW50ID09PSB2b2lkIDAgKSByZXBsYWNlbWVudCA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGlmICggc3RhcnQgPT09IHZvaWQgMCApIHN0YXJ0ID0gMDtcbiAgICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gcmVwbGFjZW1lbnQuY2hpbGRDb3VudDtcblxuICB2YXIgb25lID0gdGhpcy5jb250ZW50TWF0Y2hBdChmcm9tKS5tYXRjaEZyYWdtZW50KHJlcGxhY2VtZW50LCBzdGFydCwgZW5kKTtcbiAgdmFyIHR3byA9IG9uZSAmJiBvbmUubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIHRvKTtcbiAgaWYgKCF0d28gfHwgIXR3by52YWxpZEVuZCkgeyByZXR1cm4gZmFsc2UgfVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykgeyBpZiAoIXRoaXMudHlwZS5hbGxvd3NNYXJrcyhyZXBsYWNlbWVudC5jaGlsZChpKS5tYXJrcykpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gOjogKG51bWJlciwgbnVtYmVyLCBOb2RlVHlwZSwgP1tNYXJrXSkg4oaSIGJvb2xcbi8vIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGBmcm9tYCB0byBgdG9gIChieSBpbmRleCkgd2l0aCBhXG4vLyBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIHdvdWxkIGxlYXZlIHRoZSBub2RlJ3MgY29udGVudCB2YWxpZC5cbk5vZGUucHJvdG90eXBlLmNhblJlcGxhY2VXaXRoID0gZnVuY3Rpb24gY2FuUmVwbGFjZVdpdGggKGZyb20sIHRvLCB0eXBlLCBtYXJrcykge1xuICBpZiAobWFya3MgJiYgIXRoaXMudHlwZS5hbGxvd3NNYXJrcyhtYXJrcykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIHN0YXJ0ID0gdGhpcy5jb250ZW50TWF0Y2hBdChmcm9tKS5tYXRjaFR5cGUodHlwZSk7XG4gIHZhciBlbmQgPSBzdGFydCAmJiBzdGFydC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICByZXR1cm4gZW5kID8gZW5kLnZhbGlkRW5kIDogZmFsc2Vcbn07XG5cbi8vIDo6IChOb2RlKSDihpIgYm9vbFxuLy8gVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBub2RlJ3MgY29udGVudCBjb3VsZCBiZSBhcHBlbmRlZCB0byB0aGlzXG4vLyBub2RlLiBJZiB0aGF0IG5vZGUgaXMgZW1wdHksIHRoaXMgd2lsbCBvbmx5IHJldHVybiB0cnVlIGlmIHRoZXJlXG4vLyBpcyBhdCBsZWFzdCBvbmUgbm9kZSB0eXBlIHRoYXQgY2FuIGFwcGVhciBpbiBib3RoIG5vZGVzICh0byBhdm9pZFxuLy8gbWVyZ2luZyBjb21wbGV0ZWx5IGluY29tcGF0aWJsZSBub2RlcykuXG5Ob2RlLnByb3RvdHlwZS5jYW5BcHBlbmQgPSBmdW5jdGlvbiBjYW5BcHBlbmQgKG90aGVyKSB7XG4gIGlmIChvdGhlci5jb250ZW50LnNpemUpIHsgcmV0dXJuIHRoaXMuY2FuUmVwbGFjZSh0aGlzLmNoaWxkQ291bnQsIHRoaXMuY2hpbGRDb3VudCwgb3RoZXIuY29udGVudCkgfVxuICBlbHNlIHsgcmV0dXJuIHRoaXMudHlwZS5jb21wYXRpYmxlQ29udGVudChvdGhlci50eXBlKSB9XG59O1xuXG4vLyA6OiAoKVxuLy8gQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cyBjb25mb3JtIHRvIHRoZVxuLy8gc2NoZW1hLCBhbmQgcmFpc2UgZXJyb3Igd2hlbiB0aGV5IGRvIG5vdC5cbk5vZGUucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gY2hlY2sgKCkge1xuICBpZiAoIXRoaXMudHlwZS52YWxpZENvbnRlbnQodGhpcy5jb250ZW50KSlcbiAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKChcIkludmFsaWQgY29udGVudCBmb3Igbm9kZSBcIiArICh0aGlzLnR5cGUubmFtZSkgKyBcIjogXCIgKyAodGhpcy5jb250ZW50LnRvU3RyaW5nKCkuc2xpY2UoMCwgNTApKSkpIH1cbiAgdmFyIGNvcHkgPSBNYXJrLm5vbmU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrcy5sZW5ndGg7IGkrKykgeyBjb3B5ID0gdGhpcy5tYXJrc1tpXS5hZGRUb1NldChjb3B5KTsgfVxuICBpZiAoIU1hcmsuc2FtZVNldChjb3B5LCB0aGlzLm1hcmtzKSlcbiAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKChcIkludmFsaWQgY29sbGVjdGlvbiBvZiBtYXJrcyBmb3Igbm9kZSBcIiArICh0aGlzLnR5cGUubmFtZSkgKyBcIjogXCIgKyAodGhpcy5tYXJrcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0udHlwZS5uYW1lOyB9KSkpKSB9XG4gIHRoaXMuY29udGVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLmNoZWNrKCk7IH0pO1xufTtcblxuLy8gOjogKCkg4oaSIE9iamVjdFxuLy8gUmV0dXJuIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZS5cbk5vZGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHZhciBvYmogPSB7dHlwZTogdGhpcy50eXBlLm5hbWV9O1xuICBmb3IgKHZhciBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICBvYmouYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgIGJyZWFrXG4gIH1cbiAgaWYgKHRoaXMuY29udGVudC5zaXplKVxuICAgIHsgb2JqLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQudG9KU09OKCk7IH1cbiAgaWYgKHRoaXMubWFya3MubGVuZ3RoKVxuICAgIHsgb2JqLm1hcmtzID0gdGhpcy5tYXJrcy5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udG9KU09OKCk7IH0pOyB9XG4gIHJldHVybiBvYmpcbn07XG5cbi8vIDo6IChTY2hlbWEsIE9iamVjdCkg4oaSIE5vZGVcbi8vIERlc2VyaWFsaXplIGEgbm9kZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuTm9kZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OIChzY2hlbWEsIGpzb24pIHtcbiAgaWYgKCFqc29uKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTm9kZS5mcm9tSlNPTlwiKSB9XG4gIHZhciBtYXJrcyA9IG51bGw7XG4gIGlmIChqc29uLm1hcmtzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24ubWFya3MpKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtYXJrIGRhdGEgZm9yIE5vZGUuZnJvbUpTT05cIikgfVxuICAgIG1hcmtzID0ganNvbi5tYXJrcy5tYXAoc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gIH1cbiAgaWYgKGpzb24udHlwZSA9PSBcInRleHRcIikge1xuICAgIGlmICh0eXBlb2YganNvbi50ZXh0ICE9IFwic3RyaW5nXCIpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRleHQgbm9kZSBpbiBKU09OXCIpIH1cbiAgICByZXR1cm4gc2NoZW1hLnRleHQoanNvbi50ZXh0LCBtYXJrcylcbiAgfVxuICB2YXIgY29udGVudCA9IEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KTtcbiAgcmV0dXJuIHNjaGVtYS5ub2RlVHlwZShqc29uLnR5cGUpLmNyZWF0ZShqc29uLmF0dHJzLCBjb250ZW50LCBtYXJrcylcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDMgKTtcblxudmFyIFRleHROb2RlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTm9kZSkge1xuICBmdW5jdGlvbiBUZXh0Tm9kZSh0eXBlLCBhdHRycywgY29udGVudCwgbWFya3MpIHtcbiAgICBOb2RlLmNhbGwodGhpcywgdHlwZSwgYXR0cnMsIG51bGwsIG1hcmtzKTtcblxuICAgIGlmICghY29udGVudCkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdCBhbGxvd2VkXCIpIH1cblxuICAgIHRoaXMudGV4dCA9IGNvbnRlbnQ7XG4gIH1cblxuICBpZiAoIE5vZGUgKSBUZXh0Tm9kZS5fX3Byb3RvX18gPSBOb2RlO1xuICBUZXh0Tm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBOb2RlICYmIE5vZGUucHJvdG90eXBlICk7XG4gIFRleHROb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHROb2RlO1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgdGV4dENvbnRlbnQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sbm9kZVNpemU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBUZXh0Tm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpIHsgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcykgfVxuICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXh0KSlcbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMkMS50ZXh0Q29udGVudC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRleHQgfTtcblxuICBUZXh0Tm9kZS5wcm90b3R5cGUudGV4dEJldHdlZW4gPSBmdW5jdGlvbiB0ZXh0QmV0d2VlbiAoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMudGV4dC5zbGljZShmcm9tLCB0bykgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMkMS5ub2RlU2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoIH07XG5cbiAgVGV4dE5vZGUucHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbiBtYXJrIChtYXJrcykge1xuICAgIHJldHVybiBtYXJrcyA9PSB0aGlzLm1hcmtzID8gdGhpcyA6IG5ldyBUZXh0Tm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMudGV4dCwgbWFya3MpXG4gIH07XG5cbiAgVGV4dE5vZGUucHJvdG90eXBlLndpdGhUZXh0ID0gZnVuY3Rpb24gd2l0aFRleHQgKHRleHQpIHtcbiAgICBpZiAodGV4dCA9PSB0aGlzLnRleHQpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHJldHVybiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0ZXh0LCB0aGlzLm1hcmtzKVxuICB9O1xuXG4gIFRleHROb2RlLnByb3RvdHlwZS5jdXQgPSBmdW5jdGlvbiBjdXQgKGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMudGV4dC5sZW5ndGg7XG5cbiAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMudGV4dC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHJldHVybiB0aGlzLndpdGhUZXh0KHRoaXMudGV4dC5zbGljZShmcm9tLCB0bykpXG4gIH07XG5cbiAgVGV4dE5vZGUucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy50ZXh0ID09IG90aGVyLnRleHRcbiAgfTtcblxuICBUZXh0Tm9kZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICB2YXIgYmFzZSA9IE5vZGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMpO1xuICAgIGJhc2UudGV4dCA9IHRoaXMudGV4dDtcbiAgICByZXR1cm4gYmFzZVxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUZXh0Tm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbiAgcmV0dXJuIFRleHROb2RlO1xufShOb2RlKSk7XG5cbmZ1bmN0aW9uIHdyYXBNYXJrcyhtYXJrcywgc3RyKSB7XG4gIGZvciAodmFyIGkgPSBtYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICB7IHN0ciA9IG1hcmtzW2ldLnR5cGUubmFtZSArIFwiKFwiICsgc3RyICsgXCIpXCI7IH1cbiAgcmV0dXJuIHN0clxufVxuXG4vLyA6Oi0gSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IGEgbWF0Y2ggc3RhdGUgb2YgYSBub2RlXG4vLyB0eXBlJ3MgW2NvbnRlbnQgZXhwcmVzc2lvbl0oI21vZGVsLk5vZGVTcGVjLmNvbnRlbnQpLCBhbmQgY2FuIGJlXG4vLyB1c2VkIHRvIGZpbmQgb3V0IHdoZXRoZXIgZnVydGhlciBjb250ZW50IG1hdGNoZXMgaGVyZSwgYW5kIHdoZXRoZXJcbi8vIGEgZ2l2ZW4gcG9zaXRpb24gaXMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG52YXIgQ29udGVudE1hdGNoID0gZnVuY3Rpb24gQ29udGVudE1hdGNoKHZhbGlkRW5kKSB7XG4gIC8vIDo6IGJvb2xcbiAgLy8gVHJ1ZSB3aGVuIHRoaXMgbWF0Y2ggc3RhdGUgcmVwcmVzZW50cyBhIHZhbGlkIGVuZCBvZiB0aGUgbm9kZS5cbiAgdGhpcy52YWxpZEVuZCA9IHZhbGlkRW5kO1xuICB0aGlzLm5leHQgPSBbXTtcbiAgdGhpcy53cmFwQ2FjaGUgPSBbXTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkNCA9IHsgaW5saW5lQ29udGVudDogeyBjb25maWd1cmFibGU6IHRydWUgfSxkZWZhdWx0VHlwZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxlZGdlQ291bnQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuQ29udGVudE1hdGNoLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHN0cmluZywgbm9kZVR5cGVzKSB7XG4gIHZhciBzdHJlYW0gPSBuZXcgVG9rZW5TdHJlYW0oc3RyaW5nLCBub2RlVHlwZXMpO1xuICBpZiAoc3RyZWFtLm5leHQgPT0gbnVsbCkgeyByZXR1cm4gQ29udGVudE1hdGNoLmVtcHR5IH1cbiAgdmFyIGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgaWYgKHN0cmVhbS5uZXh0KSB7IHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRyYWlsaW5nIHRleHRcIik7IH1cbiAgdmFyIG1hdGNoID0gZGZhKG5mYShleHByKSk7XG4gIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSk7XG4gIHJldHVybiBtYXRjaFxufTtcblxuLy8gOjogKE5vZGVUeXBlKSDihpIgP0NvbnRlbnRNYXRjaFxuLy8gTWF0Y2ggYSBub2RlIHR5cGUsIHJldHVybmluZyBhIG1hdGNoIGFmdGVyIHRoYXQgbm9kZSBpZlxuLy8gc3VjY2Vzc2Z1bC5cbkNvbnRlbnRNYXRjaC5wcm90b3R5cGUubWF0Y2hUeXBlID0gZnVuY3Rpb24gbWF0Y2hUeXBlICh0eXBlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSArPSAyKVxuICAgIHsgaWYgKHRoaXMubmV4dFtpXSA9PSB0eXBlKSB7IHJldHVybiB0aGlzLm5leHRbaSArIDFdIH0gfVxuICByZXR1cm4gbnVsbFxufTtcblxuLy8gOjogKEZyYWdtZW50LCA/bnVtYmVyLCA/bnVtYmVyKSDihpIgP0NvbnRlbnRNYXRjaFxuLy8gVHJ5IHRvIG1hdGNoIGEgZnJhZ21lbnQuIFJldHVybnMgdGhlIHJlc3VsdGluZyBtYXRjaCB3aGVuXG4vLyBzdWNjZXNzZnVsLlxuQ29udGVudE1hdGNoLnByb3RvdHlwZS5tYXRjaEZyYWdtZW50ID0gZnVuY3Rpb24gbWF0Y2hGcmFnbWVudCAoZnJhZywgc3RhcnQsIGVuZCkge1xuICAgIGlmICggc3RhcnQgPT09IHZvaWQgMCApIHN0YXJ0ID0gMDtcbiAgICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gZnJhZy5jaGlsZENvdW50O1xuXG4gIHZhciBjdXIgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGN1ciAmJiBpIDwgZW5kOyBpKyspXG4gICAgeyBjdXIgPSBjdXIubWF0Y2hUeXBlKGZyYWcuY2hpbGQoaSkudHlwZSk7IH1cbiAgcmV0dXJuIGN1clxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDQuaW5saW5lQ29udGVudC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmaXJzdCA9IHRoaXMubmV4dFswXTtcbiAgcmV0dXJuIGZpcnN0ID8gZmlyc3QuaXNJbmxpbmUgOiBmYWxzZVxufTtcblxuLy8gOjogP05vZGVUeXBlXG4vLyBHZXQgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGUgdHlwZSBhdCB0aGlzIG1hdGNoIHBvc2l0aW9uIHRoYXQgY2FuXG4vLyBiZSBnZW5lcmF0ZWQuXG5wcm90b3R5cGVBY2Nlc3NvcnMkNC5kZWZhdWx0VHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLm5leHRbaV07XG4gICAgaWYgKCEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpKSB7IHJldHVybiB0eXBlIH1cbiAgfVxufTtcblxuQ29udGVudE1hdGNoLnByb3RvdHlwZS5jb21wYXRpYmxlID0gZnVuY3Rpb24gY29tcGF0aWJsZSAob3RoZXIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpICs9IDIpXG4gICAgeyBmb3IgKHZhciBqID0gMDsgaiA8IG90aGVyLm5leHQubGVuZ3RoOyBqICs9IDIpXG4gICAgICB7IGlmICh0aGlzLm5leHRbaV0gPT0gb3RoZXIubmV4dFtqXSkgeyByZXR1cm4gdHJ1ZSB9IH0gfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIDo6IChGcmFnbWVudCwgYm9vbCwgP251bWJlcikg4oaSID9GcmFnbWVudFxuLy8gVHJ5IHRvIG1hdGNoIHRoZSBnaXZlbiBmcmFnbWVudCwgYW5kIGlmIHRoYXQgZmFpbHMsIHNlZSBpZiBpdCBjYW5cbi8vIGJlIG1hZGUgdG8gbWF0Y2ggYnkgaW5zZXJ0aW5nIG5vZGVzIGluIGZyb250IG9mIGl0LiBXaGVuXG4vLyBzdWNjZXNzZnVsLCByZXR1cm4gYSBmcmFnbWVudCBvZiBpbnNlcnRlZCBub2RlcyAod2hpY2ggbWF5IGJlXG4vLyBlbXB0eSBpZiBub3RoaW5nIGhhZCB0byBiZSBpbnNlcnRlZCkuIFdoZW4gYHRvRW5kYCBpcyB0cnVlLCBvbmx5XG4vLyByZXR1cm4gYSBmcmFnbWVudCBpZiB0aGUgcmVzdWx0aW5nIG1hdGNoIGdvZXMgdG8gdGhlIGVuZCBvZiB0aGVcbi8vIGNvbnRlbnQgZXhwcmVzc2lvbi5cbkNvbnRlbnRNYXRjaC5wcm90b3R5cGUuZmlsbEJlZm9yZSA9IGZ1bmN0aW9uIGZpbGxCZWZvcmUgKGFmdGVyLCB0b0VuZCwgc3RhcnRJbmRleCkge1xuICAgIGlmICggdG9FbmQgPT09IHZvaWQgMCApIHRvRW5kID0gZmFsc2U7XG4gICAgaWYgKCBzdGFydEluZGV4ID09PSB2b2lkIDAgKSBzdGFydEluZGV4ID0gMDtcblxuICB2YXIgc2VlbiA9IFt0aGlzXTtcbiAgZnVuY3Rpb24gc2VhcmNoKG1hdGNoLCB0eXBlcykge1xuICAgIHZhciBmaW5pc2hlZCA9IG1hdGNoLm1hdGNoRnJhZ21lbnQoYWZ0ZXIsIHN0YXJ0SW5kZXgpO1xuICAgIGlmIChmaW5pc2hlZCAmJiAoIXRvRW5kIHx8IGZpbmlzaGVkLnZhbGlkRW5kKSlcbiAgICAgIHsgcmV0dXJuIEZyYWdtZW50LmZyb20odHlwZXMubWFwKGZ1bmN0aW9uICh0cCkgeyByZXR1cm4gdHAuY3JlYXRlQW5kRmlsbCgpOyB9KSkgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgdHlwZSA9IG1hdGNoLm5leHRbaV0sIG5leHQgPSBtYXRjaC5uZXh0W2kgKyAxXTtcbiAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSAmJiBzZWVuLmluZGV4T2YobmV4dCkgPT0gLTEpIHtcbiAgICAgICAgc2Vlbi5wdXNoKG5leHQpO1xuICAgICAgICB2YXIgZm91bmQgPSBzZWFyY2gobmV4dCwgdHlwZXMuY29uY2F0KHR5cGUpKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7IHJldHVybiBmb3VuZCB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlYXJjaCh0aGlzLCBbXSlcbn07XG5cbi8vIDo6IChOb2RlVHlwZSkg4oaSID9bTm9kZVR5cGVdXG4vLyBGaW5kIGEgc2V0IG9mIHdyYXBwaW5nIG5vZGUgdHlwZXMgdGhhdCB3b3VsZCBhbGxvdyBhIG5vZGUgb2YgdGhlXG4vLyBnaXZlbiB0eXBlIHRvIGFwcGVhciBhdCB0aGlzIHBvc2l0aW9uLiBUaGUgcmVzdWx0IG1heSBiZSBlbXB0eVxuLy8gKHdoZW4gaXQgZml0cyBkaXJlY3RseSkgYW5kIHdpbGwgYmUgbnVsbCB3aGVuIG5vIHN1Y2ggd3JhcHBpbmdcbi8vIGV4aXN0cy5cbkNvbnRlbnRNYXRjaC5wcm90b3R5cGUuZmluZFdyYXBwaW5nID0gZnVuY3Rpb24gZmluZFdyYXBwaW5nICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndyYXBDYWNoZS5sZW5ndGg7IGkgKz0gMilcbiAgICB7IGlmICh0aGlzLndyYXBDYWNoZVtpXSA9PSB0YXJnZXQpIHsgcmV0dXJuIHRoaXMud3JhcENhY2hlW2kgKyAxXSB9IH1cbiAgdmFyIGNvbXB1dGVkID0gdGhpcy5jb21wdXRlV3JhcHBpbmcodGFyZ2V0KTtcbiAgdGhpcy53cmFwQ2FjaGUucHVzaCh0YXJnZXQsIGNvbXB1dGVkKTtcbiAgcmV0dXJuIGNvbXB1dGVkXG59O1xuXG5Db250ZW50TWF0Y2gucHJvdG90eXBlLmNvbXB1dGVXcmFwcGluZyA9IGZ1bmN0aW9uIGNvbXB1dGVXcmFwcGluZyAodGFyZ2V0KSB7XG4gIHZhciBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgYWN0aXZlID0gW3ttYXRjaDogdGhpcywgdHlwZTogbnVsbCwgdmlhOiBudWxsfV07XG4gIHdoaWxlIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBhY3RpdmUuc2hpZnQoKSwgbWF0Y2ggPSBjdXJyZW50Lm1hdGNoO1xuICAgIGlmIChtYXRjaC5tYXRjaFR5cGUodGFyZ2V0KSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIgb2JqID0gY3VycmVudDsgb2JqLnR5cGU7IG9iaiA9IG9iai52aWEpXG4gICAgICAgIHsgcmVzdWx0LnB1c2gob2JqLnR5cGUpOyB9XG4gICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciB0eXBlID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgIGlmICghdHlwZS5pc0xlYWYgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpICYmICEodHlwZS5uYW1lIGluIHNlZW4pICYmICghY3VycmVudC50eXBlIHx8IG1hdGNoLm5leHRbaSArIDFdLnZhbGlkRW5kKSkge1xuICAgICAgICBhY3RpdmUucHVzaCh7bWF0Y2g6IHR5cGUuY29udGVudE1hdGNoLCB0eXBlOiB0eXBlLCB2aWE6IGN1cnJlbnR9KTtcbiAgICAgICAgc2Vlblt0eXBlLm5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIDo6IG51bWJlclxuLy8gVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyB0aGlzIG5vZGUgaGFzIGluIHRoZSBmaW5pdGVcbi8vIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxucHJvdG90eXBlQWNjZXNzb3JzJDQuZWRnZUNvdW50LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGggPj4gMVxufTtcblxuLy8gOjogKG51bWJlcikg4oaSIHt0eXBlOiBOb2RlVHlwZSwgbmV4dDogQ29udGVudE1hdGNofVxuLy8gR2V0IHRoZSBfbl/igIt0aCBvdXRnb2luZyBlZGdlIGZyb20gdGhpcyBub2RlIGluIHRoZSBmaW5pdGVcbi8vIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxuQ29udGVudE1hdGNoLnByb3RvdHlwZS5lZGdlID0gZnVuY3Rpb24gZWRnZSAobikge1xuICB2YXIgaSA9IG4gPDwgMTtcbiAgaWYgKGkgPj0gdGhpcy5uZXh0Lmxlbmd0aCkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcigoXCJUaGVyZSdzIG5vIFwiICsgbiArIFwidGggZWRnZSBpbiB0aGlzIGNvbnRlbnQgbWF0Y2hcIikpIH1cbiAgcmV0dXJuIHt0eXBlOiB0aGlzLm5leHRbaV0sIG5leHQ6IHRoaXMubmV4dFtpICsgMV19XG59O1xuXG5Db250ZW50TWF0Y2gucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgc2VlbiA9IFtdO1xuICBmdW5jdGlvbiBzY2FuKG0pIHtcbiAgICBzZWVuLnB1c2gobSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBtLm5leHQubGVuZ3RoOyBpICs9IDIpXG4gICAgICB7IGlmIChzZWVuLmluZGV4T2YobS5uZXh0W2ldKSA9PSAtMSkgeyBzY2FuKG0ubmV4dFtpXSk7IH0gfVxuICB9XG4gIHNjYW4odGhpcyk7XG4gIHJldHVybiBzZWVuLm1hcChmdW5jdGlvbiAobSwgaSkge1xuICAgIHZhciBvdXQgPSBpICsgKG0udmFsaWRFbmQgPyBcIipcIiA6IFwiIFwiKSArIFwiIFwiO1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG0ubmV4dC5sZW5ndGg7IGkkMSArPSAyKVxuICAgICAgeyBvdXQgKz0gKGkkMSA/IFwiLCBcIiA6IFwiXCIpICsgbS5uZXh0W2kkMV0ubmFtZSArIFwiLT5cIiArIHNlZW4uaW5kZXhPZihtLm5leHRbaSQxICsgMV0pOyB9XG4gICAgcmV0dXJuIG91dFxuICB9KS5qb2luKFwiXFxuXCIpXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ29udGVudE1hdGNoLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDQgKTtcblxuQ29udGVudE1hdGNoLmVtcHR5ID0gbmV3IENvbnRlbnRNYXRjaCh0cnVlKTtcblxudmFyIFRva2VuU3RyZWFtID0gZnVuY3Rpb24gVG9rZW5TdHJlYW0oc3RyaW5nLCBub2RlVHlwZXMpIHtcbiAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gIHRoaXMubm9kZVR5cGVzID0gbm9kZVR5cGVzO1xuICB0aGlzLmlubGluZSA9IG51bGw7XG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy50b2tlbnMgPSBzdHJpbmcuc3BsaXQoL1xccyooPz1cXGJ8XFxXfCQpLyk7XG4gIGlmICh0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXSA9PSBcIlwiKSB7IHRoaXMudG9rZW5zLnBvcCgpOyB9XG4gIGlmICh0aGlzLnRva2Vuc1swXSA9PSBcIlwiKSB7IHRoaXMudG9rZW5zLnNoaWZ0KCk7IH1cbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSQyID0geyBuZXh0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxJDIubmV4dC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnBvc10gfTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIGVhdCAodG9rKSB7IHJldHVybiB0aGlzLm5leHQgPT0gdG9rICYmICh0aGlzLnBvcysrIHx8IHRydWUpIH07XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5lcnIgPSBmdW5jdGlvbiBlcnIgKHN0cikgeyB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3RyICsgXCIgKGluIGNvbnRlbnQgZXhwcmVzc2lvbiAnXCIgKyB0aGlzLnN0cmluZyArIFwiJylcIikgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRva2VuU3RyZWFtLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDEkMiApO1xuXG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyZWFtKSB7XG4gIHZhciBleHBycyA9IFtdO1xuICBkbyB7IGV4cHJzLnB1c2gocGFyc2VFeHByU2VxKHN0cmVhbSkpOyB9XG4gIHdoaWxlIChzdHJlYW0uZWF0KFwifFwiKSlcbiAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7dHlwZTogXCJjaG9pY2VcIiwgZXhwcnM6IGV4cHJzfVxufVxuXG5mdW5jdGlvbiBwYXJzZUV4cHJTZXEoc3RyZWFtKSB7XG4gIHZhciBleHBycyA9IFtdO1xuICBkbyB7IGV4cHJzLnB1c2gocGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkpOyB9XG4gIHdoaWxlIChzdHJlYW0ubmV4dCAmJiBzdHJlYW0ubmV4dCAhPSBcIilcIiAmJiBzdHJlYW0ubmV4dCAhPSBcInxcIilcbiAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7dHlwZTogXCJzZXFcIiwgZXhwcnM6IGV4cHJzfVxufVxuXG5mdW5jdGlvbiBwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSB7XG4gIHZhciBleHByID0gcGFyc2VFeHByQXRvbShzdHJlYW0pO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIrXCIpKVxuICAgICAgeyBleHByID0ge3R5cGU6IFwicGx1c1wiLCBleHByOiBleHByfTsgfVxuICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKVxuICAgICAgeyBleHByID0ge3R5cGU6IFwic3RhclwiLCBleHByOiBleHByfTsgfVxuICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCI/XCIpKVxuICAgICAgeyBleHByID0ge3R5cGU6IFwib3B0XCIsIGV4cHI6IGV4cHJ9OyB9XG4gICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIntcIikpXG4gICAgICB7IGV4cHIgPSBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpOyB9XG4gICAgZWxzZSB7IGJyZWFrIH1cbiAgfVxuICByZXR1cm4gZXhwclxufVxuXG5mdW5jdGlvbiBwYXJzZU51bShzdHJlYW0pIHtcbiAgaWYgKC9cXEQvLnRlc3Qoc3RyZWFtLm5leHQpKSB7IHN0cmVhbS5lcnIoXCJFeHBlY3RlZCBudW1iZXIsIGdvdCAnXCIgKyBzdHJlYW0ubmV4dCArIFwiJ1wiKTsgfVxuICB2YXIgcmVzdWx0ID0gTnVtYmVyKHN0cmVhbS5uZXh0KTtcbiAgc3RyZWFtLnBvcysrO1xuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXhwclJhbmdlKHN0cmVhbSwgZXhwcikge1xuICB2YXIgbWluID0gcGFyc2VOdW0oc3RyZWFtKSwgbWF4ID0gbWluO1xuICBpZiAoc3RyZWFtLmVhdChcIixcIikpIHtcbiAgICBpZiAoc3RyZWFtLm5leHQgIT0gXCJ9XCIpIHsgbWF4ID0gcGFyc2VOdW0oc3RyZWFtKTsgfVxuICAgIGVsc2UgeyBtYXggPSAtMTsgfVxuICB9XG4gIGlmICghc3RyZWFtLmVhdChcIn1cIikpIHsgc3RyZWFtLmVycihcIlVuY2xvc2VkIGJyYWNlZCByYW5nZVwiKTsgfVxuICByZXR1cm4ge3R5cGU6IFwicmFuZ2VcIiwgbWluOiBtaW4sIG1heDogbWF4LCBleHByOiBleHByfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlTmFtZShzdHJlYW0sIG5hbWUpIHtcbiAgdmFyIHR5cGVzID0gc3RyZWFtLm5vZGVUeXBlcywgdHlwZSA9IHR5cGVzW25hbWVdO1xuICBpZiAodHlwZSkgeyByZXR1cm4gW3R5cGVdIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciB0eXBlTmFtZSBpbiB0eXBlcykge1xuICAgIHZhciB0eXBlJDEgPSB0eXBlc1t0eXBlTmFtZV07XG4gICAgaWYgKHR5cGUkMS5ncm91cHMuaW5kZXhPZihuYW1lKSA+IC0xKSB7IHJlc3VsdC5wdXNoKHR5cGUkMSk7IH1cbiAgfVxuICBpZiAocmVzdWx0Lmxlbmd0aCA9PSAwKSB7IHN0cmVhbS5lcnIoXCJObyBub2RlIHR5cGUgb3IgZ3JvdXAgJ1wiICsgbmFtZSArIFwiJyBmb3VuZFwiKTsgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXhwckF0b20oc3RyZWFtKSB7XG4gIGlmIChzdHJlYW0uZWF0KFwiKFwiKSkge1xuICAgIHZhciBleHByID0gcGFyc2VFeHByKHN0cmVhbSk7XG4gICAgaWYgKCFzdHJlYW0uZWF0KFwiKVwiKSkgeyBzdHJlYW0uZXJyKFwiTWlzc2luZyBjbG9zaW5nIHBhcmVuXCIpOyB9XG4gICAgcmV0dXJuIGV4cHJcbiAgfSBlbHNlIGlmICghL1xcVy8udGVzdChzdHJlYW0ubmV4dCkpIHtcbiAgICB2YXIgZXhwcnMgPSByZXNvbHZlTmFtZShzdHJlYW0sIHN0cmVhbS5uZXh0KS5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmIChzdHJlYW0uaW5saW5lID09IG51bGwpIHsgc3RyZWFtLmlubGluZSA9IHR5cGUuaXNJbmxpbmU7IH1cbiAgICAgIGVsc2UgaWYgKHN0cmVhbS5pbmxpbmUgIT0gdHlwZS5pc0lubGluZSkgeyBzdHJlYW0uZXJyKFwiTWl4aW5nIGlubGluZSBhbmQgYmxvY2sgY29udGVudFwiKTsgfVxuICAgICAgcmV0dXJuIHt0eXBlOiBcIm5hbWVcIiwgdmFsdWU6IHR5cGV9XG4gICAgfSk7XG4gICAgc3RyZWFtLnBvcysrO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDoge3R5cGU6IFwiY2hvaWNlXCIsIGV4cHJzOiBleHByc31cbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZXJyKFwiVW5leHBlY3RlZCB0b2tlbiAnXCIgKyBzdHJlYW0ubmV4dCArIFwiJ1wiKTtcbiAgfVxufVxuXG4vLyBUaGUgY29kZSBiZWxvdyBoZWxwcyBjb21waWxlIGEgcmVndWxhci1leHByZXNzaW9uLWxpa2UgbGFuZ3VhZ2Vcbi8vIGludG8gYSBkZXRlcm1pbmlzdGljIGZpbml0ZSBhdXRvbWF0b24uIEZvciBhIGdvb2QgaW50cm9kdWN0aW9uIHRvXG4vLyB0aGVzZSBjb25jZXB0cywgc2VlIGh0dHBzOi8vc3d0Y2guY29tL35yc2MvcmVnZXhwL3JlZ2V4cDEuaHRtbFxuXG4vLyA6IChPYmplY3QpIOKGkiBbW3t0ZXJtOiA/YW55LCB0bzogbnVtYmVyfV1dXG4vLyBDb25zdHJ1Y3QgYW4gTkZBIGZyb20gYW4gZXhwcmVzc2lvbiBhcyByZXR1cm5lZCBieSB0aGUgcGFyc2VyLiBUaGVcbi8vIE5GQSBpcyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBzdGF0ZXMsIHdoaWNoIGFyZSB0aGVtc2VsdmVzXG4vLyBhcnJheXMgb2YgZWRnZXMsIHdoaWNoIGFyZSBge3Rlcm0sIHRvfWAgb2JqZWN0cy4gVGhlIGZpcnN0IHN0YXRlIGlzXG4vLyB0aGUgZW50cnkgc3RhdGUgYW5kIHRoZSBsYXN0IG5vZGUgaXMgdGhlIHN1Y2Nlc3Mgc3RhdGUuXG4vL1xuLy8gTm90ZSB0aGF0IHVubGlrZSB0eXBpY2FsIE5GQXMsIHRoZSBlZGdlIG9yZGVyaW5nIGluIHRoaXMgb25lIGlzXG4vLyBzaWduaWZpY2FudCwgaW4gdGhhdCBpdCBpcyB1c2VkIHRvIGNvbnRydWN0IGZpbGxlciBjb250ZW50IHdoZW5cbi8vIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIG5mYShleHByKSB7XG4gIHZhciBuZmEgPSBbW11dO1xuICBjb25uZWN0KGNvbXBpbGUoZXhwciwgMCksIG5vZGUoKSk7XG4gIHJldHVybiBuZmFcblxuICBmdW5jdGlvbiBub2RlKCkgeyByZXR1cm4gbmZhLnB1c2goW10pIC0gMSB9XG4gIGZ1bmN0aW9uIGVkZ2UoZnJvbSwgdG8sIHRlcm0pIHtcbiAgICB2YXIgZWRnZSA9IHt0ZXJtOiB0ZXJtLCB0bzogdG99O1xuICAgIG5mYVtmcm9tXS5wdXNoKGVkZ2UpO1xuICAgIHJldHVybiBlZGdlXG4gIH1cbiAgZnVuY3Rpb24gY29ubmVjdChlZGdlcywgdG8pIHsgZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkgeyByZXR1cm4gZWRnZS50byA9IHRvOyB9KTsgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGUoZXhwciwgZnJvbSkge1xuICAgIGlmIChleHByLnR5cGUgPT0gXCJjaG9pY2VcIikge1xuICAgICAgcmV0dXJuIGV4cHIuZXhwcnMucmVkdWNlKGZ1bmN0aW9uIChvdXQsIGV4cHIpIHsgcmV0dXJuIG91dC5jb25jYXQoY29tcGlsZShleHByLCBmcm9tKSk7IH0sIFtdKVxuICAgIH0gZWxzZSBpZiAoZXhwci50eXBlID09IFwic2VxXCIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIHZhciBuZXh0ID0gY29tcGlsZShleHByLmV4cHJzW2ldLCBmcm9tKTtcbiAgICAgICAgaWYgKGkgPT0gZXhwci5leHBycy5sZW5ndGggLSAxKSB7IHJldHVybiBuZXh0IH1cbiAgICAgICAgY29ubmVjdChuZXh0LCBmcm9tID0gbm9kZSgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInN0YXJcIikge1xuICAgICAgdmFyIGxvb3AgPSBub2RlKCk7XG4gICAgICBlZGdlKGZyb20sIGxvb3ApO1xuICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgbG9vcCksIGxvb3ApO1xuICAgICAgcmV0dXJuIFtlZGdlKGxvb3ApXVxuICAgIH0gZWxzZSBpZiAoZXhwci50eXBlID09IFwicGx1c1wiKSB7XG4gICAgICB2YXIgbG9vcCQxID0gbm9kZSgpO1xuICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSksIGxvb3AkMSk7XG4gICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBsb29wJDEpLCBsb29wJDEpO1xuICAgICAgcmV0dXJuIFtlZGdlKGxvb3AkMSldXG4gICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJvcHRcIikge1xuICAgICAgcmV0dXJuIFtlZGdlKGZyb20pXS5jb25jYXQoY29tcGlsZShleHByLmV4cHIsIGZyb20pKVxuICAgIH0gZWxzZSBpZiAoZXhwci50eXBlID09IFwicmFuZ2VcIikge1xuICAgICAgdmFyIGN1ciA9IGZyb207XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBleHByLm1pbjsgaSQxKyspIHtcbiAgICAgICAgdmFyIG5leHQkMSA9IG5vZGUoKTtcbiAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgbmV4dCQxKTtcbiAgICAgICAgY3VyID0gbmV4dCQxO1xuICAgICAgfVxuICAgICAgaWYgKGV4cHIubWF4ID09IC0xKSB7XG4gICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIGN1cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpJDIgPSBleHByLm1pbjsgaSQyIDwgZXhwci5tYXg7IGkkMisrKSB7XG4gICAgICAgICAgdmFyIG5leHQkMiA9IG5vZGUoKTtcbiAgICAgICAgICBlZGdlKGN1ciwgbmV4dCQyKTtcbiAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBuZXh0JDIpO1xuICAgICAgICAgIGN1ciA9IG5leHQkMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtlZGdlKGN1cildXG4gICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJuYW1lXCIpIHtcbiAgICAgIHJldHVybiBbZWRnZShmcm9tLCBudWxsLCBleHByLnZhbHVlKV1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY21wKGEsIGIpIHsgcmV0dXJuIGIgLSBhIH1cblxuLy8gR2V0IHRoZSBzZXQgb2Ygbm9kZXMgcmVhY2hhYmxlIGJ5IG51bGwgZWRnZXMgZnJvbSBgbm9kZWAuIE9taXRcbi8vIG5vZGVzIHdpdGggb25seSBhIHNpbmdsZSBudWxsLW91dC1lZGdlLCBzaW5jZSB0aGV5IG1heSBsZWFkIHRvXG4vLyBuZWVkbGVzcyBkdXBsaWNhdGVkIG5vZGVzLlxuZnVuY3Rpb24gbnVsbEZyb20obmZhLCBub2RlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgc2Nhbihub2RlKTtcbiAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcClcblxuICBmdW5jdGlvbiBzY2FuKG5vZGUpIHtcbiAgICB2YXIgZWRnZXMgPSBuZmFbbm9kZV07XG4gICAgaWYgKGVkZ2VzLmxlbmd0aCA9PSAxICYmICFlZGdlc1swXS50ZXJtKSB7IHJldHVybiBzY2FuKGVkZ2VzWzBdLnRvKSB9XG4gICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlZiA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIHRlcm0gPSByZWYudGVybTtcbiAgICAgIHZhciB0byA9IHJlZi50bztcbiAgICAgIGlmICghdGVybSAmJiByZXN1bHQuaW5kZXhPZih0bykgPT0gLTEpIHsgc2Nhbih0byk7IH1cbiAgICB9XG4gIH1cbn1cblxuLy8gOiAoW1t7dGVybTogP2FueSwgdG86IG51bWJlcn1dXSkg4oaSIENvbnRlbnRNYXRjaFxuLy8gQ29tcGlsZXMgYW4gTkZBIGFzIHByb2R1Y2VkIGJ5IGBuZmFgIGludG8gYSBERkEsIG1vZGVsZWQgYXMgYSBzZXRcbi8vIG9mIHN0YXRlIG9iamVjdHMgKGBDb250ZW50TWF0Y2hgIGluc3RhbmNlcykgd2l0aCB0cmFuc2l0aW9uc1xuLy8gYmV0d2VlbiB0aGVtLlxuZnVuY3Rpb24gZGZhKG5mYSkge1xuICB2YXIgbGFiZWxlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBleHBsb3JlKG51bGxGcm9tKG5mYSwgMCkpXG5cbiAgZnVuY3Rpb24gZXhwbG9yZShzdGF0ZXMpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIG5mYVtub2RlXS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIHRlcm0gPSByZWYudGVybTtcbiAgICAgICAgdmFyIHRvID0gcmVmLnRvO1xuXG4gICAgICAgIGlmICghdGVybSkgeyByZXR1cm4gfVxuICAgICAgICB2YXIga25vd24gPSBvdXQuaW5kZXhPZih0ZXJtKSwgc2V0ID0ga25vd24gPiAtMSAmJiBvdXRba25vd24gKyAxXTtcbiAgICAgICAgbnVsbEZyb20obmZhLCB0bykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmICghc2V0KSB7IG91dC5wdXNoKHRlcm0sIHNldCA9IFtdKTsgfVxuICAgICAgICAgIGlmIChzZXQuaW5kZXhPZihub2RlKSA9PSAtMSkgeyBzZXQucHVzaChub2RlKTsgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBzdGF0ZSA9IGxhYmVsZWRbc3RhdGVzLmpvaW4oXCIsXCIpXSA9IG5ldyBDb250ZW50TWF0Y2goc3RhdGVzLmluZGV4T2YobmZhLmxlbmd0aCAtIDEpID4gLTEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgc3RhdGVzJDEgPSBvdXRbaSArIDFdLnNvcnQoY21wKTtcbiAgICAgIHN0YXRlLm5leHQucHVzaChvdXRbaV0sIGxhYmVsZWRbc3RhdGVzJDEuam9pbihcIixcIildIHx8IGV4cGxvcmUoc3RhdGVzJDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKSB7XG4gIGZvciAodmFyIGkgPSAwLCB3b3JrID0gW21hdGNoXTsgaSA8IHdvcmsubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhdGUgPSB3b3JrW2ldLCBkZWFkID0gIXN0YXRlLnZhbGlkRW5kLCBub2RlcyA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RhdGUubmV4dC5sZW5ndGg7IGogKz0gMikge1xuICAgICAgdmFyIG5vZGUgPSBzdGF0ZS5uZXh0W2pdLCBuZXh0ID0gc3RhdGUubmV4dFtqICsgMV07XG4gICAgICBub2Rlcy5wdXNoKG5vZGUubmFtZSk7XG4gICAgICBpZiAoZGVhZCAmJiAhKG5vZGUuaXNUZXh0IHx8IG5vZGUuaGFzUmVxdWlyZWRBdHRycygpKSkgeyBkZWFkID0gZmFsc2U7IH1cbiAgICAgIGlmICh3b3JrLmluZGV4T2YobmV4dCkgPT0gLTEpIHsgd29yay5wdXNoKG5leHQpOyB9XG4gICAgfVxuICAgIGlmIChkZWFkKSB7IHN0cmVhbS5lcnIoXCJPbmx5IG5vbi1nZW5lcmF0YWJsZSBub2RlcyAoXCIgKyBub2Rlcy5qb2luKFwiLCBcIikgKyBcIikgaW4gYSByZXF1aXJlZCBwb3NpdGlvbiAoc2VlIGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2dlbmVyYXRhYmxlKVwiKTsgfVxuICB9XG59XG5cbi8vIEZvciBub2RlIHR5cGVzIHdoZXJlIGFsbCBhdHRycyBoYXZlIGEgZGVmYXVsdCB2YWx1ZSAob3Igd2hpY2ggZG9uJ3Rcbi8vIGhhdmUgYW55IGF0dHJpYnV0ZXMpLCBidWlsZCB1cCBhIHNpbmdsZSByZXVzYWJsZSBkZWZhdWx0IGF0dHJpYnV0ZVxuLy8gb2JqZWN0LCBhbmQgdXNlIGl0IGZvciBhbGwgbm9kZXMgdGhhdCBkb24ndCBzcGVjaWZ5IHNwZWNpZmljXG4vLyBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gZGVmYXVsdEF0dHJzKGF0dHJzKSB7XG4gIHZhciBkZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAodmFyIGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1thdHRyTmFtZV07XG4gICAgaWYgKCFhdHRyLmhhc0RlZmF1bHQpIHsgcmV0dXJuIG51bGwgfVxuICAgIGRlZmF1bHRzW2F0dHJOYW1lXSA9IGF0dHIuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gZGVmYXVsdHNcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUF0dHJzKGF0dHJzLCB2YWx1ZSkge1xuICB2YXIgYnVpbHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKHZhciBuYW1lIGluIGF0dHJzKSB7XG4gICAgdmFyIGdpdmVuID0gdmFsdWUgJiYgdmFsdWVbbmFtZV07XG4gICAgaWYgKGdpdmVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cnNbbmFtZV07XG4gICAgICBpZiAoYXR0ci5oYXNEZWZhdWx0KSB7IGdpdmVuID0gYXR0ci5kZWZhdWx0OyB9XG4gICAgICBlbHNlIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyB2YWx1ZSBzdXBwbGllZCBmb3IgYXR0cmlidXRlIFwiICsgbmFtZSkgfVxuICAgIH1cbiAgICBidWlsdFtuYW1lXSA9IGdpdmVuO1xuICB9XG4gIHJldHVybiBidWlsdFxufVxuXG5mdW5jdGlvbiBpbml0QXR0cnMoYXR0cnMpIHtcbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChhdHRycykgeyBmb3IgKHZhciBuYW1lIGluIGF0dHJzKSB7IHJlc3VsdFtuYW1lXSA9IG5ldyBBdHRyaWJ1dGUoYXR0cnNbbmFtZV0pOyB9IH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyA6Oi0gTm9kZSB0eXBlcyBhcmUgb2JqZWN0cyBhbGxvY2F0ZWQgb25jZSBwZXIgYFNjaGVtYWAgYW5kIHVzZWQgdG9cbi8vIFt0YWddKCNtb2RlbC5Ob2RlLnR5cGUpIGBOb2RlYCBpbnN0YW5jZXMuIFRoZXkgY29udGFpbiBpbmZvcm1hdGlvblxuLy8gYWJvdXQgdGhlIG5vZGUgdHlwZSwgc3VjaCBhcyBpdHMgbmFtZSBhbmQgd2hhdCBraW5kIG9mIG5vZGUgaXRcbi8vIHJlcHJlc2VudHMuXG52YXIgTm9kZVR5cGUgPSBmdW5jdGlvbiBOb2RlVHlwZShuYW1lLCBzY2hlbWEsIHNwZWMpIHtcbiAgLy8gOjogc3RyaW5nXG4gIC8vIFRoZSBuYW1lIHRoZSBub2RlIHR5cGUgaGFzIGluIHRoaXMgc2NoZW1hLlxuICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIC8vIDo6IFNjaGVtYVxuICAvLyBBIGxpbmsgYmFjayB0byB0aGUgYFNjaGVtYWAgdGhlIG5vZGUgdHlwZSBiZWxvbmdzIHRvLlxuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcblxuICAvLyA6OiBOb2RlU3BlY1xuICAvLyBUaGUgc3BlYyB0aGF0IHRoaXMgdHlwZSBpcyBiYXNlZCBvblxuICB0aGlzLnNwZWMgPSBzcGVjO1xuXG4gIHRoaXMuZ3JvdXBzID0gc3BlYy5ncm91cCA/IHNwZWMuZ3JvdXAuc3BsaXQoXCIgXCIpIDogW107XG4gIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMoc3BlYy5hdHRycyk7XG5cbiAgdGhpcy5kZWZhdWx0QXR0cnMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG5cbiAgLy8gOjogQ29udGVudE1hdGNoXG4gIC8vIFRoZSBzdGFydGluZyBtYXRjaCBvZiB0aGUgbm9kZSB0eXBlJ3MgY29udGVudCBleHByZXNzaW9uLlxuICB0aGlzLmNvbnRlbnRNYXRjaCA9IG51bGw7XG5cbiAgLy8gOiA/W01hcmtUeXBlXVxuICAvLyBUaGUgc2V0IG9mIG1hcmtzIGFsbG93ZWQgaW4gdGhpcyBub2RlLiBgbnVsbGAgbWVhbnMgYWxsIG1hcmtzXG4gIC8vIGFyZSBhbGxvd2VkLlxuICB0aGlzLm1hcmtTZXQgPSBudWxsO1xuXG4gIC8vIDo6IGJvb2xcbiAgLy8gVHJ1ZSBpZiB0aGlzIG5vZGUgdHlwZSBoYXMgaW5saW5lIGNvbnRlbnQuXG4gIHRoaXMuaW5saW5lQ29udGVudCA9IG51bGw7XG5cbiAgLy8gOjogYm9vbFxuICAvLyBUcnVlIGlmIHRoaXMgaXMgYSBibG9jayB0eXBlXG4gIHRoaXMuaXNCbG9jayA9ICEoc3BlYy5pbmxpbmUgfHwgbmFtZSA9PSBcInRleHRcIik7XG5cbiAgLy8gOjogYm9vbFxuICAvLyBUcnVlIGlmIHRoaXMgaXMgdGhlIHRleHQgbm9kZSB0eXBlLlxuICB0aGlzLmlzVGV4dCA9IG5hbWUgPT0gXCJ0ZXh0XCI7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDUgPSB7IGlzSW5saW5lOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlzVGV4dGJsb2NrOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlzTGVhZjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpc0F0b206IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuLy8gOjogYm9vbFxuLy8gVHJ1ZSBpZiB0aGlzIGlzIGFuIGlubGluZSB0eXBlLlxucHJvdG90eXBlQWNjZXNzb3JzJDUuaXNJbmxpbmUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMuaXNCbG9jayB9O1xuXG4vLyA6OiBib29sXG4vLyBUcnVlIGlmIHRoaXMgaXMgYSB0ZXh0YmxvY2sgdHlwZSwgYSBibG9jayB0aGF0IGNvbnRhaW5zIGlubGluZVxuLy8gY29udGVudC5cbnByb3RvdHlwZUFjY2Vzc29ycyQ1LmlzVGV4dGJsb2NrLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaXNCbG9jayAmJiB0aGlzLmlubGluZUNvbnRlbnQgfTtcblxuLy8gOjogYm9vbFxuLy8gVHJ1ZSBmb3Igbm9kZSB0eXBlcyB0aGF0IGFsbG93IG5vIGNvbnRlbnQuXG5wcm90b3R5cGVBY2Nlc3NvcnMkNS5pc0xlYWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250ZW50TWF0Y2ggPT0gQ29udGVudE1hdGNoLmVtcHR5IH07XG5cbi8vIDo6IGJvb2xcbi8vIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgYW4gYXRvbSwgaS5lLiB3aGVuIGl0IGRvZXMgbm90IGhhdmVcbi8vIGRpcmVjdGx5IGVkaXRhYmxlIGNvbnRlbnQuXG5wcm90b3R5cGVBY2Nlc3NvcnMkNS5pc0F0b20uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgfHwgdGhpcy5zcGVjLmF0b20gfTtcblxuLy8gOjogKCkg4oaSIGJvb2xcbi8vIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgbm9kZSB0eXBlIGhhcyBhbnkgcmVxdWlyZWQgYXR0cmlidXRlcy5cbk5vZGVUeXBlLnByb3RvdHlwZS5oYXNSZXF1aXJlZEF0dHJzID0gZnVuY3Rpb24gaGFzUmVxdWlyZWRBdHRycyAoKSB7XG4gIGZvciAodmFyIG4gaW4gdGhpcy5hdHRycykgeyBpZiAodGhpcy5hdHRyc1tuXS5pc1JlcXVpcmVkKSB7IHJldHVybiB0cnVlIH0gfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbk5vZGVUeXBlLnByb3RvdHlwZS5jb21wYXRpYmxlQ29udGVudCA9IGZ1bmN0aW9uIGNvbXBhdGlibGVDb250ZW50IChvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnRlbnRNYXRjaC5jb21wYXRpYmxlKG90aGVyLmNvbnRlbnRNYXRjaClcbn07XG5cbk5vZGVUeXBlLnByb3RvdHlwZS5jb21wdXRlQXR0cnMgPSBmdW5jdGlvbiBjb21wdXRlQXR0cnMkMSAoYXR0cnMpIHtcbiAgaWYgKCFhdHRycyAmJiB0aGlzLmRlZmF1bHRBdHRycykgeyByZXR1cm4gdGhpcy5kZWZhdWx0QXR0cnMgfVxuICBlbHNlIHsgcmV0dXJuIGNvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycykgfVxufTtcblxuLy8gOjogKD9PYmplY3QsID91bmlvbjxGcmFnbWVudCwgTm9kZSwgW05vZGVdPiwgP1tNYXJrXSkg4oaSIE5vZGVcbi8vIENyZWF0ZSBhIGBOb2RlYCBvZiB0aGlzIHR5cGUuIFRoZSBnaXZlbiBhdHRyaWJ1dGVzIGFyZVxuLy8gY2hlY2tlZCBhbmQgZGVmYXVsdGVkICh5b3UgY2FuIHBhc3MgYG51bGxgIHRvIHVzZSB0aGUgdHlwZSdzXG4vLyBkZWZhdWx0cyBlbnRpcmVseSwgaWYgbm8gcmVxdWlyZWQgYXR0cmlidXRlcyBleGlzdCkuIGBjb250ZW50YFxuLy8gbWF5IGJlIGEgYEZyYWdtZW50YCwgYSBub2RlLCBhbiBhcnJheSBvZiBub2Rlcywgb3Jcbi8vIGBudWxsYC4gU2ltaWxhcmx5IGBtYXJrc2AgbWF5IGJlIGBudWxsYCB0byBkZWZhdWx0IHRvIHRoZSBlbXB0eVxuLy8gc2V0IG9mIG1hcmtzLlxuTm9kZVR5cGUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAoYXR0cnMsIGNvbnRlbnQsIG1hcmtzKSB7XG4gIGlmICh0aGlzLmlzVGV4dCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlVHlwZS5jcmVhdGUgY2FuJ3QgY29uc3RydWN0IHRleHQgbm9kZXNcIikgfVxuICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCBNYXJrLnNldEZyb20obWFya3MpKVxufTtcblxuLy8gOjogKD9PYmplY3QsID91bmlvbjxGcmFnbWVudCwgTm9kZSwgW05vZGVdPiwgP1tNYXJrXSkg4oaSIE5vZGVcbi8vIExpa2UgW2BjcmVhdGVgXSgjbW9kZWwuTm9kZVR5cGUuY3JlYXRlKSwgYnV0IGNoZWNrIHRoZSBnaXZlbiBjb250ZW50XG4vLyBhZ2FpbnN0IHRoZSBub2RlIHR5cGUncyBjb250ZW50IHJlc3RyaWN0aW9ucywgYW5kIHRocm93IGFuIGVycm9yXG4vLyBpZiBpdCBkb2Vzbid0IG1hdGNoLlxuTm9kZVR5cGUucHJvdG90eXBlLmNyZWF0ZUNoZWNrZWQgPSBmdW5jdGlvbiBjcmVhdGVDaGVja2VkIChhdHRycywgY29udGVudCwgbWFya3MpIHtcbiAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gIGlmICghdGhpcy52YWxpZENvbnRlbnQoY29udGVudCkpXG4gICAgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY29udGVudCBmb3Igbm9kZSBcIiArIHRoaXMubmFtZSkgfVxuICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBjb250ZW50LCBNYXJrLnNldEZyb20obWFya3MpKVxufTtcblxuLy8gOjogKD9PYmplY3QsID91bmlvbjxGcmFnbWVudCwgTm9kZSwgW05vZGVdPiwgP1tNYXJrXSkg4oaSID9Ob2RlXG4vLyBMaWtlIFtgY3JlYXRlYF0oI21vZGVsLk5vZGVUeXBlLmNyZWF0ZSksIGJ1dCBzZWUgaWYgaXQgaXMgbmVjZXNzYXJ5IHRvXG4vLyBhZGQgbm9kZXMgdG8gdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgZ2l2ZW4gZnJhZ21lbnQgdG8gbWFrZSBpdFxuLy8gZml0IHRoZSBub2RlLiBJZiBubyBmaXR0aW5nIHdyYXBwaW5nIGNhbiBiZSBmb3VuZCwgcmV0dXJuIG51bGwuXG4vLyBOb3RlIHRoYXQsIGR1ZSB0byB0aGUgZmFjdCB0aGF0IHJlcXVpcmVkIG5vZGVzIGNhbiBhbHdheXMgYmVcbi8vIGNyZWF0ZWQsIHRoaXMgd2lsbCBhbHdheXMgc3VjY2VlZCBpZiB5b3UgcGFzcyBudWxsIG9yXG4vLyBgRnJhZ21lbnQuZW1wdHlgIGFzIGNvbnRlbnQuXG5Ob2RlVHlwZS5wcm90b3R5cGUuY3JlYXRlQW5kRmlsbCA9IGZ1bmN0aW9uIGNyZWF0ZUFuZEZpbGwgKGF0dHJzLCBjb250ZW50LCBtYXJrcykge1xuICBhdHRycyA9IHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKTtcbiAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gIGlmIChjb250ZW50LnNpemUpIHtcbiAgICB2YXIgYmVmb3JlID0gdGhpcy5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShjb250ZW50KTtcbiAgICBpZiAoIWJlZm9yZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgY29udGVudCA9IGJlZm9yZS5hcHBlbmQoY29udGVudCk7XG4gIH1cbiAgdmFyIGFmdGVyID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgaWYgKCFhZnRlcikgeyByZXR1cm4gbnVsbCB9XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCBhdHRycywgY29udGVudC5hcHBlbmQoYWZ0ZXIpLCBNYXJrLnNldEZyb20obWFya3MpKVxufTtcblxuLy8gOjogKEZyYWdtZW50KSDihpIgYm9vbFxuLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmcmFnbWVudCBpcyB2YWxpZCBjb250ZW50IGZvciB0aGlzIG5vZGVcbi8vIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbk5vZGVUeXBlLnByb3RvdHlwZS52YWxpZENvbnRlbnQgPSBmdW5jdGlvbiB2YWxpZENvbnRlbnQgKGNvbnRlbnQpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gIGlmICghcmVzdWx0IHx8ICFyZXN1bHQudmFsaWRFbmQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkQ291bnQ7IGkrKylcbiAgICB7IGlmICghdGhpcy5hbGxvd3NNYXJrcyhjb250ZW50LmNoaWxkKGkpLm1hcmtzKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyA6OiAoTWFya1R5cGUpIOKGkiBib29sXG4vLyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBtYXJrIHR5cGUgaXMgYWxsb3dlZCBpbiB0aGlzIG5vZGUuXG5Ob2RlVHlwZS5wcm90b3R5cGUuYWxsb3dzTWFya1R5cGUgPSBmdW5jdGlvbiBhbGxvd3NNYXJrVHlwZSAobWFya1R5cGUpIHtcbiAgcmV0dXJuIHRoaXMubWFya1NldCA9PSBudWxsIHx8IHRoaXMubWFya1NldC5pbmRleE9mKG1hcmtUeXBlKSA+IC0xXG59O1xuXG4vLyA6OiAoW01hcmtdKSDihpIgYm9vbFxuLy8gVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgYXJlIGFsbG93ZWQgaW4gdGhpcyBub2RlLlxuTm9kZVR5cGUucHJvdG90eXBlLmFsbG93c01hcmtzID0gZnVuY3Rpb24gYWxsb3dzTWFya3MgKG1hcmtzKSB7XG4gIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHsgaWYgKCF0aGlzLmFsbG93c01hcmtUeXBlKG1hcmtzW2ldLnR5cGUpKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIDo6IChbTWFya10pIOKGkiBbTWFya11cbi8vIFJlbW92ZXMgdGhlIG1hcmtzIHRoYXQgYXJlIG5vdCBhbGxvd2VkIGluIHRoaXMgbm9kZSBmcm9tIHRoZSBnaXZlbiBzZXQuXG5Ob2RlVHlwZS5wcm90b3R5cGUuYWxsb3dlZE1hcmtzID0gZnVuY3Rpb24gYWxsb3dlZE1hcmtzIChtYXJrcykge1xuICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpIHsgcmV0dXJuIG1hcmtzIH1cbiAgdmFyIGNvcHk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpIHtcbiAgICAgIGlmICghY29weSkgeyBjb3B5ID0gbWFya3Muc2xpY2UoMCwgaSk7IH1cbiAgICB9IGVsc2UgaWYgKGNvcHkpIHtcbiAgICAgIGNvcHkucHVzaChtYXJrc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAhY29weSA/IG1hcmtzIDogY29weS5sZW5ndGggPyBjb3B5IDogTWFyay5lbXB0eVxufTtcblxuTm9kZVR5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIGNvbXBpbGUgKG5vZGVzLCBzY2hlbWEpIHtcbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUsIHNwZWMpIHsgcmV0dXJuIHJlc3VsdFtuYW1lXSA9IG5ldyBOb2RlVHlwZShuYW1lLCBzY2hlbWEsIHNwZWMpOyB9KTtcblxuICB2YXIgdG9wVHlwZSA9IHNjaGVtYS5zcGVjLnRvcE5vZGUgfHwgXCJkb2NcIjtcbiAgaWYgKCFyZXN1bHRbdG9wVHlwZV0pIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTY2hlbWEgaXMgbWlzc2luZyBpdHMgdG9wIG5vZGUgdHlwZSAoJ1wiICsgdG9wVHlwZSArIFwiJylcIikgfVxuICBpZiAoIXJlc3VsdC50ZXh0KSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiRXZlcnkgc2NoZW1hIG5lZWRzIGEgJ3RleHQnIHR5cGVcIikgfVxuICBmb3IgKHZhciBfIGluIHJlc3VsdC50ZXh0LmF0dHJzKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHRleHQgbm9kZSB0eXBlIHNob3VsZCBub3QgaGF2ZSBhdHRyaWJ1dGVzXCIpIH1cblxuICByZXR1cm4gcmVzdWx0XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTm9kZVR5cGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkNSApO1xuXG4vLyBBdHRyaWJ1dGUgZGVzY3JpcHRvcnNcblxudmFyIEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZShvcHRpb25zKSB7XG4gIHRoaXMuaGFzRGVmYXVsdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcImRlZmF1bHRcIik7XG4gIHRoaXMuZGVmYXVsdCA9IG9wdGlvbnMuZGVmYXVsdDtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSQzID0geyBpc1JlcXVpcmVkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxJDMuaXNSZXF1aXJlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5oYXNEZWZhdWx0XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQXR0cmlidXRlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDEkMyApO1xuXG4vLyBNYXJrc1xuXG4vLyA6Oi0gTGlrZSBub2RlcywgbWFya3MgKHdoaWNoIGFyZSBhc3NvY2lhdGVkIHdpdGggbm9kZXMgdG8gc2lnbmlmeVxuLy8gdGhpbmdzIGxpa2UgZW1waGFzaXMgb3IgYmVpbmcgcGFydCBvZiBhIGxpbmspIGFyZVxuLy8gW3RhZ2dlZF0oI21vZGVsLk1hcmsudHlwZSkgd2l0aCB0eXBlIG9iamVjdHMsIHdoaWNoIGFyZVxuLy8gaW5zdGFudGlhdGVkIG9uY2UgcGVyIGBTY2hlbWFgLlxudmFyIE1hcmtUeXBlID0gZnVuY3Rpb24gTWFya1R5cGUobmFtZSwgcmFuaywgc2NoZW1hLCBzcGVjKSB7XG4gIC8vIDo6IHN0cmluZ1xuICAvLyBUaGUgbmFtZSBvZiB0aGUgbWFyayB0eXBlLlxuICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIC8vIDo6IFNjaGVtYVxuICAvLyBUaGUgc2NoZW1hIHRoYXQgdGhpcyBtYXJrIHR5cGUgaW5zdGFuY2UgaXMgcGFydCBvZi5cbiAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG5cbiAgLy8gOjogTWFya1NwZWNcbiAgLy8gVGhlIHNwZWMgb24gd2hpY2ggdGhlIHR5cGUgaXMgYmFzZWQuXG4gIHRoaXMuc3BlYyA9IHNwZWM7XG5cbiAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhzcGVjLmF0dHJzKTtcblxuICB0aGlzLnJhbmsgPSByYW5rO1xuICB0aGlzLmV4Y2x1ZGVkID0gbnVsbDtcbiAgdmFyIGRlZmF1bHRzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICB0aGlzLmluc3RhbmNlID0gZGVmYXVsdHMgJiYgbmV3IE1hcmsodGhpcywgZGVmYXVsdHMpO1xufTtcblxuLy8gOjogKD9PYmplY3QpIOKGkiBNYXJrXG4vLyBDcmVhdGUgYSBtYXJrIG9mIHRoaXMgdHlwZS4gYGF0dHJzYCBtYXkgYmUgYG51bGxgIG9yIGFuIG9iamVjdFxuLy8gY29udGFpbmluZyBvbmx5IHNvbWUgb2YgdGhlIG1hcmsncyBhdHRyaWJ1dGVzLiBUaGUgb3RoZXJzLCBpZlxuLy8gdGhleSBoYXZlIGRlZmF1bHRzLCB3aWxsIGJlIGFkZGVkLlxuTWFya1R5cGUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAoYXR0cnMpIHtcbiAgaWYgKCFhdHRycyAmJiB0aGlzLmluc3RhbmNlKSB7IHJldHVybiB0aGlzLmluc3RhbmNlIH1cbiAgcmV0dXJuIG5ldyBNYXJrKHRoaXMsIGNvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycykpXG59O1xuXG5NYXJrVHlwZS5jb21waWxlID0gZnVuY3Rpb24gY29tcGlsZSAobWFya3MsIHNjaGVtYSkge1xuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmFuayA9IDA7XG4gIG1hcmtzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUsIHNwZWMpIHsgcmV0dXJuIHJlc3VsdFtuYW1lXSA9IG5ldyBNYXJrVHlwZShuYW1lLCByYW5rKyssIHNjaGVtYSwgc3BlYyk7IH0pO1xuICByZXR1cm4gcmVzdWx0XG59O1xuXG4vLyA6OiAoW01hcmtdKSDihpIgW01hcmtdXG4vLyBXaGVuIHRoZXJlIGlzIGEgbWFyayBvZiB0aGlzIHR5cGUgaW4gdGhlIGdpdmVuIHNldCwgYSBuZXcgc2V0XG4vLyB3aXRob3V0IGl0IGlzIHJldHVybmVkLiBPdGhlcndpc2UsIHRoZSBpbnB1dCBzZXQgaXMgcmV0dXJuZWQuXG5NYXJrVHlwZS5wcm90b3R5cGUucmVtb3ZlRnJvbVNldCA9IGZ1bmN0aW9uIHJlbW92ZUZyb21TZXQgKHNldCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykgeyBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcykge1xuICAgIHNldCA9IHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgaS0tO1xuICB9IH1cbiAgcmV0dXJuIHNldFxufTtcblxuLy8gOjogKFtNYXJrXSkg4oaSID9NYXJrXG4vLyBUZXN0cyB3aGV0aGVyIHRoZXJlIGlzIGEgbWFyayBvZiB0aGlzIHR5cGUgaW4gdGhlIGdpdmVuIHNldC5cbk1hcmtUeXBlLnByb3RvdHlwZS5pc0luU2V0ID0gZnVuY3Rpb24gaXNJblNldCAoc2V0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgIHsgaWYgKHNldFtpXS50eXBlID09IHRoaXMpIHsgcmV0dXJuIHNldFtpXSB9IH1cbn07XG5cbi8vIDo6IChNYXJrVHlwZSkg4oaSIGJvb2xcbi8vIFF1ZXJpZXMgd2hldGhlciBhIGdpdmVuIG1hcmsgdHlwZSBpc1xuLy8gW2V4Y2x1ZGVkXSgjbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIGJ5IHRoaXMgb25lLlxuTWFya1R5cGUucHJvdG90eXBlLmV4Y2x1ZGVzID0gZnVuY3Rpb24gZXhjbHVkZXMgKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmV4Y2x1ZGVkLmluZGV4T2Yob3RoZXIpID4gLTFcbn07XG5cbi8vIFNjaGVtYVNwZWM6OiBpbnRlcmZhY2Vcbi8vIEFuIG9iamVjdCBkZXNjcmliaW5nIGEgc2NoZW1hLCBhcyBwYXNzZWQgdG8gdGhlIFtgU2NoZW1hYF0oI21vZGVsLlNjaGVtYSlcbi8vIGNvbnN0cnVjdG9yLlxuLy9cbi8vICAgbm9kZXM6OiB1bmlvbjxPYmplY3Q8Tm9kZVNwZWM+LCBPcmRlcmVkTWFwPE5vZGVTcGVjPj5cbi8vICAgVGhlIG5vZGUgdHlwZXMgaW4gdGhpcyBzY2hlbWEuIE1hcHMgbmFtZXMgdG9cbi8vICAgW2BOb2RlU3BlY2BdKCNtb2RlbC5Ob2RlU3BlYykgb2JqZWN0cyB0aGF0IGRlc2NyaWJlIHRoZSBub2RlIHR5cGVcbi8vICAgYXNzb2NpYXRlZCB3aXRoIHRoYXQgbmFtZS4gVGhlaXIgb3JkZXIgaXMgc2lnbmlmaWNhbnTigJRpdFxuLy8gICBkZXRlcm1pbmVzIHdoaWNoIFtwYXJzZSBydWxlc10oI21vZGVsLk5vZGVTcGVjLnBhcnNlRE9NKSB0YWtlXG4vLyAgIHByZWNlZGVuY2UgYnkgZGVmYXVsdCwgYW5kIHdoaWNoIG5vZGVzIGNvbWUgZmlyc3QgaW4gYSBnaXZlblxuLy8gICBbZ3JvdXBdKCNtb2RlbC5Ob2RlU3BlYy5ncm91cCkuXG4vL1xuLy8gICBtYXJrczo6ID91bmlvbjxPYmplY3Q8TWFya1NwZWM+LCBPcmRlcmVkTWFwPE1hcmtTcGVjPj5cbi8vICAgVGhlIG1hcmsgdHlwZXMgdGhhdCBleGlzdCBpbiB0aGlzIHNjaGVtYS4gVGhlIG9yZGVyIGluIHdoaWNoIHRoZXlcbi8vICAgYXJlIHByb3ZpZGVkIGRldGVybWluZXMgdGhlIG9yZGVyIGluIHdoaWNoIFttYXJrXG4vLyAgIHNldHNdKCNtb2RlbC5NYXJrLmFkZFRvU2V0KSBhcmUgc29ydGVkIGFuZCBpbiB3aGljaCBbcGFyc2Vcbi8vICAgcnVsZXNdKCNtb2RlbC5NYXJrU3BlYy5wYXJzZURPTSkgYXJlIHRyaWVkLlxuLy9cbi8vICAgdG9wTm9kZTo6ID9zdHJpbmdcbi8vICAgVGhlIG5hbWUgb2YgdGhlIGRlZmF1bHQgdG9wLWxldmVsIG5vZGUgZm9yIHRoZSBzY2hlbWEuIERlZmF1bHRzXG4vLyAgIHRvIGBcImRvY1wiYC5cblxuLy8gTm9kZVNwZWM6OiBpbnRlcmZhY2Vcbi8vXG4vLyAgIGNvbnRlbnQ6OiA/c3RyaW5nXG4vLyAgIFRoZSBjb250ZW50IGV4cHJlc3Npb24gZm9yIHRoaXMgbm9kZSwgYXMgZGVzY3JpYmVkIGluIHRoZSBbc2NoZW1hXG4vLyAgIGd1aWRlXSgvZG9jcy9ndWlkZS8jc2NoZW1hLmNvbnRlbnRfZXhwcmVzc2lvbnMpLiBXaGVuIG5vdCBnaXZlbixcbi8vICAgdGhlIG5vZGUgZG9lcyBub3QgYWxsb3cgYW55IGNvbnRlbnQuXG4vL1xuLy8gICBtYXJrczo6ID9zdHJpbmdcbi8vICAgVGhlIG1hcmtzIHRoYXQgYXJlIGFsbG93ZWQgaW5zaWRlIG9mIHRoaXMgbm9kZS4gTWF5IGJlIGFcbi8vICAgc3BhY2Utc2VwYXJhdGVkIHN0cmluZyByZWZlcnJpbmcgdG8gbWFyayBuYW1lcyBvciBncm91cHMsIGBcIl9cImBcbi8vICAgdG8gZXhwbGljaXRseSBhbGxvdyBhbGwgbWFya3MsIG9yIGBcIlwiYCB0byBkaXNhbGxvdyBtYXJrcy4gV2hlblxuLy8gICBub3QgZ2l2ZW4sIG5vZGVzIHdpdGggaW5saW5lIGNvbnRlbnQgZGVmYXVsdCB0byBhbGxvd2luZyBhbGxcbi8vICAgbWFya3MsIG90aGVyIG5vZGVzIGRlZmF1bHQgdG8gbm90IGFsbG93aW5nIG1hcmtzLlxuLy9cbi8vICAgZ3JvdXA6OiA/c3RyaW5nXG4vLyAgIFRoZSBncm91cCBvciBzcGFjZS1zZXBhcmF0ZWQgZ3JvdXBzIHRvIHdoaWNoIHRoaXMgbm9kZSBiZWxvbmdzLFxuLy8gICB3aGljaCBjYW4gYmUgcmVmZXJyZWQgdG8gaW4gdGhlIGNvbnRlbnQgZXhwcmVzc2lvbnMgZm9yIHRoZVxuLy8gICBzY2hlbWEuXG4vL1xuLy8gICBpbmxpbmU6OiA/Ym9vbFxuLy8gICBTaG91bGQgYmUgc2V0IHRvIHRydWUgZm9yIGlubGluZSBub2Rlcy4gKEltcGxpZWQgZm9yIHRleHQgbm9kZXMuKVxuLy9cbi8vICAgYXRvbTo6ID9ib29sXG4vLyAgIENhbiBiZSBzZXQgdG8gdHJ1ZSB0byBpbmRpY2F0ZSB0aGF0LCB0aG91Z2ggdGhpcyBpc24ndCBhIFtsZWFmXG4vLyAgIG5vZGVdKCNtb2RlbC5Ob2RlVHlwZS5pc0xlYWYpLCBpdCBkb2Vzbid0IGhhdmUgZGlyZWN0bHkgZWRpdGFibGVcbi8vICAgY29udGVudCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBzaW5nbGUgdW5pdCBpbiB0aGUgdmlldy5cbi8vXG4vLyAgIGF0dHJzOjogP09iamVjdDxBdHRyaWJ1dGVTcGVjPlxuLy8gICBUaGUgYXR0cmlidXRlcyB0aGF0IG5vZGVzIG9mIHRoaXMgdHlwZSBnZXQuXG4vL1xuLy8gICBzZWxlY3RhYmxlOjogP2Jvb2xcbi8vICAgQ29udHJvbHMgd2hldGhlciBub2RlcyBvZiB0aGlzIHR5cGUgY2FuIGJlIHNlbGVjdGVkIGFzIGEgW25vZGVcbi8vICAgc2VsZWN0aW9uXSgjc3RhdGUuTm9kZVNlbGVjdGlvbikuIERlZmF1bHRzIHRvIHRydWUgZm9yIG5vbi10ZXh0XG4vLyAgIG5vZGVzLlxuLy9cbi8vICAgZHJhZ2dhYmxlOjogP2Jvb2xcbi8vICAgRGV0ZXJtaW5lcyB3aGV0aGVyIG5vZGVzIG9mIHRoaXMgdHlwZSBjYW4gYmUgZHJhZ2dlZCB3aXRob3V0XG4vLyAgIGJlaW5nIHNlbGVjdGVkLiBEZWZhdWx0cyB0byBmYWxzZS5cbi8vXG4vLyAgIGNvZGU6OiA/Ym9vbFxuLy8gICBDYW4gYmUgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgbm9kZSBjb250YWlucyBjb2RlLCB3aGljaFxuLy8gICBjYXVzZXMgc29tZSBjb21tYW5kcyB0byBiZWhhdmUgZGlmZmVyZW50bHkuXG4vL1xuLy8gICBkZWZpbmluZzo6ID9ib29sXG4vLyAgIERldGVybWluZXMgd2hldGhlciB0aGlzIG5vZGUgaXMgY29uc2lkZXJlZCBhbiBpbXBvcnRhbnQgcGFyZW50XG4vLyAgIG5vZGUgZHVyaW5nIHJlcGxhY2Ugb3BlcmF0aW9ucyAoc3VjaCBhcyBwYXN0ZSkuIE5vbi1kZWZpbmluZyAodGhlXG4vLyAgIGRlZmF1bHQpIG5vZGVzIGdldCBkcm9wcGVkIHdoZW4gdGhlaXIgZW50aXJlIGNvbnRlbnQgaXMgcmVwbGFjZWQsXG4vLyAgIHdoZXJlYXMgZGVmaW5pbmcgbm9kZXMgcGVyc2lzdCBhbmQgd3JhcCB0aGUgaW5zZXJ0ZWQgY29udGVudC5cbi8vICAgTGlrZXdpc2UsIGluIF9pbnNlcnRlZF8gY29udGVudCB0aGUgZGVmaW5pbmcgcGFyZW50cyBvZiB0aGVcbi8vICAgY29udGVudCBhcmUgcHJlc2VydmVkIHdoZW4gcG9zc2libGUuIFR5cGljYWxseSxcbi8vICAgbm9uLWRlZmF1bHQtcGFyYWdyYXBoIHRleHRibG9jayB0eXBlcywgYW5kIHBvc3NpYmx5IGxpc3QgaXRlbXMsXG4vLyAgIGFyZSBtYXJrZWQgYXMgZGVmaW5pbmcuXG4vL1xuLy8gICBpc29sYXRpbmc6OiA/Ym9vbFxuLy8gICBXaGVuIGVuYWJsZWQgKGRlZmF1bHQgaXMgZmFsc2UpLCB0aGUgc2lkZXMgb2Ygbm9kZXMgb2YgdGhpcyB0eXBlXG4vLyAgIGNvdW50IGFzIGJvdW5kYXJpZXMgdGhhdCByZWd1bGFyIGVkaXRpbmcgb3BlcmF0aW9ucywgbGlrZVxuLy8gICBiYWNrc3BhY2luZyBvciBsaWZ0aW5nLCB3b24ndCBjcm9zcy4gQW4gZXhhbXBsZSBvZiBhIG5vZGUgdGhhdFxuLy8gICBzaG91bGQgcHJvYmFibHkgaGF2ZSB0aGlzIGVuYWJsZWQgaXMgYSB0YWJsZSBjZWxsLlxuLy9cbi8vICAgdG9ET006OiA/KG5vZGU6IE5vZGUpIOKGkiBET01PdXRwdXRTcGVjXG4vLyAgIERlZmluZXMgdGhlIGRlZmF1bHQgd2F5IGEgbm9kZSBvZiB0aGlzIHR5cGUgc2hvdWxkIGJlIHNlcmlhbGl6ZWRcbi8vICAgdG8gRE9NL0hUTUwgKGFzIHVzZWQgYnlcbi8vICAgW2BET01TZXJpYWxpemVyLmZyb21TY2hlbWFgXSgjbW9kZWwuRE9NU2VyaWFsaXplcl5mcm9tU2NoZW1hKSkuXG4vLyAgIFNob3VsZCByZXR1cm4gYSBET00gbm9kZSBvciBhbiBbYXJyYXlcbi8vICAgc3RydWN0dXJlXSgjbW9kZWwuRE9NT3V0cHV0U3BlYykgdGhhdCBkZXNjcmliZXMgb25lLCB3aXRoIGFuXG4vLyAgIG9wdGlvbmFsIG51bWJlciB6ZXJvICjigJxob2xl4oCdKSBpbiBpdCB0byBpbmRpY2F0ZSB3aGVyZSB0aGUgbm9kZSdzXG4vLyAgIGNvbnRlbnQgc2hvdWxkIGJlIGluc2VydGVkLlxuLy9cbi8vICAgRm9yIHRleHQgbm9kZXMsIHRoZSBkZWZhdWx0IGlzIHRvIGNyZWF0ZSBhIHRleHQgRE9NIG5vZGUuIFRob3VnaFxuLy8gICBpdCBpcyBwb3NzaWJsZSB0byBjcmVhdGUgYSBzZXJpYWxpemVyIHdoZXJlIHRleHQgaXMgcmVuZGVyZWRcbi8vICAgZGlmZmVyZW50bHksIHRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbnNpZGUgdGhlIGVkaXRvciwgc28geW91XG4vLyAgIHNob3VsZG4ndCBvdmVycmlkZSB0aGF0IGluIHlvdXIgdGV4dCBub2RlIHNwZWMuXG4vL1xuLy8gICBwYXJzZURPTTo6ID9bUGFyc2VSdWxlXVxuLy8gICBBc3NvY2lhdGVzIERPTSBwYXJzZXIgaW5mb3JtYXRpb24gd2l0aCB0aGlzIG5vZGUsIHdoaWNoIGNhbiBiZVxuLy8gICB1c2VkIGJ5IFtgRE9NUGFyc2VyLmZyb21TY2hlbWFgXSgjbW9kZWwuRE9NUGFyc2VyXmZyb21TY2hlbWEpIHRvXG4vLyAgIGF1dG9tYXRpY2FsbHkgZGVyaXZlIGEgcGFyc2VyLiBUaGUgYG5vZGVgIGZpZWxkIGluIHRoZSBydWxlcyBpc1xuLy8gICBpbXBsaWVkICh0aGUgbmFtZSBvZiB0aGlzIG5vZGUgd2lsbCBiZSBmaWxsZWQgaW4gYXV0b21hdGljYWxseSkuXG4vLyAgIElmIHlvdSBzdXBwbHkgeW91ciBvd24gcGFyc2VyLCB5b3UgZG8gbm90IG5lZWQgdG8gYWxzbyBzcGVjaWZ5XG4vLyAgIHBhcnNpbmcgcnVsZXMgaW4geW91ciBzY2hlbWEuXG4vL1xuLy8gICB0b0RlYnVnU3RyaW5nOjogPyhub2RlOiBOb2RlKSAtPiBzdHJpbmdcbi8vICAgRGVmaW5lcyB0aGUgZGVmYXVsdCB3YXkgYSBub2RlIG9mIHRoaXMgdHlwZSBzaG91bGQgYmUgc2VyaWFsaXplZFxuLy8gICB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgZGVidWdnaW5nIChlLmcuIGluIGVycm9yIG1lc3NhZ2VzKS5cblxuLy8gTWFya1NwZWM6OiBpbnRlcmZhY2Vcbi8vXG4vLyAgIGF0dHJzOjogP09iamVjdDxBdHRyaWJ1dGVTcGVjPlxuLy8gICBUaGUgYXR0cmlidXRlcyB0aGF0IG1hcmtzIG9mIHRoaXMgdHlwZSBnZXQuXG4vL1xuLy8gICBpbmNsdXNpdmU6OiA/Ym9vbFxuLy8gICBXaGV0aGVyIHRoaXMgbWFyayBzaG91bGQgYmUgYWN0aXZlIHdoZW4gdGhlIGN1cnNvciBpcyBwb3NpdGlvbmVkXG4vLyAgIGF0IGl0cyBlbmQgKG9yIGF0IGl0cyBzdGFydCB3aGVuIHRoYXQgaXMgYWxzbyB0aGUgc3RhcnQgb2YgdGhlXG4vLyAgIHBhcmVudCBub2RlKS4gRGVmYXVsdHMgdG8gdHJ1ZS5cbi8vXG4vLyAgIGV4Y2x1ZGVzOjogP3N0cmluZ1xuLy8gICBEZXRlcm1pbmVzIHdoaWNoIG90aGVyIG1hcmtzIHRoaXMgbWFyayBjYW4gY29leGlzdCB3aXRoLiBTaG91bGRcbi8vICAgYmUgYSBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5ncyBuYW1pbmcgb3RoZXIgbWFya3Mgb3IgZ3JvdXBzIG9mIG1hcmtzLlxuLy8gICBXaGVuIGEgbWFyayBpcyBbYWRkZWRdKCNtb2RlbC5NYXJrLmFkZFRvU2V0KSB0byBhIHNldCwgYWxsIG1hcmtzXG4vLyAgIHRoYXQgaXQgZXhjbHVkZXMgYXJlIHJlbW92ZWQgaW4gdGhlIHByb2Nlc3MuIElmIHRoZSBzZXQgY29udGFpbnNcbi8vICAgYW55IG1hcmsgdGhhdCBleGNsdWRlcyB0aGUgbmV3IG1hcmsgYnV0IGlzIG5vdCwgaXRzZWxmLCBleGNsdWRlZFxuLy8gICBieSB0aGUgbmV3IG1hcmssIHRoZSBtYXJrIGNhbiBub3QgYmUgYWRkZWQgYW4gdGhlIHNldC4gWW91IGNhblxuLy8gICB1c2UgdGhlIHZhbHVlIGBcIl9cImAgdG8gaW5kaWNhdGUgdGhhdCB0aGUgbWFyayBleGNsdWRlcyBhbGxcbi8vICAgbWFya3MgaW4gdGhlIHNjaGVtYS5cbi8vXG4vLyAgIERlZmF1bHRzIHRvIG9ubHkgYmVpbmcgZXhjbHVzaXZlIHdpdGggbWFya3Mgb2YgdGhlIHNhbWUgdHlwZS4gWW91XG4vLyAgIGNhbiBzZXQgaXQgdG8gYW4gZW1wdHkgc3RyaW5nIChvciBhbnkgc3RyaW5nIG5vdCBjb250YWluaW5nIHRoZVxuLy8gICBtYXJrJ3Mgb3duIG5hbWUpIHRvIGFsbG93IG11bHRpcGxlIG1hcmtzIG9mIGEgZ2l2ZW4gdHlwZSB0b1xuLy8gICBjb2V4aXN0IChhcyBsb25nIGFzIHRoZXkgaGF2ZSBkaWZmZXJlbnQgYXR0cmlidXRlcykuXG4vL1xuLy8gICBncm91cDo6ID9zdHJpbmdcbi8vICAgVGhlIGdyb3VwIG9yIHNwYWNlLXNlcGFyYXRlZCBncm91cHMgdG8gd2hpY2ggdGhpcyBtYXJrIGJlbG9uZ3MuXG4vL1xuLy8gICBzcGFubmluZzo6ID9ib29sXG4vLyAgIERldGVybWluZXMgd2hldGhlciBtYXJrcyBvZiB0aGlzIHR5cGUgY2FuIHNwYW4gbXVsdGlwbGUgYWRqYWNlbnRcbi8vICAgbm9kZXMgd2hlbiBzZXJpYWxpemVkIHRvIERPTS9IVE1MLiBEZWZhdWx0cyB0byB0cnVlLlxuLy9cbi8vICAgdG9ET006OiA/KG1hcms6IE1hcmssIGlubGluZTogYm9vbCkg4oaSIERPTU91dHB1dFNwZWNcbi8vICAgRGVmaW5lcyB0aGUgZGVmYXVsdCB3YXkgbWFya3Mgb2YgdGhpcyB0eXBlIHNob3VsZCBiZSBzZXJpYWxpemVkXG4vLyAgIHRvIERPTS9IVE1MLiBXaGVuIHRoZSByZXN1bHRpbmcgc3BlYyBjb250YWlucyBhIGhvbGUsIHRoYXQgaXNcbi8vICAgd2hlcmUgdGhlIG1hcmtlZCBjb250ZW50IGlzIHBsYWNlZC4gT3RoZXJ3aXNlLCBpdCBpcyBhcHBlbmRlZCB0b1xuLy8gICB0aGUgdG9wIG5vZGUuXG4vL1xuLy8gICBwYXJzZURPTTo6ID9bUGFyc2VSdWxlXVxuLy8gICBBc3NvY2lhdGVzIERPTSBwYXJzZXIgaW5mb3JtYXRpb24gd2l0aCB0aGlzIG1hcmsgKHNlZSB0aGVcbi8vICAgY29ycmVzcG9uZGluZyBbbm9kZSBzcGVjIGZpZWxkXSgjbW9kZWwuTm9kZVNwZWMucGFyc2VET00pKS4gVGhlXG4vLyAgIGBtYXJrYCBmaWVsZCBpbiB0aGUgcnVsZXMgaXMgaW1wbGllZC5cblxuLy8gQXR0cmlidXRlU3BlYzo6IGludGVyZmFjZVxuLy9cbi8vIFVzZWQgdG8gW2RlZmluZV0oI21vZGVsLk5vZGVTcGVjLmF0dHJzKSBhdHRyaWJ1dGVzIG9uIG5vZGVzIG9yXG4vLyBtYXJrcy5cbi8vXG4vLyAgIGRlZmF1bHQ6OiA/YW55XG4vLyAgIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIGF0dHJpYnV0ZSwgdG8gdXNlIHdoZW4gbm8gZXhwbGljaXRcbi8vICAgdmFsdWUgaXMgcHJvdmlkZWQuIEF0dHJpYnV0ZXMgdGhhdCBoYXZlIG5vIGRlZmF1bHQgbXVzdCBiZVxuLy8gICBwcm92aWRlZCB3aGVuZXZlciBhIG5vZGUgb3IgbWFyayBvZiBhIHR5cGUgdGhhdCBoYXMgdGhlbSBpc1xuLy8gICBjcmVhdGVkLlxuXG4vLyA6Oi0gQSBkb2N1bWVudCBzY2hlbWEuIEhvbGRzIFtub2RlXSgjbW9kZWwuTm9kZVR5cGUpIGFuZCBbbWFya1xuLy8gdHlwZV0oI21vZGVsLk1hcmtUeXBlKSBvYmplY3RzIGZvciB0aGUgbm9kZXMgYW5kIG1hcmtzIHRoYXQgbWF5XG4vLyBvY2N1ciBpbiBjb25mb3JtaW5nIGRvY3VtZW50cywgYW5kIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yXG4vLyBjcmVhdGluZyBhbmQgZGVzZXJpYWxpemluZyBzdWNoIGRvY3VtZW50cy5cbnZhciBTY2hlbWEgPSBmdW5jdGlvbiBTY2hlbWEoc3BlYykge1xuICAvLyA6OiBTY2hlbWFTcGVjXG4gIC8vIFRoZSBbc3BlY10oI21vZGVsLlNjaGVtYVNwZWMpIG9uIHdoaWNoIHRoZSBzY2hlbWEgaXMgYmFzZWQsXG4gIC8vIHdpdGggdGhlIGFkZGVkIGd1YXJhbnRlZSB0aGF0IGl0cyBgbm9kZXNgIGFuZCBgbWFya3NgXG4gIC8vIHByb3BlcnRpZXMgYXJlXG4gIC8vIFtgT3JkZXJlZE1hcGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL29yZGVyZWRtYXApIGluc3RhbmNlc1xuICAvLyAobm90IHJhdyBvYmplY3RzKS5cbiAgdGhpcy5zcGVjID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc3BlYykgeyB0aGlzLnNwZWNbcHJvcF0gPSBzcGVjW3Byb3BdOyB9XG4gIHRoaXMuc3BlYy5ub2RlcyA9IE9yZGVyZWRNYXAuZnJvbShzcGVjLm5vZGVzKTtcbiAgdGhpcy5zcGVjLm1hcmtzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubWFya3MpO1xuXG4gIC8vIDo6IE9iamVjdDxOb2RlVHlwZT5cbiAgLy8gQW4gb2JqZWN0IG1hcHBpbmcgdGhlIHNjaGVtYSdzIG5vZGUgbmFtZXMgdG8gbm9kZSB0eXBlIG9iamVjdHMuXG4gIHRoaXMubm9kZXMgPSBOb2RlVHlwZS5jb21waWxlKHRoaXMuc3BlYy5ub2RlcywgdGhpcyk7XG5cbiAgLy8gOjogT2JqZWN0PE1hcmtUeXBlPlxuICAvLyBBIG1hcCBmcm9tIG1hcmsgbmFtZXMgdG8gbWFyayB0eXBlIG9iamVjdHMuXG4gIHRoaXMubWFya3MgPSBNYXJrVHlwZS5jb21waWxlKHRoaXMuc3BlYy5tYXJrcywgdGhpcyk7XG5cbiAgdmFyIGNvbnRlbnRFeHByQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKHZhciBwcm9wJDEgaW4gdGhpcy5ub2Rlcykge1xuICAgIGlmIChwcm9wJDEgaW4gdGhpcy5tYXJrcylcbiAgICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IocHJvcCQxICsgXCIgY2FuIG5vdCBiZSBib3RoIGEgbm9kZSBhbmQgYSBtYXJrXCIpIH1cbiAgICB2YXIgdHlwZSA9IHRoaXMubm9kZXNbcHJvcCQxXSwgY29udGVudEV4cHIgPSB0eXBlLnNwZWMuY29udGVudCB8fCBcIlwiLCBtYXJrRXhwciA9IHR5cGUuc3BlYy5tYXJrcztcbiAgICB0eXBlLmNvbnRlbnRNYXRjaCA9IGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdIHx8XG4gICAgICAoY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gPSBDb250ZW50TWF0Y2gucGFyc2UoY29udGVudEV4cHIsIHRoaXMubm9kZXMpKTtcbiAgICB0eXBlLmlubGluZUNvbnRlbnQgPSB0eXBlLmNvbnRlbnRNYXRjaC5pbmxpbmVDb250ZW50O1xuICAgIHR5cGUubWFya1NldCA9IG1hcmtFeHByID09IFwiX1wiID8gbnVsbCA6XG4gICAgICBtYXJrRXhwciA/IGdhdGhlck1hcmtzKHRoaXMsIG1hcmtFeHByLnNwbGl0KFwiIFwiKSkgOlxuICAgICAgbWFya0V4cHIgPT0gXCJcIiB8fCAhdHlwZS5pbmxpbmVDb250ZW50ID8gW10gOiBudWxsO1xuICB9XG4gIGZvciAodmFyIHByb3AkMiBpbiB0aGlzLm1hcmtzKSB7XG4gICAgdmFyIHR5cGUkMSA9IHRoaXMubWFya3NbcHJvcCQyXSwgZXhjbCA9IHR5cGUkMS5zcGVjLmV4Y2x1ZGVzO1xuICAgIHR5cGUkMS5leGNsdWRlZCA9IGV4Y2wgPT0gbnVsbCA/IFt0eXBlJDFdIDogZXhjbCA9PSBcIlwiID8gW10gOiBnYXRoZXJNYXJrcyh0aGlzLCBleGNsLnNwbGl0KFwiIFwiKSk7XG4gIH1cblxuICB0aGlzLm5vZGVGcm9tSlNPTiA9IHRoaXMubm9kZUZyb21KU09OLmJpbmQodGhpcyk7XG4gIHRoaXMubWFya0Zyb21KU09OID0gdGhpcy5tYXJrRnJvbUpTT04uYmluZCh0aGlzKTtcblxuICAvLyA6OiBOb2RlVHlwZVxuICAvLyBUaGUgdHlwZSBvZiB0aGUgW2RlZmF1bHQgdG9wIG5vZGVdKCNtb2RlbC5TY2hlbWFTcGVjLnRvcE5vZGUpXG4gIC8vIGZvciB0aGlzIHNjaGVtYS5cbiAgdGhpcy50b3BOb2RlVHlwZSA9IHRoaXMubm9kZXNbdGhpcy5zcGVjLnRvcE5vZGUgfHwgXCJkb2NcIl07XG5cbiAgLy8gOjogT2JqZWN0XG4gIC8vIEFuIG9iamVjdCBmb3Igc3RvcmluZyB3aGF0ZXZlciB2YWx1ZXMgbW9kdWxlcyBtYXkgd2FudCB0b1xuICAvLyBjb21wdXRlIGFuZCBjYWNoZSBwZXIgc2NoZW1hLiAoSWYgeW91IHdhbnQgdG8gc3RvcmUgc29tZXRoaW5nXG4gIC8vIGluIGl0LCB0cnkgdG8gdXNlIHByb3BlcnR5IG5hbWVzIHVubGlrZWx5IHRvIGNsYXNoLilcbiAgdGhpcy5jYWNoZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLmNhY2hlZC53cmFwcGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufTtcblxuLy8gOjogKHVuaW9uPHN0cmluZywgTm9kZVR5cGU+LCA/T2JqZWN0LCA/dW5pb248RnJhZ21lbnQsIE5vZGUsIFtOb2RlXT4sID9bTWFya10pIOKGkiBOb2RlXG4vLyBDcmVhdGUgYSBub2RlIGluIHRoaXMgc2NoZW1hLiBUaGUgYHR5cGVgIG1heSBiZSBhIHN0cmluZyBvciBhXG4vLyBgTm9kZVR5cGVgIGluc3RhbmNlLiBBdHRyaWJ1dGVzIHdpbGwgYmUgZXh0ZW5kZWRcbi8vIHdpdGggZGVmYXVsdHMsIGBjb250ZW50YCBtYXkgYmUgYSBgRnJhZ21lbnRgLFxuLy8gYG51bGxgLCBhIGBOb2RlYCwgb3IgYW4gYXJyYXkgb2Ygbm9kZXMuXG5TY2hlbWEucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiBub2RlICh0eXBlLCBhdHRycywgY29udGVudCwgbWFya3MpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpXG4gICAgeyB0eXBlID0gdGhpcy5ub2RlVHlwZSh0eXBlKTsgfVxuICBlbHNlIGlmICghKHR5cGUgaW5zdGFuY2VvZiBOb2RlVHlwZSkpXG4gICAgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbm9kZSB0eXBlOiBcIiArIHR5cGUpIH1cbiAgZWxzZSBpZiAodHlwZS5zY2hlbWEgIT0gdGhpcylcbiAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGZyb20gZGlmZmVyZW50IHNjaGVtYSB1c2VkIChcIiArIHR5cGUubmFtZSArIFwiKVwiKSB9XG5cbiAgcmV0dXJuIHR5cGUuY3JlYXRlQ2hlY2tlZChhdHRycywgY29udGVudCwgbWFya3MpXG59O1xuXG4vLyA6OiAoc3RyaW5nLCA/W01hcmtdKSDihpIgTm9kZVxuLy8gQ3JlYXRlIGEgdGV4dCBub2RlIGluIHRoZSBzY2hlbWEuIEVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdFxuLy8gYWxsb3dlZC5cblNjaGVtYS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uIHRleHQgKHRleHQkMSwgbWFya3MpIHtcbiAgdmFyIHR5cGUgPSB0aGlzLm5vZGVzLnRleHQ7XG4gIHJldHVybiBuZXcgVGV4dE5vZGUodHlwZSwgdHlwZS5kZWZhdWx0QXR0cnMsIHRleHQkMSwgTWFyay5zZXRGcm9tKG1hcmtzKSlcbn07XG5cbi8vIDo6ICh1bmlvbjxzdHJpbmcsIE1hcmtUeXBlPiwgP09iamVjdCkg4oaSIE1hcmtcbi8vIENyZWF0ZSBhIG1hcmsgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgYXR0cmlidXRlcy5cblNjaGVtYS5wcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uIG1hcmsgKHR5cGUsIGF0dHJzKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKSB7IHR5cGUgPSB0aGlzLm1hcmtzW3R5cGVdOyB9XG4gIHJldHVybiB0eXBlLmNyZWF0ZShhdHRycylcbn07XG5cbi8vIDo6IChPYmplY3QpIOKGkiBOb2RlXG4vLyBEZXNlcmlhbGl6ZSBhIG5vZGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgaXNcbi8vIGJvdW5kLlxuU2NoZW1hLnByb3RvdHlwZS5ub2RlRnJvbUpTT04gPSBmdW5jdGlvbiBub2RlRnJvbUpTT04gKGpzb24pIHtcbiAgcmV0dXJuIE5vZGUuZnJvbUpTT04odGhpcywganNvbilcbn07XG5cbi8vIDo6IChPYmplY3QpIOKGkiBNYXJrXG4vLyBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgaXNcbi8vIGJvdW5kLlxuU2NoZW1hLnByb3RvdHlwZS5tYXJrRnJvbUpTT04gPSBmdW5jdGlvbiBtYXJrRnJvbUpTT04gKGpzb24pIHtcbiAgcmV0dXJuIE1hcmsuZnJvbUpTT04odGhpcywganNvbilcbn07XG5cblNjaGVtYS5wcm90b3R5cGUubm9kZVR5cGUgPSBmdW5jdGlvbiBub2RlVHlwZSAobmFtZSkge1xuICB2YXIgZm91bmQgPSB0aGlzLm5vZGVzW25hbWVdO1xuICBpZiAoIWZvdW5kKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsgbmFtZSkgfVxuICByZXR1cm4gZm91bmRcbn07XG5cbmZ1bmN0aW9uIGdhdGhlck1hcmtzKHNjaGVtYSwgbWFya3MpIHtcbiAgdmFyIGZvdW5kID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IG1hcmtzW2ldLCBtYXJrID0gc2NoZW1hLm1hcmtzW25hbWVdLCBvayA9IG1hcms7XG4gICAgaWYgKG1hcmspIHtcbiAgICAgIGZvdW5kLnB1c2gobWFyayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc2NoZW1hLm1hcmtzKSB7XG4gICAgICAgIHZhciBtYXJrJDEgPSBzY2hlbWEubWFya3NbcHJvcF07XG4gICAgICAgIGlmIChuYW1lID09IFwiX1wiIHx8IChtYXJrJDEuc3BlYy5ncm91cCAmJiBtYXJrJDEuc3BlYy5ncm91cC5zcGxpdChcIiBcIikuaW5kZXhPZihuYW1lKSA+IC0xKSlcbiAgICAgICAgICB7IGZvdW5kLnB1c2gob2sgPSBtYXJrJDEpOyB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghb2spIHsgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5rbm93biBtYXJrIHR5cGU6ICdcIiArIG1hcmtzW2ldICsgXCInXCIpIH1cbiAgfVxuICByZXR1cm4gZm91bmRcbn1cblxuLy8gUGFyc2VPcHRpb25zOjogaW50ZXJmYWNlXG4vLyBUaGVzZSBhcmUgdGhlIG9wdGlvbnMgcmVjb2duaXplZCBieSB0aGVcbi8vIFtgcGFyc2VgXSgjbW9kZWwuRE9NUGFyc2VyLnBhcnNlKSBhbmRcbi8vIFtgcGFyc2VTbGljZWBdKCNtb2RlbC5ET01QYXJzZXIucGFyc2VTbGljZSkgbWV0aG9kcy5cbi8vXG4vLyAgIHByZXNlcnZlV2hpdGVzcGFjZTo6ID91bmlvbjxib29sLCBcImZ1bGxcIj5cbi8vICAgQnkgZGVmYXVsdCwgd2hpdGVzcGFjZSBpcyBjb2xsYXBzZWQgYXMgcGVyIEhUTUwncyBydWxlcy4gUGFzc1xuLy8gICBgdHJ1ZWAgdG8gcHJlc2VydmUgd2hpdGVzcGFjZSwgYnV0IG5vcm1hbGl6ZSBuZXdsaW5lcyB0b1xuLy8gICBzcGFjZXMsIGFuZCBgXCJmdWxsXCJgIHRvIHByZXNlcnZlIHdoaXRlc3BhY2UgZW50aXJlbHkuXG4vL1xuLy8gICBmaW5kUG9zaXRpb25zOjogP1t7bm9kZTogZG9tLk5vZGUsIG9mZnNldDogbnVtYmVyfV1cbi8vICAgV2hlbiBnaXZlbiwgdGhlIHBhcnNlciB3aWxsLCBiZXNpZGUgcGFyc2luZyB0aGUgY29udGVudCxcbi8vICAgcmVjb3JkIHRoZSBkb2N1bWVudCBwb3NpdGlvbnMgb2YgdGhlIGdpdmVuIERPTSBwb3NpdGlvbnMuIEl0XG4vLyAgIHdpbGwgZG8gc28gYnkgd3JpdGluZyB0byB0aGUgb2JqZWN0cywgYWRkaW5nIGEgYHBvc2AgcHJvcGVydHlcbi8vICAgdGhhdCBob2xkcyB0aGUgZG9jdW1lbnQgcG9zaXRpb24uIERPTSBwb3NpdGlvbnMgdGhhdCBhcmUgbm90XG4vLyAgIGluIHRoZSBwYXJzZWQgY29udGVudCB3aWxsIG5vdCBiZSB3cml0dGVuIHRvLlxuLy9cbi8vICAgZnJvbTo6ID9udW1iZXJcbi8vICAgVGhlIGNoaWxkIG5vZGUgaW5kZXggdG8gc3RhcnQgcGFyc2luZyBmcm9tLlxuLy9cbi8vICAgdG86OiA/bnVtYmVyXG4vLyAgIFRoZSBjaGlsZCBub2RlIGluZGV4IHRvIHN0b3AgcGFyc2luZyBhdC5cbi8vXG4vLyAgIHRvcE5vZGU6OiA/Tm9kZVxuLy8gICBCeSBkZWZhdWx0LCB0aGUgY29udGVudCBpcyBwYXJzZWQgaW50byB0aGUgc2NoZW1hJ3MgZGVmYXVsdFxuLy8gICBbdG9wIG5vZGUgdHlwZV0oI21vZGVsLlNjaGVtYS50b3BOb2RlVHlwZSkuIFlvdSBjYW4gcGFzcyB0aGlzXG4vLyAgIG9wdGlvbiB0byB1c2UgdGhlIHR5cGUgYW5kIGF0dHJpYnV0ZXMgZnJvbSBhIGRpZmZlcmVudCBub2RlXG4vLyAgIGFzIHRoZSB0b3AgY29udGFpbmVyLlxuLy9cbi8vICAgdG9wTWF0Y2g6OiA/Q29udGVudE1hdGNoXG4vLyAgIFByb3ZpZGUgdGhlIHN0YXJ0aW5nIGNvbnRlbnQgbWF0Y2ggdGhhdCBjb250ZW50IHBhcnNlZCBpbnRvIHRoZVxuLy8gICB0b3Agbm9kZSBpcyBtYXRjaGVkIGFnYWluc3QuXG4vL1xuLy8gICBjb250ZXh0OjogP1Jlc29sdmVkUG9zXG4vLyAgIEEgc2V0IG9mIGFkZGl0aW9uYWwgbm9kZXMgdG8gY291bnQgYXNcbi8vICAgW2NvbnRleHRdKCNtb2RlbC5QYXJzZVJ1bGUuY29udGV4dCkgd2hlbiBwYXJzaW5nLCBhYm92ZSB0aGVcbi8vICAgZ2l2ZW4gW3RvcCBub2RlXSgjbW9kZWwuUGFyc2VPcHRpb25zLnRvcE5vZGUpLlxuXG4vLyBQYXJzZVJ1bGU6OiBpbnRlcmZhY2Vcbi8vIEEgdmFsdWUgdGhhdCBkZXNjcmliZXMgaG93IHRvIHBhcnNlIGEgZ2l2ZW4gRE9NIG5vZGUgb3IgaW5saW5lXG4vLyBzdHlsZSBhcyBhIFByb3NlTWlycm9yIG5vZGUgb3IgbWFyay5cbi8vXG4vLyAgIHRhZzo6ID9zdHJpbmdcbi8vICAgQSBDU1Mgc2VsZWN0b3IgZGVzY3JpYmluZyB0aGUga2luZCBvZiBET00gZWxlbWVudHMgdG8gbWF0Y2guIEFcbi8vICAgc2luZ2xlIHJ1bGUgc2hvdWxkIGhhdmUgX2VpdGhlcl8gYSBgdGFnYCBvciBhIGBzdHlsZWAgcHJvcGVydHkuXG4vL1xuLy8gICBuYW1lc3BhY2U6OiA/c3RyaW5nXG4vLyAgIFRoZSBuYW1lc3BhY2UgdG8gbWF0Y2guIFRoaXMgc2hvdWxkIGJlIHVzZWQgd2l0aCBgdGFnYC5cbi8vICAgTm9kZXMgYXJlIG9ubHkgbWF0Y2hlZCB3aGVuIHRoZSBuYW1lc3BhY2UgbWF0Y2hlcyBvciB0aGlzIHByb3BlcnR5XG4vLyAgIGlzIG51bGwuXG4vL1xuLy8gICBzdHlsZTo6ID9zdHJpbmdcbi8vICAgQSBDU1MgcHJvcGVydHkgbmFtZSB0byBtYXRjaC4gV2hlbiBnaXZlbiwgdGhpcyBydWxlIG1hdGNoZXNcbi8vICAgaW5saW5lIHN0eWxlcyB0aGF0IGxpc3QgdGhhdCBwcm9wZXJ0eS4gTWF5IGFsc28gaGF2ZSB0aGUgZm9ybVxuLy8gICBgXCJwcm9wZXJ0eT12YWx1ZVwiYCwgaW4gd2hpY2ggY2FzZSB0aGUgcnVsZSBvbmx5IG1hdGNoZXMgaWYgdGhlXG4vLyAgIHByb3BlcnR5J3MgdmFsdWUgZXhhY3RseSBtYXRjaGVzIHRoZSBnaXZlbiB2YWx1ZS4gKEZvciBtb3JlXG4vLyAgIGNvbXBsaWNhdGVkIGZpbHRlcnMsIHVzZSBbYGdldEF0dHJzYF0oI21vZGVsLlBhcnNlUnVsZS5nZXRBdHRycylcbi8vICAgYW5kIHJldHVybiBmYWxzZSB0byBpbmRpY2F0ZSB0aGF0IHRoZSBtYXRjaCBmYWlsZWQuKSBSdWxlc1xuLy8gICBtYXRjaGluZyBzdHlsZXMgbWF5IG9ubHkgcHJvZHVjZSBbbWFya3NdKCNtb2RlbC5QYXJzZVJ1bGUubWFyayksXG4vLyAgIG5vdCBub2Rlcy5cbi8vXG4vLyAgIHByaW9yaXR5OjogP251bWJlclxuLy8gICBDYW4gYmUgdXNlZCB0byBjaGFuZ2UgdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBwYXJzZSBydWxlcyBpbiBhXG4vLyAgIHNjaGVtYSBhcmUgdHJpZWQuIFRob3NlIHdpdGggaGlnaGVyIHByaW9yaXR5IGNvbWUgZmlyc3QuIFJ1bGVzXG4vLyAgIHdpdGhvdXQgYSBwcmlvcml0eSBhcmUgY291bnRlZCBhcyBoYXZpbmcgcHJpb3JpdHkgNTAuIFRoaXNcbi8vICAgcHJvcGVydHkgaXMgb25seSBtZWFuaW5nZnVsIGluIGEgc2NoZW1h4oCUd2hlbiBkaXJlY3RseVxuLy8gICBjb25zdHJ1Y3RpbmcgYSBwYXJzZXIsIHRoZSBvcmRlciBvZiB0aGUgcnVsZSBhcnJheSBpcyB1c2VkLlxuLy9cbi8vICAgY29uc3VtaW5nOjogP2Jvb2xlYW5cbi8vICAgQnkgZGVmYXVsdCwgd2hlbiBhIHJ1bGUgbWF0Y2hlcyBhbiBlbGVtZW50IG9yIHN0eWxlLCBubyBmdXJ0aGVyXG4vLyAgIHJ1bGVzIGdldCBhIGNoYW5jZSB0byBtYXRjaCBpdC4gQnkgc2V0dGluZyB0aGlzIHRvIGBmYWxzZWAsIHlvdVxuLy8gICBpbmRpY2F0ZSB0aGF0IGV2ZW4gd2hlbiB0aGlzIHJ1bGUgbWF0Y2hlcywgb3RoZXIgcnVsZXMgdGhhdCBjb21lXG4vLyAgIGFmdGVyIGl0IHNob3VsZCBhbHNvIHJ1bi5cbi8vXG4vLyAgIGNvbnRleHQ6OiA/c3RyaW5nXG4vLyAgIFdoZW4gZ2l2ZW4sIHJlc3RyaWN0cyB0aGlzIHJ1bGUgdG8gb25seSBtYXRjaCB3aGVuIHRoZSBjdXJyZW50XG4vLyAgIGNvbnRleHTigJR0aGUgcGFyZW50IG5vZGVzIGludG8gd2hpY2ggdGhlIGNvbnRlbnQgaXMgYmVpbmdcbi8vICAgcGFyc2Vk4oCUbWF0Y2hlcyB0aGlzIGV4cHJlc3Npb24uIFNob3VsZCBjb250YWluIG9uZSBvciBtb3JlIG5vZGVcbi8vICAgbmFtZXMgb3Igbm9kZSBncm91cCBuYW1lcyBmb2xsb3dlZCBieSBzaW5nbGUgb3IgZG91YmxlIHNsYXNoZXMuXG4vLyAgIEZvciBleGFtcGxlIGBcInBhcmFncmFwaC9cImAgbWVhbnMgdGhlIHJ1bGUgb25seSBtYXRjaGVzIHdoZW4gdGhlXG4vLyAgIHBhcmVudCBub2RlIGlzIGEgcGFyYWdyYXBoLCBgXCJibG9ja3F1b3RlL3BhcmFncmFwaC9cImAgcmVzdHJpY3RzXG4vLyAgIGl0IHRvIGJlIGluIGEgcGFyYWdyYXBoIHRoYXQgaXMgaW5zaWRlIGEgYmxvY2txdW90ZSwgYW5kXG4vLyAgIGBcInNlY3Rpb24vL1wiYCBtYXRjaGVzIGFueSBwb3NpdGlvbiBpbnNpZGUgYSBzZWN0aW9u4oCUYSBkb3VibGVcbi8vICAgc2xhc2ggbWF0Y2hlcyBhbnkgc2VxdWVuY2Ugb2YgYW5jZXN0b3Igbm9kZXMuIFRvIGFsbG93IG11bHRpcGxlXG4vLyAgIGRpZmZlcmVudCBjb250ZXh0cywgdGhleSBjYW4gYmUgc2VwYXJhdGVkIGJ5IGEgcGlwZSAoYHxgKVxuLy8gICBjaGFyYWN0ZXIsIGFzIGluIGBcImJsb2NrcXVvdGUvfGxpc3RfaXRlbS9cImAuXG4vL1xuLy8gICBub2RlOjogP3N0cmluZ1xuLy8gICBUaGUgbmFtZSBvZiB0aGUgbm9kZSB0eXBlIHRvIGNyZWF0ZSB3aGVuIHRoaXMgcnVsZSBtYXRjaGVzLiBPbmx5XG4vLyAgIHZhbGlkIGZvciBydWxlcyB3aXRoIGEgYHRhZ2AgcHJvcGVydHksIG5vdCBmb3Igc3R5bGUgcnVsZXMuIEVhY2hcbi8vICAgcnVsZSBzaG91bGQgaGF2ZSBvbmUgb2YgYSBgbm9kZWAsIGBtYXJrYCwgb3IgYGlnbm9yZWAgcHJvcGVydHlcbi8vICAgKGV4Y2VwdCB3aGVuIGl0IGFwcGVhcnMgaW4gYSBbbm9kZV0oI21vZGVsLk5vZGVTcGVjLnBhcnNlRE9NKSBvclxuLy8gICBbbWFyayBzcGVjXSgjbW9kZWwuTWFya1NwZWMucGFyc2VET00pLCBpbiB3aGljaCBjYXNlIHRoZSBgbm9kZWBcbi8vICAgb3IgYG1hcmtgIHByb3BlcnR5IHdpbGwgYmUgZGVyaXZlZCBmcm9tIGl0cyBwb3NpdGlvbikuXG4vL1xuLy8gICBtYXJrOjogP3N0cmluZ1xuLy8gICBUaGUgbmFtZSBvZiB0aGUgbWFyayB0eXBlIHRvIHdyYXAgdGhlIG1hdGNoZWQgY29udGVudCBpbi5cbi8vXG4vLyAgIGlnbm9yZTo6ID9ib29sXG4vLyAgIFdoZW4gdHJ1ZSwgaWdub3JlIGNvbnRlbnQgdGhhdCBtYXRjaGVzIHRoaXMgcnVsZS5cbi8vXG4vLyAgIGNsb3NlUGFyZW50OjogP2Jvb2xcbi8vICAgV2hlbiB0cnVlLCBmaW5kaW5nIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoaXMgcnVsZSB3aWxsIGNsb3NlXG4vLyAgIHRoZSBjdXJyZW50IG5vZGUuXG4vL1xuLy8gICBza2lwOjogP2Jvb2xcbi8vICAgV2hlbiB0cnVlLCBpZ25vcmUgdGhlIG5vZGUgdGhhdCBtYXRjaGVzIHRoaXMgcnVsZSwgYnV0IGRvIHBhcnNlXG4vLyAgIGl0cyBjb250ZW50LlxuLy9cbi8vICAgYXR0cnM6OiA/T2JqZWN0XG4vLyAgIEF0dHJpYnV0ZXMgZm9yIHRoZSBub2RlIG9yIG1hcmsgY3JlYXRlZCBieSB0aGlzIHJ1bGUuIFdoZW5cbi8vICAgYGdldEF0dHJzYCBpcyBwcm92aWRlZCwgaXQgdGFrZXMgcHJlY2VkZW5jZS5cbi8vXG4vLyAgIGdldEF0dHJzOjogPyh1bmlvbjxkb20uTm9kZSwgc3RyaW5nPikg4oaSID91bmlvbjxPYmplY3QsIGZhbHNlPlxuLy8gICBBIGZ1bmN0aW9uIHVzZWQgdG8gY29tcHV0ZSB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIG5vZGUgb3IgbWFya1xuLy8gICBjcmVhdGVkIGJ5IHRoaXMgcnVsZS4gQ2FuIGFsc28gYmUgdXNlZCB0byBkZXNjcmliZSBmdXJ0aGVyXG4vLyAgIGNvbmRpdGlvbnMgdGhlIERPTSBlbGVtZW50IG9yIHN0eWxlIG11c3QgbWF0Y2guIFdoZW4gaXQgcmV0dXJuc1xuLy8gICBgZmFsc2VgLCB0aGUgcnVsZSB3b24ndCBtYXRjaC4gV2hlbiBpdCByZXR1cm5zIG51bGwgb3IgdW5kZWZpbmVkLFxuLy8gICB0aGF0IGlzIGludGVycHJldGVkIGFzIGFuIGVtcHR5L2RlZmF1bHQgc2V0IG9mIGF0dHJpYnV0ZXMuXG4vL1xuLy8gICBDYWxsZWQgd2l0aCBhIERPTSBFbGVtZW50IGZvciBgdGFnYCBydWxlcywgYW5kIHdpdGggYSBzdHJpbmcgKHRoZVxuLy8gICBzdHlsZSdzIHZhbHVlKSBmb3IgYHN0eWxlYCBydWxlcy5cbi8vXG4vLyAgIGNvbnRlbnRFbGVtZW50OjogP3VuaW9uPHN0cmluZywgKGRvbS5Ob2RlKSDihpIgZG9tLk5vZGU+XG4vLyAgIEZvciBgdGFnYCBydWxlcyB0aGF0IHByb2R1Y2Ugbm9uLWxlYWYgbm9kZXMgb3IgbWFya3MsIGJ5IGRlZmF1bHRcbi8vICAgdGhlIGNvbnRlbnQgb2YgdGhlIERPTSBlbGVtZW50IGlzIHBhcnNlZCBhcyBjb250ZW50IG9mIHRoZSBtYXJrXG4vLyAgIG9yIG5vZGUuIElmIHRoZSBjaGlsZCBub2RlcyBhcmUgaW4gYSBkZXNjZW5kZW50IG5vZGUsIHRoaXMgbWF5IGJlXG4vLyAgIGEgQ1NTIHNlbGVjdG9yIHN0cmluZyB0aGF0IHRoZSBwYXJzZXIgbXVzdCB1c2UgdG8gZmluZCB0aGUgYWN0dWFsXG4vLyAgIGNvbnRlbnQgZWxlbWVudCwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGFjdHVhbCBjb250ZW50XG4vLyAgIGVsZW1lbnQgdG8gdGhlIHBhcnNlci5cbi8vXG4vLyAgIGdldENvbnRlbnQ6OiA/KGRvbS5Ob2RlLCBzY2hlbWE6IFNjaGVtYSkg4oaSIEZyYWdtZW50XG4vLyAgIENhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIHRoZSBjb250ZW50IG9mIGEgbWF0Y2hlZCBub2RlLiBXaGVuXG4vLyAgIHByZXNlbnQsIGluc3RlYWQgb2YgcGFyc2luZyB0aGUgbm9kZSdzIGNoaWxkIG5vZGVzLCB0aGUgcmVzdWx0IG9mXG4vLyAgIHRoaXMgZnVuY3Rpb24gaXMgdXNlZC5cbi8vXG4vLyAgIHByZXNlcnZlV2hpdGVzcGFjZTo6ID91bmlvbjxib29sLCBcImZ1bGxcIj5cbi8vICAgQ29udHJvbHMgd2hldGhlciB3aGl0ZXNwYWNlIHNob3VsZCBiZSBwcmVzZXJ2ZWQgd2hlbiBwYXJzaW5nIHRoZVxuLy8gICBjb250ZW50IGluc2lkZSB0aGUgbWF0Y2hlZCBlbGVtZW50LiBgZmFsc2VgIG1lYW5zIHdoaXRlc3BhY2UgbWF5XG4vLyAgIGJlIGNvbGxhcHNlZCwgYHRydWVgIG1lYW5zIHRoYXQgd2hpdGVzcGFjZSBzaG91bGQgYmUgcHJlc2VydmVkXG4vLyAgIGJ1dCBuZXdsaW5lcyBub3JtYWxpemVkIHRvIHNwYWNlcywgYW5kIGBcImZ1bGxcImAgbWVhbnMgdGhhdFxuLy8gICBuZXdsaW5lcyBzaG91bGQgYWxzbyBiZSBwcmVzZXJ2ZWQuXG5cbi8vIDo6LSBBIERPTSBwYXJzZXIgcmVwcmVzZW50cyBhIHN0cmF0ZWd5IGZvciBwYXJzaW5nIERPTSBjb250ZW50IGludG9cbi8vIGEgUHJvc2VNaXJyb3IgZG9jdW1lbnQgY29uZm9ybWluZyB0byBhIGdpdmVuIHNjaGVtYS4gSXRzIGJlaGF2aW9yXG4vLyBpcyBkZWZpbmVkIGJ5IGFuIGFycmF5IG9mIFtydWxlc10oI21vZGVsLlBhcnNlUnVsZSkuXG52YXIgRE9NUGFyc2VyID0gZnVuY3Rpb24gRE9NUGFyc2VyKHNjaGVtYSwgcnVsZXMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gOjogU2NoZW1hXG4gIC8vIFRoZSBzY2hlbWEgaW50byB3aGljaCB0aGUgcGFyc2VyIHBhcnNlcy5cbiAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIC8vIDo6IFtQYXJzZVJ1bGVdXG4gIC8vIFRoZSBzZXQgb2YgW3BhcnNlIHJ1bGVzXSgjbW9kZWwuUGFyc2VSdWxlKSB0aGF0IHRoZSBwYXJzZXJcbiAgLy8gdXNlcywgaW4gb3JkZXIgb2YgcHJlY2VkZW5jZS5cbiAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICB0aGlzLnRhZ3MgPSBbXTtcbiAgdGhpcy5zdHlsZXMgPSBbXTtcblxuICBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgaWYgKHJ1bGUudGFnKSB7IHRoaXMkMS50YWdzLnB1c2gocnVsZSk7IH1cbiAgICBlbHNlIGlmIChydWxlLnN0eWxlKSB7IHRoaXMkMS5zdHlsZXMucHVzaChydWxlKTsgfVxuICB9KTtcblxuICAvLyBPbmx5IG5vcm1hbGl6ZSBsaXN0IGVsZW1lbnRzIHdoZW4gbGlzdHMgaW4gdGhlIHNjaGVtYSBjYW4ndCBkaXJlY3RseSBjb250YWluIHRoZW1zZWx2ZXNcbiAgdGhpcy5ub3JtYWxpemVMaXN0cyA9ICF0aGlzLnRhZ3Muc29tZShmdW5jdGlvbiAocikge1xuICAgIGlmICghL14odWx8b2wpXFxiLy50ZXN0KHIudGFnKSB8fCAhci5ub2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIG5vZGUgPSBzY2hlbWEubm9kZXNbci5ub2RlXTtcbiAgICByZXR1cm4gbm9kZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKG5vZGUpXG4gIH0pO1xufTtcblxuLy8gOjogKGRvbS5Ob2RlLCA/UGFyc2VPcHRpb25zKSDihpIgTm9kZVxuLy8gUGFyc2UgYSBkb2N1bWVudCBmcm9tIHRoZSBjb250ZW50IG9mIGEgRE9NIG5vZGUuXG5ET01QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGRvbSwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIHZhciBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCBmYWxzZSk7XG4gIGNvbnRleHQuYWRkQWxsKGRvbSwgbnVsbCwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgcmV0dXJuIGNvbnRleHQuZmluaXNoKClcbn07XG5cbi8vIDo6IChkb20uTm9kZSwgP1BhcnNlT3B0aW9ucykg4oaSIFNsaWNlXG4vLyBQYXJzZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGdpdmVuIERPTSBub2RlLCBsaWtlXG4vLyBbYHBhcnNlYF0oI21vZGVsLkRPTVBhcnNlci5wYXJzZSksIGFuZCB0YWtlcyB0aGUgc2FtZSBzZXQgb2Zcbi8vIG9wdGlvbnMuIEJ1dCB1bmxpa2UgdGhhdCBtZXRob2QsIHdoaWNoIHByb2R1Y2VzIGEgd2hvbGUgbm9kZSxcbi8vIHRoaXMgb25lIHJldHVybnMgYSBzbGljZSB0aGF0IGlzIG9wZW4gYXQgdGhlIHNpZGVzLCBtZWFuaW5nIHRoYXRcbi8vIHRoZSBzY2hlbWEgY29uc3RyYWludHMgYXJlbid0IGFwcGxpZWQgdG8gdGhlIHN0YXJ0IG9mIG5vZGVzIHRvXG4vLyB0aGUgbGVmdCBvZiB0aGUgaW5wdXQgYW5kIHRoZSBlbmQgb2Ygbm9kZXMgYXQgdGhlIGVuZC5cbkRPTVBhcnNlci5wcm90b3R5cGUucGFyc2VTbGljZSA9IGZ1bmN0aW9uIHBhcnNlU2xpY2UgKGRvbSwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIHZhciBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCB0cnVlKTtcbiAgY29udGV4dC5hZGRBbGwoZG9tLCBudWxsLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICByZXR1cm4gU2xpY2UubWF4T3Blbihjb250ZXh0LmZpbmlzaCgpKVxufTtcblxuRE9NUGFyc2VyLnByb3RvdHlwZS5tYXRjaFRhZyA9IGZ1bmN0aW9uIG1hdGNoVGFnIChkb20sIGNvbnRleHQsIGFmdGVyKSB7XG4gIGZvciAodmFyIGkgPSBhZnRlciA/IHRoaXMudGFncy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJ1bGUgPSB0aGlzLnRhZ3NbaV07XG4gICAgaWYgKG1hdGNoZXMoZG9tLCBydWxlLnRhZykgJiZcbiAgICAgICAgKHJ1bGUubmFtZXNwYWNlID09PSB1bmRlZmluZWQgfHwgZG9tLm5hbWVzcGFjZVVSSSA9PSBydWxlLm5hbWVzcGFjZSkgJiZcbiAgICAgICAgKCFydWxlLmNvbnRleHQgfHwgY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpKSkge1xuICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnMoZG9tKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHsgY29udGludWUgfVxuICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ1bGVcbiAgICB9XG4gIH1cbn07XG5cbkRPTVBhcnNlci5wcm90b3R5cGUubWF0Y2hTdHlsZSA9IGZ1bmN0aW9uIG1hdGNoU3R5bGUgKHByb3AsIHZhbHVlLCBjb250ZXh0LCBhZnRlcikge1xuICBmb3IgKHZhciBpID0gYWZ0ZXIgPyB0aGlzLnN0eWxlcy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy5zdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcnVsZSA9IHRoaXMuc3R5bGVzW2ldO1xuICAgIGlmIChydWxlLnN0eWxlLmluZGV4T2YocHJvcCkgIT0gMCB8fFxuICAgICAgICBydWxlLmNvbnRleHQgJiYgIWNvbnRleHQubWF0Y2hlc0NvbnRleHQocnVsZS5jb250ZXh0KSB8fFxuICAgICAgICAvLyBUZXN0IHRoYXQgdGhlIHN0eWxlIHN0cmluZyBlaXRoZXIgcHJlY2lzZWx5IG1hdGNoZXMgdGhlIHByb3AsXG4gICAgICAgIC8vIG9yIGhhcyBhbiAnPScgc2lnbiBhZnRlciB0aGUgcHJvcCwgZm9sbG93ZWQgYnkgdGhlIGdpdmVuXG4gICAgICAgIC8vIHZhbHVlLlxuICAgICAgICBydWxlLnN0eWxlLmxlbmd0aCA+IHByb3AubGVuZ3RoICYmXG4gICAgICAgIChydWxlLnN0eWxlLmNoYXJDb2RlQXQocHJvcC5sZW5ndGgpICE9IDYxIHx8IHJ1bGUuc3R5bGUuc2xpY2UocHJvcC5sZW5ndGggKyAxKSAhPSB2YWx1ZSkpXG4gICAgICB7IGNvbnRpbnVlIH1cbiAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgdmFyIHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnModmFsdWUpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHsgY29udGludWUgfVxuICAgICAgcnVsZS5hdHRycyA9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVcbiAgfVxufTtcblxuLy8gOiAoU2NoZW1hKSDihpIgW1BhcnNlUnVsZV1cbkRPTVBhcnNlci5zY2hlbWFSdWxlcyA9IGZ1bmN0aW9uIHNjaGVtYVJ1bGVzIChzY2hlbWEpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmdW5jdGlvbiBpbnNlcnQocnVsZSkge1xuICAgIHZhciBwcmlvcml0eSA9IHJ1bGUucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogcnVsZS5wcmlvcml0eSwgaSA9IDA7XG4gICAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gcmVzdWx0W2ldLCBuZXh0UHJpb3JpdHkgPSBuZXh0LnByaW9yaXR5ID09IG51bGwgPyA1MCA6IG5leHQucHJpb3JpdHk7XG4gICAgICBpZiAobmV4dFByaW9yaXR5IDwgcHJpb3JpdHkpIHsgYnJlYWsgfVxuICAgIH1cbiAgICByZXN1bHQuc3BsaWNlKGksIDAsIHJ1bGUpO1xuICB9XG5cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG4gICAgdmFyIHJ1bGVzID0gc2NoZW1hLm1hcmtzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgaWYgKHJ1bGVzKSB7IHJ1bGVzLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICBydWxlLm1hcmsgPSBuYW1lO1xuICAgIH0pOyB9XG4gIH07XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHNjaGVtYS5tYXJrcykgbG9vcCggbmFtZSApO1xuICB2YXIgbG9vcCQxID0gZnVuY3Rpb24gKCBuYW1lICkge1xuICAgIHZhciBydWxlcyQxID0gc2NoZW1hLm5vZGVzW25hbWUkMV0uc3BlYy5wYXJzZURPTTtcbiAgICBpZiAocnVsZXMkMSkgeyBydWxlcyQxLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICBydWxlLm5vZGUgPSBuYW1lJDE7XG4gICAgfSk7IH1cbiAgfTtcblxuICAgIGZvciAodmFyIG5hbWUkMSBpbiBzY2hlbWEubm9kZXMpIGxvb3AkMSgpO1xuICByZXR1cm4gcmVzdWx0XG59O1xuXG4vLyA6OiAoU2NoZW1hKSDihpIgRE9NUGFyc2VyXG4vLyBDb25zdHJ1Y3QgYSBET00gcGFyc2VyIHVzaW5nIHRoZSBwYXJzaW5nIHJ1bGVzIGxpc3RlZCBpbiBhXG4vLyBzY2hlbWEncyBbbm9kZSBzcGVjc10oI21vZGVsLk5vZGVTcGVjLnBhcnNlRE9NKSwgcmVvcmRlcmVkIGJ5XG4vLyBbcHJpb3JpdHldKCNtb2RlbC5QYXJzZVJ1bGUucHJpb3JpdHkpLlxuRE9NUGFyc2VyLmZyb21TY2hlbWEgPSBmdW5jdGlvbiBmcm9tU2NoZW1hIChzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyIHx8XG4gICAgKHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyID0gbmV3IERPTVBhcnNlcihzY2hlbWEsIERPTVBhcnNlci5zY2hlbWFSdWxlcyhzY2hlbWEpKSlcbn07XG5cbi8vIDogT2JqZWN0PGJvb2w+IFRoZSBibG9jay1sZXZlbCB0YWdzIGluIEhUTUw1XG52YXIgYmxvY2tUYWdzID0ge1xuICBhZGRyZXNzOiB0cnVlLCBhcnRpY2xlOiB0cnVlLCBhc2lkZTogdHJ1ZSwgYmxvY2txdW90ZTogdHJ1ZSwgY2FudmFzOiB0cnVlLFxuICBkZDogdHJ1ZSwgZGl2OiB0cnVlLCBkbDogdHJ1ZSwgZmllbGRzZXQ6IHRydWUsIGZpZ2NhcHRpb246IHRydWUsIGZpZ3VyZTogdHJ1ZSxcbiAgZm9vdGVyOiB0cnVlLCBmb3JtOiB0cnVlLCBoMTogdHJ1ZSwgaDI6IHRydWUsIGgzOiB0cnVlLCBoNDogdHJ1ZSwgaDU6IHRydWUsXG4gIGg2OiB0cnVlLCBoZWFkZXI6IHRydWUsIGhncm91cDogdHJ1ZSwgaHI6IHRydWUsIGxpOiB0cnVlLCBub3NjcmlwdDogdHJ1ZSwgb2w6IHRydWUsXG4gIG91dHB1dDogdHJ1ZSwgcDogdHJ1ZSwgcHJlOiB0cnVlLCBzZWN0aW9uOiB0cnVlLCB0YWJsZTogdHJ1ZSwgdGZvb3Q6IHRydWUsIHVsOiB0cnVlXG59O1xuXG4vLyA6IE9iamVjdDxib29sPiBUaGUgdGFncyB0aGF0IHdlIG5vcm1hbGx5IGlnbm9yZS5cbnZhciBpZ25vcmVUYWdzID0ge1xuICBoZWFkOiB0cnVlLCBub3NjcmlwdDogdHJ1ZSwgb2JqZWN0OiB0cnVlLCBzY3JpcHQ6IHRydWUsIHN0eWxlOiB0cnVlLCB0aXRsZTogdHJ1ZVxufTtcblxuLy8gOiBPYmplY3Q8Ym9vbD4gTGlzdCB0YWdzLlxudmFyIGxpc3RUYWdzID0ge29sOiB0cnVlLCB1bDogdHJ1ZX07XG5cbi8vIFVzaW5nIGEgYml0ZmllbGQgZm9yIG5vZGUgY29udGV4dCBvcHRpb25zXG52YXIgT1BUX1BSRVNFUlZFX1dTID0gMSwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgPSAyLCBPUFRfT1BFTl9MRUZUID0gNDtcblxuZnVuY3Rpb24gd3NPcHRpb25zRm9yKHByZXNlcnZlV2hpdGVzcGFjZSkge1xuICByZXR1cm4gKHByZXNlcnZlV2hpdGVzcGFjZSA/IE9QVF9QUkVTRVJWRV9XUyA6IDApIHwgKHByZXNlcnZlV2hpdGVzcGFjZSA9PT0gXCJmdWxsXCIgPyBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IDApXG59XG5cbnZhciBOb2RlQ29udGV4dCA9IGZ1bmN0aW9uIE5vZGVDb250ZXh0KHR5cGUsIGF0dHJzLCBtYXJrcywgcGVuZGluZ01hcmtzLCBzb2xpZCwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICB0aGlzLnNvbGlkID0gc29saWQ7XG4gIHRoaXMubWF0Y2ggPSBtYXRjaCB8fCAob3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQgPyBudWxsIDogdHlwZS5jb250ZW50TWF0Y2gpO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgLy8gTWFya3MgYXBwbGllZCB0byB0aGlzIG5vZGUgaXRzZWxmXG4gIHRoaXMubWFya3MgPSBtYXJrcztcbiAgLy8gTWFya3MgYXBwbGllZCB0byBpdHMgY2hpbGRyZW5cbiAgdGhpcy5hY3RpdmVNYXJrcyA9IE1hcmsubm9uZTtcbiAgLy8gTWFya3MgdGhhdCBjYW4ndCBhcHBseSBoZXJlLCBidXQgd2lsbCBiZSB1c2VkIGluIGNoaWxkcmVuIGlmIHBvc3NpYmxlXG4gIHRoaXMucGVuZGluZ01hcmtzID0gcGVuZGluZ01hcmtzO1xuICAvLyBOZXN0ZWQgTWFya3Mgd2l0aCBzYW1lIHR5cGVcbiAgdGhpcy5zdGFzaE1hcmtzID0gW107XG59O1xuXG5Ob2RlQ29udGV4dC5wcm90b3R5cGUuZmluZFdyYXBwaW5nID0gZnVuY3Rpb24gZmluZFdyYXBwaW5nIChub2RlKSB7XG4gIGlmICghdGhpcy5tYXRjaCkge1xuICAgIGlmICghdGhpcy50eXBlKSB7IHJldHVybiBbXSB9XG4gICAgdmFyIGZpbGwgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgaWYgKGZpbGwpIHtcbiAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZmlsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gsIHdyYXA7XG4gICAgICBpZiAod3JhcCA9IHN0YXJ0LmZpbmRXcmFwcGluZyhub2RlLnR5cGUpKSB7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBzdGFydDtcbiAgICAgICAgcmV0dXJuIHdyYXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLm1hdGNoLmZpbmRXcmFwcGluZyhub2RlLnR5cGUpXG59O1xuXG5Ob2RlQ29udGV4dC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoIChvcGVuRW5kKSB7XG4gIGlmICghKHRoaXMub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHsgLy8gU3RyaXAgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgIHZhciBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSwgbTtcbiAgICBpZiAobGFzdCAmJiBsYXN0LmlzVGV4dCAmJiAobSA9IC9bIFxcdFxcclxcblxcdTAwMGNdKyQvLmV4ZWMobGFzdC50ZXh0KSkpIHtcbiAgICAgIGlmIChsYXN0LnRleHQubGVuZ3RoID09IG1bMF0ubGVuZ3RoKSB7IHRoaXMuY29udGVudC5wb3AoKTsgfVxuICAgICAgZWxzZSB7IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gPSBsYXN0LndpdGhUZXh0KGxhc3QudGV4dC5zbGljZSgwLCBsYXN0LnRleHQubGVuZ3RoIC0gbVswXS5sZW5ndGgpKTsgfVxuICAgIH1cbiAgfVxuICB2YXIgY29udGVudCA9IEZyYWdtZW50LmZyb20odGhpcy5jb250ZW50KTtcbiAgaWYgKCFvcGVuRW5kICYmIHRoaXMubWF0Y2gpXG4gICAgeyBjb250ZW50ID0gY29udGVudC5hcHBlbmQodGhpcy5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7IH1cbiAgcmV0dXJuIHRoaXMudHlwZSA/IHRoaXMudHlwZS5jcmVhdGUodGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcykgOiBjb250ZW50XG59O1xuXG5Ob2RlQ29udGV4dC5wcm90b3R5cGUucG9wRnJvbVN0YXNoTWFyayA9IGZ1bmN0aW9uIHBvcEZyb21TdGFzaE1hcmsgKG1hcmspIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuc3Rhc2hNYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICB7IGlmIChtYXJrLmVxKHRoaXMuc3Rhc2hNYXJrc1tpXSkpIHsgcmV0dXJuIHRoaXMuc3Rhc2hNYXJrcy5zcGxpY2UoaSwgMSlbMF0gfSB9XG59O1xuXG5Ob2RlQ29udGV4dC5wcm90b3R5cGUuYXBwbHlQZW5kaW5nID0gZnVuY3Rpb24gYXBwbHlQZW5kaW5nIChuZXh0VHlwZSkge1xuICBmb3IgKHZhciBpID0gMCwgcGVuZGluZyA9IHRoaXMucGVuZGluZ01hcmtzOyBpIDwgcGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXJrID0gcGVuZGluZ1tpXTtcbiAgICBpZiAoKHRoaXMudHlwZSA/IHRoaXMudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpIDogbWFya01heUFwcGx5KG1hcmsudHlwZSwgbmV4dFR5cGUpKSAmJlxuICAgICAgICAhbWFyay5pc0luU2V0KHRoaXMuYWN0aXZlTWFya3MpKSB7XG4gICAgICB0aGlzLmFjdGl2ZU1hcmtzID0gbWFyay5hZGRUb1NldCh0aGlzLmFjdGl2ZU1hcmtzKTtcbiAgICAgIHRoaXMucGVuZGluZ01hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KHRoaXMucGVuZGluZ01hcmtzKTtcbiAgICB9XG4gIH1cbn07XG5cbk5vZGVDb250ZXh0LnByb3RvdHlwZS5pbmxpbmVDb250ZXh0ID0gZnVuY3Rpb24gaW5saW5lQ29udGV4dCAobm9kZSkge1xuICBpZiAodGhpcy50eXBlKSB7IHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudCB9XG4gIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKSB7IHJldHVybiB0aGlzLmNvbnRlbnRbMF0uaXNJbmxpbmUgfVxuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlICYmICFibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpXG59O1xuXG52YXIgUGFyc2VDb250ZXh0ID0gZnVuY3Rpb24gUGFyc2VDb250ZXh0KHBhcnNlciwgb3B0aW9ucywgb3Blbikge1xuICAvLyA6IERPTVBhcnNlciBUaGUgcGFyc2VyIHdlIGFyZSB1c2luZy5cbiAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIC8vIDogT2JqZWN0IFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGlzIHBhcnNlLlxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmlzT3BlbiA9IG9wZW47XG4gIHZhciB0b3BOb2RlID0gb3B0aW9ucy50b3BOb2RlLCB0b3BDb250ZXh0O1xuICB2YXIgdG9wT3B0aW9ucyA9IHdzT3B0aW9uc0ZvcihvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSkgfCAob3BlbiA/IE9QVF9PUEVOX0xFRlQgOiAwKTtcbiAgaWYgKHRvcE5vZGUpXG4gICAgeyB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHRvcE5vZGUudHlwZSwgdG9wTm9kZS5hdHRycywgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRvcE1hdGNoIHx8IHRvcE5vZGUudHlwZS5jb250ZW50TWF0Y2gsIHRvcE9wdGlvbnMpOyB9XG4gIGVsc2UgaWYgKG9wZW4pXG4gICAgeyB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KG51bGwsIG51bGwsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTsgfVxuICBlbHNlXG4gICAgeyB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHBhcnNlci5zY2hlbWEudG9wTm9kZVR5cGUsIG51bGwsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTsgfVxuICB0aGlzLm5vZGVzID0gW3RvcENvbnRleHRdO1xuICAvLyA6IFtNYXJrXSBUaGUgY3VycmVudCBzZXQgb2YgbWFya3NcbiAgdGhpcy5vcGVuID0gMDtcbiAgdGhpcy5maW5kID0gb3B0aW9ucy5maW5kUG9zaXRpb25zO1xuICB0aGlzLm5lZWRzQmxvY2sgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkNiA9IHsgdG9wOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGN1cnJlbnRQb3M6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDYudG9wLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNbdGhpcy5vcGVuXVxufTtcblxuLy8gOiAoZG9tLk5vZGUpXG4vLyBBZGQgYSBET00gbm9kZSB0byB0aGUgY29udGVudC4gVGV4dCBpcyBpbnNlcnRlZCBhcyB0ZXh0IG5vZGUsXG4vLyBvdGhlcndpc2UsIHRoZSBub2RlIGlzIHBhc3NlZCB0byBgYWRkRWxlbWVudGAgb3IsIGlmIGl0IGhhcyBhXG4vLyBgc3R5bGVgIGF0dHJpYnV0ZSwgYGFkZEVsZW1lbnRXaXRoU3R5bGVzYC5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuYWRkRE9NID0gZnVuY3Rpb24gYWRkRE9NIChkb20pIHtcbiAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgdGhpcy5hZGRUZXh0Tm9kZShkb20pO1xuICB9IGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgdmFyIHN0eWxlID0gZG9tLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIHZhciBtYXJrcyA9IHN0eWxlID8gdGhpcy5yZWFkU3R5bGVzKHBhcnNlU3R5bGVzKHN0eWxlKSkgOiBudWxsLCB0b3AgPSB0aGlzLnRvcDtcbiAgICBpZiAobWFya3MgIT0gbnVsbCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7IHRoaXMuYWRkUGVuZGluZ01hcmsobWFya3NbaV0pOyB9IH1cbiAgICB0aGlzLmFkZEVsZW1lbnQoZG9tKTtcbiAgICBpZiAobWFya3MgIT0gbnVsbCkgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBtYXJrcy5sZW5ndGg7IGkkMSsrKSB7IHRoaXMucmVtb3ZlUGVuZGluZ01hcmsobWFya3NbaSQxXSwgdG9wKTsgfSB9XG4gIH1cbn07XG5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuYWRkVGV4dE5vZGUgPSBmdW5jdGlvbiBhZGRUZXh0Tm9kZSAoZG9tKSB7XG4gIHZhciB2YWx1ZSA9IGRvbS5ub2RlVmFsdWU7XG4gIHZhciB0b3AgPSB0aGlzLnRvcDtcbiAgaWYgKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgfHxcbiAgICAgIHRvcC5pbmxpbmVDb250ZXh0KGRvbSkgfHxcbiAgICAgIC9bXiBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkpIHtcbiAgICBpZiAoISh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvWyBcXHRcXHJcXG5cXHUwMDBjXSsvZywgXCIgXCIpO1xuICAgICAgLy8gSWYgdGhpcyBzdGFydHMgd2l0aCB3aGl0ZXNwYWNlLCBhbmQgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUgaXQsIG9yXG4gICAgICAvLyBhIGhhcmQgYnJlYWssIG9yIGEgdGV4dCBub2RlIHRoYXQgZW5kcyB3aXRoIHdoaXRlc3BhY2UsIHN0cmlwIHRoZVxuICAgICAgLy8gbGVhZGluZyBzcGFjZS5cbiAgICAgIGlmICgvXlsgXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpICYmIHRoaXMub3BlbiA9PSB0aGlzLm5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdmFyIG5vZGVCZWZvcmUgPSB0b3AuY29udGVudFt0b3AuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGRvbU5vZGVCZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGVCZWZvcmUgfHxcbiAgICAgICAgICAgIChkb21Ob2RlQmVmb3JlICYmIGRvbU5vZGVCZWZvcmUubm9kZU5hbWUgPT0gJ0JSJykgfHxcbiAgICAgICAgICAgIChub2RlQmVmb3JlLmlzVGV4dCAmJiAvWyBcXHRcXHJcXG5cXHUwMDBjXSQvLnRlc3Qobm9kZUJlZm9yZS50ZXh0KSkpXG4gICAgICAgICAgeyB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTX0ZVTEwpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csIFwiIFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHsgdGhpcy5pbnNlcnROb2RlKHRoaXMucGFyc2VyLnNjaGVtYS50ZXh0KHZhbHVlKSk7IH1cbiAgICB0aGlzLmZpbmRJblRleHQoZG9tKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgfVxufTtcblxuLy8gOiAoZG9tLkVsZW1lbnQsID9QYXJzZVJ1bGUpXG4vLyBUcnkgdG8gZmluZCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiB0YWcgYW5kIHVzZSB0aGF0IHRvIHBhcnNlLiBJZlxuLy8gbm9uZSBpcyBmb3VuZCwgdGhlIGVsZW1lbnQncyBjb250ZW50IG5vZGVzIGFyZSBhZGRlZCBkaXJlY3RseS5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuYWRkRWxlbWVudCA9IGZ1bmN0aW9uIGFkZEVsZW1lbnQgKGRvbSwgbWF0Y2hBZnRlcikge1xuICB2YXIgbmFtZSA9IGRvbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBydWxlSUQ7XG4gIGlmIChsaXN0VGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB0aGlzLnBhcnNlci5ub3JtYWxpemVMaXN0cykgeyBub3JtYWxpemVMaXN0KGRvbSk7IH1cbiAgdmFyIHJ1bGUgPSAodGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZSAmJiB0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlKGRvbSkpIHx8XG4gICAgICAocnVsZUlEID0gdGhpcy5wYXJzZXIubWF0Y2hUYWcoZG9tLCB0aGlzLCBtYXRjaEFmdGVyKSk7XG4gIGlmIChydWxlID8gcnVsZS5pZ25vcmUgOiBpZ25vcmVUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgdGhpcy5pZ25vcmVGYWxsYmFjayhkb20pO1xuICB9IGVsc2UgaWYgKCFydWxlIHx8IHJ1bGUuc2tpcCB8fCBydWxlLmNsb3NlUGFyZW50KSB7XG4gICAgaWYgKHJ1bGUgJiYgcnVsZS5jbG9zZVBhcmVudCkgeyB0aGlzLm9wZW4gPSBNYXRoLm1heCgwLCB0aGlzLm9wZW4gLSAxKTsgfVxuICAgIGVsc2UgaWYgKHJ1bGUgJiYgcnVsZS5za2lwLm5vZGVUeXBlKSB7IGRvbSA9IHJ1bGUuc2tpcDsgfVxuICAgIHZhciBzeW5jLCB0b3AgPSB0aGlzLnRvcCwgb2xkTmVlZHNCbG9jayA9IHRoaXMubmVlZHNCbG9jaztcbiAgICBpZiAoYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBzeW5jID0gdHJ1ZTtcbiAgICAgIGlmICghdG9wLnR5cGUpIHsgdGhpcy5uZWVkc0Jsb2NrID0gdHJ1ZTsgfVxuICAgIH0gZWxzZSBpZiAoIWRvbS5maXJzdENoaWxkKSB7XG4gICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20pO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuYWRkQWxsKGRvbSk7XG4gICAgaWYgKHN5bmMpIHsgdGhpcy5zeW5jKHRvcCk7IH1cbiAgICB0aGlzLm5lZWRzQmxvY2sgPSBvbGROZWVkc0Jsb2NrO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSA/IHJ1bGVJRCA6IG51bGwpO1xuICB9XG59O1xuXG4vLyBDYWxsZWQgZm9yIGxlYWYgRE9NIG5vZGVzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGJlIGlnbm9yZWRcblBhcnNlQ29udGV4dC5wcm90b3R5cGUubGVhZkZhbGxiYWNrID0gZnVuY3Rpb24gbGVhZkZhbGxiYWNrIChkb20pIHtcbiAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgdGhpcy50b3AudHlwZSAmJiB0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpXG4gICAgeyB0aGlzLmFkZFRleHROb2RlKGRvbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpKTsgfVxufTtcblxuLy8gQ2FsbGVkIGZvciBpZ25vcmVkIG5vZGVzXG5QYXJzZUNvbnRleHQucHJvdG90eXBlLmlnbm9yZUZhbGxiYWNrID0gZnVuY3Rpb24gaWdub3JlRmFsbGJhY2sgKGRvbSkge1xuICAvLyBJZ25vcmVkIEJSIG5vZGVzIHNob3VsZCBhdCBsZWFzdCBjcmVhdGUgYW4gaW5saW5lIGNvbnRleHRcbiAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgKCF0aGlzLnRvcC50eXBlIHx8ICF0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpKVxuICAgIHsgdGhpcy5maW5kUGxhY2UodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQoXCItXCIpKTsgfVxufTtcblxuLy8gUnVuIGFueSBzdHlsZSBwYXJzZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlJ3Mgc3R5bGVzLiBFaXRoZXJcbi8vIHJldHVybiBhbiBhcnJheSBvZiBtYXJrcywgb3IgbnVsbCB0byBpbmRpY2F0ZSBzb21lIG9mIHRoZSBzdHlsZXNcbi8vIGhhZCBhIHJ1bGUgd2l0aCBgaWdub3JlYCBzZXQuXG5QYXJzZUNvbnRleHQucHJvdG90eXBlLnJlYWRTdHlsZXMgPSBmdW5jdGlvbiByZWFkU3R5bGVzIChzdHlsZXMpIHtcbiAgdmFyIG1hcmtzID0gTWFyay5ub25lO1xuICBzdHlsZTogZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBmb3IgKHZhciBhZnRlciA9IG51bGw7Oykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLnBhcnNlci5tYXRjaFN0eWxlKHN0eWxlc1tpXSwgc3R5bGVzW2kgKyAxXSwgdGhpcywgYWZ0ZXIpO1xuICAgICAgaWYgKCFydWxlKSB7IGNvbnRpbnVlIHN0eWxlIH1cbiAgICAgIGlmIChydWxlLmlnbm9yZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICBtYXJrcyA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdLmNyZWF0ZShydWxlLmF0dHJzKS5hZGRUb1NldChtYXJrcyk7XG4gICAgICBpZiAocnVsZS5jb25zdW1pbmcgPT09IGZhbHNlKSB7IGFmdGVyID0gcnVsZTsgfVxuICAgICAgZWxzZSB7IGJyZWFrIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hcmtzXG59O1xuXG4vLyA6IChkb20uRWxlbWVudCwgUGFyc2VSdWxlKSDihpIgYm9vbFxuLy8gTG9vayB1cCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBub2RlLiBJZiBub25lIGFyZSBmb3VuZCwgcmV0dXJuXG4vLyBmYWxzZS4gT3RoZXJ3aXNlLCBhcHBseSBpdCwgdXNlIGl0cyByZXR1cm4gdmFsdWUgdG8gZHJpdmUgdGhlIHdheVxuLy8gdGhlIG5vZGUncyBjb250ZW50IGlzIHdyYXBwZWQsIGFuZCByZXR1cm4gdHJ1ZS5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuYWRkRWxlbWVudEJ5UnVsZSA9IGZ1bmN0aW9uIGFkZEVsZW1lbnRCeVJ1bGUgKGRvbSwgcnVsZSwgY29udGludWVBZnRlcikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBzeW5jLCBub2RlVHlwZSwgbWFya1R5cGUsIG1hcms7XG4gIGlmIChydWxlLm5vZGUpIHtcbiAgICBub2RlVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tydWxlLm5vZGVdO1xuICAgIGlmICghbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICBzeW5jID0gdGhpcy5lbnRlcihub2RlVHlwZSwgcnVsZS5hdHRycywgcnVsZS5wcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuaW5zZXJ0Tm9kZShub2RlVHlwZS5jcmVhdGUocnVsZS5hdHRycykpKSB7XG4gICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdO1xuICAgIG1hcmsgPSBtYXJrVHlwZS5jcmVhdGUocnVsZS5hdHRycyk7XG4gICAgdGhpcy5hZGRQZW5kaW5nTWFyayhtYXJrKTtcbiAgfVxuICB2YXIgc3RhcnRJbiA9IHRoaXMudG9wO1xuXG4gIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZS5pc0xlYWYpIHtcbiAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgfSBlbHNlIGlmIChjb250aW51ZUFmdGVyKSB7XG4gICAgdGhpcy5hZGRFbGVtZW50KGRvbSwgY29udGludWVBZnRlcik7XG4gIH0gZWxzZSBpZiAocnVsZS5nZXRDb250ZW50KSB7XG4gICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgcnVsZS5nZXRDb250ZW50KGRvbSwgdGhpcy5wYXJzZXIuc2NoZW1hKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0aGlzJDEuaW5zZXJ0Tm9kZShub2RlKTsgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50O1xuICAgIGlmICh0eXBlb2YgY29udGVudERPTSA9PSBcInN0cmluZ1wiKSB7IGNvbnRlbnRET00gPSBkb20ucXVlcnlTZWxlY3Rvcihjb250ZW50RE9NKTsgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBjb250ZW50RE9NID09IFwiZnVuY3Rpb25cIikgeyBjb250ZW50RE9NID0gY29udGVudERPTShkb20pOyB9XG4gICAgaWYgKCFjb250ZW50RE9NKSB7IGNvbnRlbnRET00gPSBkb207IH1cbiAgICB0aGlzLmZpbmRBcm91bmQoZG9tLCBjb250ZW50RE9NLCB0cnVlKTtcbiAgICB0aGlzLmFkZEFsbChjb250ZW50RE9NLCBzeW5jKTtcbiAgfVxuICBpZiAoc3luYykgeyB0aGlzLnN5bmMoc3RhcnRJbik7IHRoaXMub3Blbi0tOyB9XG4gIGlmIChtYXJrKSB7IHRoaXMucmVtb3ZlUGVuZGluZ01hcmsobWFyaywgc3RhcnRJbik7IH1cbn07XG5cbi8vIDogKGRvbS5Ob2RlLCA/Tm9kZUJ1aWxkZXIsID9udW1iZXIsID9udW1iZXIpXG4vLyBBZGQgYWxsIGNoaWxkIG5vZGVzIGJldHdlZW4gYHN0YXJ0SW5kZXhgIGFuZCBgZW5kSW5kZXhgIChvciB0aGVcbi8vIHdob2xlIG5vZGUsIGlmIG5vdCBnaXZlbikuIElmIGBzeW5jYCBpcyBwYXNzZWQsIHVzZSBpdCB0b1xuLy8gc3luY2hyb25pemUgYWZ0ZXIgZXZlcnkgYmxvY2sgZWxlbWVudC5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gYWRkQWxsIChwYXJlbnQsIHN5bmMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gIHZhciBpbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcbiAgZm9yICh2YXIgZG9tID0gc3RhcnRJbmRleCA/IHBhcmVudC5jaGlsZE5vZGVzW3N0YXJ0SW5kZXhdIDogcGFyZW50LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgIGVuZCA9IGVuZEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50LmNoaWxkTm9kZXNbZW5kSW5kZXhdO1xuICAgICAgIGRvbSAhPSBlbmQ7IGRvbSA9IGRvbS5uZXh0U2libGluZywgKytpbmRleCkge1xuICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgdGhpcy5hZGRET00oZG9tKTtcbiAgICBpZiAoc3luYyAmJiBibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkoZG9tLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgeyB0aGlzLnN5bmMoc3luYyk7IH1cbiAgfVxuICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xufTtcblxuLy8gVHJ5IHRvIGZpbmQgYSB3YXkgdG8gZml0IHRoZSBnaXZlbiBub2RlIHR5cGUgaW50byB0aGUgY3VycmVudFxuLy8gY29udGV4dC4gTWF5IGFkZCBpbnRlcm1lZGlhdGUgd3JhcHBlcnMgYW5kL29yIGxlYXZlIG5vbi1zb2xpZFxuLy8gbm9kZXMgdGhhdCB3ZSdyZSBpbi5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuZmluZFBsYWNlID0gZnVuY3Rpb24gZmluZFBsYWNlIChub2RlKSB7XG4gIHZhciByb3V0ZSwgc3luYztcbiAgZm9yICh2YXIgZGVwdGggPSB0aGlzLm9wZW47IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICB2YXIgY3ggPSB0aGlzLm5vZGVzW2RlcHRoXTtcbiAgICB2YXIgZm91bmQgPSBjeC5maW5kV3JhcHBpbmcobm9kZSk7XG4gICAgaWYgKGZvdW5kICYmICghcm91dGUgfHwgcm91dGUubGVuZ3RoID4gZm91bmQubGVuZ3RoKSkge1xuICAgICAgcm91dGUgPSBmb3VuZDtcbiAgICAgIHN5bmMgPSBjeDtcbiAgICAgIGlmICghZm91bmQubGVuZ3RoKSB7IGJyZWFrIH1cbiAgICB9XG4gICAgaWYgKGN4LnNvbGlkKSB7IGJyZWFrIH1cbiAgfVxuICBpZiAoIXJvdXRlKSB7IHJldHVybiBmYWxzZSB9XG4gIHRoaXMuc3luYyhzeW5jKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3V0ZS5sZW5ndGg7IGkrKylcbiAgICB7IHRoaXMuZW50ZXJJbm5lcihyb3V0ZVtpXSwgbnVsbCwgZmFsc2UpOyB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyA6IChOb2RlKSDihpIgP05vZGVcbi8vIFRyeSB0byBpbnNlcnQgdGhlIGdpdmVuIG5vZGUsIGFkanVzdGluZyB0aGUgY29udGV4dCB3aGVuIG5lZWRlZC5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuaW5zZXJ0Tm9kZSA9IGZ1bmN0aW9uIGluc2VydE5vZGUgKG5vZGUpIHtcbiAgaWYgKG5vZGUuaXNJbmxpbmUgJiYgdGhpcy5uZWVkc0Jsb2NrICYmICF0aGlzLnRvcC50eXBlKSB7XG4gICAgdmFyIGJsb2NrID0gdGhpcy50ZXh0YmxvY2tGcm9tQ29udGV4dCgpO1xuICAgIGlmIChibG9jaykgeyB0aGlzLmVudGVySW5uZXIoYmxvY2spOyB9XG4gIH1cbiAgaWYgKHRoaXMuZmluZFBsYWNlKG5vZGUpKSB7XG4gICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgdmFyIHRvcCA9IHRoaXMudG9wO1xuICAgIHRvcC5hcHBseVBlbmRpbmcobm9kZS50eXBlKTtcbiAgICBpZiAodG9wLm1hdGNoKSB7IHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUobm9kZS50eXBlKTsgfVxuICAgIHZhciBtYXJrcyA9IHRvcC5hY3RpdmVNYXJrcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICB7IGlmICghdG9wLnR5cGUgfHwgdG9wLnR5cGUuYWxsb3dzTWFya1R5cGUobm9kZS5tYXJrc1tpXS50eXBlKSlcbiAgICAgICAgeyBtYXJrcyA9IG5vZGUubWFya3NbaV0uYWRkVG9TZXQobWFya3MpOyB9IH1cbiAgICB0b3AuY29udGVudC5wdXNoKG5vZGUubWFyayhtYXJrcykpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyA6IChOb2RlVHlwZSwgP09iamVjdCkg4oaSIGJvb2xcbi8vIFRyeSB0byBzdGFydCBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUsIGFkanVzdGluZyB0aGUgY29udGV4dCB3aGVuXG4vLyBuZWNlc3NhcnkuXG5QYXJzZUNvbnRleHQucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gZW50ZXIgKHR5cGUsIGF0dHJzLCBwcmVzZXJ2ZVdTKSB7XG4gIHZhciBvayA9IHRoaXMuZmluZFBsYWNlKHR5cGUuY3JlYXRlKGF0dHJzKSk7XG4gIGlmIChvaykgeyB0aGlzLmVudGVySW5uZXIodHlwZSwgYXR0cnMsIHRydWUsIHByZXNlcnZlV1MpOyB9XG4gIHJldHVybiBva1xufTtcblxuLy8gT3BlbiBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGVcblBhcnNlQ29udGV4dC5wcm90b3R5cGUuZW50ZXJJbm5lciA9IGZ1bmN0aW9uIGVudGVySW5uZXIgKHR5cGUsIGF0dHJzLCBzb2xpZCwgcHJlc2VydmVXUykge1xuICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgdmFyIHRvcCA9IHRoaXMudG9wO1xuICB0b3AuYXBwbHlQZW5kaW5nKHR5cGUpO1xuICB0b3AubWF0Y2ggPSB0b3AubWF0Y2ggJiYgdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlLCBhdHRycyk7XG4gIHZhciBvcHRpb25zID0gcHJlc2VydmVXUyA9PSBudWxsID8gdG9wLm9wdGlvbnMgJiB+T1BUX09QRU5fTEVGVCA6IHdzT3B0aW9uc0ZvcihwcmVzZXJ2ZVdTKTtcbiAgaWYgKCh0b3Aub3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQpICYmIHRvcC5jb250ZW50Lmxlbmd0aCA9PSAwKSB7IG9wdGlvbnMgfD0gT1BUX09QRU5fTEVGVDsgfVxuICB0aGlzLm5vZGVzLnB1c2gobmV3IE5vZGVDb250ZXh0KHR5cGUsIGF0dHJzLCB0b3AuYWN0aXZlTWFya3MsIHRvcC5wZW5kaW5nTWFya3MsIHNvbGlkLCBudWxsLCBvcHRpb25zKSk7XG4gIHRoaXMub3BlbisrO1xufTtcblxuLy8gTWFrZSBzdXJlIGFsbCBub2RlcyBhYm92ZSB0aGlzLm9wZW4gYXJlIGZpbmlzaGVkIGFuZCBhZGRlZCB0b1xuLy8gdGhlaXIgcGFyZW50c1xuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5jbG9zZUV4dHJhID0gZnVuY3Rpb24gY2xvc2VFeHRyYSAob3BlbkVuZCkge1xuICB2YXIgaSA9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgaWYgKGkgPiB0aGlzLm9wZW4pIHtcbiAgICBmb3IgKDsgaSA+IHRoaXMub3BlbjsgaS0tKSB7IHRoaXMubm9kZXNbaSAtIDFdLmNvbnRlbnQucHVzaCh0aGlzLm5vZGVzW2ldLmZpbmlzaChvcGVuRW5kKSk7IH1cbiAgICB0aGlzLm5vZGVzLmxlbmd0aCA9IHRoaXMub3BlbiArIDE7XG4gIH1cbn07XG5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoICgpIHtcbiAgdGhpcy5vcGVuID0gMDtcbiAgdGhpcy5jbG9zZUV4dHJhKHRoaXMuaXNPcGVuKTtcbiAgcmV0dXJuIHRoaXMubm9kZXNbMF0uZmluaXNoKHRoaXMuaXNPcGVuIHx8IHRoaXMub3B0aW9ucy50b3BPcGVuKVxufTtcblxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gc3luYyAodG8pIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMub3BlbjsgaSA+PSAwOyBpLS0pIHsgaWYgKHRoaXMubm9kZXNbaV0gPT0gdG8pIHtcbiAgICB0aGlzLm9wZW4gPSBpO1xuICAgIHJldHVyblxuICB9IH1cbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQ2LmN1cnJlbnRQb3MuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLm5vZGVzW2ldLmNvbnRlbnQ7XG4gICAgZm9yICh2YXIgaiA9IGNvbnRlbnQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICB7IHBvcyArPSBjb250ZW50W2pdLm5vZGVTaXplOyB9XG4gICAgaWYgKGkpIHsgcG9zKys7IH1cbiAgfVxuICByZXR1cm4gcG9zXG59O1xuXG5QYXJzZUNvbnRleHQucHJvdG90eXBlLmZpbmRBdFBvaW50ID0gZnVuY3Rpb24gZmluZEF0UG9pbnQgKHBhcmVudCwgb2Zmc2V0KSB7XG4gIGlmICh0aGlzLmZpbmQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gcGFyZW50ICYmIHRoaXMuZmluZFtpXS5vZmZzZXQgPT0gb2Zmc2V0KVxuICAgICAgeyB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zOyB9XG4gIH0gfVxufTtcblxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5maW5kSW5zaWRlID0gZnVuY3Rpb24gZmluZEluc2lkZSAocGFyZW50KSB7XG4gIGlmICh0aGlzLmZpbmQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpXG4gICAgICB7IHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7IH1cbiAgfSB9XG59O1xuXG5QYXJzZUNvbnRleHQucHJvdG90eXBlLmZpbmRBcm91bmQgPSBmdW5jdGlvbiBmaW5kQXJvdW5kIChwYXJlbnQsIGNvbnRlbnQsIGJlZm9yZSkge1xuICBpZiAocGFyZW50ICE9IGNvbnRlbnQgJiYgdGhpcy5maW5kKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKSB7XG4gICAgICB2YXIgcG9zID0gY29udGVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzLmZpbmRbaV0ubm9kZSk7XG4gICAgICBpZiAocG9zICYgKGJlZm9yZSA/IDIgOiA0KSlcbiAgICAgICAgeyB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zOyB9XG4gICAgfVxuICB9IH1cbn07XG5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuZmluZEluVGV4dCA9IGZ1bmN0aW9uIGZpbmRJblRleHQgKHRleHROb2RlKSB7XG4gIGlmICh0aGlzLmZpbmQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gdGV4dE5vZGUpXG4gICAgICB7IHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3MgLSAodGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aCAtIHRoaXMuZmluZFtpXS5vZmZzZXQpOyB9XG4gIH0gfVxufTtcblxuLy8gOiAoc3RyaW5nKSDihpIgYm9vbFxuLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBbY29udGV4dFxuLy8gc3RyaW5nXSgjUGFyc2VSdWxlLmNvbnRleHQpIG1hdGNoZXMgdGhpcyBjb250ZXh0LlxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5tYXRjaGVzQ29udGV4dCA9IGZ1bmN0aW9uIG1hdGNoZXNDb250ZXh0IChjb250ZXh0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGNvbnRleHQuaW5kZXhPZihcInxcIikgPiAtMSlcbiAgICB7IHJldHVybiBjb250ZXh0LnNwbGl0KC9cXHMqXFx8XFxzKi8pLnNvbWUodGhpcy5tYXRjaGVzQ29udGV4dCwgdGhpcykgfVxuXG4gIHZhciBwYXJ0cyA9IGNvbnRleHQuc3BsaXQoXCIvXCIpO1xuICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gIHZhciB1c2VSb290ID0gIXRoaXMuaXNPcGVuICYmICghb3B0aW9uIHx8IG9wdGlvbi5wYXJlbnQudHlwZSA9PSB0aGlzLm5vZGVzWzBdLnR5cGUpO1xuICB2YXIgbWluRGVwdGggPSAtKG9wdGlvbiA/IG9wdGlvbi5kZXB0aCArIDEgOiAwKSArICh1c2VSb290ID8gMCA6IDEpO1xuICB2YXIgbWF0Y2ggPSBmdW5jdGlvbiAoaSwgZGVwdGgpIHtcbiAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PSBcIlwiKSB7XG4gICAgICAgIGlmIChpID09IHBhcnRzLmxlbmd0aCAtIDEgfHwgaSA9PSAwKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgZm9yICg7IGRlcHRoID49IG1pbkRlcHRoOyBkZXB0aC0tKVxuICAgICAgICAgIHsgaWYgKG1hdGNoKGkgLSAxLCBkZXB0aCkpIHsgcmV0dXJuIHRydWUgfSB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5leHQgPSBkZXB0aCA+IDAgfHwgKGRlcHRoID09IDAgJiYgdXNlUm9vdCkgPyB0aGlzJDEubm9kZXNbZGVwdGhdLnR5cGVcbiAgICAgICAgICAgIDogb3B0aW9uICYmIGRlcHRoID49IG1pbkRlcHRoID8gb3B0aW9uLm5vZGUoZGVwdGggLSBtaW5EZXB0aCkudHlwZVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAoIW5leHQgfHwgKG5leHQubmFtZSAhPSBwYXJ0ICYmIG5leHQuZ3JvdXBzLmluZGV4T2YocGFydCkgPT0gLTEpKVxuICAgICAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgZGVwdGgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcbiAgcmV0dXJuIG1hdGNoKHBhcnRzLmxlbmd0aCAtIDEsIHRoaXMub3Blbilcbn07XG5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUudGV4dGJsb2NrRnJvbUNvbnRleHQgPSBmdW5jdGlvbiB0ZXh0YmxvY2tGcm9tQ29udGV4dCAoKSB7XG4gIHZhciAkY29udGV4dCA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICBpZiAoJGNvbnRleHQpIHsgZm9yICh2YXIgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgIHZhciBkZWZsdCA9ICRjb250ZXh0Lm5vZGUoZCkuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXhBZnRlcihkKSkuZGVmYXVsdFR5cGU7XG4gICAgaWYgKGRlZmx0ICYmIGRlZmx0LmlzVGV4dGJsb2NrICYmIGRlZmx0LmRlZmF1bHRBdHRycykgeyByZXR1cm4gZGVmbHQgfVxuICB9IH1cbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXMpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tuYW1lXTtcbiAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiB0eXBlLmRlZmF1bHRBdHRycykgeyByZXR1cm4gdHlwZSB9XG4gIH1cbn07XG5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuYWRkUGVuZGluZ01hcmsgPSBmdW5jdGlvbiBhZGRQZW5kaW5nTWFyayAobWFyaykge1xuICB2YXIgZm91bmQgPSBmaW5kU2FtZU1hcmtJblNldChtYXJrLCB0aGlzLnRvcC5wZW5kaW5nTWFya3MpO1xuICBpZiAoZm91bmQpIHsgdGhpcy50b3Auc3Rhc2hNYXJrcy5wdXNoKGZvdW5kKTsgfVxuICB0aGlzLnRvcC5wZW5kaW5nTWFya3MgPSBtYXJrLmFkZFRvU2V0KHRoaXMudG9wLnBlbmRpbmdNYXJrcyk7XG59O1xuXG5QYXJzZUNvbnRleHQucHJvdG90eXBlLnJlbW92ZVBlbmRpbmdNYXJrID0gZnVuY3Rpb24gcmVtb3ZlUGVuZGluZ01hcmsgKG1hcmssIHVwdG8pIHtcbiAgZm9yICh2YXIgZGVwdGggPSB0aGlzLm9wZW47IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICB2YXIgbGV2ZWwgPSB0aGlzLm5vZGVzW2RlcHRoXTtcbiAgICB2YXIgZm91bmQgPSBsZXZlbC5wZW5kaW5nTWFya3MubGFzdEluZGV4T2YobWFyayk7XG4gICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgIGxldmVsLnBlbmRpbmdNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldChsZXZlbC5wZW5kaW5nTWFya3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXZlbC5hY3RpdmVNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldChsZXZlbC5hY3RpdmVNYXJrcyk7XG4gICAgICB2YXIgc3Rhc2hNYXJrID0gbGV2ZWwucG9wRnJvbVN0YXNoTWFyayhtYXJrKTtcbiAgICAgIGlmIChzdGFzaE1hcmsgJiYgbGV2ZWwudHlwZSAmJiBsZXZlbC50eXBlLmFsbG93c01hcmtUeXBlKHN0YXNoTWFyay50eXBlKSlcbiAgICAgICAgeyBsZXZlbC5hY3RpdmVNYXJrcyA9IHN0YXNoTWFyay5hZGRUb1NldChsZXZlbC5hY3RpdmVNYXJrcyk7IH1cbiAgICB9XG4gICAgaWYgKGxldmVsID09IHVwdG8pIHsgYnJlYWsgfVxuICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggUGFyc2VDb250ZXh0LnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDYgKTtcblxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGRpcmVjdGx5IG5lc3RlZCBsaXN0IG5vZGVzIHByb2R1Y2VkIGJ5IHNvbWVcbi8vIHRvb2xzIGFuZCBhbGxvd2VkIGJ5IGJyb3dzZXJzIHRvIG1lYW4gdGhhdCB0aGUgbmVzdGVkIGxpc3QgaXNcbi8vIGFjdHVhbGx5IHBhcnQgb2YgdGhlIGxpc3QgaXRlbSBhYm92ZSBpdC5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpc3QoZG9tKSB7XG4gIGZvciAodmFyIGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQsIHByZXZJdGVtID0gbnVsbDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICB2YXIgbmFtZSA9IGNoaWxkLm5vZGVUeXBlID09IDEgPyBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICBpZiAobmFtZSAmJiBsaXN0VGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBwcmV2SXRlbSkge1xuICAgICAgcHJldkl0ZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgY2hpbGQgPSBwcmV2SXRlbTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJsaVwiKSB7XG4gICAgICBwcmV2SXRlbSA9IGNoaWxkO1xuICAgIH0gZWxzZSBpZiAobmFtZSkge1xuICAgICAgcHJldkl0ZW0gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG4vLyBBcHBseSBhIENTUyBzZWxlY3Rvci5cbmZ1bmN0aW9uIG1hdGNoZXMoZG9tLCBzZWxlY3Rvcikge1xuICByZXR1cm4gKGRvbS5tYXRjaGVzIHx8IGRvbS5tc01hdGNoZXNTZWxlY3RvciB8fCBkb20ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGRvbS5tb3pNYXRjaGVzU2VsZWN0b3IpLmNhbGwoZG9tLCBzZWxlY3Rvcilcbn1cblxuLy8gOiAoc3RyaW5nKSDihpIgW3N0cmluZ11cbi8vIFRva2VuaXplIGEgc3R5bGUgYXR0cmlidXRlIGludG8gcHJvcGVydHkvdmFsdWUgcGFpcnMuXG5mdW5jdGlvbiBwYXJzZVN0eWxlcyhzdHlsZSkge1xuICB2YXIgcmUgPSAvXFxzKihbXFx3LV0rKVxccyo6XFxzKihbXjtdKykvZywgbSwgcmVzdWx0ID0gW107XG4gIHdoaWxlIChtID0gcmUuZXhlYyhzdHlsZSkpIHsgcmVzdWx0LnB1c2gobVsxXSwgbVsyXS50cmltKCkpOyB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY29weShvYmopIHtcbiAgdmFyIGNvcHkgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHsgY29weVtwcm9wXSA9IG9ialtwcm9wXTsgfVxuICByZXR1cm4gY29weVxufVxuXG4vLyBVc2VkIHdoZW4gZmluZGluZyBhIG1hcmsgYXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZyYWdtZW50IHBhcnNlLlxuLy8gQ2hlY2tzIHdoZXRoZXIgaXQgd291bGQgYmUgcmVhc29uYWJsZSB0byBhcHBseSBhIGdpdmVuIG1hcmsgdHlwZSB0b1xuLy8gYSBnaXZlbiBub2RlLCBieSBsb29raW5nIGF0IHRoZSB3YXkgdGhlIG1hcmsgb2NjdXJzIGluIHRoZSBzY2hlbWEuXG5mdW5jdGlvbiBtYXJrTWF5QXBwbHkobWFya1R5cGUsIG5vZGVUeXBlKSB7XG4gIHZhciBub2RlcyA9IG5vZGVUeXBlLnNjaGVtYS5ub2RlcztcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVzW25hbWVdO1xuICAgIGlmICghcGFyZW50LmFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSkgeyByZXR1cm4gfVxuICAgIHZhciBzZWVuID0gW10sIHNjYW4gPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIHNlZW4ucHVzaChtYXRjaCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciByZWYgPSBtYXRjaC5lZGdlKGkpO1xuICAgICAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgICAgICB2YXIgbmV4dCA9IHJlZi5uZXh0O1xuICAgICAgICBpZiAodHlwZSA9PSBub2RlVHlwZSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICAgIGlmIChzZWVuLmluZGV4T2YobmV4dCkgPCAwICYmIHNjYW4obmV4dCkpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHNjYW4ocGFyZW50LmNvbnRlbnRNYXRjaCkpIHsgcmV0dXJuIHsgdjogdHJ1ZSB9IH1cbiAgfTtcblxuICBmb3IgKHZhciBuYW1lIGluIG5vZGVzKSB7XG4gICAgdmFyIHJldHVybmVkID0gbG9vcCggbmFtZSApO1xuXG4gICAgaWYgKCByZXR1cm5lZCApIHJldHVybiByZXR1cm5lZC52O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRTYW1lTWFya0luU2V0KG1hcmssIHNldCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtYXJrLmVxKHNldFtpXSkpIHsgcmV0dXJuIHNldFtpXSB9XG4gIH1cbn1cblxuLy8gRE9NT3V0cHV0U3BlYzo6IGludGVyZmFjZVxuLy8gQSBkZXNjcmlwdGlvbiBvZiBhIERPTSBzdHJ1Y3R1cmUuIENhbiBiZSBlaXRoZXIgYSBzdHJpbmcsIHdoaWNoIGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhIHRleHQgbm9kZSwgYSBET00gbm9kZSwgd2hpY2ggaXMgaW50ZXJwcmV0ZWQgYXNcbi8vIGl0c2VsZiwgYSBge2RvbTogTm9kZSwgY29udGVudERPTTogP05vZGV9YCBvYmplY3QsIG9yIGFuIGFycmF5LlxuLy9cbi8vIEFuIGFycmF5IGRlc2NyaWJlcyBhIERPTSBlbGVtZW50LiBUaGUgZmlyc3QgdmFsdWUgaW4gdGhlIGFycmF5XG4vLyBzaG91bGQgYmUgYSBzdHJpbmfigJR0aGUgbmFtZSBvZiB0aGUgRE9NIGVsZW1lbnQsIG9wdGlvbmFsbHkgcHJlZml4ZWRcbi8vIGJ5IGEgbmFtZXNwYWNlIFVSTCBhbmQgYSBzcGFjZS4gSWYgdGhlIHNlY29uZCBlbGVtZW50IGlzIHBsYWluXG4vLyBvYmplY3QsIGl0IGlzIGludGVycHJldGVkIGFzIGEgc2V0IG9mIGF0dHJpYnV0ZXMgZm9yIHRoZSBlbGVtZW50LlxuLy8gQW55IGVsZW1lbnRzIGFmdGVyIHRoYXQgKGluY2x1ZGluZyB0aGUgMm5kIGlmIGl0J3Mgbm90IGFuIGF0dHJpYnV0ZVxuLy8gb2JqZWN0KSBhcmUgaW50ZXJwcmV0ZWQgYXMgY2hpbGRyZW4gb2YgdGhlIERPTSBlbGVtZW50cywgYW5kIG11c3Rcbi8vIGVpdGhlciBiZSB2YWxpZCBgRE9NT3V0cHV0U3BlY2AgdmFsdWVzLCBvciB0aGUgbnVtYmVyIHplcm8uXG4vL1xuLy8gVGhlIG51bWJlciB6ZXJvIChwcm9ub3VuY2VkIOKAnGhvbGXigJ0pIGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhlIHBsYWNlXG4vLyB3aGVyZSBhIG5vZGUncyBjaGlsZCBub2RlcyBzaG91bGQgYmUgaW5zZXJ0ZWQuIElmIGl0IG9jY3VycyBpbiBhblxuLy8gb3V0cHV0IHNwZWMsIGl0IHNob3VsZCBiZSB0aGUgb25seSBjaGlsZCBlbGVtZW50IGluIGl0cyBwYXJlbnRcbi8vIG5vZGUuXG5cbi8vIDo6LSBBIERPTSBzZXJpYWxpemVyIGtub3dzIGhvdyB0byBjb252ZXJ0IFByb3NlTWlycm9yIG5vZGVzIGFuZFxuLy8gbWFya3Mgb2YgdmFyaW91cyB0eXBlcyB0byBET00gbm9kZXMuXG52YXIgRE9NU2VyaWFsaXplciA9IGZ1bmN0aW9uIERPTVNlcmlhbGl6ZXIobm9kZXMsIG1hcmtzKSB7XG4gIC8vIDo6IE9iamVjdDwobm9kZTogTm9kZSkg4oaSIERPTU91dHB1dFNwZWM+XG4gIC8vIFRoZSBub2RlIHNlcmlhbGl6YXRpb24gZnVuY3Rpb25zLlxuICB0aGlzLm5vZGVzID0gbm9kZXMgfHwge307XG4gIC8vIDo6IE9iamVjdDw/KG1hcms6IE1hcmssIGlubGluZTogYm9vbCkg4oaSIERPTU91dHB1dFNwZWM+XG4gIC8vIFRoZSBtYXJrIHNlcmlhbGl6YXRpb24gZnVuY3Rpb25zLlxuICB0aGlzLm1hcmtzID0gbWFya3MgfHwge307XG59O1xuXG4vLyA6OiAoRnJhZ21lbnQsID9PYmplY3QpIOKGkiBkb20uRG9jdW1lbnRGcmFnbWVudFxuLy8gU2VyaWFsaXplIHRoZSBjb250ZW50IG9mIHRoaXMgZnJhZ21lbnQgdG8gYSBET00gZnJhZ21lbnQuIFdoZW5cbi8vIG5vdCBpbiB0aGUgYnJvd3NlciwgdGhlIGBkb2N1bWVudGAgb3B0aW9uLCBjb250YWluaW5nIGEgRE9NXG4vLyBkb2N1bWVudCwgc2hvdWxkIGJlIHBhc3NlZCBzbyB0aGF0IHRoZSBzZXJpYWxpemVyIGNhbiBjcmVhdGVcbi8vIG5vZGVzLlxuRE9NU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplRnJhZ21lbnQgPSBmdW5jdGlvbiBzZXJpYWxpemVGcmFnbWVudCAoZnJhZ21lbnQsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIGlmICghdGFyZ2V0KSB7IHRhcmdldCA9IGRvYyhvcHRpb25zKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7IH1cblxuICB2YXIgdG9wID0gdGFyZ2V0LCBhY3RpdmUgPSBudWxsO1xuICBmcmFnbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKGFjdGl2ZSB8fCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgaWYgKCFhY3RpdmUpIHsgYWN0aXZlID0gW107IH1cbiAgICAgIHZhciBrZWVwID0gMCwgcmVuZGVyZWQgPSAwO1xuICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoICYmIHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHQgPSBub2RlLm1hcmtzW3JlbmRlcmVkXTtcbiAgICAgICAgaWYgKCF0aGlzJDEubWFya3NbbmV4dC50eXBlLm5hbWVdKSB7IHJlbmRlcmVkKys7IGNvbnRpbnVlIH1cbiAgICAgICAgaWYgKCFuZXh0LmVxKGFjdGl2ZVtrZWVwXSkgfHwgbmV4dC50eXBlLnNwZWMuc3Bhbm5pbmcgPT09IGZhbHNlKSB7IGJyZWFrIH1cbiAgICAgICAga2VlcCArPSAyOyByZW5kZXJlZCsrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgIHRvcCA9IGFjdGl2ZS5wb3AoKTtcbiAgICAgICAgYWN0aXZlLnBvcCgpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGFkZCA9IG5vZGUubWFya3NbcmVuZGVyZWQrK107XG4gICAgICAgIHZhciBtYXJrRE9NID0gdGhpcyQxLnNlcmlhbGl6ZU1hcmsoYWRkLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG1hcmtET00pIHtcbiAgICAgICAgICBhY3RpdmUucHVzaChhZGQsIHRvcCk7XG4gICAgICAgICAgdG9wLmFwcGVuZENoaWxkKG1hcmtET00uZG9tKTtcbiAgICAgICAgICB0b3AgPSBtYXJrRE9NLmNvbnRlbnRET00gfHwgbWFya0RPTS5kb207XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdG9wLmFwcGVuZENoaWxkKHRoaXMkMS5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykpO1xuICB9KTtcblxuICByZXR1cm4gdGFyZ2V0XG59O1xuXG5ET01TZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVOb2RlSW5uZXIgPSBmdW5jdGlvbiBzZXJpYWxpemVOb2RlSW5uZXIgKG5vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICB2YXIgcmVmID1cbiAgICAgIERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2Mob3B0aW9ucyksIHRoaXMubm9kZXNbbm9kZS50eXBlLm5hbWVdKG5vZGUpKTtcbiAgICB2YXIgZG9tID0gcmVmLmRvbTtcbiAgICB2YXIgY29udGVudERPTSA9IHJlZi5jb250ZW50RE9NO1xuICBpZiAoY29udGVudERPTSkge1xuICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbm90IGFsbG93ZWQgaW4gYSBsZWFmIG5vZGUgc3BlY1wiKSB9XG4gICAgaWYgKG9wdGlvbnMub25Db250ZW50KVxuICAgICAgeyBvcHRpb25zLm9uQ29udGVudChub2RlLCBjb250ZW50RE9NLCBvcHRpb25zKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5zZXJpYWxpemVGcmFnbWVudChub2RlLmNvbnRlbnQsIG9wdGlvbnMsIGNvbnRlbnRET00pOyB9XG4gIH1cbiAgcmV0dXJuIGRvbVxufTtcblxuLy8gOjogKE5vZGUsID9PYmplY3QpIOKGkiBkb20uTm9kZVxuLy8gU2VyaWFsaXplIHRoaXMgbm9kZSB0byBhIERPTSBub2RlLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3Vcbi8vIG5lZWQgdG8gc2VyaWFsaXplIGEgcGFydCBvZiBhIGRvY3VtZW50LCBhcyBvcHBvc2VkIHRvIHRoZSB3aG9sZVxuLy8gZG9jdW1lbnQuIFRvIHNlcmlhbGl6ZSBhIHdob2xlIGRvY3VtZW50LCB1c2Vcbi8vIFtgc2VyaWFsaXplRnJhZ21lbnRgXSgjbW9kZWwuRE9NU2VyaWFsaXplci5zZXJpYWxpemVGcmFnbWVudCkgb25cbi8vIGl0cyBbY29udGVudF0oI21vZGVsLk5vZGUuY29udGVudCkuXG5ET01TZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVOb2RlID0gZnVuY3Rpb24gc2VyaWFsaXplTm9kZSAobm9kZSwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIHZhciBkb20gPSB0aGlzLnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKTtcbiAgZm9yICh2YXIgaSA9IG5vZGUubWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgd3JhcCA9IHRoaXMuc2VyaWFsaXplTWFyayhub2RlLm1hcmtzW2ldLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICBpZiAod3JhcCkge1xuKHdyYXAuY29udGVudERPTSB8fCB3cmFwLmRvbSkuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgIGRvbSA9IHdyYXAuZG9tO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZG9tXG59O1xuXG5ET01TZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVNYXJrID0gZnVuY3Rpb24gc2VyaWFsaXplTWFyayAobWFyaywgaW5saW5lLCBvcHRpb25zKSB7XG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdmFyIHRvRE9NID0gdGhpcy5tYXJrc1ttYXJrLnR5cGUubmFtZV07XG4gIHJldHVybiB0b0RPTSAmJiBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0b0RPTShtYXJrLCBpbmxpbmUpKVxufTtcblxuLy8gOjogKGRvbS5Eb2N1bWVudCwgRE9NT3V0cHV0U3BlYykg4oaSIHtkb206IGRvbS5Ob2RlLCBjb250ZW50RE9NOiA/ZG9tLk5vZGV9XG4vLyBSZW5kZXIgYW4gW291dHB1dCBzcGVjXSgjbW9kZWwuRE9NT3V0cHV0U3BlYykgdG8gYSBET00gbm9kZS4gSWZcbi8vIHRoZSBzcGVjIGhhcyBhIGhvbGUgKHplcm8pIGluIGl0LCBgY29udGVudERPTWAgd2lsbCBwb2ludCBhdCB0aGVcbi8vIG5vZGUgd2l0aCB0aGUgaG9sZS5cbkRPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyA9IGZ1bmN0aW9uIHJlbmRlclNwZWMgKGRvYywgc3RydWN0dXJlLCB4bWxOUykge1xuICAgIGlmICggeG1sTlMgPT09IHZvaWQgMCApIHhtbE5TID0gbnVsbDtcblxuICBpZiAodHlwZW9mIHN0cnVjdHVyZSA9PSBcInN0cmluZ1wiKVxuICAgIHsgcmV0dXJuIHtkb206IGRvYy5jcmVhdGVUZXh0Tm9kZShzdHJ1Y3R1cmUpfSB9XG4gIGlmIChzdHJ1Y3R1cmUubm9kZVR5cGUgIT0gbnVsbClcbiAgICB7IHJldHVybiB7ZG9tOiBzdHJ1Y3R1cmV9IH1cbiAgaWYgKHN0cnVjdHVyZS5kb20gJiYgc3RydWN0dXJlLmRvbS5ub2RlVHlwZSAhPSBudWxsKVxuICAgIHsgcmV0dXJuIHN0cnVjdHVyZSB9XG4gIHZhciB0YWdOYW1lID0gc3RydWN0dXJlWzBdLCBzcGFjZSA9IHRhZ05hbWUuaW5kZXhPZihcIiBcIik7XG4gIGlmIChzcGFjZSA+IDApIHtcbiAgICB4bWxOUyA9IHRhZ05hbWUuc2xpY2UoMCwgc3BhY2UpO1xuICAgIHRhZ05hbWUgPSB0YWdOYW1lLnNsaWNlKHNwYWNlICsgMSk7XG4gIH1cbiAgdmFyIGNvbnRlbnRET00gPSBudWxsLCBkb20gPSB4bWxOUyA/IGRvYy5jcmVhdGVFbGVtZW50TlMoeG1sTlMsIHRhZ05hbWUpIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIHZhciBhdHRycyA9IHN0cnVjdHVyZVsxXSwgc3RhcnQgPSAxO1xuICBpZiAoYXR0cnMgJiYgdHlwZW9mIGF0dHJzID09IFwib2JqZWN0XCIgJiYgYXR0cnMubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShhdHRycykpIHtcbiAgICBzdGFydCA9IDI7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBhdHRycykgeyBpZiAoYXR0cnNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgdmFyIHNwYWNlJDEgPSBuYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgaWYgKHNwYWNlJDEgPiAwKSB7IGRvbS5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNsaWNlKDAsIHNwYWNlJDEpLCBuYW1lLnNsaWNlKHNwYWNlJDEgKyAxKSwgYXR0cnNbbmFtZV0pOyB9XG4gICAgICBlbHNlIHsgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7IH1cbiAgICB9IH1cbiAgfVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzdHJ1Y3R1cmUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBzdHJ1Y3R1cmVbaV07XG4gICAgaWYgKGNoaWxkID09PSAwKSB7XG4gICAgICBpZiAoaSA8IHN0cnVjdHVyZS5sZW5ndGggLSAxIHx8IGkgPiBzdGFydClcbiAgICAgICAgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBtdXN0IGJlIHRoZSBvbmx5IGNoaWxkIG9mIGl0cyBwYXJlbnQgbm9kZVwiKSB9XG4gICAgICByZXR1cm4ge2RvbTogZG9tLCBjb250ZW50RE9NOiBkb219XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZWYgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jLCBjaGlsZCwgeG1sTlMpO1xuICAgICAgICB2YXIgaW5uZXIgPSByZWYuZG9tO1xuICAgICAgICB2YXIgaW5uZXJDb250ZW50ID0gcmVmLmNvbnRlbnRET007XG4gICAgICBkb20uYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgICAgaWYgKGlubmVyQ29udGVudCkge1xuICAgICAgICBpZiAoY29udGVudERPTSkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11bHRpcGxlIGNvbnRlbnQgaG9sZXNcIikgfVxuICAgICAgICBjb250ZW50RE9NID0gaW5uZXJDb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge2RvbTogZG9tLCBjb250ZW50RE9NOiBjb250ZW50RE9NfVxufTtcblxuLy8gOjogKFNjaGVtYSkg4oaSIERPTVNlcmlhbGl6ZXJcbi8vIEJ1aWxkIGEgc2VyaWFsaXplciB1c2luZyB0aGUgW2B0b0RPTWBdKCNtb2RlbC5Ob2RlU3BlYy50b0RPTSlcbi8vIHByb3BlcnRpZXMgaW4gYSBzY2hlbWEncyBub2RlIGFuZCBtYXJrIHNwZWNzLlxuRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hID0gZnVuY3Rpb24gZnJvbVNjaGVtYSAoc2NoZW1hKSB7XG4gIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgfHxcbiAgICAoc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyID0gbmV3IERPTVNlcmlhbGl6ZXIodGhpcy5ub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSwgdGhpcy5tYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSkpXG59O1xuXG4vLyA6IChTY2hlbWEpIOKGkiBPYmplY3Q8KG5vZGU6IE5vZGUpIOKGkiBET01PdXRwdXRTcGVjPlxuLy8gR2F0aGVyIHRoZSBzZXJpYWxpemVycyBpbiBhIHNjaGVtYSdzIG5vZGUgc3BlY3MgaW50byBhbiBvYmplY3QuXG4vLyBUaGlzIGNhbiBiZSB1c2VmdWwgYXMgYSBiYXNlIHRvIGJ1aWxkIGEgY3VzdG9tIHNlcmlhbGl6ZXIgZnJvbS5cbkRPTVNlcmlhbGl6ZXIubm9kZXNGcm9tU2NoZW1hID0gZnVuY3Rpb24gbm9kZXNGcm9tU2NoZW1hIChzY2hlbWEpIHtcbiAgdmFyIHJlc3VsdCA9IGdhdGhlclRvRE9NKHNjaGVtYS5ub2Rlcyk7XG4gIGlmICghcmVzdWx0LnRleHQpIHsgcmVzdWx0LnRleHQgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50ZXh0OyB9OyB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIDogKFNjaGVtYSkg4oaSIE9iamVjdDwobWFyazogTWFyaykg4oaSIERPTU91dHB1dFNwZWM+XG4vLyBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3MgbWFyayBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbkRPTVNlcmlhbGl6ZXIubWFya3NGcm9tU2NoZW1hID0gZnVuY3Rpb24gbWFya3NGcm9tU2NoZW1hIChzY2hlbWEpIHtcbiAgcmV0dXJuIGdhdGhlclRvRE9NKHNjaGVtYS5tYXJrcylcbn07XG5cbmZ1bmN0aW9uIGdhdGhlclRvRE9NKG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG4gICAgdmFyIHRvRE9NID0gb2JqW25hbWVdLnNwZWMudG9ET007XG4gICAgaWYgKHRvRE9NKSB7IHJlc3VsdFtuYW1lXSA9IHRvRE9NOyB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkb2Mob3B0aW9ucykge1xuICAvLyBkZWNsYXJlIGdsb2JhbDogd2luZG93XG4gIHJldHVybiBvcHRpb25zLmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudFxufVxuXG5leHBvcnQgeyBDb250ZW50TWF0Y2gsIERPTVBhcnNlciwgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE1hcmssIE1hcmtUeXBlLCBOb2RlLCBOb2RlUmFuZ2UsIE5vZGVUeXBlLCBSZXBsYWNlRXJyb3IsIFJlc29sdmVkUG9zLCBTY2hlbWEsIFNsaWNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCB7IFNjaGVtYSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcblxudmFyIHBET00gPSBbXCJwXCIsIDBdLCBibG9ja3F1b3RlRE9NID0gW1wiYmxvY2txdW90ZVwiLCAwXSwgaHJET00gPSBbXCJoclwiXSxcbiAgICAgIHByZURPTSA9IFtcInByZVwiLCBbXCJjb2RlXCIsIDBdXSwgYnJET00gPSBbXCJiclwiXTtcblxuLy8gOjogT2JqZWN0XG4vLyBbU3BlY3NdKCNtb2RlbC5Ob2RlU3BlYykgZm9yIHRoZSBub2RlcyBkZWZpbmVkIGluIHRoaXMgc2NoZW1hLlxudmFyIG5vZGVzID0ge1xuICAvLyA6OiBOb2RlU3BlYyBUaGUgdG9wIGxldmVsIGRvY3VtZW50IG5vZGUuXG4gIGRvYzoge1xuICAgIGNvbnRlbnQ6IFwiYmxvY2srXCJcbiAgfSxcblxuICAvLyA6OiBOb2RlU3BlYyBBIHBsYWluIHBhcmFncmFwaCB0ZXh0YmxvY2suIFJlcHJlc2VudGVkIGluIHRoZSBET01cbiAgLy8gYXMgYSBgPHA+YCBlbGVtZW50LlxuICBwYXJhZ3JhcGg6IHtcbiAgICBjb250ZW50OiBcImlubGluZSpcIixcbiAgICBncm91cDogXCJibG9ja1wiLFxuICAgIHBhcnNlRE9NOiBbe3RhZzogXCJwXCJ9XSxcbiAgICB0b0RPTTogZnVuY3Rpb24gdG9ET00oKSB7IHJldHVybiBwRE9NIH1cbiAgfSxcblxuICAvLyA6OiBOb2RlU3BlYyBBIGJsb2NrcXVvdGUgKGA8YmxvY2txdW90ZT5gKSB3cmFwcGluZyBvbmUgb3IgbW9yZSBibG9ja3MuXG4gIGJsb2NrcXVvdGU6IHtcbiAgICBjb250ZW50OiBcImJsb2NrK1wiLFxuICAgIGdyb3VwOiBcImJsb2NrXCIsXG4gICAgZGVmaW5pbmc6IHRydWUsXG4gICAgcGFyc2VET006IFt7dGFnOiBcImJsb2NrcXVvdGVcIn1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHsgcmV0dXJuIGJsb2NrcXVvdGVET00gfVxuICB9LFxuXG4gIC8vIDo6IE5vZGVTcGVjIEEgaG9yaXpvbnRhbCBydWxlIChgPGhyPmApLlxuICBob3Jpem9udGFsX3J1bGU6IHtcbiAgICBncm91cDogXCJibG9ja1wiLFxuICAgIHBhcnNlRE9NOiBbe3RhZzogXCJoclwifV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkgeyByZXR1cm4gaHJET00gfVxuICB9LFxuXG4gIC8vIDo6IE5vZGVTcGVjIEEgaGVhZGluZyB0ZXh0YmxvY2ssIHdpdGggYSBgbGV2ZWxgIGF0dHJpYnV0ZSB0aGF0XG4gIC8vIHNob3VsZCBob2xkIHRoZSBudW1iZXIgMSB0byA2LiBQYXJzZWQgYW5kIHNlcmlhbGl6ZWQgYXMgYDxoMT5gIHRvXG4gIC8vIGA8aDY+YCBlbGVtZW50cy5cbiAgaGVhZGluZzoge1xuICAgIGF0dHJzOiB7bGV2ZWw6IHtkZWZhdWx0OiAxfX0sXG4gICAgY29udGVudDogXCJpbmxpbmUqXCIsXG4gICAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICBwYXJzZURPTTogW3t0YWc6IFwiaDFcIiwgYXR0cnM6IHtsZXZlbDogMX19LFxuICAgICAgICAgICAgICAge3RhZzogXCJoMlwiLCBhdHRyczoge2xldmVsOiAyfX0sXG4gICAgICAgICAgICAgICB7dGFnOiBcImgzXCIsIGF0dHJzOiB7bGV2ZWw6IDN9fSxcbiAgICAgICAgICAgICAgIHt0YWc6IFwiaDRcIiwgYXR0cnM6IHtsZXZlbDogNH19LFxuICAgICAgICAgICAgICAge3RhZzogXCJoNVwiLCBhdHRyczoge2xldmVsOiA1fX0sXG4gICAgICAgICAgICAgICB7dGFnOiBcImg2XCIsIGF0dHJzOiB7bGV2ZWw6IDZ9fV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKG5vZGUpIHsgcmV0dXJuIFtcImhcIiArIG5vZGUuYXR0cnMubGV2ZWwsIDBdIH1cbiAgfSxcblxuICAvLyA6OiBOb2RlU3BlYyBBIGNvZGUgbGlzdGluZy4gRGlzYWxsb3dzIG1hcmtzIG9yIG5vbi10ZXh0IGlubGluZVxuICAvLyBub2RlcyBieSBkZWZhdWx0LiBSZXByZXNlbnRlZCBhcyBhIGA8cHJlPmAgZWxlbWVudCB3aXRoIGFcbiAgLy8gYDxjb2RlPmAgZWxlbWVudCBpbnNpZGUgb2YgaXQuXG4gIGNvZGVfYmxvY2s6IHtcbiAgICBjb250ZW50OiBcInRleHQqXCIsXG4gICAgbWFya3M6IFwiXCIsXG4gICAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgICBjb2RlOiB0cnVlLFxuICAgIGRlZmluaW5nOiB0cnVlLFxuICAgIHBhcnNlRE9NOiBbe3RhZzogXCJwcmVcIiwgcHJlc2VydmVXaGl0ZXNwYWNlOiBcImZ1bGxcIn1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHsgcmV0dXJuIHByZURPTSB9XG4gIH0sXG5cbiAgLy8gOjogTm9kZVNwZWMgVGhlIHRleHQgbm9kZS5cbiAgdGV4dDoge1xuICAgIGdyb3VwOiBcImlubGluZVwiXG4gIH0sXG5cbiAgLy8gOjogTm9kZVNwZWMgQW4gaW5saW5lIGltYWdlIChgPGltZz5gKSBub2RlLiBTdXBwb3J0cyBgc3JjYCxcbiAgLy8gYGFsdGAsIGFuZCBgaHJlZmAgYXR0cmlidXRlcy4gVGhlIGxhdHRlciB0d28gZGVmYXVsdCB0byB0aGUgZW1wdHlcbiAgLy8gc3RyaW5nLlxuICBpbWFnZToge1xuICAgIGlubGluZTogdHJ1ZSxcbiAgICBhdHRyczoge1xuICAgICAgc3JjOiB7fSxcbiAgICAgIGFsdDoge2RlZmF1bHQ6IG51bGx9LFxuICAgICAgdGl0bGU6IHtkZWZhdWx0OiBudWxsfVxuICAgIH0sXG4gICAgZ3JvdXA6IFwiaW5saW5lXCIsXG4gICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgIHBhcnNlRE9NOiBbe3RhZzogXCJpbWdbc3JjXVwiLCBnZXRBdHRyczogZnVuY3Rpb24gZ2V0QXR0cnMoZG9tKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzcmM6IGRvbS5nZXRBdHRyaWJ1dGUoXCJzcmNcIiksXG4gICAgICAgIHRpdGxlOiBkb20uZ2V0QXR0cmlidXRlKFwidGl0bGVcIiksXG4gICAgICAgIGFsdDogZG9tLmdldEF0dHJpYnV0ZShcImFsdFwiKVxuICAgICAgfVxuICAgIH19XSxcbiAgICB0b0RPTTogZnVuY3Rpb24gdG9ET00obm9kZSkgeyB2YXIgcmVmID0gbm9kZS5hdHRycztcbiAgICB2YXIgc3JjID0gcmVmLnNyYztcbiAgICB2YXIgYWx0ID0gcmVmLmFsdDtcbiAgICB2YXIgdGl0bGUgPSByZWYudGl0bGU7IHJldHVybiBbXCJpbWdcIiwge3NyYzogc3JjLCBhbHQ6IGFsdCwgdGl0bGU6IHRpdGxlfV0gfVxuICB9LFxuXG4gIC8vIDo6IE5vZGVTcGVjIEEgaGFyZCBsaW5lIGJyZWFrLCByZXByZXNlbnRlZCBpbiB0aGUgRE9NIGFzIGA8YnI+YC5cbiAgaGFyZF9icmVhazoge1xuICAgIGlubGluZTogdHJ1ZSxcbiAgICBncm91cDogXCJpbmxpbmVcIixcbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICBwYXJzZURPTTogW3t0YWc6IFwiYnJcIn1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHsgcmV0dXJuIGJyRE9NIH1cbiAgfVxufTtcblxudmFyIGVtRE9NID0gW1wiZW1cIiwgMF0sIHN0cm9uZ0RPTSA9IFtcInN0cm9uZ1wiLCAwXSwgY29kZURPTSA9IFtcImNvZGVcIiwgMF07XG5cbi8vIDo6IE9iamVjdCBbU3BlY3NdKCNtb2RlbC5NYXJrU3BlYykgZm9yIHRoZSBtYXJrcyBpbiB0aGUgc2NoZW1hLlxudmFyIG1hcmtzID0ge1xuICAvLyA6OiBNYXJrU3BlYyBBIGxpbmsuIEhhcyBgaHJlZmAgYW5kIGB0aXRsZWAgYXR0cmlidXRlcy4gYHRpdGxlYFxuICAvLyBkZWZhdWx0cyB0byB0aGUgZW1wdHkgc3RyaW5nLiBSZW5kZXJlZCBhbmQgcGFyc2VkIGFzIGFuIGA8YT5gXG4gIC8vIGVsZW1lbnQuXG4gIGxpbms6IHtcbiAgICBhdHRyczoge1xuICAgICAgaHJlZjoge30sXG4gICAgICB0aXRsZToge2RlZmF1bHQ6IG51bGx9XG4gICAgfSxcbiAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgIHBhcnNlRE9NOiBbe3RhZzogXCJhW2hyZWZdXCIsIGdldEF0dHJzOiBmdW5jdGlvbiBnZXRBdHRycyhkb20pIHtcbiAgICAgIHJldHVybiB7aHJlZjogZG9tLmdldEF0dHJpYnV0ZShcImhyZWZcIiksIHRpdGxlOiBkb20uZ2V0QXR0cmlidXRlKFwidGl0bGVcIil9XG4gICAgfX1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTShub2RlKSB7IHZhciByZWYgPSBub2RlLmF0dHJzO1xuICAgIHZhciBocmVmID0gcmVmLmhyZWY7XG4gICAgdmFyIHRpdGxlID0gcmVmLnRpdGxlOyByZXR1cm4gW1wiYVwiLCB7aHJlZjogaHJlZiwgdGl0bGU6IHRpdGxlfSwgMF0gfVxuICB9LFxuXG4gIC8vIDo6IE1hcmtTcGVjIEFuIGVtcGhhc2lzIG1hcmsuIFJlbmRlcmVkIGFzIGFuIGA8ZW0+YCBlbGVtZW50LlxuICAvLyBIYXMgcGFyc2UgcnVsZXMgdGhhdCBhbHNvIG1hdGNoIGA8aT5gIGFuZCBgZm9udC1zdHlsZTogaXRhbGljYC5cbiAgZW06IHtcbiAgICBwYXJzZURPTTogW3t0YWc6IFwiaVwifSwge3RhZzogXCJlbVwifSwge3N0eWxlOiBcImZvbnQtc3R5bGU9aXRhbGljXCJ9XSxcbiAgICB0b0RPTTogZnVuY3Rpb24gdG9ET00oKSB7IHJldHVybiBlbURPTSB9XG4gIH0sXG5cbiAgLy8gOjogTWFya1NwZWMgQSBzdHJvbmcgbWFyay4gUmVuZGVyZWQgYXMgYDxzdHJvbmc+YCwgcGFyc2UgcnVsZXNcbiAgLy8gYWxzbyBtYXRjaCBgPGI+YCBhbmQgYGZvbnQtd2VpZ2h0OiBib2xkYC5cbiAgc3Ryb25nOiB7XG4gICAgcGFyc2VET006IFt7dGFnOiBcInN0cm9uZ1wifSxcbiAgICAgICAgICAgICAgIC8vIFRoaXMgd29ya3MgYXJvdW5kIGEgR29vZ2xlIERvY3MgbWlzYmVoYXZpb3Igd2hlcmVcbiAgICAgICAgICAgICAgIC8vIHBhc3RlZCBjb250ZW50IHdpbGwgYmUgaW5leHBsaWNhYmx5IHdyYXBwZWQgaW4gYDxiPmBcbiAgICAgICAgICAgICAgIC8vIHRhZ3Mgd2l0aCBhIGZvbnQtd2VpZ2h0IG5vcm1hbC5cbiAgICAgICAgICAgICAgIHt0YWc6IFwiYlwiLCBnZXRBdHRyczogZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc3R5bGUuZm9udFdlaWdodCAhPSBcIm5vcm1hbFwiICYmIG51bGw7IH19LFxuICAgICAgICAgICAgICAge3N0eWxlOiBcImZvbnQtd2VpZ2h0XCIsIGdldEF0dHJzOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIC9eKGJvbGQoZXIpP3xbNS05XVxcZHsyLH0pJC8udGVzdCh2YWx1ZSkgJiYgbnVsbDsgfX1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHsgcmV0dXJuIHN0cm9uZ0RPTSB9XG4gIH0sXG5cbiAgLy8gOjogTWFya1NwZWMgQ29kZSBmb250IG1hcmsuIFJlcHJlc2VudGVkIGFzIGEgYDxjb2RlPmAgZWxlbWVudC5cbiAgY29kZToge1xuICAgIHBhcnNlRE9NOiBbe3RhZzogXCJjb2RlXCJ9XSxcbiAgICB0b0RPTTogZnVuY3Rpb24gdG9ET00oKSB7IHJldHVybiBjb2RlRE9NIH1cbiAgfVxufTtcblxuLy8gOjogU2NoZW1hXG4vLyBUaGlzIHNjaGVtYSByb3VnaGx5IGNvcnJlc3BvbmRzIHRvIHRoZSBkb2N1bWVudCBzY2hlbWEgdXNlZCBieVxuLy8gW0NvbW1vbk1hcmtdKGh0dHA6Ly9jb21tb25tYXJrLm9yZy8pLCBtaW51cyB0aGUgbGlzdCBlbGVtZW50cyxcbi8vIHdoaWNoIGFyZSBkZWZpbmVkIGluIHRoZSBbYHByb3NlbWlycm9yLXNjaGVtYS1saXN0YF0oI3NjaGVtYS1saXN0KVxuLy8gbW9kdWxlLlxuLy9cbi8vIFRvIHJldXNlIGVsZW1lbnRzIGZyb20gdGhpcyBzY2hlbWEsIGV4dGVuZCBvciByZWFkIGZyb20gaXRzXG4vLyBgc3BlYy5ub2Rlc2AgYW5kIGBzcGVjLm1hcmtzYCBbcHJvcGVydGllc10oI21vZGVsLlNjaGVtYS5zcGVjKS5cbnZhciBzY2hlbWEgPSBuZXcgU2NoZW1hKHtub2Rlczogbm9kZXMsIG1hcmtzOiBtYXJrc30pO1xuXG5leHBvcnQgeyBtYXJrcywgbm9kZXMsIHNjaGVtYSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJpbXBvcnQgeyBmaW5kV3JhcHBpbmcsIFJlcGxhY2VBcm91bmRTdGVwLCBjYW5TcGxpdCwgbGlmdFRhcmdldCB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBOb2RlUmFuZ2UsIEZyYWdtZW50LCBTbGljZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcblxudmFyIG9sRE9NID0gW1wib2xcIiwgMF0sIHVsRE9NID0gW1widWxcIiwgMF0sIGxpRE9NID0gW1wibGlcIiwgMF07XG5cbi8vIDo6IE5vZGVTcGVjXG4vLyBBbiBvcmRlcmVkIGxpc3QgW25vZGUgc3BlY10oI21vZGVsLk5vZGVTcGVjKS4gSGFzIGEgc2luZ2xlXG4vLyBhdHRyaWJ1dGUsIGBvcmRlcmAsIHdoaWNoIGRldGVybWluZXMgdGhlIG51bWJlciBhdCB3aGljaCB0aGUgbGlzdFxuLy8gc3RhcnRzIGNvdW50aW5nLCBhbmQgZGVmYXVsdHMgdG8gMS4gUmVwcmVzZW50ZWQgYXMgYW4gYDxvbD5gXG4vLyBlbGVtZW50LlxudmFyIG9yZGVyZWRMaXN0ID0ge1xuICBhdHRyczoge29yZGVyOiB7ZGVmYXVsdDogMX19LFxuICBwYXJzZURPTTogW3t0YWc6IFwib2xcIiwgZ2V0QXR0cnM6IGZ1bmN0aW9uIGdldEF0dHJzKGRvbSkge1xuICAgIHJldHVybiB7b3JkZXI6IGRvbS5oYXNBdHRyaWJ1dGUoXCJzdGFydFwiKSA/ICtkb20uZ2V0QXR0cmlidXRlKFwic3RhcnRcIikgOiAxfVxuICB9fV0sXG4gIHRvRE9NOiBmdW5jdGlvbiB0b0RPTShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuYXR0cnMub3JkZXIgPT0gMSA/IG9sRE9NIDogW1wib2xcIiwge3N0YXJ0OiBub2RlLmF0dHJzLm9yZGVyfSwgMF1cbiAgfVxufTtcblxuLy8gOjogTm9kZVNwZWNcbi8vIEEgYnVsbGV0IGxpc3Qgbm9kZSBzcGVjLCByZXByZXNlbnRlZCBpbiB0aGUgRE9NIGFzIGA8dWw+YC5cbnZhciBidWxsZXRMaXN0ID0ge1xuICBwYXJzZURPTTogW3t0YWc6IFwidWxcIn1dLFxuICB0b0RPTTogZnVuY3Rpb24gdG9ET00oKSB7IHJldHVybiB1bERPTSB9XG59O1xuXG4vLyA6OiBOb2RlU3BlY1xuLy8gQSBsaXN0IGl0ZW0gKGA8bGk+YCkgc3BlYy5cbnZhciBsaXN0SXRlbSA9IHtcbiAgcGFyc2VET006IFt7dGFnOiBcImxpXCJ9XSxcbiAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkgeyByZXR1cm4gbGlET00gfSxcbiAgZGVmaW5pbmc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGFkZChvYmosIHByb3BzKSB7XG4gIHZhciBjb3B5ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7IGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07IH1cbiAgZm9yICh2YXIgcHJvcCQxIGluIHByb3BzKSB7IGNvcHlbcHJvcCQxXSA9IHByb3BzW3Byb3AkMV07IH1cbiAgcmV0dXJuIGNvcHlcbn1cblxuLy8gOjogKE9yZGVyZWRNYXA8Tm9kZVNwZWM+LCBzdHJpbmcsID9zdHJpbmcpIOKGkiBPcmRlcmVkTWFwPE5vZGVTcGVjPlxuLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFkZGluZyBsaXN0LXJlbGF0ZWQgbm9kZSB0eXBlcyB0byBhIG1hcFxuLy8gc3BlY2lmeWluZyB0aGUgbm9kZXMgZm9yIGEgc2NoZW1hLiBBZGRzXG4vLyBbYG9yZGVyZWRMaXN0YF0oI3NjaGVtYS1saXN0Lm9yZGVyZWRMaXN0KSBhcyBgXCJvcmRlcmVkX2xpc3RcImAsXG4vLyBbYGJ1bGxldExpc3RgXSgjc2NoZW1hLWxpc3QuYnVsbGV0TGlzdCkgYXMgYFwiYnVsbGV0X2xpc3RcImAsIGFuZFxuLy8gW2BsaXN0SXRlbWBdKCNzY2hlbWEtbGlzdC5saXN0SXRlbSkgYXMgYFwibGlzdF9pdGVtXCJgLlxuLy9cbi8vIGBpdGVtQ29udGVudGAgZGV0ZXJtaW5lcyB0aGUgY29udGVudCBleHByZXNzaW9uIGZvciB0aGUgbGlzdCBpdGVtcy5cbi8vIElmIHlvdSB3YW50IHRoZSBjb21tYW5kcyBkZWZpbmVkIGluIHRoaXMgbW9kdWxlIHRvIGFwcGx5IHRvIHlvdXJcbi8vIGxpc3Qgc3RydWN0dXJlLCBpdCBzaG91bGQgaGF2ZSBhIHNoYXBlIGxpa2UgYFwicGFyYWdyYXBoIGJsb2NrKlwiYCBvclxuLy8gYFwicGFyYWdyYXBoIChvcmRlcmVkX2xpc3QgfCBidWxsZXRfbGlzdCkqXCJgLiBgbGlzdEdyb3VwYCBjYW4gYmVcbi8vIGdpdmVuIHRvIGFzc2lnbiBhIGdyb3VwIG5hbWUgdG8gdGhlIGxpc3Qgbm9kZSB0eXBlcywgZm9yIGV4YW1wbGVcbi8vIGBcImJsb2NrXCJgLlxuZnVuY3Rpb24gYWRkTGlzdE5vZGVzKG5vZGVzLCBpdGVtQ29udGVudCwgbGlzdEdyb3VwKSB7XG4gIHJldHVybiBub2Rlcy5hcHBlbmQoe1xuICAgIG9yZGVyZWRfbGlzdDogYWRkKG9yZGVyZWRMaXN0LCB7Y29udGVudDogXCJsaXN0X2l0ZW0rXCIsIGdyb3VwOiBsaXN0R3JvdXB9KSxcbiAgICBidWxsZXRfbGlzdDogYWRkKGJ1bGxldExpc3QsIHtjb250ZW50OiBcImxpc3RfaXRlbStcIiwgZ3JvdXA6IGxpc3RHcm91cH0pLFxuICAgIGxpc3RfaXRlbTogYWRkKGxpc3RJdGVtLCB7Y29udGVudDogaXRlbUNvbnRlbnR9KVxuICB9KVxufVxuXG4vLyA6OiAoTm9kZVR5cGUsID9PYmplY3QpIOKGkiAoc3RhdGU6IEVkaXRvclN0YXRlLCBkaXNwYXRjaDogPyh0cjogVHJhbnNhY3Rpb24pKSDihpIgYm9vbFxuLy8gUmV0dXJucyBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgc2VsZWN0aW9uIGluIGEgbGlzdCB3aXRoXG4vLyB0aGUgZ2l2ZW4gdHlwZSBhbiBhdHRyaWJ1dGVzLiBJZiBgZGlzcGF0Y2hgIGlzIG51bGwsIG9ubHkgcmV0dXJuIGFcbi8vIHZhbHVlIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyBpcyBwb3NzaWJsZSwgYnV0IGRvbid0IGFjdHVhbGx5XG4vLyBwZXJmb3JtIHRoZSBjaGFuZ2UuXG5mdW5jdGlvbiB3cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRycykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICB2YXIgJGZyb20gPSByZWYuJGZyb207XG4gICAgdmFyICR0byA9IHJlZi4kdG87XG4gICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCBkb0pvaW4gPSBmYWxzZSwgb3V0ZXJSYW5nZSA9IHJhbmdlO1xuICAgIGlmICghcmFuZ2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAvLyBUaGlzIGlzIGF0IHRoZSB0b3Agb2YgYW4gZXhpc3RpbmcgbGlzdCBpdGVtXG4gICAgaWYgKHJhbmdlLmRlcHRoID49IDIgJiYgJGZyb20ubm9kZShyYW5nZS5kZXB0aCAtIDEpLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobGlzdFR5cGUpICYmIHJhbmdlLnN0YXJ0SW5kZXggPT0gMCkge1xuICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhpcyBpcyB0aGUgdG9wIG9mIHRoZSBsaXN0XG4gICAgICBpZiAoJGZyb20uaW5kZXgocmFuZ2UuZGVwdGggLSAxKSA9PSAwKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgJGluc2VydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0IC0gMik7XG4gICAgICBvdXRlclJhbmdlID0gbmV3IE5vZGVSYW5nZSgkaW5zZXJ0LCAkaW5zZXJ0LCByYW5nZS5kZXB0aCk7XG4gICAgICBpZiAocmFuZ2UuZW5kSW5kZXggPCByYW5nZS5wYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgeyByYW5nZSA9IG5ldyBOb2RlUmFuZ2UoJGZyb20sIHN0YXRlLmRvYy5yZXNvbHZlKCR0by5lbmQocmFuZ2UuZGVwdGgpKSwgcmFuZ2UuZGVwdGgpOyB9XG4gICAgICBkb0pvaW4gPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgd3JhcCA9IGZpbmRXcmFwcGluZyhvdXRlclJhbmdlLCBsaXN0VHlwZSwgYXR0cnMsIHJhbmdlKTtcbiAgICBpZiAoIXdyYXApIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goZG9XcmFwSW5MaXN0KHN0YXRlLnRyLCByYW5nZSwgd3JhcCwgZG9Kb2luLCBsaXN0VHlwZSkuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGRvV3JhcEluTGlzdCh0ciwgcmFuZ2UsIHdyYXBwZXJzLCBqb2luQmVmb3JlLCBsaXN0VHlwZSkge1xuICB2YXIgY29udGVudCA9IEZyYWdtZW50LmVtcHR5O1xuICBmb3IgKHZhciBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgeyBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpOyB9XG5cbiAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAocmFuZ2Uuc3RhcnQgLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcmFuZ2UuZW5kLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xuXG4gIHZhciBmb3VuZCA9IDA7XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHdyYXBwZXJzLmxlbmd0aDsgaSQxKyspIHsgaWYgKHdyYXBwZXJzW2kkMV0udHlwZSA9PSBsaXN0VHlwZSkgeyBmb3VuZCA9IGkkMSArIDE7IH0gfVxuICB2YXIgc3BsaXREZXB0aCA9IHdyYXBwZXJzLmxlbmd0aCAtIGZvdW5kO1xuXG4gIHZhciBzcGxpdFBvcyA9IHJhbmdlLnN0YXJ0ICsgd3JhcHBlcnMubGVuZ3RoIC0gKGpvaW5CZWZvcmUgPyAyIDogMCksIHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgZm9yICh2YXIgaSQyID0gcmFuZ2Uuc3RhcnRJbmRleCwgZSA9IHJhbmdlLmVuZEluZGV4LCBmaXJzdCA9IHRydWU7IGkkMiA8IGU7IGkkMisrLCBmaXJzdCA9IGZhbHNlKSB7XG4gICAgaWYgKCFmaXJzdCAmJiBjYW5TcGxpdCh0ci5kb2MsIHNwbGl0UG9zLCBzcGxpdERlcHRoKSkge1xuICAgICAgdHIuc3BsaXQoc3BsaXRQb3MsIHNwbGl0RGVwdGgpO1xuICAgICAgc3BsaXRQb3MgKz0gMiAqIHNwbGl0RGVwdGg7XG4gICAgfVxuICAgIHNwbGl0UG9zICs9IHBhcmVudC5jaGlsZChpJDIpLm5vZGVTaXplO1xuICB9XG4gIHJldHVybiB0clxufVxuXG4vLyA6OiAoTm9kZVR5cGUpIOKGkiAoc3RhdGU6IEVkaXRvclN0YXRlLCBkaXNwYXRjaDogPyh0cjogVHJhbnNhY3Rpb24pKSDihpIgYm9vbFxuLy8gQnVpbGQgYSBjb21tYW5kIHRoYXQgc3BsaXRzIGEgbm9uLWVtcHR5IHRleHRibG9jayBhdCB0aGUgdG9wIGxldmVsXG4vLyBvZiBhIGxpc3QgaXRlbSBieSBhbHNvIHNwbGl0dGluZyB0aGF0IGxpc3QgaXRlbS5cbmZ1bmN0aW9uIHNwbGl0TGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgdmFyICRmcm9tID0gcmVmLiRmcm9tO1xuICAgIHZhciAkdG8gPSByZWYuJHRvO1xuICAgIHZhciBub2RlID0gcmVmLm5vZGU7XG4gICAgaWYgKChub2RlICYmIG5vZGUuaXNCbG9jaykgfHwgJGZyb20uZGVwdGggPCAyIHx8ICEkZnJvbS5zYW1lUGFyZW50KCR0bykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPSBpdGVtVHlwZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgLy8gSW4gYW4gZW1wdHkgYmxvY2suIElmIHRoaXMgaXMgYSBuZXN0ZWQgbGlzdCwgdGhlIHdyYXBwaW5nXG4gICAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICAgIGlmICgkZnJvbS5kZXB0aCA9PSAyIHx8ICRmcm9tLm5vZGUoLTMpLnR5cGUgIT0gaXRlbVR5cGUgfHxcbiAgICAgICAgICAkZnJvbS5pbmRleCgtMikgIT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB2YXIgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICB2YXIgZGVwdGhCZWZvcmUgPSAkZnJvbS5pbmRleCgtMSkgPyAxIDogJGZyb20uaW5kZXgoLTIpID8gMiA6IDM7XG4gICAgICAgIC8vIEJ1aWxkIGEgZnJhZ21lbnQgY29udGFpbmluZyBlbXB0eSB2ZXJzaW9ucyBvZiB0aGUgc3RydWN0dXJlXG4gICAgICAgIC8vIGZyb20gdGhlIG91dGVyIGxpc3QgaXRlbSB0byB0aGUgcGFyZW50IG5vZGUgb2YgdGhlIGN1cnNvclxuICAgICAgICBmb3IgKHZhciBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQtLSlcbiAgICAgICAgICB7IHdyYXAgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weSh3cmFwKSk7IH1cbiAgICAgICAgdmFyIGRlcHRoQWZ0ZXIgPSAkZnJvbS5pbmRleEFmdGVyKC0xKSA8ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgPyAxXG4gICAgICAgICAgICA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzO1xuICAgICAgICAvLyBBZGQgYSBzZWNvbmQgbGlzdCBpdGVtIHdpdGggYW4gZW1wdHkgZGVmYXVsdCBzdGFydCBub2RlXG4gICAgICAgIHdyYXAgPSB3cmFwLmFwcGVuZChGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICB2YXIgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSk7XG4gICAgICAgIHZhciB0ciQxID0gc3RhdGUudHIucmVwbGFjZShzdGFydCwgJGZyb20uYWZ0ZXIoLWRlcHRoQWZ0ZXIpLCBuZXcgU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSk7XG4gICAgICAgIHZhciBzZWwgPSAtMTtcbiAgICAgICAgdHIkMS5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ciQxLmRvYy5jb250ZW50LnNpemUsIGZ1bmN0aW9uIChub2RlLCBwb3MpIHtcbiAgICAgICAgICBpZiAoc2VsID4gLTEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZiAobm9kZS5pc1RleHRibG9jayAmJiBub2RlLmNvbnRlbnQuc2l6ZSA9PSAwKSB7IHNlbCA9IHBvcyArIDE7IH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzZWwgPiAtMSkgeyB0ciQxLnNldFNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24uY29uc3RydWN0b3IubmVhcih0ciQxLmRvYy5yZXNvbHZlKHNlbCkpKTsgfVxuICAgICAgICBkaXNwYXRjaCh0ciQxLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgdmFyIG5leHRUeXBlID0gJHRvLnBvcyA9PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbDtcbiAgICB2YXIgdHIgPSBzdGF0ZS50ci5kZWxldGUoJGZyb20ucG9zLCAkdG8ucG9zKTtcbiAgICB2YXIgdHlwZXMgPSBuZXh0VHlwZSAmJiBbbnVsbCwge3R5cGU6IG5leHRUeXBlfV07XG4gICAgaWYgKCFjYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMiwgdHlwZXMpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGRpc3BhdGNoKSB7IGRpc3BhdGNoKHRyLnNwbGl0KCRmcm9tLnBvcywgMiwgdHlwZXMpLnNjcm9sbEludG9WaWV3KCkpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG4vLyA6OiAoTm9kZVR5cGUpIOKGkiAoc3RhdGU6IEVkaXRvclN0YXRlLCBkaXNwYXRjaDogPyh0cjogVHJhbnNhY3Rpb24pKSDihpIgYm9vbFxuLy8gQ3JlYXRlIGEgY29tbWFuZCB0byBsaWZ0IHRoZSBsaXN0IGl0ZW0gYXJvdW5kIHRoZSBzZWxlY3Rpb24gdXAgaW50b1xuLy8gYSB3cmFwcGluZyBsaXN0LlxuZnVuY3Rpb24gbGlmdExpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIHZhciAkZnJvbSA9IHJlZi4kZnJvbTtcbiAgICB2YXIgJHRvID0gcmVmLiR0bztcbiAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuY2hpbGRDb3VudCAmJiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PSBpdGVtVHlwZTsgfSk7XG4gICAgaWYgKCFyYW5nZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICghZGlzcGF0Y2gpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmICgkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZSA9PSBpdGVtVHlwZSkgLy8gSW5zaWRlIGEgcGFyZW50IGxpc3RcbiAgICAgIHsgcmV0dXJuIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSkgfVxuICAgIGVsc2UgLy8gT3V0ZXIgbGlzdCBub2RlXG4gICAgICB7IHJldHVybiBsaWZ0T3V0T2ZMaXN0KHN0YXRlLCBkaXNwYXRjaCwgcmFuZ2UpIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpIHtcbiAgdmFyIHRyID0gc3RhdGUudHIsIGVuZCA9IHJhbmdlLmVuZCwgZW5kT2ZMaXN0ID0gcmFuZ2UuJHRvLmVuZChyYW5nZS5kZXB0aCk7XG4gIGlmIChlbmQgPCBlbmRPZkxpc3QpIHtcbiAgICAvLyBUaGVyZSBhcmUgc2libGluZ3MgYWZ0ZXIgdGhlIGxpZnRlZCBpdGVtcywgd2hpY2ggbXVzdCBiZWNvbWVcbiAgICAvLyBjaGlsZHJlbiBvZiB0aGUgbGFzdCBpdGVtXG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZW5kIC0gMSwgZW5kT2ZMaXN0LCBlbmQsIGVuZE9mTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGUobnVsbCwgcmFuZ2UucGFyZW50LmNvcHkoKSkpLCAxLCAwKSwgMSwgdHJ1ZSkpO1xuICAgIHJhbmdlID0gbmV3IE5vZGVSYW5nZSh0ci5kb2MucmVzb2x2ZShyYW5nZS4kZnJvbS5wb3MpLCB0ci5kb2MucmVzb2x2ZShlbmRPZkxpc3QpLCByYW5nZS5kZXB0aCk7XG4gIH1cbiAgZGlzcGF0Y2godHIubGlmdChyYW5nZSwgbGlmdFRhcmdldChyYW5nZSkpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBsaWZ0T3V0T2ZMaXN0KHN0YXRlLCBkaXNwYXRjaCwgcmFuZ2UpIHtcbiAgdmFyIHRyID0gc3RhdGUudHIsIGxpc3QgPSByYW5nZS5wYXJlbnQ7XG4gIC8vIE1lcmdlIHRoZSBsaXN0IGl0ZW1zIGludG8gYSBzaW5nbGUgYmlnIGl0ZW1cbiAgZm9yICh2YXIgcG9zID0gcmFuZ2UuZW5kLCBpID0gcmFuZ2UuZW5kSW5kZXggLSAxLCBlID0gcmFuZ2Uuc3RhcnRJbmRleDsgaSA+IGU7IGktLSkge1xuICAgIHBvcyAtPSBsaXN0LmNoaWxkKGkpLm5vZGVTaXplO1xuICAgIHRyLmRlbGV0ZShwb3MgLSAxLCBwb3MgKyAxKTtcbiAgfVxuICB2YXIgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQpLCBpdGVtID0gJHN0YXJ0Lm5vZGVBZnRlcjtcbiAgaWYgKHRyLm1hcHBpbmcubWFwKHJhbmdlLmVuZCkgIT0gcmFuZ2Uuc3RhcnQgKyAkc3RhcnQubm9kZUFmdGVyLm5vZGVTaXplKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBhdFN0YXJ0ID0gcmFuZ2Uuc3RhcnRJbmRleCA9PSAwLCBhdEVuZCA9IHJhbmdlLmVuZEluZGV4ID09IGxpc3QuY2hpbGRDb3VudDtcbiAgdmFyIHBhcmVudCA9ICRzdGFydC5ub2RlKC0xKSwgaW5kZXhCZWZvcmUgPSAkc3RhcnQuaW5kZXgoLTEpO1xuICBpZiAoIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4QmVmb3JlICsgKGF0U3RhcnQgPyAwIDogMSksIGluZGV4QmVmb3JlICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbnRlbnQuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QpKSkpXG4gICAgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgc3RhcnQgPSAkc3RhcnQucG9zLCBlbmQgPSBzdGFydCArIGl0ZW0ubm9kZVNpemU7XG4gIC8vIFN0cmlwIG9mZiB0aGUgc3Vycm91bmRpbmcgbGlzdC4gQXQgdGhlIHNpZGVzIHdoZXJlIHdlJ3JlIG5vdCBhdFxuICAvLyB0aGUgZW5kIG9mIHRoZSBsaXN0LCB0aGUgZXhpc3RpbmcgbGlzdCBpcyBjbG9zZWQuIEF0IHNpZGVzIHdoZXJlXG4gIC8vIHRoaXMgaXMgdGhlIGVuZCwgaXQgaXMgb3ZlcndyaXR0ZW4gdG8gaXRzIGVuZC5cbiAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQgLSAoYXRTdGFydCA/IDEgOiAwKSwgZW5kICsgKGF0RW5kID8gMSA6IDApLCBzdGFydCArIDEsIGVuZCAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTbGljZSgoYXRTdGFydCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoYXRFbmQgPyBGcmFnbWVudC5lbXB0eSA6IEZyYWdtZW50LmZyb20obGlzdC5jb3B5KEZyYWdtZW50LmVtcHR5KSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRTdGFydCA/IDAgOiAxLCBhdEVuZCA/IDAgOiAxKSwgYXRTdGFydCA/IDAgOiAxKSk7XG4gIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoTm9kZVR5cGUpIOKGkiAoc3RhdGU6IEVkaXRvclN0YXRlLCBkaXNwYXRjaDogPyh0cjogVHJhbnNhY3Rpb24pKSDihpIgYm9vbFxuLy8gQ3JlYXRlIGEgY29tbWFuZCB0byBzaW5rIHRoZSBsaXN0IGl0ZW0gYXJvdW5kIHRoZSBzZWxlY3Rpb24gZG93blxuLy8gaW50byBhbiBpbm5lciBsaXN0LlxuZnVuY3Rpb24gc2lua0xpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIHZhciAkZnJvbSA9IHJlZi4kZnJvbTtcbiAgICB2YXIgJHRvID0gcmVmLiR0bztcbiAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuY2hpbGRDb3VudCAmJiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PSBpdGVtVHlwZTsgfSk7XG4gICAgaWYgKCFyYW5nZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleDtcbiAgICBpZiAoc3RhcnRJbmRleCA9PSAwKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudCwgbm9kZUJlZm9yZSA9IHBhcmVudC5jaGlsZChzdGFydEluZGV4IC0gMSk7XG4gICAgaWYgKG5vZGVCZWZvcmUudHlwZSAhPSBpdGVtVHlwZSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICB2YXIgbmVzdGVkQmVmb3JlID0gbm9kZUJlZm9yZS5sYXN0Q2hpbGQgJiYgbm9kZUJlZm9yZS5sYXN0Q2hpbGQudHlwZSA9PSBwYXJlbnQudHlwZTtcbiAgICAgIHZhciBpbm5lciA9IEZyYWdtZW50LmZyb20obmVzdGVkQmVmb3JlID8gaXRlbVR5cGUuY3JlYXRlKCkgOiBudWxsKTtcbiAgICAgIHZhciBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKHBhcmVudC50eXBlLmNyZWF0ZShudWxsLCBpbm5lcikpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkQmVmb3JlID8gMyA6IDEsIDApO1xuICAgICAgdmFyIGJlZm9yZSA9IHJhbmdlLnN0YXJ0LCBhZnRlciA9IHJhbmdlLmVuZDtcbiAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKGJlZm9yZSAtIChuZXN0ZWRCZWZvcmUgPyAzIDogMSksIGFmdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlLCBhZnRlciwgc2xpY2UsIDEsIHRydWUpKVxuICAgICAgICAgICAgICAgLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmV4cG9ydCB7IGFkZExpc3ROb2RlcywgYnVsbGV0TGlzdCwgbGlmdExpc3RJdGVtLCBsaXN0SXRlbSwgb3JkZXJlZExpc3QsIHNpbmtMaXN0SXRlbSwgc3BsaXRMaXN0SXRlbSwgd3JhcEluTGlzdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJpbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQsIE1hcmssIE5vZGUgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBSZXBsYWNlU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFRyYW5zZm9ybSB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbnZhciBjbGFzc2VzQnlJZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8vIDo6LSBTdXBlcmNsYXNzIGZvciBlZGl0b3Igc2VsZWN0aW9ucy4gRXZlcnkgc2VsZWN0aW9uIHR5cGUgc2hvdWxkXG4vLyBleHRlbmQgdGhpcy4gU2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG52YXIgU2VsZWN0aW9uID0gZnVuY3Rpb24gU2VsZWN0aW9uKCRhbmNob3IsICRoZWFkLCByYW5nZXMpIHtcbiAgLy8gOjogW1NlbGVjdGlvblJhbmdlXVxuICAvLyBUaGUgcmFuZ2VzIGNvdmVyZWQgYnkgdGhlIHNlbGVjdGlvbi5cbiAgdGhpcy5yYW5nZXMgPSByYW5nZXMgfHwgW25ldyBTZWxlY3Rpb25SYW5nZSgkYW5jaG9yLm1pbigkaGVhZCksICRhbmNob3IubWF4KCRoZWFkKSldO1xuICAvLyA6OiBSZXNvbHZlZFBvc1xuICAvLyBUaGUgcmVzb2x2ZWQgYW5jaG9yIG9mIHRoZSBzZWxlY3Rpb24gKHRoZSBzaWRlIHRoYXQgc3RheXMgaW5cbiAgLy8gcGxhY2Ugd2hlbiB0aGUgc2VsZWN0aW9uIGlzIG1vZGlmaWVkKS5cbiAgdGhpcy4kYW5jaG9yID0gJGFuY2hvcjtcbiAgLy8gOjogUmVzb2x2ZWRQb3NcbiAgLy8gVGhlIHJlc29sdmVkIGhlYWQgb2YgdGhlIHNlbGVjdGlvbiAodGhlIHNpZGUgdGhhdCBtb3ZlcyB3aGVuXG4gIC8vIHRoZSBzZWxlY3Rpb24gaXMgbW9kaWZpZWQpLlxuICB0aGlzLiRoZWFkID0gJGhlYWQ7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBhbmNob3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saGVhZDogeyBjb25maWd1cmFibGU6IHRydWUgfSxmcm9tOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHRvOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LCRmcm9tOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LCR0bzogeyBjb25maWd1cmFibGU6IHRydWUgfSxlbXB0eTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyA6OiBudW1iZXJcbi8vIFRoZSBzZWxlY3Rpb24ncyBhbmNob3IsIGFzIGFuIHVucmVzb2x2ZWQgcG9zaXRpb24uXG5wcm90b3R5cGVBY2Nlc3NvcnMuYW5jaG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJGFuY2hvci5wb3MgfTtcblxuLy8gOjogbnVtYmVyXG4vLyBUaGUgc2VsZWN0aW9uJ3MgaGVhZC5cbnByb3RvdHlwZUFjY2Vzc29ycy5oZWFkLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJGhlYWQucG9zIH07XG5cbi8vIDo6IG51bWJlclxuLy8gVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxucHJvdG90eXBlQWNjZXNzb3JzLmZyb20uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kZnJvbS5wb3MgfTtcblxuLy8gOjogbnVtYmVyXG4vLyBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG5wcm90b3R5cGVBY2Nlc3NvcnMudG8uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kdG8ucG9zIH07XG5cbi8vIDo6IFJlc29sdmVkUG9zXG4vLyBUaGUgcmVzb2x2ZWQgbG93ZXJib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbnByb3RvdHlwZUFjY2Vzc29ycy4kZnJvbS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJhbmdlc1swXS4kZnJvbVxufTtcblxuLy8gOjogUmVzb2x2ZWRQb3Ncbi8vIFRoZSByZXNvbHZlZCB1cHBlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbnByb3RvdHlwZUFjY2Vzc29ycy4kdG8uZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yYW5nZXNbMF0uJHRvXG59O1xuXG4vLyA6OiBib29sXG4vLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2VsZWN0aW9uIGNvbnRhaW5zIGFueSBjb250ZW50LlxucHJvdG90eXBlQWNjZXNzb3JzLmVtcHR5LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICB7IGlmIChyYW5nZXNbaV0uJGZyb20ucG9zICE9IHJhbmdlc1tpXS4kdG8ucG9zKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIGVxOjogKFNlbGVjdGlvbikg4oaSIGJvb2xcbi8vIFRlc3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIHRoZSBzYW1lIGFzIGFub3RoZXIgc2VsZWN0aW9uLlxuXG4vLyBtYXA6OiAoZG9jOiBOb2RlLCBtYXBwaW5nOiBNYXBwYWJsZSkg4oaSIFNlbGVjdGlvblxuLy8gTWFwIHRoaXMgc2VsZWN0aW9uIHRocm91Z2ggYSBbbWFwcGFibGVdKCN0cmFuc2Zvcm0uTWFwcGFibGUpIHRoaW5nLiBgZG9jYFxuLy8gc2hvdWxkIGJlIHRoZSBuZXcgZG9jdW1lbnQgdG8gd2hpY2ggd2UgYXJlIG1hcHBpbmcuXG5cbi8vIDo6ICgpIOKGkiBTbGljZVxuLy8gR2V0IHRoZSBjb250ZW50IG9mIHRoaXMgc2VsZWN0aW9uIGFzIGEgc2xpY2UuXG5TZWxlY3Rpb24ucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiBjb250ZW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuJGZyb20ubm9kZSgwKS5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8sIHRydWUpXG59O1xuXG4vLyA6OiAoVHJhbnNhY3Rpb24sID9TbGljZSlcbi8vIFJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgc2xpY2Ugb3IsIGlmIG5vIHNsaWNlIGlzIGdpdmVuLFxuLy8gZGVsZXRlIHRoZSBzZWxlY3Rpb24uIFdpbGwgYXBwZW5kIHRvIHRoZSBnaXZlbiB0cmFuc2FjdGlvbi5cblNlbGVjdGlvbi5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKHRyLCBjb250ZW50KSB7XG4gICAgaWYgKCBjb250ZW50ID09PSB2b2lkIDAgKSBjb250ZW50ID0gU2xpY2UuZW1wdHk7XG5cbiAgLy8gUHV0IHRoZSBuZXcgc2VsZWN0aW9uIGF0IHRoZSBwb3NpdGlvbiBhZnRlciB0aGUgaW5zZXJ0ZWRcbiAgLy8gY29udGVudC4gV2hlbiB0aGF0IGVuZGVkIGluIGFuIGlubGluZSBub2RlLCBzZWFyY2ggYmFja3dhcmRzLFxuICAvLyB0byBnZXQgdGhlIHBvc2l0aW9uIGFmdGVyIHRoYXQgbm9kZS4gSWYgbm90LCBzZWFyY2ggZm9yd2FyZC5cbiAgdmFyIGxhc3ROb2RlID0gY29udGVudC5jb250ZW50Lmxhc3RDaGlsZCwgbGFzdFBhcmVudCA9IG51bGw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5vcGVuRW5kOyBpKyspIHtcbiAgICBsYXN0UGFyZW50ID0gbGFzdE5vZGU7XG4gICAgbGFzdE5vZGUgPSBsYXN0Tm9kZS5sYXN0Q2hpbGQ7XG4gIH1cblxuICB2YXIgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCwgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHJhbmdlcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgdmFyIHJlZiA9IHJhbmdlc1tpJDFdO1xuICAgICAgdmFyICRmcm9tID0gcmVmLiRmcm9tO1xuICAgICAgdmFyICR0byA9IHJlZi4kdG87XG4gICAgICB2YXIgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgdHIucmVwbGFjZVJhbmdlKG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIG1hcHBpbmcubWFwKCR0by5wb3MpLCBpJDEgPyBTbGljZS5lbXB0eSA6IGNvbnRlbnQpO1xuICAgIGlmIChpJDEgPT0gMClcbiAgICAgIHsgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIG1hcEZyb20sIChsYXN0Tm9kZSA/IGxhc3ROb2RlLmlzSW5saW5lIDogbGFzdFBhcmVudCAmJiBsYXN0UGFyZW50LmlzVGV4dGJsb2NrKSA/IC0xIDogMSk7IH1cbiAgfVxufTtcblxuLy8gOjogKFRyYW5zYWN0aW9uLCBOb2RlKVxuLy8gUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUsIGFwcGVuZGluZyB0aGUgY2hhbmdlc1xuLy8gdG8gdGhlIGdpdmVuIHRyYW5zYWN0aW9uLlxuU2VsZWN0aW9uLnByb3RvdHlwZS5yZXBsYWNlV2l0aCA9IGZ1bmN0aW9uIHJlcGxhY2VXaXRoICh0ciwgbm9kZSkge1xuICB2YXIgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCwgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlZiA9IHJhbmdlc1tpXTtcbiAgICAgIHZhciAkZnJvbSA9IHJlZi4kZnJvbTtcbiAgICAgIHZhciAkdG8gPSByZWYuJHRvO1xuICAgICAgdmFyIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXAoJGZyb20ucG9zKSwgdG8gPSBtYXBwaW5nLm1hcCgkdG8ucG9zKTtcbiAgICBpZiAoaSkge1xuICAgICAgdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBub2RlKTtcbiAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBtYXBGcm9tLCBub2RlLmlzSW5saW5lID8gLTEgOiAxKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHRvSlNPTjo6ICgpIOKGkiBPYmplY3Rcbi8vIENvbnZlcnQgdGhlIHNlbGVjdGlvbiB0byBhIEpTT04gcmVwcmVzZW50YXRpb24uIFdoZW4gaW1wbGVtZW50aW5nXG4vLyB0aGlzIGZvciBhIGN1c3RvbSBzZWxlY3Rpb24gY2xhc3MsIG1ha2Ugc3VyZSB0byBnaXZlIHRoZSBvYmplY3QgYVxuLy8gYHR5cGVgIHByb3BlcnR5IHdob3NlIHZhbHVlIG1hdGNoZXMgdGhlIElEIHVuZGVyIHdoaWNoIHlvdVxuLy8gW3JlZ2lzdGVyZWRdKCNzdGF0ZS5TZWxlY3Rpb25eanNvbklEKSB5b3VyIGNsYXNzLlxuXG4vLyA6OiAoUmVzb2x2ZWRQb3MsIG51bWJlciwgP2Jvb2wpIOKGkiA/U2VsZWN0aW9uXG4vLyBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gc3RhcnRpbmcgYXQgdGhlIGdpdmVuXG4vLyBwb3NpdGlvbiBhbmQgc2VhcmNoaW5nIGJhY2sgaWYgYGRpcmAgaXMgbmVnYXRpdmUsIGFuZCBmb3J3YXJkIGlmXG4vLyBwb3NpdGl2ZS4gV2hlbiBgdGV4dE9ubHlgIGlzIHRydWUsIG9ubHkgY29uc2lkZXIgY3Vyc29yXG4vLyBzZWxlY3Rpb25zLiBXaWxsIHJldHVybiBudWxsIHdoZW4gbm8gdmFsaWQgc2VsZWN0aW9uIHBvc2l0aW9uIGlzXG4vLyBmb3VuZC5cblNlbGVjdGlvbi5maW5kRnJvbSA9IGZ1bmN0aW9uIGZpbmRGcm9tICgkcG9zLCBkaXIsIHRleHRPbmx5KSB7XG4gIHZhciBpbm5lciA9ICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQgPyBuZXcgVGV4dFNlbGVjdGlvbigkcG9zKVxuICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLnBhcmVudCwgJHBvcy5wb3MsICRwb3MuaW5kZXgoKSwgZGlyLCB0ZXh0T25seSk7XG4gIGlmIChpbm5lcikgeyByZXR1cm4gaW5uZXIgfVxuXG4gIGZvciAodmFyIGRlcHRoID0gJHBvcy5kZXB0aCAtIDE7IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICB2YXIgZm91bmQgPSBkaXIgPCAwXG4gICAgICAgID8gZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5iZWZvcmUoZGVwdGggKyAxKSwgJHBvcy5pbmRleChkZXB0aCksIGRpciwgdGV4dE9ubHkpXG4gICAgICAgIDogZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5hZnRlcihkZXB0aCArIDEpLCAkcG9zLmluZGV4KGRlcHRoKSArIDEsIGRpciwgdGV4dE9ubHkpO1xuICAgIGlmIChmb3VuZCkgeyByZXR1cm4gZm91bmQgfVxuICB9XG59O1xuXG4vLyA6OiAoUmVzb2x2ZWRQb3MsID9udW1iZXIpIOKGkiBTZWxlY3Rpb25cbi8vIEZpbmQgYSB2YWxpZCBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBuZWFyIHRoZSBnaXZlblxuLy8gcG9zaXRpb24uIFNlYXJjaGVzIGZvcndhcmQgZmlyc3QgYnkgZGVmYXVsdCwgYnV0IGlmIGBiaWFzYCBpc1xuLy8gbmVnYXRpdmUsIGl0IHdpbGwgc2VhcmNoIGJhY2t3YXJkcyBmaXJzdC5cblNlbGVjdGlvbi5uZWFyID0gZnVuY3Rpb24gbmVhciAoJHBvcywgYmlhcykge1xuICAgIGlmICggYmlhcyA9PT0gdm9pZCAwICkgYmlhcyA9IDE7XG5cbiAgcmV0dXJuIHRoaXMuZmluZEZyb20oJHBvcywgYmlhcykgfHwgdGhpcy5maW5kRnJvbSgkcG9zLCAtYmlhcykgfHwgbmV3IEFsbFNlbGVjdGlvbigkcG9zLm5vZGUoMCkpXG59O1xuXG4vLyA6OiAoTm9kZSkg4oaSIFNlbGVjdGlvblxuLy8gRmluZCB0aGUgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gY2xvc2VzdCB0byB0aGUgc3RhcnQgb2Zcbi8vIHRoZSBnaXZlbiBkb2N1bWVudC4gV2lsbCByZXR1cm4gYW5cbi8vIFtgQWxsU2VsZWN0aW9uYF0oI3N0YXRlLkFsbFNlbGVjdGlvbikgaWYgbm8gdmFsaWQgcG9zaXRpb25cbi8vIGV4aXN0cy5cblNlbGVjdGlvbi5hdFN0YXJ0ID0gZnVuY3Rpb24gYXRTdGFydCAoZG9jKSB7XG4gIHJldHVybiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBkb2MsIDAsIDAsIDEpIHx8IG5ldyBBbGxTZWxlY3Rpb24oZG9jKVxufTtcblxuLy8gOjogKE5vZGUpIOKGkiBTZWxlY3Rpb25cbi8vIEZpbmQgdGhlIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIGNsb3Nlc3QgdG8gdGhlIGVuZCBvZiB0aGVcbi8vIGdpdmVuIGRvY3VtZW50LlxuU2VsZWN0aW9uLmF0RW5kID0gZnVuY3Rpb24gYXRFbmQgKGRvYykge1xuICByZXR1cm4gZmluZFNlbGVjdGlvbkluKGRvYywgZG9jLCBkb2MuY29udGVudC5zaXplLCBkb2MuY2hpbGRDb3VudCwgLTEpIHx8IG5ldyBBbGxTZWxlY3Rpb24oZG9jKVxufTtcblxuLy8gOjogKE5vZGUsIE9iamVjdCkg4oaSIFNlbGVjdGlvblxuLy8gRGVzZXJpYWxpemUgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBzZWxlY3Rpb24uIE11c3QgYmVcbi8vIGltcGxlbWVudGVkIGZvciBjdXN0b20gY2xhc3NlcyAoYXMgYSBzdGF0aWMgY2xhc3MgbWV0aG9kKS5cblNlbGVjdGlvbi5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OIChkb2MsIGpzb24pIHtcbiAgaWYgKCFqc29uIHx8ICFqc29uLnR5cGUpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTZWxlY3Rpb24uZnJvbUpTT05cIikgfVxuICB2YXIgY2xzID0gY2xhc3Nlc0J5SWRbanNvbi50eXBlXTtcbiAgaWYgKCFjbHMpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKFwiTm8gc2VsZWN0aW9uIHR5cGUgXCIgKyAoanNvbi50eXBlKSArIFwiIGRlZmluZWRcIikpIH1cbiAgcmV0dXJuIGNscy5mcm9tSlNPTihkb2MsIGpzb24pXG59O1xuXG4vLyA6OiAoc3RyaW5nLCBjb25zdHJ1Y3RvcjxTZWxlY3Rpb24+KVxuLy8gVG8gYmUgYWJsZSB0byBkZXNlcmlhbGl6ZSBzZWxlY3Rpb25zIGZyb20gSlNPTiwgY3VzdG9tIHNlbGVjdGlvblxuLy8gY2xhc3NlcyBtdXN0IHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCBhbiBJRCBzdHJpbmcsIHNvIHRoYXQgdGhleVxuLy8gY2FuIGJlIGRpc2FtYmlndWF0ZWQuIFRyeSB0byBwaWNrIHNvbWV0aGluZyB0aGF0J3MgdW5saWtlbHkgdG9cbi8vIGNsYXNoIHdpdGggY2xhc3NlcyBmcm9tIG90aGVyIG1vZHVsZXMuXG5TZWxlY3Rpb24uanNvbklEID0gZnVuY3Rpb24ganNvbklEIChpZCwgc2VsZWN0aW9uQ2xhc3MpIHtcbiAgaWYgKGlkIGluIGNsYXNzZXNCeUlkKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzZWxlY3Rpb24gSlNPTiBJRCBcIiArIGlkKSB9XG4gIGNsYXNzZXNCeUlkW2lkXSA9IHNlbGVjdGlvbkNsYXNzO1xuICBzZWxlY3Rpb25DbGFzcy5wcm90b3R5cGUuanNvbklEID0gaWQ7XG4gIHJldHVybiBzZWxlY3Rpb25DbGFzc1xufTtcblxuLy8gOjogKCkg4oaSIFNlbGVjdGlvbkJvb2ttYXJrXG4vLyBHZXQgYSBbYm9va21hcmtdKCNzdGF0ZS5TZWxlY3Rpb25Cb29rbWFyaykgZm9yIHRoaXMgc2VsZWN0aW9uLFxuLy8gd2hpY2ggaXMgYSB2YWx1ZSB0aGF0IGNhbiBiZSBtYXBwZWQgd2l0aG91dCBoYXZpbmcgYWNjZXNzIHRvIGFcbi8vIGN1cnJlbnQgZG9jdW1lbnQsIGFuZCBsYXRlciByZXNvbHZlZCB0byBhIHJlYWwgc2VsZWN0aW9uIGZvciBhXG4vLyBnaXZlbiBkb2N1bWVudCBhZ2Fpbi4gKFRoaXMgaXMgdXNlZCBtb3N0bHkgYnkgdGhlIGhpc3RvcnkgdG9cbi8vIHRyYWNrIGFuZCByZXN0b3JlIG9sZCBzZWxlY3Rpb25zLikgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2Zcbi8vIHRoaXMgbWV0aG9kIGp1c3QgY29udmVydHMgdGhlIHNlbGVjdGlvbiB0byBhIHRleHQgc2VsZWN0aW9uIGFuZFxuLy8gcmV0dXJucyB0aGUgYm9va21hcmsgZm9yIHRoYXQuXG5TZWxlY3Rpb24ucHJvdG90eXBlLmdldEJvb2ttYXJrID0gZnVuY3Rpb24gZ2V0Qm9va21hcmsgKCkge1xuICByZXR1cm4gVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKHRoaXMuJGFuY2hvciwgdGhpcy4kaGVhZCkuZ2V0Qm9va21hcmsoKVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFNlbGVjdGlvbi5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4vLyA6OiBib29sXG4vLyBDb250cm9scyB3aGV0aGVyLCB3aGVuIGEgc2VsZWN0aW9uIG9mIHRoaXMgdHlwZSBpcyBhY3RpdmUgaW4gdGhlXG4vLyBicm93c2VyLCB0aGUgc2VsZWN0ZWQgcmFuZ2Ugc2hvdWxkIGJlIHZpc2libGUgdG8gdGhlIHVzZXIuIERlZmF1bHRzXG4vLyB0byBgdHJ1ZWAuXG5TZWxlY3Rpb24ucHJvdG90eXBlLnZpc2libGUgPSB0cnVlO1xuXG4vLyBTZWxlY3Rpb25Cb29rbWFyazo6IGludGVyZmFjZVxuLy8gQSBsaWdodHdlaWdodCwgZG9jdW1lbnQtaW5kZXBlbmRlbnQgcmVwcmVzZW50YXRpb24gb2YgYSBzZWxlY3Rpb24uXG4vLyBZb3UgY2FuIGRlZmluZSBhIGN1c3RvbSBib29rbWFyayB0eXBlIGZvciBhIGN1c3RvbSBzZWxlY3Rpb24gY2xhc3Ncbi8vIHRvIG1ha2UgdGhlIGhpc3RvcnkgaGFuZGxlIGl0IHdlbGwuXG4vL1xuLy8gICBtYXA6OiAobWFwcGluZzogTWFwcGluZykg4oaSIFNlbGVjdGlvbkJvb2ttYXJrXG4vLyAgIE1hcCB0aGUgYm9va21hcmsgdGhyb3VnaCBhIHNldCBvZiBjaGFuZ2VzLlxuLy9cbi8vICAgcmVzb2x2ZTo6IChkb2M6IE5vZGUpIOKGkiBTZWxlY3Rpb25cbi8vICAgUmVzb2x2ZSB0aGUgYm9va21hcmsgdG8gYSByZWFsIHNlbGVjdGlvbiBhZ2Fpbi4gVGhpcyBtYXkgbmVlZCB0b1xuLy8gICBkbyBzb21lIGVycm9yIGNoZWNraW5nIGFuZCBtYXkgZmFsbCBiYWNrIHRvIGEgZGVmYXVsdCAodXN1YWxseVxuLy8gICBbYFRleHRTZWxlY3Rpb24uYmV0d2VlbmBdKCNzdGF0ZS5UZXh0U2VsZWN0aW9uXmJldHdlZW4pKSBpZlxuLy8gICBtYXBwaW5nIG1hZGUgdGhlIGJvb2ttYXJrIGludmFsaWQuXG5cbi8vIDo6LSBSZXByZXNlbnRzIGEgc2VsZWN0ZWQgcmFuZ2UgaW4gYSBkb2N1bWVudC5cbnZhciBTZWxlY3Rpb25SYW5nZSA9IGZ1bmN0aW9uIFNlbGVjdGlvblJhbmdlKCRmcm9tLCAkdG8pIHtcbiAgLy8gOjogUmVzb2x2ZWRQb3NcbiAgLy8gVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSByYW5nZS5cbiAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAvLyA6OiBSZXNvbHZlZFBvc1xuICAvLyBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxuICB0aGlzLiR0byA9ICR0bztcbn07XG5cbi8vIDo6LSBBIHRleHQgc2VsZWN0aW9uIHJlcHJlc2VudHMgYSBjbGFzc2ljYWwgZWRpdG9yIHNlbGVjdGlvbiwgd2l0aFxuLy8gYSBoZWFkICh0aGUgbW92aW5nIHNpZGUpIGFuZCBhbmNob3IgKGltbW9iaWxlIHNpZGUpLCBib3RoIG9mIHdoaWNoXG4vLyBwb2ludCBpbnRvIHRleHRibG9jayBub2Rlcy4gSXQgY2FuIGJlIGVtcHR5IChhIHJlZ3VsYXIgY3Vyc29yXG4vLyBwb3NpdGlvbikuXG52YXIgVGV4dFNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlbGVjdGlvbikge1xuICBmdW5jdGlvbiBUZXh0U2VsZWN0aW9uKCRhbmNob3IsICRoZWFkKSB7XG4gICAgaWYgKCAkaGVhZCA9PT0gdm9pZCAwICkgJGhlYWQgPSAkYW5jaG9yO1xuXG4gICAgU2VsZWN0aW9uLmNhbGwodGhpcywgJGFuY2hvciwgJGhlYWQpO1xuICB9XG5cbiAgaWYgKCBTZWxlY3Rpb24gKSBUZXh0U2VsZWN0aW9uLl9fcHJvdG9fXyA9IFNlbGVjdGlvbjtcbiAgVGV4dFNlbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZWxlY3Rpb24gJiYgU2VsZWN0aW9uLnByb3RvdHlwZSApO1xuICBUZXh0U2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHRTZWxlY3Rpb247XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxID0geyAkY3Vyc29yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgLy8gOjogP1Jlc29sdmVkUG9zXG4gIC8vIFJldHVybnMgYSByZXNvbHZlZCBwb3NpdGlvbiBpZiB0aGlzIGlzIGEgY3Vyc29yIHNlbGVjdGlvbiAoYW5cbiAgLy8gZW1wdHkgdGV4dCBzZWxlY3Rpb24pLCBhbmQgbnVsbCBvdGhlcndpc2UuXG4gIHByb3RvdHlwZUFjY2Vzc29ycyQxLiRjdXJzb3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kYW5jaG9yLnBvcyA9PSB0aGlzLiRoZWFkLnBvcyA/IHRoaXMuJGhlYWQgOiBudWxsIH07XG5cbiAgVGV4dFNlbGVjdGlvbi5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChkb2MsIG1hcHBpbmcpIHtcbiAgICB2YXIgJGhlYWQgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICBpZiAoISRoZWFkLnBhcmVudC5pbmxpbmVDb250ZW50KSB7IHJldHVybiBTZWxlY3Rpb24ubmVhcigkaGVhZCkgfVxuICAgIHZhciAkYW5jaG9yID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5hbmNob3IpKTtcbiAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRhbmNob3IgOiAkaGVhZCwgJGhlYWQpXG4gIH07XG5cbiAgVGV4dFNlbGVjdGlvbi5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKHRyLCBjb250ZW50KSB7XG4gICAgaWYgKCBjb250ZW50ID09PSB2b2lkIDAgKSBjb250ZW50ID0gU2xpY2UuZW1wdHk7XG5cbiAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnJlcGxhY2UuY2FsbCh0aGlzLCB0ciwgY29udGVudCk7XG4gICAgaWYgKGNvbnRlbnQgPT0gU2xpY2UuZW1wdHkpIHtcbiAgICAgIHZhciBtYXJrcyA9IHRoaXMuJGZyb20ubWFya3NBY3Jvc3ModGhpcy4kdG8pO1xuICAgICAgaWYgKG1hcmtzKSB7IHRyLmVuc3VyZU1hcmtzKG1hcmtzKTsgfVxuICAgIH1cbiAgfTtcblxuICBUZXh0U2VsZWN0aW9uLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgb3RoZXIuYW5jaG9yID09IHRoaXMuYW5jaG9yICYmIG90aGVyLmhlYWQgPT0gdGhpcy5oZWFkXG4gIH07XG5cbiAgVGV4dFNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0Qm9va21hcmsgPSBmdW5jdGlvbiBnZXRCb29rbWFyayAoKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsodGhpcy5hbmNob3IsIHRoaXMuaGVhZClcbiAgfTtcblxuICBUZXh0U2VsZWN0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB7dHlwZTogXCJ0ZXh0XCIsIGFuY2hvcjogdGhpcy5hbmNob3IsIGhlYWQ6IHRoaXMuaGVhZH1cbiAgfTtcblxuICBUZXh0U2VsZWN0aW9uLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04gKGRvYywganNvbikge1xuICAgIGlmICh0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5oZWFkICE9IFwibnVtYmVyXCIpXG4gICAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgVGV4dFNlbGVjdGlvbi5mcm9tSlNPTlwiKSB9XG4gICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0aW9uKGRvYy5yZXNvbHZlKGpzb24uYW5jaG9yKSwgZG9jLnJlc29sdmUoanNvbi5oZWFkKSlcbiAgfTtcblxuICAvLyA6OiAoTm9kZSwgbnVtYmVyLCA/bnVtYmVyKSDihpIgVGV4dFNlbGVjdGlvblxuICAvLyBDcmVhdGUgYSB0ZXh0IHNlbGVjdGlvbiBmcm9tIG5vbi1yZXNvbHZlZCBwb3NpdGlvbnMuXG4gIFRleHRTZWxlY3Rpb24uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlIChkb2MsIGFuY2hvciwgaGVhZCkge1xuICAgIGlmICggaGVhZCA9PT0gdm9pZCAwICkgaGVhZCA9IGFuY2hvcjtcblxuICAgIHZhciAkYW5jaG9yID0gZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgICByZXR1cm4gbmV3IHRoaXMoJGFuY2hvciwgaGVhZCA9PSBhbmNob3IgPyAkYW5jaG9yIDogZG9jLnJlc29sdmUoaGVhZCkpXG4gIH07XG5cbiAgLy8gOjogKFJlc29sdmVkUG9zLCBSZXNvbHZlZFBvcywgP251bWJlcikg4oaSIFNlbGVjdGlvblxuICAvLyBSZXR1cm4gYSB0ZXh0IHNlbGVjdGlvbiB0aGF0IHNwYW5zIHRoZSBnaXZlbiBwb3NpdGlvbnMgb3IsIGlmXG4gIC8vIHRoZXkgYXJlbid0IHRleHQgcG9zaXRpb25zLCBmaW5kIGEgdGV4dCBzZWxlY3Rpb24gbmVhciB0aGVtLlxuICAvLyBgYmlhc2AgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtZXRob2Qgc2VhcmNoZXMgZm9yd2FyZCAoZGVmYXVsdClcbiAgLy8gb3IgYmFja3dhcmRzIChuZWdhdGl2ZSBudW1iZXIpIGZpcnN0LiBXaWxsIGZhbGwgYmFjayB0byBjYWxsaW5nXG4gIC8vIFtgU2VsZWN0aW9uLm5lYXJgXSgjc3RhdGUuU2VsZWN0aW9uXm5lYXIpIHdoZW4gdGhlIGRvY3VtZW50XG4gIC8vIGRvZXNuJ3QgY29udGFpbiBhIHZhbGlkIHRleHQgcG9zaXRpb24uXG4gIFRleHRTZWxlY3Rpb24uYmV0d2VlbiA9IGZ1bmN0aW9uIGJldHdlZW4gKCRhbmNob3IsICRoZWFkLCBiaWFzKSB7XG4gICAgdmFyIGRQb3MgPSAkYW5jaG9yLnBvcyAtICRoZWFkLnBvcztcbiAgICBpZiAoIWJpYXMgfHwgZFBvcykgeyBiaWFzID0gZFBvcyA+PSAwID8gMSA6IC0xOyB9XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgdmFyIGZvdW5kID0gU2VsZWN0aW9uLmZpbmRGcm9tKCRoZWFkLCBiaWFzLCB0cnVlKSB8fCBTZWxlY3Rpb24uZmluZEZyb20oJGhlYWQsIC1iaWFzLCB0cnVlKTtcbiAgICAgIGlmIChmb3VuZCkgeyAkaGVhZCA9IGZvdW5kLiRoZWFkOyB9XG4gICAgICBlbHNlIHsgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkLCBiaWFzKSB9XG4gICAgfVxuICAgIGlmICghJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgaWYgKGRQb3MgPT0gMCkge1xuICAgICAgICAkYW5jaG9yID0gJGhlYWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkYW5jaG9yID0gKFNlbGVjdGlvbi5maW5kRnJvbSgkYW5jaG9yLCAtYmlhcywgdHJ1ZSkgfHwgU2VsZWN0aW9uLmZpbmRGcm9tKCRhbmNob3IsIGJpYXMsIHRydWUpKS4kYW5jaG9yO1xuICAgICAgICBpZiAoKCRhbmNob3IucG9zIDwgJGhlYWQucG9zKSAhPSAoZFBvcyA8IDApKSB7ICRhbmNob3IgPSAkaGVhZDsgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oJGFuY2hvciwgJGhlYWQpXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRleHRTZWxlY3Rpb24ucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG4gIHJldHVybiBUZXh0U2VsZWN0aW9uO1xufShTZWxlY3Rpb24pKTtcblxuU2VsZWN0aW9uLmpzb25JRChcInRleHRcIiwgVGV4dFNlbGVjdGlvbik7XG5cbnZhciBUZXh0Qm9va21hcmsgPSBmdW5jdGlvbiBUZXh0Qm9va21hcmsoYW5jaG9yLCBoZWFkKSB7XG4gIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICB0aGlzLmhlYWQgPSBoZWFkO1xufTtcblRleHRCb29rbWFyay5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nKSB7XG4gIHJldHVybiBuZXcgVGV4dEJvb2ttYXJrKG1hcHBpbmcubWFwKHRoaXMuYW5jaG9yKSwgbWFwcGluZy5tYXAodGhpcy5oZWFkKSlcbn07XG5UZXh0Qm9va21hcmsucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChkb2MpIHtcbiAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbihkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIGRvYy5yZXNvbHZlKHRoaXMuaGVhZCkpXG59O1xuXG4vLyA6Oi0gQSBub2RlIHNlbGVjdGlvbiBpcyBhIHNlbGVjdGlvbiB0aGF0IHBvaW50cyBhdCBhIHNpbmdsZSBub2RlLlxuLy8gQWxsIG5vZGVzIG1hcmtlZCBbc2VsZWN0YWJsZV0oI21vZGVsLk5vZGVTcGVjLnNlbGVjdGFibGUpIGNhbiBiZVxuLy8gdGhlIHRhcmdldCBvZiBhIG5vZGUgc2VsZWN0aW9uLiBJbiBzdWNoIGEgc2VsZWN0aW9uLCBgZnJvbWAgYW5kXG4vLyBgdG9gIHBvaW50IGRpcmVjdGx5IGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHNlbGVjdGVkIG5vZGUsIGBhbmNob3JgXG4vLyBlcXVhbHMgYGZyb21gLCBhbmQgYGhlYWRgIGVxdWFscyBgdG9gLi5cbnZhciBOb2RlU2VsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2VsZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIE5vZGVTZWxlY3Rpb24oJHBvcykge1xuICAgIHZhciBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgdmFyICRlbmQgPSAkcG9zLm5vZGUoMCkucmVzb2x2ZSgkcG9zLnBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgIFNlbGVjdGlvbi5jYWxsKHRoaXMsICRwb3MsICRlbmQpO1xuICAgIC8vIDo6IE5vZGUgVGhlIHNlbGVjdGVkIG5vZGUuXG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIGlmICggU2VsZWN0aW9uICkgTm9kZVNlbGVjdGlvbi5fX3Byb3RvX18gPSBTZWxlY3Rpb247XG4gIE5vZGVTZWxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VsZWN0aW9uICYmIFNlbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgTm9kZVNlbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOb2RlU2VsZWN0aW9uO1xuXG4gIE5vZGVTZWxlY3Rpb24ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAoZG9jLCBtYXBwaW5nKSB7XG4gICAgdmFyIHJlZiA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICB2YXIgZGVsZXRlZCA9IHJlZi5kZWxldGVkO1xuICAgIHZhciBwb3MgPSByZWYucG9zO1xuICAgIHZhciAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoZGVsZXRlZCkgeyByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJHBvcykgfVxuICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKVxuICB9O1xuXG4gIE5vZGVTZWxlY3Rpb24ucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiBjb250ZW50ICgpIHtcbiAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odGhpcy5ub2RlKSwgMCwgMClcbiAgfTtcblxuICBOb2RlU2VsZWN0aW9uLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgb3RoZXIuYW5jaG9yID09IHRoaXMuYW5jaG9yXG4gIH07XG5cbiAgTm9kZVNlbGVjdGlvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4ge3R5cGU6IFwibm9kZVwiLCBhbmNob3I6IHRoaXMuYW5jaG9yfVxuICB9O1xuXG4gIE5vZGVTZWxlY3Rpb24ucHJvdG90eXBlLmdldEJvb2ttYXJrID0gZnVuY3Rpb24gZ2V0Qm9va21hcmsgKCkgeyByZXR1cm4gbmV3IE5vZGVCb29rbWFyayh0aGlzLmFuY2hvcikgfTtcblxuICBOb2RlU2VsZWN0aW9uLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04gKGRvYywganNvbikge1xuICAgIGlmICh0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIilcbiAgICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlU2VsZWN0aW9uLmZyb21KU09OXCIpIH1cbiAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpKVxuICB9O1xuXG4gIC8vIDo6IChOb2RlLCBudW1iZXIpIOKGkiBOb2RlU2VsZWN0aW9uXG4gIC8vIENyZWF0ZSBhIG5vZGUgc2VsZWN0aW9uIGZyb20gbm9uLXJlc29sdmVkIHBvc2l0aW9ucy5cbiAgTm9kZVNlbGVjdGlvbi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUgKGRvYywgZnJvbSkge1xuICAgIHJldHVybiBuZXcgdGhpcyhkb2MucmVzb2x2ZShmcm9tKSlcbiAgfTtcblxuICAvLyA6OiAoTm9kZSkg4oaSIGJvb2xcbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIG1heSBiZSBzZWxlY3RlZCBhcyBhIG5vZGVcbiAgLy8gc2VsZWN0aW9uLlxuICBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIGlzU2VsZWN0YWJsZSAobm9kZSkge1xuICAgIHJldHVybiAhbm9kZS5pc1RleHQgJiYgbm9kZS50eXBlLnNwZWMuc2VsZWN0YWJsZSAhPT0gZmFsc2VcbiAgfTtcblxuICByZXR1cm4gTm9kZVNlbGVjdGlvbjtcbn0oU2VsZWN0aW9uKSk7XG5cbk5vZGVTZWxlY3Rpb24ucHJvdG90eXBlLnZpc2libGUgPSBmYWxzZTtcblxuU2VsZWN0aW9uLmpzb25JRChcIm5vZGVcIiwgTm9kZVNlbGVjdGlvbik7XG5cbnZhciBOb2RlQm9va21hcmsgPSBmdW5jdGlvbiBOb2RlQm9va21hcmsoYW5jaG9yKSB7XG4gIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xufTtcbk5vZGVCb29rbWFyay5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nKSB7XG4gIHZhciByZWYgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmFuY2hvcik7XG4gICAgdmFyIGRlbGV0ZWQgPSByZWYuZGVsZXRlZDtcbiAgICB2YXIgcG9zID0gcmVmLnBvcztcbiAgcmV0dXJuIGRlbGV0ZWQgPyBuZXcgVGV4dEJvb2ttYXJrKHBvcywgcG9zKSA6IG5ldyBOb2RlQm9va21hcmsocG9zKVxufTtcbk5vZGVCb29rbWFyay5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKGRvYykge1xuICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKHRoaXMuYW5jaG9yKSwgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICBpZiAobm9kZSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkgeyByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oJHBvcykgfVxuICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJHBvcylcbn07XG5cbi8vIDo6LSBBIHNlbGVjdGlvbiB0eXBlIHRoYXQgcmVwcmVzZW50cyBzZWxlY3RpbmcgdGhlIHdob2xlIGRvY3VtZW50XG4vLyAod2hpY2ggY2FuIG5vdCBuZWNlc3NhcmlseSBiZSBleHByZXNzZWQgd2l0aCBhIHRleHQgc2VsZWN0aW9uLCB3aGVuXG4vLyB0aGVyZSBhcmUgZm9yIGV4YW1wbGUgbGVhZiBibG9jayBub2RlcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZVxuLy8gZG9jdW1lbnQpLlxudmFyIEFsbFNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlbGVjdGlvbikge1xuICBmdW5jdGlvbiBBbGxTZWxlY3Rpb24oZG9jKSB7XG4gICAgU2VsZWN0aW9uLmNhbGwodGhpcywgZG9jLnJlc29sdmUoMCksIGRvYy5yZXNvbHZlKGRvYy5jb250ZW50LnNpemUpKTtcbiAgfVxuXG4gIGlmICggU2VsZWN0aW9uICkgQWxsU2VsZWN0aW9uLl9fcHJvdG9fXyA9IFNlbGVjdGlvbjtcbiAgQWxsU2VsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNlbGVjdGlvbiAmJiBTZWxlY3Rpb24ucHJvdG90eXBlICk7XG4gIEFsbFNlbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbGxTZWxlY3Rpb247XG5cbiAgQWxsU2VsZWN0aW9uLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAodHIsIGNvbnRlbnQpIHtcbiAgICBpZiAoIGNvbnRlbnQgPT09IHZvaWQgMCApIGNvbnRlbnQgPSBTbGljZS5lbXB0eTtcblxuICAgIGlmIChjb250ZW50ID09IFNsaWNlLmVtcHR5KSB7XG4gICAgICB0ci5kZWxldGUoMCwgdHIuZG9jLmNvbnRlbnQuc2l6ZSk7XG4gICAgICB2YXIgc2VsID0gU2VsZWN0aW9uLmF0U3RhcnQodHIuZG9jKTtcbiAgICAgIGlmICghc2VsLmVxKHRyLnNlbGVjdGlvbikpIHsgdHIuc2V0U2VsZWN0aW9uKHNlbCk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgU2VsZWN0aW9uLnByb3RvdHlwZS5yZXBsYWNlLmNhbGwodGhpcywgdHIsIGNvbnRlbnQpO1xuICAgIH1cbiAgfTtcblxuICBBbGxTZWxlY3Rpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7IHJldHVybiB7dHlwZTogXCJhbGxcIn0gfTtcblxuICBBbGxTZWxlY3Rpb24uZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTiAoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYykgfTtcblxuICBBbGxTZWxlY3Rpb24ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYykgfTtcblxuICBBbGxTZWxlY3Rpb24ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyKSB7IHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiB9O1xuXG4gIEFsbFNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0Qm9va21hcmsgPSBmdW5jdGlvbiBnZXRCb29rbWFyayAoKSB7IHJldHVybiBBbGxCb29rbWFyayB9O1xuXG4gIHJldHVybiBBbGxTZWxlY3Rpb247XG59KFNlbGVjdGlvbikpO1xuXG5TZWxlY3Rpb24uanNvbklEKFwiYWxsXCIsIEFsbFNlbGVjdGlvbik7XG5cbnZhciBBbGxCb29rbWFyayA9IHtcbiAgbWFwOiBmdW5jdGlvbiBtYXAoKSB7IHJldHVybiB0aGlzIH0sXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYykgfVxufTtcblxuLy8gRklYTUUgd2UnbGwgbmVlZCBzb21lIGF3YXJlbmVzcyBvZiB0ZXh0IGRpcmVjdGlvbiB3aGVuIHNjYW5uaW5nIGZvciBzZWxlY3Rpb25zXG5cbi8vIFRyeSB0byBmaW5kIGEgc2VsZWN0aW9uIGluc2lkZSB0aGUgZ2l2ZW4gbm9kZS4gYHBvc2AgcG9pbnRzIGF0IHRoZVxuLy8gcG9zaXRpb24gd2hlcmUgdGhlIHNlYXJjaCBzdGFydHMuIFdoZW4gYHRleHRgIGlzIHRydWUsIG9ubHkgcmV0dXJuXG4vLyB0ZXh0IHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBub2RlLCBwb3MsIGluZGV4LCBkaXIsIHRleHQpIHtcbiAgaWYgKG5vZGUuaW5saW5lQ29udGVudCkgeyByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBwb3MpIH1cbiAgZm9yICh2YXIgaSA9IGluZGV4IC0gKGRpciA+IDAgPyAwIDogMSk7IGRpciA+IDAgPyBpIDwgbm9kZS5jaGlsZENvdW50IDogaSA+PSAwOyBpICs9IGRpcikge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQoaSk7XG4gICAgaWYgKCFjaGlsZC5pc0F0b20pIHtcbiAgICAgIHZhciBpbm5lciA9IGZpbmRTZWxlY3Rpb25Jbihkb2MsIGNoaWxkLCBwb3MgKyBkaXIsIGRpciA8IDAgPyBjaGlsZC5jaGlsZENvdW50IDogMCwgZGlyLCB0ZXh0KTtcbiAgICAgIGlmIChpbm5lcikgeyByZXR1cm4gaW5uZXIgfVxuICAgIH0gZWxzZSBpZiAoIXRleHQgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoY2hpbGQpKSB7XG4gICAgICByZXR1cm4gTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBwb3MgLSAoZGlyIDwgMCA/IGNoaWxkLm5vZGVTaXplIDogMCkpXG4gICAgfVxuICAgIHBvcyArPSBjaGlsZC5ub2RlU2l6ZSAqIGRpcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgc3RhcnRMZW4sIGJpYXMpIHtcbiAgdmFyIGxhc3QgPSB0ci5zdGVwcy5sZW5ndGggLSAxO1xuICBpZiAobGFzdCA8IHN0YXJ0TGVuKSB7IHJldHVybiB9XG4gIHZhciBzdGVwID0gdHIuc3RlcHNbbGFzdF07XG4gIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCB8fCBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZUFyb3VuZFN0ZXApKSB7IHJldHVybiB9XG4gIHZhciBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbbGFzdF0sIGVuZDtcbiAgbWFwLmZvckVhY2goZnVuY3Rpb24gKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgeyBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gbmV3VG87IH0gfSk7XG4gIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSk7XG59XG5cbnZhciBVUERBVEVEX1NFTCA9IDEsIFVQREFURURfTUFSS1MgPSAyLCBVUERBVEVEX1NDUk9MTCA9IDQ7XG5cbi8vIDo6LSBBbiBlZGl0b3Igc3RhdGUgdHJhbnNhY3Rpb24sIHdoaWNoIGNhbiBiZSBhcHBsaWVkIHRvIGEgc3RhdGUgdG9cbi8vIGNyZWF0ZSBhbiB1cGRhdGVkIHN0YXRlLiBVc2Vcbi8vIFtgRWRpdG9yU3RhdGUudHJgXSgjc3RhdGUuRWRpdG9yU3RhdGUudHIpIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZS5cbi8vXG4vLyBUcmFuc2FjdGlvbnMgdHJhY2sgY2hhbmdlcyB0byB0aGUgZG9jdW1lbnQgKHRoZXkgYXJlIGEgc3ViY2xhc3Mgb2Zcbi8vIFtgVHJhbnNmb3JtYF0oI3RyYW5zZm9ybS5UcmFuc2Zvcm0pKSwgYnV0IGFsc28gb3RoZXIgc3RhdGUgY2hhbmdlcyxcbi8vIGxpa2Ugc2VsZWN0aW9uIHVwZGF0ZXMgYW5kIGFkanVzdG1lbnRzIG9mIHRoZSBzZXQgb2YgW3N0b3JlZFxuLy8gbWFya3NdKCNzdGF0ZS5FZGl0b3JTdGF0ZS5zdG9yZWRNYXJrcykuIEluIGFkZGl0aW9uLCB5b3UgY2FuIHN0b3JlXG4vLyBtZXRhZGF0YSBwcm9wZXJ0aWVzIGluIGEgdHJhbnNhY3Rpb24sIHdoaWNoIGFyZSBleHRyYSBwaWVjZXMgb2Zcbi8vIGluZm9ybWF0aW9uIHRoYXQgY2xpZW50IGNvZGUgb3IgcGx1Z2lucyBjYW4gdXNlIHRvIGRlc2NyaWJlIHdoYXQgYVxuLy8gdHJhbnNhY2lvbiByZXByZXNlbnRzLCBzbyB0aGF0IHRoZXkgY2FuIHVwZGF0ZSB0aGVpciBbb3duXG4vLyBzdGF0ZV0oI3N0YXRlLlN0YXRlRmllbGQpIGFjY29yZGluZ2x5LlxuLy9cbi8vIFRoZSBbZWRpdG9yIHZpZXddKCN2aWV3LkVkaXRvclZpZXcpIHVzZXMgYSBmZXcgbWV0YWRhdGEgcHJvcGVydGllczpcbi8vIGl0IHdpbGwgYXR0YWNoIGEgcHJvcGVydHkgYFwicG9pbnRlclwiYCB3aXRoIHRoZSB2YWx1ZSBgdHJ1ZWAgdG9cbi8vIHNlbGVjdGlvbiB0cmFuc2FjdGlvbnMgZGlyZWN0bHkgY2F1c2VkIGJ5IG1vdXNlIG9yIHRvdWNoIGlucHV0LCBhbmRcbi8vIGEgYFwidWlFdmVudFwiYCBwcm9wZXJ0eSBvZiB0aGF0IG1heSBiZSBgXCJwYXN0ZVwiYCwgYFwiY3V0XCJgLCBvciBgXCJkcm9wXCJgLlxudmFyIFRyYW5zYWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoVHJhbnNmb3JtKSB7XG4gIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKHN0YXRlKSB7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgc3RhdGUuZG9jKTtcbiAgICAvLyA6OiBudW1iZXJcbiAgICAvLyBUaGUgdGltZXN0YW1wIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRyYW5zYWN0aW9uLCBpbiB0aGUgc2FtZVxuICAgIC8vIGZvcm1hdCBhcyBgRGF0ZS5ub3coKWAuXG4gICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAvLyBUaGUgc3RlcCBjb3VudCBmb3Igd2hpY2ggdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIHZhbGlkLlxuICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gMDtcbiAgICAvLyA6OiA/W01hcmtdXG4gICAgLy8gVGhlIHN0b3JlZCBtYXJrcyBzZXQgYnkgdGhpcyB0cmFuc2FjdGlvbiwgaWYgYW55LlxuICAgIHRoaXMuc3RvcmVkTWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcztcbiAgICAvLyBCaXRmaWVsZCB0byB0cmFjayB3aGljaCBhc3BlY3RzIG9mIHRoZSBzdGF0ZSB3ZXJlIHVwZGF0ZWQgYnlcbiAgICAvLyB0aGlzIHRyYW5zYWN0aW9uLlxuICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgLy8gT2JqZWN0IHVzZWQgdG8gc3RvcmUgbWV0YWRhdGEgcHJvcGVydGllcyBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgIHRoaXMubWV0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBpZiAoIFRyYW5zZm9ybSApIFRyYW5zYWN0aW9uLl9fcHJvdG9fXyA9IFRyYW5zZm9ybTtcbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVHJhbnNmb3JtICYmIFRyYW5zZm9ybS5wcm90b3R5cGUgKTtcbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNhY3Rpb247XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgc2VsZWN0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHNlbGVjdGlvblNldDogeyBjb25maWd1cmFibGU6IHRydWUgfSxzdG9yZWRNYXJrc1NldDogeyBjb25maWd1cmFibGU6IHRydWUgfSxpc0dlbmVyaWM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sc2Nyb2xsZWRJbnRvVmlldzogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIC8vIDo6IFNlbGVjdGlvblxuICAvLyBUaGUgdHJhbnNhY3Rpb24ncyBjdXJyZW50IHNlbGVjdGlvbi4gVGhpcyBkZWZhdWx0cyB0byB0aGUgZWRpdG9yXG4gIC8vIHNlbGVjdGlvbiBbbWFwcGVkXSgjc3RhdGUuU2VsZWN0aW9uLm1hcCkgdGhyb3VnaCB0aGUgc3RlcHMgaW4gdGhlXG4gIC8vIHRyYW5zYWN0aW9uLCBidXQgY2FuIGJlIG92ZXJ3cml0dGVuIHdpdGhcbiAgLy8gW2BzZXRTZWxlY3Rpb25gXSgjc3RhdGUuVHJhbnNhY3Rpb24uc2V0U2VsZWN0aW9uKS5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLnNlbGVjdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY3VyU2VsZWN0aW9uRm9yIDwgdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gdGhpcy5jdXJTZWxlY3Rpb24ubWFwKHRoaXMuZG9jLCB0aGlzLm1hcHBpbmcuc2xpY2UodGhpcy5jdXJTZWxlY3Rpb25Gb3IpKTtcbiAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1clNlbGVjdGlvblxuICB9O1xuXG4gIC8vIDo6IChTZWxlY3Rpb24pIOKGkiBUcmFuc2FjdGlvblxuICAvLyBVcGRhdGUgdGhlIHRyYW5zYWN0aW9uJ3MgY3VycmVudCBzZWxlY3Rpb24uIFdpbGwgZGV0ZXJtaW5lIHRoZVxuICAvLyBzZWxlY3Rpb24gdGhhdCB0aGUgZWRpdG9yIGdldHMgd2hlbiB0aGUgdHJhbnNhY3Rpb24gaXMgYXBwbGllZC5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIHNldFNlbGVjdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgaWYgKHNlbGVjdGlvbi4kZnJvbS5kb2MgIT0gdGhpcy5kb2MpXG4gICAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBhc3NlZCB0byBzZXRTZWxlY3Rpb24gbXVzdCBwb2ludCBhdCB0aGUgY3VycmVudCBkb2N1bWVudFwiKSB9XG4gICAgdGhpcy5jdXJTZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgdGhpcy5jdXJTZWxlY3Rpb25Gb3IgPSB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgICB0aGlzLnVwZGF0ZWQgPSAodGhpcy51cGRhdGVkIHwgVVBEQVRFRF9TRUwpICYgflVQREFURURfTUFSS1M7XG4gICAgdGhpcy5zdG9yZWRNYXJrcyA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcblxuICAvLyA6OiBib29sXG4gIC8vIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiB3YXMgZXhwbGljaXRseSB1cGRhdGVkIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5zZWxlY3Rpb25TZXQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TRUwpID4gMFxuICB9O1xuXG4gIC8vIDo6ICg/W01hcmtdKSDihpIgVHJhbnNhY3Rpb25cbiAgLy8gU2V0IHRoZSBjdXJyZW50IHN0b3JlZCBtYXJrcy5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNldFN0b3JlZE1hcmtzID0gZnVuY3Rpb24gc2V0U3RvcmVkTWFya3MgKG1hcmtzKSB7XG4gICAgdGhpcy5zdG9yZWRNYXJrcyA9IG1hcmtzO1xuICAgIHRoaXMudXBkYXRlZCB8PSBVUERBVEVEX01BUktTO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG5cbiAgLy8gOjogKFtNYXJrXSkg4oaSIFRyYW5zYWN0aW9uXG4gIC8vIE1ha2Ugc3VyZSB0aGUgY3VycmVudCBzdG9yZWQgbWFya3Mgb3IsIGlmIHRoYXQgaXMgbnVsbCwgdGhlIG1hcmtzXG4gIC8vIGF0IHRoZSBzZWxlY3Rpb24sIG1hdGNoIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MuIERvZXMgbm90aGluZyBpZlxuICAvLyB0aGlzIGlzIGFscmVhZHkgdGhlIGNhc2UuXG4gIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5lbnN1cmVNYXJrcyA9IGZ1bmN0aW9uIGVuc3VyZU1hcmtzIChtYXJrcykge1xuICAgIGlmICghTWFyay5zYW1lU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSwgbWFya3MpKVxuICAgICAgeyB0aGlzLnNldFN0b3JlZE1hcmtzKG1hcmtzKTsgfVxuICAgIHJldHVybiB0aGlzXG4gIH07XG5cbiAgLy8gOjogKE1hcmspIOKGkiBUcmFuc2FjdGlvblxuICAvLyBBZGQgYSBtYXJrIHRvIHRoZSBzZXQgb2Ygc3RvcmVkIG1hcmtzLlxuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuYWRkU3RvcmVkTWFyayA9IGZ1bmN0aW9uIGFkZFN0b3JlZE1hcmsgKG1hcmspIHtcbiAgICByZXR1cm4gdGhpcy5lbnN1cmVNYXJrcyhtYXJrLmFkZFRvU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSkpXG4gIH07XG5cbiAgLy8gOjogKHVuaW9uPE1hcmssIE1hcmtUeXBlPikg4oaSIFRyYW5zYWN0aW9uXG4gIC8vIFJlbW92ZSBhIG1hcmsgb3IgbWFyayB0eXBlIGZyb20gdGhlIHNldCBvZiBzdG9yZWQgbWFya3MuXG4gIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdG9yZWRNYXJrID0gZnVuY3Rpb24gcmVtb3ZlU3RvcmVkTWFyayAobWFyaykge1xuICAgIHJldHVybiB0aGlzLmVuc3VyZU1hcmtzKG1hcmsucmVtb3ZlRnJvbVNldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpKVxuICB9O1xuXG4gIC8vIDo6IGJvb2xcbiAgLy8gV2hldGhlciB0aGUgc3RvcmVkIG1hcmtzIHdlcmUgZXhwbGljaXRseSBzZXQgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5zdG9yZWRNYXJrc1NldC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX01BUktTKSA+IDBcbiAgfTtcblxuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuYWRkU3RlcCA9IGZ1bmN0aW9uIGFkZFN0ZXAgKHN0ZXAsIGRvYykge1xuICAgIFRyYW5zZm9ybS5wcm90b3R5cGUuYWRkU3RlcC5jYWxsKHRoaXMsIHN0ZXAsIGRvYyk7XG4gICAgdGhpcy51cGRhdGVkID0gdGhpcy51cGRhdGVkICYgflVQREFURURfTUFSS1M7XG4gICAgdGhpcy5zdG9yZWRNYXJrcyA9IG51bGw7XG4gIH07XG5cbiAgLy8gOjogKG51bWJlcikg4oaSIFRyYW5zYWN0aW9uXG4gIC8vIFVwZGF0ZSB0aGUgdGltZXN0YW1wIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZXRUaW1lID0gZnVuY3Rpb24gc2V0VGltZSAodGltZSkge1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcblxuICAvLyA6OiAoU2xpY2UpIOKGkiBUcmFuc2FjdGlvblxuICAvLyBSZXBsYWNlIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBzbGljZS5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlcGxhY2VTZWxlY3Rpb24gPSBmdW5jdGlvbiByZXBsYWNlU2VsZWN0aW9uIChzbGljZSkge1xuICAgIHRoaXMuc2VsZWN0aW9uLnJlcGxhY2UodGhpcywgc2xpY2UpO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG5cbiAgLy8gOjogKE5vZGUsID9ib29sKSDihpIgVHJhbnNhY3Rpb25cbiAgLy8gUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUuIFdoZW4gYGluaGVyaXRNYXJrc2AgaXNcbiAgLy8gdHJ1ZSBhbmQgdGhlIGNvbnRlbnQgaXMgaW5saW5lLCBpdCBpbmhlcml0cyB0aGUgbWFya3MgZnJvbSB0aGVcbiAgLy8gcGxhY2Ugd2hlcmUgaXQgaXMgaW5zZXJ0ZWQuXG4gIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZXBsYWNlU2VsZWN0aW9uV2l0aCA9IGZ1bmN0aW9uIHJlcGxhY2VTZWxlY3Rpb25XaXRoIChub2RlLCBpbmhlcml0TWFya3MpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgaWYgKGluaGVyaXRNYXJrcyAhPT0gZmFsc2UpXG4gICAgICB7IG5vZGUgPSBub2RlLm1hcmsodGhpcy5zdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLmVtcHR5ID8gc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkgOiAoc2VsZWN0aW9uLiRmcm9tLm1hcmtzQWNyb3NzKHNlbGVjdGlvbi4kdG8pIHx8IE1hcmsubm9uZSkpKTsgfVxuICAgIHNlbGVjdGlvbi5yZXBsYWNlV2l0aCh0aGlzLCBub2RlKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xuXG4gIC8vIDo6ICgpIOKGkiBUcmFuc2FjdGlvblxuICAvLyBEZWxldGUgdGhlIHNlbGVjdGlvbi5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmRlbGV0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIGRlbGV0ZVNlbGVjdGlvbiAoKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24ucmVwbGFjZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xuXG4gIC8vIDo6IChzdHJpbmcsIGZyb206ID9udW1iZXIsIHRvOiA/bnVtYmVyKSDihpIgVHJhbnNhY3Rpb25cbiAgLy8gUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2UsIG9yIHRoZSBzZWxlY3Rpb24gaWYgbm8gcmFuZ2UgaXMgZ2l2ZW4sXG4gIC8vIHdpdGggYSB0ZXh0IG5vZGUgY29udGFpbmluZyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuaW5zZXJ0VGV4dCA9IGZ1bmN0aW9uIGluc2VydFRleHQgKHRleHQsIGZyb20sIHRvKSB7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSBmcm9tO1xuXG4gICAgdmFyIHNjaGVtYSA9IHRoaXMuZG9jLnR5cGUuc2NoZW1hO1xuICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgIGlmICghdGV4dCkgeyByZXR1cm4gdGhpcy5kZWxldGVTZWxlY3Rpb24oKSB9XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlU2VsZWN0aW9uV2l0aChzY2hlbWEudGV4dCh0ZXh0KSwgdHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzLmRlbGV0ZVJhbmdlKGZyb20sIHRvKSB9XG4gICAgICB2YXIgbWFya3MgPSB0aGlzLnN0b3JlZE1hcmtzO1xuICAgICAgaWYgKCFtYXJrcykge1xuICAgICAgICB2YXIgJGZyb20gPSB0aGlzLmRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgICBtYXJrcyA9IHRvID09IGZyb20gPyAkZnJvbS5tYXJrcygpIDogJGZyb20ubWFya3NBY3Jvc3ModGhpcy5kb2MucmVzb2x2ZSh0bykpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBzY2hlbWEudGV4dCh0ZXh0LCBtYXJrcykpO1xuICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5lbXB0eSkgeyB0aGlzLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0aGlzLnNlbGVjdGlvbi4kdG8pKTsgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH07XG5cbiAgLy8gOjogKHVuaW9uPHN0cmluZywgUGx1Z2luLCBQbHVnaW5LZXk+LCBhbnkpIOKGkiBUcmFuc2FjdGlvblxuICAvLyBTdG9yZSBhIG1ldGFkYXRhIHByb3BlcnR5IGluIHRoaXMgdHJhbnNhY3Rpb24sIGtleWVkIGVpdGhlciBieVxuICAvLyBuYW1lIG9yIGJ5IHBsdWdpbi5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNldE1ldGEgPSBmdW5jdGlvbiBzZXRNZXRhIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcblxuICAvLyA6OiAodW5pb248c3RyaW5nLCBQbHVnaW4sIFBsdWdpbktleT4pIOKGkiBhbnlcbiAgLy8gUmV0cmlldmUgYSBtZXRhZGF0YSBwcm9wZXJ0eSBmb3IgYSBnaXZlbiBuYW1lIG9yIHBsdWdpbi5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmdldE1ldGEgPSBmdW5jdGlvbiBnZXRNZXRhIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldXG4gIH07XG5cbiAgLy8gOjogYm9vbFxuICAvLyBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBkb2Vzbid0IGNvbnRhaW4gYW55IG1ldGFkYXRhLFxuICAvLyBhbmQgY2FuIHRodXMgc2FmZWx5IGJlIGV4dGVuZGVkLlxuICBwcm90b3R5cGVBY2Nlc3NvcnMuaXNHZW5lcmljLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfIGluIHRoaXMubWV0YSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLy8gOjogKCkg4oaSIFRyYW5zYWN0aW9uXG4gIC8vIEluZGljYXRlIHRoYXQgdGhlIGVkaXRvciBzaG91bGQgc2Nyb2xsIHRoZSBzZWxlY3Rpb24gaW50byB2aWV3XG4gIC8vIHdoZW4gdXBkYXRlZCB0byB0aGUgc3RhdGUgcHJvZHVjZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNjcm9sbEludG9WaWV3ID0gZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcgKCkge1xuICAgIHRoaXMudXBkYXRlZCB8PSBVUERBVEVEX1NDUk9MTDtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5zY3JvbGxlZEludG9WaWV3LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfU0NST0xMKSA+IDBcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gVHJhbnNhY3Rpb247XG59KFRyYW5zZm9ybSkpO1xuXG5mdW5jdGlvbiBiaW5kKGYsIHNlbGYpIHtcbiAgcmV0dXJuICFzZWxmIHx8ICFmID8gZiA6IGYuYmluZChzZWxmKVxufVxuXG52YXIgRmllbGREZXNjID0gZnVuY3Rpb24gRmllbGREZXNjKG5hbWUsIGRlc2MsIHNlbGYpIHtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5pbml0ID0gYmluZChkZXNjLmluaXQsIHNlbGYpO1xuICB0aGlzLmFwcGx5ID0gYmluZChkZXNjLmFwcGx5LCBzZWxmKTtcbn07XG5cbnZhciBiYXNlRmllbGRzID0gW1xuICBuZXcgRmllbGREZXNjKFwiZG9jXCIsIHtcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KGNvbmZpZykgeyByZXR1cm4gY29uZmlnLmRvYyB8fCBjb25maWcuc2NoZW1hLnRvcE5vZGVUeXBlLmNyZWF0ZUFuZEZpbGwoKSB9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0cikgeyByZXR1cm4gdHIuZG9jIH1cbiAgfSksXG5cbiAgbmV3IEZpZWxkRGVzYyhcInNlbGVjdGlvblwiLCB7XG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdChjb25maWcsIGluc3RhbmNlKSB7IHJldHVybiBjb25maWcuc2VsZWN0aW9uIHx8IFNlbGVjdGlvbi5hdFN0YXJ0KGluc3RhbmNlLmRvYykgfSxcbiAgICBhcHBseTogZnVuY3Rpb24gYXBwbHkodHIpIHsgcmV0dXJuIHRyLnNlbGVjdGlvbiB9XG4gIH0pLFxuXG4gIG5ldyBGaWVsZERlc2MoXCJzdG9yZWRNYXJrc1wiLCB7XG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdChjb25maWcpIHsgcmV0dXJuIGNvbmZpZy5zdG9yZWRNYXJrcyB8fCBudWxsIH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRyLCBfbWFya3MsIF9vbGQsIHN0YXRlKSB7IHJldHVybiBzdGF0ZS5zZWxlY3Rpb24uJGN1cnNvciA/IHRyLnN0b3JlZE1hcmtzIDogbnVsbCB9XG4gIH0pLFxuXG4gIG5ldyBGaWVsZERlc2MoXCJzY3JvbGxUb1NlbGVjdGlvblwiLCB7XG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHsgcmV0dXJuIDAgfSxcbiAgICBhcHBseTogZnVuY3Rpb24gYXBwbHkodHIsIHByZXYpIHsgcmV0dXJuIHRyLnNjcm9sbGVkSW50b1ZpZXcgPyBwcmV2ICsgMSA6IHByZXYgfVxuICB9KVxuXTtcblxuLy8gT2JqZWN0IHdyYXBwaW5nIHRoZSBwYXJ0IG9mIGEgc3RhdGUgb2JqZWN0IHRoYXQgc3RheXMgdGhlIHNhbWVcbi8vIGFjcm9zcyB0cmFuc2FjdGlvbnMuIFN0b3JlZCBpbiB0aGUgc3RhdGUncyBgY29uZmlnYCBwcm9wZXJ0eS5cbnZhciBDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gQ29uZmlndXJhdGlvbihzY2hlbWEsIHBsdWdpbnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIHRoaXMuZmllbGRzID0gYmFzZUZpZWxkcy5jb25jYXQoKTtcbiAgdGhpcy5wbHVnaW5zID0gW107XG4gIHRoaXMucGx1Z2luc0J5S2V5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKHBsdWdpbnMpIHsgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICBpZiAodGhpcyQxLnBsdWdpbnNCeUtleVtwbHVnaW4ua2V5XSlcbiAgICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBZGRpbmcgZGlmZmVyZW50IGluc3RhbmNlcyBvZiBhIGtleWVkIHBsdWdpbiAoXCIgKyBwbHVnaW4ua2V5ICsgXCIpXCIpIH1cbiAgICB0aGlzJDEucGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgdGhpcyQxLnBsdWdpbnNCeUtleVtwbHVnaW4ua2V5XSA9IHBsdWdpbjtcbiAgICBpZiAocGx1Z2luLnNwZWMuc3RhdGUpXG4gICAgICB7IHRoaXMkMS5maWVsZHMucHVzaChuZXcgRmllbGREZXNjKHBsdWdpbi5rZXksIHBsdWdpbi5zcGVjLnN0YXRlLCBwbHVnaW4pKTsgfVxuICB9KTsgfVxufTtcblxuLy8gOjotIFRoZSBzdGF0ZSBvZiBhIFByb3NlTWlycm9yIGVkaXRvciBpcyByZXByZXNlbnRlZCBieSBhbiBvYmplY3Rcbi8vIG9mIHRoaXMgdHlwZS4gQSBzdGF0ZSBpcyBhIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmXigJRpdCBpc24ndFxuLy8gdXBkYXRlZCwgYnV0IHJhdGhlciBhIG5ldyBzdGF0ZSB2YWx1ZSBpcyBjb21wdXRlZCBmcm9tIGFuIG9sZCBvbmVcbi8vIHVzaW5nIHRoZSBbYGFwcGx5YF0oI3N0YXRlLkVkaXRvclN0YXRlLmFwcGx5KSBtZXRob2QuXG4vL1xuLy8gQSBzdGF0ZSBob2xkcyBhIG51bWJlciBvZiBidWlsdC1pbiBmaWVsZHMsIGFuZCBwbHVnaW5zIGNhblxuLy8gW2RlZmluZV0oI3N0YXRlLlBsdWdpblNwZWMuc3RhdGUpIGFkZGl0aW9uYWwgZmllbGRzLlxudmFyIEVkaXRvclN0YXRlID0gZnVuY3Rpb24gRWRpdG9yU3RhdGUoY29uZmlnKSB7XG4gIHRoaXMuY29uZmlnID0gY29uZmlnO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxID0geyBzY2hlbWE6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0scGx1Z2luczogeyBjb25maWd1cmFibGU6IHRydWUgfSx0cjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBkb2M6OiBOb2RlXG4vLyBUaGUgY3VycmVudCBkb2N1bWVudC5cblxuLy8gc2VsZWN0aW9uOjogU2VsZWN0aW9uXG4vLyBUaGUgc2VsZWN0aW9uLlxuXG4vLyBzdG9yZWRNYXJrczo6ID9bTWFya11cbi8vIEEgc2V0IG9mIG1hcmtzIHRvIGFwcGx5IHRvIHRoZSBuZXh0IGlucHV0LiBXaWxsIGJlIG51bGwgd2hlblxuLy8gbm8gZXhwbGljaXQgbWFya3MgaGF2ZSBiZWVuIHNldC5cblxuLy8gOjogU2NoZW1hXG4vLyBUaGUgc2NoZW1hIG9mIHRoZSBzdGF0ZSdzIGRvY3VtZW50LlxucHJvdG90eXBlQWNjZXNzb3JzJDEuc2NoZW1hLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29uZmlnLnNjaGVtYVxufTtcblxuLy8gOjogW1BsdWdpbl1cbi8vIFRoZSBwbHVnaW5zIHRoYXQgYXJlIGFjdGl2ZSBpbiB0aGlzIHN0YXRlLlxucHJvdG90eXBlQWNjZXNzb3JzJDEucGx1Z2lucy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbmZpZy5wbHVnaW5zXG59O1xuXG4vLyA6OiAoVHJhbnNhY3Rpb24pIOKGkiBFZGl0b3JTdGF0ZVxuLy8gQXBwbHkgdGhlIGdpdmVuIHRyYW5zYWN0aW9uIHRvIHByb2R1Y2UgYSBuZXcgc3RhdGUuXG5FZGl0b3JTdGF0ZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseSAodHIpIHtcbiAgcmV0dXJuIHRoaXMuYXBwbHlUcmFuc2FjdGlvbih0cikuc3RhdGVcbn07XG5cbi8vIDogKFRyYW5zYWN0aW9uKSDihpIgYm9vbFxuRWRpdG9yU3RhdGUucHJvdG90eXBlLmZpbHRlclRyYW5zYWN0aW9uID0gZnVuY3Rpb24gZmlsdGVyVHJhbnNhY3Rpb24gKHRyLCBpZ25vcmUpIHtcbiAgICBpZiAoIGlnbm9yZSA9PT0gdm9pZCAwICkgaWdub3JlID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7IGlmIChpICE9IGlnbm9yZSkge1xuICAgIHZhciBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgIGlmIChwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiAmJiAhcGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24uY2FsbChwbHVnaW4sIHRyLCB0aGlzKSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyA6OiAoVHJhbnNhY3Rpb24pIOKGkiB7c3RhdGU6IEVkaXRvclN0YXRlLCB0cmFuc2FjdGlvbnM6IFtUcmFuc2FjdGlvbl19XG4vLyBWZXJib3NlIHZhcmlhbnQgb2YgW2BhcHBseWBdKCNzdGF0ZS5FZGl0b3JTdGF0ZS5hcHBseSkgdGhhdFxuLy8gcmV0dXJucyB0aGUgcHJlY2lzZSB0cmFuc2FjdGlvbnMgdGhhdCB3ZXJlIGFwcGxpZWQgKHdoaWNoIG1pZ2h0XG4vLyBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBbdHJhbnNhY3Rpb25cbi8vIGhvb2tzXSgjc3RhdGUuUGx1Z2luU3BlYy5maWx0ZXJUcmFuc2FjdGlvbikgb2Zcbi8vIHBsdWdpbnMpIGFsb25nIHdpdGggdGhlIG5ldyBzdGF0ZS5cbkVkaXRvclN0YXRlLnByb3RvdHlwZS5hcHBseVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gYXBwbHlUcmFuc2FjdGlvbiAocm9vdFRyKSB7XG4gIGlmICghdGhpcy5maWx0ZXJUcmFuc2FjdGlvbihyb290VHIpKSB7IHJldHVybiB7c3RhdGU6IHRoaXMsIHRyYW5zYWN0aW9uczogW119IH1cblxuICB2YXIgdHJzID0gW3Jvb3RUcl0sIG5ld1N0YXRlID0gdGhpcy5hcHBseUlubmVyKHJvb3RUciksIHNlZW4gPSBudWxsO1xuICAvLyBUaGlzIGxvb3AgcmVwZWF0ZWRseSBnaXZlcyBwbHVnaW5zIGEgY2hhbmNlIHRvIHJlc3BvbmQgdG9cbiAgLy8gdHJhbnNhY3Rpb25zIGFzIG5ldyB0cmFuc2FjdGlvbnMgYXJlIGFkZGVkLCBtYWtpbmcgc3VyZSB0byBvbmx5XG4gIC8vIHBhc3MgdGhlIHRyYW5zYWN0aW9ucyB0aGUgcGx1Z2luIGRpZCBub3Qgc2VlIGJlZm9yZS5cbiAgIGZvciAoOzspIHtcbiAgICB2YXIgaGF2ZU5ldyA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBsdWdpbiA9IHRoaXMuY29uZmlnLnBsdWdpbnNbaV07XG4gICAgICBpZiAocGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdmFyIG4gPSBzZWVuID8gc2VlbltpXS5uIDogMCwgb2xkU3RhdGUgPSBzZWVuID8gc2VlbltpXS5zdGF0ZSA6IHRoaXM7XG4gICAgICAgIHZhciB0ciA9IG4gPCB0cnMubGVuZ3RoICYmXG4gICAgICAgICAgICBwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbi5jYWxsKHBsdWdpbiwgbiA/IHRycy5zbGljZShuKSA6IHRycywgb2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgICAgaWYgKHRyICYmIG5ld1N0YXRlLmZpbHRlclRyYW5zYWN0aW9uKHRyLCBpKSkge1xuICAgICAgICAgIHRyLnNldE1ldGEoXCJhcHBlbmRlZFRyYW5zYWN0aW9uXCIsIHJvb3RUcik7XG4gICAgICAgICAgaWYgKCFzZWVuKSB7XG4gICAgICAgICAgICBzZWVuID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgIHsgc2Vlbi5wdXNoKGogPCBpID8ge3N0YXRlOiBuZXdTdGF0ZSwgbjogdHJzLmxlbmd0aH0gOiB7c3RhdGU6IHRoaXMsIG46IDB9KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0cnMucHVzaCh0cik7XG4gICAgICAgICAgbmV3U3RhdGUgPSBuZXdTdGF0ZS5hcHBseUlubmVyKHRyKTtcbiAgICAgICAgICBoYXZlTmV3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VlbikgeyBzZWVuW2ldID0ge3N0YXRlOiBuZXdTdGF0ZSwgbjogdHJzLmxlbmd0aH07IH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFoYXZlTmV3KSB7IHJldHVybiB7c3RhdGU6IG5ld1N0YXRlLCB0cmFuc2FjdGlvbnM6IHRyc30gfVxuICB9XG59O1xuXG4vLyA6IChUcmFuc2FjdGlvbikg4oaSIEVkaXRvclN0YXRlXG5FZGl0b3JTdGF0ZS5wcm90b3R5cGUuYXBwbHlJbm5lciA9IGZ1bmN0aW9uIGFwcGx5SW5uZXIgKHRyKSB7XG4gIGlmICghdHIuYmVmb3JlLmVxKHRoaXMuZG9jKSkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGEgbWlzbWF0Y2hlZCB0cmFuc2FjdGlvblwiKSB9XG4gIHZhciBuZXdJbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSh0aGlzLmNvbmZpZyksIGZpZWxkcyA9IHRoaXMuY29uZmlnLmZpZWxkcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgbmV3SW5zdGFuY2VbZmllbGQubmFtZV0gPSBmaWVsZC5hcHBseSh0ciwgdGhpc1tmaWVsZC5uYW1lXSwgdGhpcywgbmV3SW5zdGFuY2UpO1xuICB9XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGFwcGx5TGlzdGVuZXJzLmxlbmd0aDsgaSQxKyspIHsgYXBwbHlMaXN0ZW5lcnNbaSQxXSh0aGlzLCB0ciwgbmV3SW5zdGFuY2UpOyB9XG4gIHJldHVybiBuZXdJbnN0YW5jZVxufTtcblxuLy8gOjogVHJhbnNhY3Rpb25cbi8vIFN0YXJ0IGEgW3RyYW5zYWN0aW9uXSgjc3RhdGUuVHJhbnNhY3Rpb24pIGZyb20gdGhpcyBzdGF0ZS5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLnRyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbih0aGlzKSB9O1xuXG4vLyA6OiAoT2JqZWN0KSDihpIgRWRpdG9yU3RhdGVcbi8vIENyZWF0ZSBhIG5ldyBzdGF0ZS5cbi8vXG4vLyBjb25maWc6Oi0gQ29uZmlndXJhdGlvbiBvcHRpb25zLiBNdXN0IGNvbnRhaW4gYHNjaGVtYWAgb3IgYGRvY2AgKG9yIGJvdGgpLlxuLy9cbi8vICAgIHNjaGVtYTo6ID9TY2hlbWFcbi8vICAgIFRoZSBzY2hlbWEgdG8gdXNlIChvbmx5IHJlbGV2YW50IGlmIG5vIGBkb2NgIGlzIHNwZWNpZmllZCkuXG4vL1xuLy8gICAgZG9jOjogP05vZGVcbi8vICAgIFRoZSBzdGFydGluZyBkb2N1bWVudC5cbi8vXG4vLyAgICBzZWxlY3Rpb246OiA/U2VsZWN0aW9uXG4vLyAgICBBIHZhbGlkIHNlbGVjdGlvbiBpbiB0aGUgZG9jdW1lbnQuXG4vL1xuLy8gICAgc3RvcmVkTWFya3M6OiA/W01hcmtdXG4vLyAgICBUaGUgaW5pdGlhbCBzZXQgb2YgW3N0b3JlZCBtYXJrc10oI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKS5cbi8vXG4vLyAgICBwbHVnaW5zOjogP1tQbHVnaW5dXG4vLyAgICBUaGUgcGx1Z2lucyB0aGF0IHNob3VsZCBiZSBhY3RpdmUgaW4gdGhpcyBzdGF0ZS5cbkVkaXRvclN0YXRlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAoY29uZmlnKSB7XG4gIHZhciAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLmRvYyA/IGNvbmZpZy5kb2MudHlwZS5zY2hlbWEgOiBjb25maWcuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gIHZhciBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAkY29uZmlnLmZpZWxkcy5sZW5ndGg7IGkrKylcbiAgICB7IGluc3RhbmNlWyRjb25maWcuZmllbGRzW2ldLm5hbWVdID0gJGNvbmZpZy5maWVsZHNbaV0uaW5pdChjb25maWcsIGluc3RhbmNlKTsgfVxuICByZXR1cm4gaW5zdGFuY2Vcbn07XG5cbi8vIDo6IChPYmplY3QpIOKGkiBFZGl0b3JTdGF0ZVxuLy8gQ3JlYXRlIGEgbmV3IHN0YXRlIGJhc2VkIG9uIHRoaXMgb25lLCBidXQgd2l0aCBhbiBhZGp1c3RlZCBzZXQgb2Zcbi8vIGFjdGl2ZSBwbHVnaW5zLiBTdGF0ZSBmaWVsZHMgdGhhdCBleGlzdCBpbiBib3RoIHNldHMgb2YgcGx1Z2luc1xuLy8gYXJlIGtlcHQgdW5jaGFuZ2VkLiBUaG9zZSB0aGF0IG5vIGxvbmdlciBleGlzdCBhcmUgZHJvcHBlZCwgYW5kXG4vLyB0aG9zZSB0aGF0IGFyZSBuZXcgYXJlIGluaXRpYWxpemVkIHVzaW5nIHRoZWlyXG4vLyBbYGluaXRgXSgjc3RhdGUuU3RhdGVGaWVsZC5pbml0KSBtZXRob2QsIHBhc3NpbmcgaW4gdGhlIG5ld1xuLy8gY29uZmlndXJhdGlvbiBvYmplY3QuLlxuLy9cbi8vIGNvbmZpZzo6LSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbi8vXG4vLyAgIHBsdWdpbnM6OiBbUGx1Z2luXVxuLy8gICBOZXcgc2V0IG9mIGFjdGl2ZSBwbHVnaW5zLlxuRWRpdG9yU3RhdGUucHJvdG90eXBlLnJlY29uZmlndXJlID0gZnVuY3Rpb24gcmVjb25maWd1cmUgKGNvbmZpZykge1xuICB2YXIgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKHRoaXMuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gIHZhciBmaWVsZHMgPSAkY29uZmlnLmZpZWxkcywgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBmaWVsZHNbaV0ubmFtZTtcbiAgICBpbnN0YW5jZVtuYW1lXSA9IHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyB0aGlzW25hbWVdIDogZmllbGRzW2ldLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlXG59O1xuXG4vLyA6OiAoP3VuaW9uPE9iamVjdDxQbHVnaW4+LCBzdHJpbmcsIG51bWJlcj4pIOKGkiBPYmplY3Rcbi8vIFNlcmlhbGl6ZSB0aGlzIHN0YXRlIHRvIEpTT04uIElmIHlvdSB3YW50IHRvIHNlcmlhbGl6ZSB0aGUgc3RhdGVcbi8vIG9mIHBsdWdpbnMsIHBhc3MgYW4gb2JqZWN0IG1hcHBpbmcgcHJvcGVydHkgbmFtZXMgdG8gdXNlIGluIHRoZVxuLy8gcmVzdWx0aW5nIEpTT04gb2JqZWN0IHRvIHBsdWdpbiBvYmplY3RzLiBUaGUgYXJndW1lbnQgbWF5IGFsc28gYmVcbi8vIGEgc3RyaW5nIG9yIG51bWJlciwgaW4gd2hpY2ggY2FzZSBpdCBpcyBpZ25vcmVkLCB0byBzdXBwb3J0IHRoZVxuLy8gd2F5IGBKU09OLnN0cmluZ2lmeWAgY2FsbHMgYHRvU3RyaW5nYCBtZXRob2RzLlxuRWRpdG9yU3RhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAocGx1Z2luRmllbGRzKSB7XG4gIHZhciByZXN1bHQgPSB7ZG9jOiB0aGlzLmRvYy50b0pTT04oKSwgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKX07XG4gIGlmICh0aGlzLnN0b3JlZE1hcmtzKSB7IHJlc3VsdC5zdG9yZWRNYXJrcyA9IHRoaXMuc3RvcmVkTWFya3MubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnRvSlNPTigpOyB9KTsgfVxuICBpZiAocGx1Z2luRmllbGRzICYmIHR5cGVvZiBwbHVnaW5GaWVsZHMgPT0gJ29iamVjdCcpIHsgZm9yICh2YXIgcHJvcCBpbiBwbHVnaW5GaWVsZHMpIHtcbiAgICBpZiAocHJvcCA9PSBcImRvY1wiIHx8IHByb3AgPT0gXCJzZWxlY3Rpb25cIilcbiAgICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgSlNPTiBmaWVsZHMgYGRvY2AgYW5kIGBzZWxlY3Rpb25gIGFyZSByZXNlcnZlZFwiKSB9XG4gICAgdmFyIHBsdWdpbiA9IHBsdWdpbkZpZWxkc1twcm9wXSwgc3RhdGUgPSBwbHVnaW4uc3BlYy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9KU09OKSB7IHJlc3VsdFtwcm9wXSA9IHN0YXRlLnRvSlNPTi5jYWxsKHBsdWdpbiwgdGhpc1twbHVnaW4ua2V5XSk7IH1cbiAgfSB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIDo6IChPYmplY3QsIE9iamVjdCwgP09iamVjdDxQbHVnaW4+KSDihpIgRWRpdG9yU3RhdGVcbi8vIERlc2VyaWFsaXplIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHN0YXRlLiBgY29uZmlnYCBzaG91bGRcbi8vIGhhdmUgYXQgbGVhc3QgYSBgc2NoZW1hYCBmaWVsZCwgYW5kIHNob3VsZCBjb250YWluIGFycmF5IG9mXG4vLyBwbHVnaW5zIHRvIGluaXRpYWxpemUgdGhlIHN0YXRlIHdpdGguIGBwbHVnaW5GaWVsZHNgIGNhbiBiZSB1c2VkXG4vLyB0byBkZXNlcmlhbGl6ZSB0aGUgc3RhdGUgb2YgcGx1Z2lucywgYnkgYXNzb2NpYXRpbmcgcGx1Z2luXG4vLyBpbnN0YW5jZXMgd2l0aCB0aGUgcHJvcGVydHkgbmFtZXMgdGhleSB1c2UgaW4gdGhlIEpTT04gb2JqZWN0LlxuLy9cbi8vIGNvbmZpZzo6LSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbi8vXG4vLyAgIHNjaGVtYTo6IFNjaGVtYVxuLy8gICBUaGUgc2NoZW1hIHRvIHVzZS5cbi8vXG4vLyAgIHBsdWdpbnM6OiA/W1BsdWdpbl1cbi8vICAgVGhlIHNldCBvZiBhY3RpdmUgcGx1Z2lucy5cbkVkaXRvclN0YXRlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04gKGNvbmZpZywganNvbiwgcGx1Z2luRmllbGRzKSB7XG4gIGlmICghanNvbikgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEVkaXRvclN0YXRlLmZyb21KU09OXCIpIH1cbiAgaWYgKCFjb25maWcuc2NoZW1hKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVxdWlyZWQgY29uZmlnIGZpZWxkICdzY2hlbWEnIG1pc3NpbmdcIikgfVxuICB2YXIgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgdmFyIGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAkY29uZmlnLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGlmIChmaWVsZC5uYW1lID09IFwiZG9jXCIpIHtcbiAgICAgIGluc3RhbmNlLmRvYyA9IE5vZGUuZnJvbUpTT04oY29uZmlnLnNjaGVtYSwganNvbi5kb2MpO1xuICAgIH0gZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInNlbGVjdGlvblwiKSB7XG4gICAgICBpbnN0YW5jZS5zZWxlY3Rpb24gPSBTZWxlY3Rpb24uZnJvbUpTT04oaW5zdGFuY2UuZG9jLCBqc29uLnNlbGVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChmaWVsZC5uYW1lID09IFwic3RvcmVkTWFya3NcIikge1xuICAgICAgaWYgKGpzb24uc3RvcmVkTWFya3MpIHsgaW5zdGFuY2Uuc3RvcmVkTWFya3MgPSBqc29uLnN0b3JlZE1hcmtzLm1hcChjb25maWcuc2NoZW1hLm1hcmtGcm9tSlNPTik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBsdWdpbkZpZWxkcykgeyBmb3IgKHZhciBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICB2YXIgcGx1Z2luID0gcGx1Z2luRmllbGRzW3Byb3BdLCBzdGF0ZSA9IHBsdWdpbi5zcGVjLnN0YXRlO1xuICAgICAgICBpZiAocGx1Z2luLmtleSA9PSBmaWVsZC5uYW1lICYmIHN0YXRlICYmIHN0YXRlLmZyb21KU09OICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbiwgcHJvcCkpIHtcbiAgICAgICAgICAvLyBUaGlzIGZpZWxkIGJlbG9uZ3MgdG8gYSBwbHVnaW4gbWFwcGVkIHRvIGEgSlNPTiBmaWVsZCwgcmVhZCBpdCBmcm9tIHRoZXJlLlxuICAgICAgICAgIGluc3RhbmNlW2ZpZWxkLm5hbWVdID0gc3RhdGUuZnJvbUpTT04uY2FsbChwbHVnaW4sIGNvbmZpZywganNvbltwcm9wXSwgaW5zdGFuY2UpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9IH1cbiAgICAgIGluc3RhbmNlW2ZpZWxkLm5hbWVdID0gZmllbGQuaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW5zdGFuY2Vcbn07XG5cbi8vIEtsdWRnZSB0byBhbGxvdyB0aGUgdmlldyB0byB0cmFjayBtYXBwaW5ncyBiZXR3ZWVuIGRpZmZlcmVudFxuLy8gaW5zdGFuY2VzIG9mIGEgc3RhdGUuXG4vL1xuLy8gRklYTUUgdGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIGFzIG9mIHByb3NlbWlycm9yLXZpZXcgMS45LjAsXG4vLyB0aG91Z2ggZHVlIHRvIGJhY2t3YXJkcy1jb21wYXQgd2Ugc2hvdWxkIHByb2JhYmx5IGtlZXAgaXQgYXJvdW5kXG4vLyBmb3IgYSB3aGlsZSAoaWYgb25seSBhcyBhIG5vLW9wKVxuRWRpdG9yU3RhdGUuYWRkQXBwbHlMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEFwcGx5TGlzdGVuZXIgKGYpIHtcbiAgYXBwbHlMaXN0ZW5lcnMucHVzaChmKTtcbn07XG5FZGl0b3JTdGF0ZS5yZW1vdmVBcHBseUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlQXBwbHlMaXN0ZW5lciAoZikge1xuICB2YXIgZm91bmQgPSBhcHBseUxpc3RlbmVycy5pbmRleE9mKGYpO1xuICBpZiAoZm91bmQgPiAtMSkgeyBhcHBseUxpc3RlbmVycy5zcGxpY2UoZm91bmQsIDEpOyB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggRWRpdG9yU3RhdGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG52YXIgYXBwbHlMaXN0ZW5lcnMgPSBbXTtcblxuLy8gUGx1Z2luU3BlYzo6IGludGVyZmFjZVxuLy9cbi8vIFRoaXMgaXMgdGhlIHR5cGUgcGFzc2VkIHRvIHRoZSBbYFBsdWdpbmBdKCNzdGF0ZS5QbHVnaW4pXG4vLyBjb25zdHJ1Y3Rvci4gSXQgcHJvdmlkZXMgYSBkZWZpbml0aW9uIGZvciBhIHBsdWdpbi5cbi8vXG4vLyAgIHByb3BzOjogP0VkaXRvclByb3BzXG4vLyAgIFRoZSBbdmlldyBwcm9wc10oI3ZpZXcuRWRpdG9yUHJvcHMpIGFkZGVkIGJ5IHRoaXMgcGx1Z2luLiBQcm9wc1xuLy8gICB0aGF0IGFyZSBmdW5jdGlvbnMgd2lsbCBiZSBib3VuZCB0byBoYXZlIHRoZSBwbHVnaW4gaW5zdGFuY2UgYXNcbi8vICAgdGhlaXIgYHRoaXNgIGJpbmRpbmcuXG4vL1xuLy8gICBzdGF0ZTo6ID9TdGF0ZUZpZWxkPGFueT5cbi8vICAgQWxsb3dzIGEgcGx1Z2luIHRvIGRlZmluZSBhIFtzdGF0ZSBmaWVsZF0oI3N0YXRlLlN0YXRlRmllbGQpLCBhblxuLy8gICBleHRyYSBzbG90IGluIHRoZSBzdGF0ZSBvYmplY3QgaW4gd2hpY2ggaXQgY2FuIGtlZXAgaXRzIG93biBkYXRhLlxuLy9cbi8vICAga2V5OjogP1BsdWdpbktleVxuLy8gICBDYW4gYmUgdXNlZCB0byBtYWtlIHRoaXMgYSBrZXllZCBwbHVnaW4uIFlvdSBjYW4gaGF2ZSBvbmx5IG9uZVxuLy8gICBwbHVnaW4gd2l0aCBhIGdpdmVuIGtleSBpbiBhIGdpdmVuIHN0YXRlLCBidXQgaXQgaXMgcG9zc2libGUgdG9cbi8vICAgYWNjZXNzIHRoZSBwbHVnaW4ncyBjb25maWd1cmF0aW9uIGFuZCBzdGF0ZSB0aHJvdWdoIHRoZSBrZXksXG4vLyAgIHdpdGhvdXQgaGF2aW5nIGFjY2VzcyB0byB0aGUgcGx1Z2luIGluc3RhbmNlIG9iamVjdC5cbi8vXG4vLyAgIHZpZXc6OiA/KEVkaXRvclZpZXcpIOKGkiBPYmplY3Rcbi8vICAgV2hlbiB0aGUgcGx1Z2luIG5lZWRzIHRvIGludGVyYWN0IHdpdGggdGhlIGVkaXRvciB2aWV3LCBvclxuLy8gICBzZXQgc29tZXRoaW5nIHVwIGluIHRoZSBET00sIHVzZSB0aGlzIGZpZWxkLiBUaGUgZnVuY3Rpb25cbi8vICAgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgcGx1Z2luJ3Mgc3RhdGUgaXMgYXNzb2NpYXRlZCB3aXRoIGFuXG4vLyAgIGVkaXRvciB2aWV3LlxuLy9cbi8vICAgICByZXR1cm46Oi1cbi8vICAgICBTaG91bGQgcmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWxcbi8vICAgICBwcm9wZXJ0aWVzOlxuLy9cbi8vICAgICAgIHVwZGF0ZTo6ID8odmlldzogRWRpdG9yVmlldywgcHJldlN0YXRlOiBFZGl0b3JTdGF0ZSlcbi8vICAgICAgIENhbGxlZCB3aGVuZXZlciB0aGUgdmlldydzIHN0YXRlIGlzIHVwZGF0ZWQuXG4vL1xuLy8gICAgICAgZGVzdHJveTo6ID8oKVxuLy8gICAgICAgQ2FsbGVkIHdoZW4gdGhlIHZpZXcgaXMgZGVzdHJveWVkIG9yIHJlY2VpdmVzIGEgc3RhdGVcbi8vICAgICAgIHdpdGggZGlmZmVyZW50IHBsdWdpbnMuXG4vL1xuLy8gICBmaWx0ZXJUcmFuc2FjdGlvbjo6ID8oVHJhbnNhY3Rpb24sIEVkaXRvclN0YXRlKSDihpIgYm9vbFxuLy8gICBXaGVuIHByZXNlbnQsIHRoaXMgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIGEgdHJhbnNhY3Rpb24gaXNcbi8vICAgYXBwbGllZCBieSB0aGUgc3RhdGUsIGFsbG93aW5nIHRoZSBwbHVnaW4gdG8gY2FuY2VsIGl0IChieVxuLy8gICByZXR1cm5pbmcgZmFsc2UpLlxuLy9cbi8vICAgYXBwZW5kVHJhbnNhY3Rpb246OiA/KHRyYW5zYWN0aW9uczogW1RyYW5zYWN0aW9uXSwgb2xkU3RhdGU6IEVkaXRvclN0YXRlLCBuZXdTdGF0ZTogRWRpdG9yU3RhdGUpIOKGkiA/VHJhbnNhY3Rpb25cbi8vICAgQWxsb3dzIHRoZSBwbHVnaW4gdG8gYXBwZW5kIGFub3RoZXIgdHJhbnNhY3Rpb24gdG8gYmUgYXBwbGllZFxuLy8gICBhZnRlciB0aGUgZ2l2ZW4gYXJyYXkgb2YgdHJhbnNhY3Rpb25zLiBXaGVuIGFub3RoZXIgcGx1Z2luXG4vLyAgIGFwcGVuZHMgYSB0cmFuc2FjdGlvbiBhZnRlciB0aGlzIHdhcyBjYWxsZWQsIGl0IGlzIGNhbGxlZCBhZ2FpblxuLy8gICB3aXRoIHRoZSBuZXcgc3RhdGUgYW5kIG5ldyB0cmFuc2FjdGlvbnPigJRidXQgb25seSB0aGUgbmV3XG4vLyAgIHRyYW5zYWN0aW9ucywgaS5lLiBpdCB3b24ndCBiZSBwYXNzZWQgdHJhbnNhY3Rpb25zIHRoYXQgaXRcbi8vICAgYWxyZWFkeSBzYXcuXG5cbmZ1bmN0aW9uIGJpbmRQcm9wcyhvYmosIHNlbGYsIHRhcmdldCkge1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIHZhciB2YWwgPSBvYmpbcHJvcF07XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7IHZhbCA9IHZhbC5iaW5kKHNlbGYpOyB9XG4gICAgZWxzZSBpZiAocHJvcCA9PSBcImhhbmRsZURPTUV2ZW50c1wiKSB7IHZhbCA9IGJpbmRQcm9wcyh2YWwsIHNlbGYsIHt9KTsgfVxuICAgIHRhcmdldFtwcm9wXSA9IHZhbDtcbiAgfVxuICByZXR1cm4gdGFyZ2V0XG59XG5cbi8vIDo6LSBQbHVnaW5zIGJ1bmRsZSBmdW5jdGlvbmFsaXR5IHRoYXQgY2FuIGJlIGFkZGVkIHRvIGFuIGVkaXRvci5cbi8vIFRoZXkgYXJlIHBhcnQgb2YgdGhlIFtlZGl0b3Igc3RhdGVdKCNzdGF0ZS5FZGl0b3JTdGF0ZSkgYW5kXG4vLyBtYXkgaW5mbHVlbmNlIHRoYXQgc3RhdGUgYW5kIHRoZSB2aWV3IHRoYXQgY29udGFpbnMgaXQuXG52YXIgUGx1Z2luID0gZnVuY3Rpb24gUGx1Z2luKHNwZWMpIHtcbiAgLy8gOjogRWRpdG9yUHJvcHNcbiAgLy8gVGhlIFtwcm9wc10oI3ZpZXcuRWRpdG9yUHJvcHMpIGV4cG9ydGVkIGJ5IHRoaXMgcGx1Z2luLlxuICB0aGlzLnByb3BzID0ge307XG4gIGlmIChzcGVjLnByb3BzKSB7IGJpbmRQcm9wcyhzcGVjLnByb3BzLCB0aGlzLCB0aGlzLnByb3BzKTsgfVxuICAvLyA6OiBPYmplY3RcbiAgLy8gVGhlIHBsdWdpbidzIFtzcGVjIG9iamVjdF0oI3N0YXRlLlBsdWdpblNwZWMpLlxuICB0aGlzLnNwZWMgPSBzcGVjO1xuICB0aGlzLmtleSA9IHNwZWMua2V5ID8gc3BlYy5rZXkua2V5IDogY3JlYXRlS2V5KFwicGx1Z2luXCIpO1xufTtcblxuLy8gOjogKEVkaXRvclN0YXRlKSDihpIgYW55XG4vLyBFeHRyYWN0IHRoZSBwbHVnaW4ncyBzdGF0ZSBmaWVsZCBmcm9tIGFuIGVkaXRvciBzdGF0ZS5cblBsdWdpbi5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiBnZXRTdGF0ZSAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW3RoaXMua2V5XSB9O1xuXG4vLyBTdGF0ZUZpZWxkOjogaW50ZXJmYWNlPFQ+XG4vLyBBIHBsdWdpbiBzcGVjIG1heSBwcm92aWRlIGEgc3RhdGUgZmllbGQgKHVuZGVyIGl0c1xuLy8gW2BzdGF0ZWBdKCNzdGF0ZS5QbHVnaW5TcGVjLnN0YXRlKSBwcm9wZXJ0eSkgb2YgdGhpcyB0eXBlLCB3aGljaFxuLy8gZGVzY3JpYmVzIHRoZSBzdGF0ZSBpdCB3YW50cyB0byBrZWVwLiBGdW5jdGlvbnMgcHJvdmlkZWQgaGVyZSBhcmVcbi8vIGFsd2F5cyBjYWxsZWQgd2l0aCB0aGUgcGx1Z2luIGluc3RhbmNlIGFzIHRoZWlyIGB0aGlzYCBiaW5kaW5nLlxuLy9cbi8vICAgaW5pdDo6IChjb25maWc6IE9iamVjdCwgaW5zdGFuY2U6IEVkaXRvclN0YXRlKSDihpIgVFxuLy8gICBJbml0aWFsaXplIHRoZSB2YWx1ZSBvZiB0aGUgZmllbGQuIGBjb25maWdgIHdpbGwgYmUgdGhlIG9iamVjdFxuLy8gICBwYXNzZWQgdG8gW2BFZGl0b3JTdGF0ZS5jcmVhdGVgXSgjc3RhdGUuRWRpdG9yU3RhdGVeY3JlYXRlKS4gTm90ZVxuLy8gICB0aGF0IGBpbnN0YW5jZWAgaXMgYSBoYWxmLWluaXRpYWxpemVkIHN0YXRlIGluc3RhbmNlLCBhbmQgd2lsbFxuLy8gICBub3QgaGF2ZSB2YWx1ZXMgZm9yIHBsdWdpbiBmaWVsZHMgaW5pdGlhbGl6ZWQgYWZ0ZXIgdGhpcyBvbmUuXG4vL1xuLy8gICBhcHBseTo6ICh0cjogVHJhbnNhY3Rpb24sIHZhbHVlOiBULCBvbGRTdGF0ZTogRWRpdG9yU3RhdGUsIG5ld1N0YXRlOiBFZGl0b3JTdGF0ZSkg4oaSIFRcbi8vICAgQXBwbHkgdGhlIGdpdmVuIHRyYW5zYWN0aW9uIHRvIHRoaXMgc3RhdGUgZmllbGQsIHByb2R1Y2luZyBhIG5ld1xuLy8gICBmaWVsZCB2YWx1ZS4gTm90ZSB0aGF0IHRoZSBgbmV3U3RhdGVgIGFyZ3VtZW50IGlzIGFnYWluIGEgcGFydGlhbGx5XG4vLyAgIGNvbnN0cnVjdGVkIHN0YXRlIGRvZXMgbm90IHlldCBjb250YWluIHRoZSBzdGF0ZSBmcm9tIHBsdWdpbnNcbi8vICAgY29taW5nIGFmdGVyIHRoaXMgb25lLlxuLy9cbi8vICAgdG9KU09OOjogPyh2YWx1ZTogVCkg4oaSICpcbi8vICAgQ29udmVydCB0aGlzIGZpZWxkIHRvIEpTT04uIE9wdGlvbmFsLCBjYW4gYmUgbGVmdCBvZmYgdG8gZGlzYWJsZVxuLy8gICBKU09OIHNlcmlhbGl6YXRpb24gZm9yIHRoZSBmaWVsZC5cbi8vXG4vLyAgIGZyb21KU09OOjogPyhjb25maWc6IE9iamVjdCwgdmFsdWU6ICosIHN0YXRlOiBFZGl0b3JTdGF0ZSkg4oaSIFRcbi8vICAgRGVzZXJpYWxpemUgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmaWVsZC4gTm90ZSB0aGF0IHRoZVxuLy8gICBgc3RhdGVgIGFyZ3VtZW50IGlzIGFnYWluIGEgaGFsZi1pbml0aWFsaXplZCBzdGF0ZS5cblxudmFyIGtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBjcmVhdGVLZXkobmFtZSkge1xuICBpZiAobmFtZSBpbiBrZXlzKSB7IHJldHVybiBuYW1lICsgXCIkXCIgKyArK2tleXNbbmFtZV0gfVxuICBrZXlzW25hbWVdID0gMDtcbiAgcmV0dXJuIG5hbWUgKyBcIiRcIlxufVxuXG4vLyA6Oi0gQSBrZXkgaXMgdXNlZCB0byBbdGFnXSgjc3RhdGUuUGx1Z2luU3BlYy5rZXkpXG4vLyBwbHVnaW5zIGluIGEgd2F5IHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gZmluZCB0aGVtLCBnaXZlbiBhblxuLy8gZWRpdG9yIHN0YXRlLiBBc3NpZ25pbmcgYSBrZXkgZG9lcyBtZWFuIG9ubHkgb25lIHBsdWdpbiBvZiB0aGF0XG4vLyB0eXBlIGNhbiBiZSBhY3RpdmUgaW4gYSBzdGF0ZS5cbnZhciBQbHVnaW5LZXkgPSBmdW5jdGlvbiBQbHVnaW5LZXkobmFtZSkge1xuaWYgKCBuYW1lID09PSB2b2lkIDAgKSBuYW1lID0gXCJrZXlcIjtcbiB0aGlzLmtleSA9IGNyZWF0ZUtleShuYW1lKTsgfTtcblxuLy8gOjogKEVkaXRvclN0YXRlKSDihpIgP1BsdWdpblxuLy8gR2V0IHRoZSBhY3RpdmUgcGx1Z2luIHdpdGggdGhpcyBrZXksIGlmIGFueSwgZnJvbSBhbiBlZGl0b3Jcbi8vIHN0YXRlLlxuUGx1Z2luS2V5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5jb25maWcucGx1Z2luc0J5S2V5W3RoaXMua2V5XSB9O1xuXG4vLyA6OiAoRWRpdG9yU3RhdGUpIOKGkiA/YW55XG4vLyBHZXQgdGhlIHBsdWdpbidzIHN0YXRlIGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuUGx1Z2luS2V5LnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlIChzdGF0ZSkgeyByZXR1cm4gc3RhdGVbdGhpcy5rZXldIH07XG5cbmV4cG9ydCB7IEFsbFNlbGVjdGlvbiwgRWRpdG9yU3RhdGUsIE5vZGVTZWxlY3Rpb24sIFBsdWdpbiwgUGx1Z2luS2V5LCBTZWxlY3Rpb24sIFNlbGVjdGlvblJhbmdlLCBUZXh0U2VsZWN0aW9uLCBUcmFuc2FjdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJpbXBvcnQgeyBSZXBsYWNlRXJyb3IsIFNsaWNlLCBGcmFnbWVudCwgTWFya1R5cGUgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5cbi8vIE1hcHBhYmxlOjogaW50ZXJmYWNlXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCB0aGluZ3MgdGhhdCBwb3NpdGlvbnMgY2FuIGJlIG1hcHBlZCB0aHJvdWdoLlxuLy8gU3VjaCBvYmplY3RzIGNvbmZvcm0gdG8gdGhpcyBpbnRlcmZhY2UuXG4vL1xuLy8gICBtYXA6OiAocG9zOiBudW1iZXIsIGFzc29jOiA/bnVtYmVyKSDihpIgbnVtYmVyXG4vLyAgIE1hcCBhIHBvc2l0aW9uIHRocm91Z2ggdGhpcyBvYmplY3QuIFdoZW4gZ2l2ZW4sIGBhc3NvY2AgKHNob3VsZFxuLy8gICBiZSAtMSBvciAxLCBkZWZhdWx0cyB0byAxKSBkZXRlcm1pbmVzIHdpdGggd2hpY2ggc2lkZSB0aGVcbi8vICAgcG9zaXRpb24gaXMgYXNzb2NpYXRlZCwgd2hpY2ggZGV0ZXJtaW5lcyBpbiB3aGljaCBkaXJlY3Rpb24gdG9cbi8vICAgbW92ZSB3aGVuIGEgY2h1bmsgb2YgY29udGVudCBpcyBpbnNlcnRlZCBhdCB0aGUgbWFwcGVkIHBvc2l0aW9uLlxuLy9cbi8vICAgbWFwUmVzdWx0OjogKHBvczogbnVtYmVyLCBhc3NvYzogP251bWJlcikg4oaSIE1hcFJlc3VsdFxuLy8gICBNYXAgYSBwb3NpdGlvbiwgYW5kIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsXG4vLyAgIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtYXBwaW5nLiBUaGUgcmVzdWx0J3MgYGRlbGV0ZWRgIGZpZWxkIHRlbGxzXG4vLyAgIHlvdSB3aGV0aGVyIHRoZSBwb3NpdGlvbiB3YXMgZGVsZXRlZCAoY29tcGxldGVseSBlbmNsb3NlZCBpbiBhXG4vLyAgIHJlcGxhY2VkIHJhbmdlKSBkdXJpbmcgdGhlIG1hcHBpbmcuIFdoZW4gY29udGVudCBvbiBvbmx5IG9uZSBzaWRlXG4vLyAgIGlzIGRlbGV0ZWQsIHRoZSBwb3NpdGlvbiBpdHNlbGYgaXMgb25seSBjb25zaWRlcmVkIGRlbGV0ZWQgd2hlblxuLy8gICBgYXNzb2NgIHBvaW50cyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBkZWxldGVkIGNvbnRlbnQuXG5cbi8vIFJlY292ZXJ5IHZhbHVlcyBlbmNvZGUgYSByYW5nZSBpbmRleCBhbmQgYW4gb2Zmc2V0LiBUaGV5IGFyZVxuLy8gcmVwcmVzZW50ZWQgYXMgbnVtYmVycywgYmVjYXVzZSB0b25zIG9mIHRoZW0gd2lsbCBiZSBjcmVhdGVkIHdoZW5cbi8vIG1hcHBpbmcsIGZvciBleGFtcGxlLCBhIGxhcmdlIG51bWJlciBvZiBkZWNvcmF0aW9ucy4gVGhlIG51bWJlcidzXG4vLyBsb3dlciAxNiBiaXRzIHByb3ZpZGUgdGhlIGluZGV4LCB0aGUgcmVtYWluaW5nIGJpdHMgdGhlIG9mZnNldC5cbi8vXG4vLyBOb3RlOiBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBiaXQgc2hpZnQgb3BlcmF0b3JzIHRvIGVuLSBhbmRcbi8vIGRlY29kZSB0aGVzZSwgc2luY2UgdGhvc2UgY2xpcCB0byAzMiBiaXRzLCB3aGljaCB3ZSBtaWdodCBpbiByYXJlXG4vLyBjYXNlcyB3YW50IHRvIG92ZXJmbG93LiBBIDY0LWJpdCBmbG9hdCBjYW4gcmVwcmVzZW50IDQ4LWJpdFxuLy8gaW50ZWdlcnMgcHJlY2lzZWx5LlxuXG52YXIgbG93ZXIxNiA9IDB4ZmZmZjtcbnZhciBmYWN0b3IxNiA9IE1hdGgucG93KDIsIDE2KTtcblxuZnVuY3Rpb24gbWFrZVJlY292ZXIoaW5kZXgsIG9mZnNldCkgeyByZXR1cm4gaW5kZXggKyBvZmZzZXQgKiBmYWN0b3IxNiB9XG5mdW5jdGlvbiByZWNvdmVySW5kZXgodmFsdWUpIHsgcmV0dXJuIHZhbHVlICYgbG93ZXIxNiB9XG5mdW5jdGlvbiByZWNvdmVyT2Zmc2V0KHZhbHVlKSB7IHJldHVybiAodmFsdWUgLSAodmFsdWUgJiBsb3dlcjE2KSkgLyBmYWN0b3IxNiB9XG5cbi8vIDo6LSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgbWFwcGVkIHBvc2l0aW9uIHdpdGggZXh0cmFcbi8vIGluZm9ybWF0aW9uLlxudmFyIE1hcFJlc3VsdCA9IGZ1bmN0aW9uIE1hcFJlc3VsdChwb3MsIGRlbGV0ZWQsIHJlY292ZXIpIHtcbiAgaWYgKCBkZWxldGVkID09PSB2b2lkIDAgKSBkZWxldGVkID0gZmFsc2U7XG4gIGlmICggcmVjb3ZlciA9PT0gdm9pZCAwICkgcmVjb3ZlciA9IG51bGw7XG5cbiAgLy8gOjogbnVtYmVyIFRoZSBtYXBwZWQgdmVyc2lvbiBvZiB0aGUgcG9zaXRpb24uXG4gIHRoaXMucG9zID0gcG9zO1xuICAvLyA6OiBib29sIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSBwb3NpdGlvbiB3YXMgZGVsZXRlZCwgdGhhdCBpcyxcbiAgLy8gd2hldGhlciB0aGUgc3RlcCByZW1vdmVkIGl0cyBzdXJyb3VuZGluZ3MgZnJvbSB0aGUgZG9jdW1lbnQuXG4gIHRoaXMuZGVsZXRlZCA9IGRlbGV0ZWQ7XG4gIHRoaXMucmVjb3ZlciA9IHJlY292ZXI7XG59O1xuXG4vLyA6OiBjbGFzcyBleHRlbmRzIE1hcHBhYmxlXG4vLyBBIG1hcCBkZXNjcmliaW5nIHRoZSBkZWxldGlvbnMgYW5kIGluc2VydGlvbnMgbWFkZSBieSBhIHN0ZXAsIHdoaWNoXG4vLyBjYW4gYmUgdXNlZCB0byBmaW5kIHRoZSBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGVcbi8vIHByZS1zdGVwIHZlcnNpb24gb2YgYSBkb2N1bWVudCBhbmQgdGhlIHNhbWUgcG9zaXRpb24gaW4gdGhlXG4vLyBwb3N0LXN0ZXAgdmVyc2lvbi5cbnZhciBTdGVwTWFwID0gZnVuY3Rpb24gU3RlcE1hcChyYW5nZXMsIGludmVydGVkKSB7XG4gIGlmICggaW52ZXJ0ZWQgPT09IHZvaWQgMCApIGludmVydGVkID0gZmFsc2U7XG5cbiAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gIHRoaXMuaW52ZXJ0ZWQgPSBpbnZlcnRlZDtcbn07XG5cblN0ZXBNYXAucHJvdG90eXBlLnJlY292ZXIgPSBmdW5jdGlvbiByZWNvdmVyICh2YWx1ZSkge1xuICB2YXIgZGlmZiA9IDAsIGluZGV4ID0gcmVjb3ZlckluZGV4KHZhbHVlKTtcbiAgaWYgKCF0aGlzLmludmVydGVkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICB7IGRpZmYgKz0gdGhpcy5yYW5nZXNbaSAqIDMgKyAyXSAtIHRoaXMucmFuZ2VzW2kgKiAzICsgMV07IH0gfVxuICByZXR1cm4gdGhpcy5yYW5nZXNbaW5kZXggKiAzXSArIGRpZmYgKyByZWNvdmVyT2Zmc2V0KHZhbHVlKVxufTtcblxuLy8gOiAobnVtYmVyLCA/bnVtYmVyKSDihpIgTWFwUmVzdWx0XG5TdGVwTWFwLnByb3RvdHlwZS5tYXBSZXN1bHQgPSBmdW5jdGlvbiBtYXBSZXN1bHQgKHBvcywgYXNzb2MpIHtcbiAgaWYgKCBhc3NvYyA9PT0gdm9pZCAwICkgYXNzb2MgPSAxO1xuIHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpIH07XG5cbi8vIDogKG51bWJlciwgP251bWJlcikg4oaSIG51bWJlclxuU3RlcE1hcC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChwb3MsIGFzc29jKSB7XG4gIGlmICggYXNzb2MgPT09IHZvaWQgMCApIGFzc29jID0gMTtcbiByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpIH07XG5cblN0ZXBNYXAucHJvdG90eXBlLl9tYXAgPSBmdW5jdGlvbiBfbWFwIChwb3MsIGFzc29jLCBzaW1wbGUpIHtcbiAgdmFyIGRpZmYgPSAwLCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApO1xuICAgIGlmIChzdGFydCA+IHBvcykgeyBicmVhayB9XG4gICAgdmFyIG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBuZXdTaXplID0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgIGlmIChwb3MgPD0gZW5kKSB7XG4gICAgICB2YXIgc2lkZSA9ICFvbGRTaXplID8gYXNzb2MgOiBwb3MgPT0gc3RhcnQgPyAtMSA6IHBvcyA9PSBlbmQgPyAxIDogYXNzb2M7XG4gICAgICB2YXIgcmVzdWx0ID0gc3RhcnQgKyBkaWZmICsgKHNpZGUgPCAwID8gMCA6IG5ld1NpemUpO1xuICAgICAgaWYgKHNpbXBsZSkgeyByZXR1cm4gcmVzdWx0IH1cbiAgICAgIHZhciByZWNvdmVyID0gcG9zID09IChhc3NvYyA8IDAgPyBzdGFydCA6IGVuZCkgPyBudWxsIDogbWFrZVJlY292ZXIoaSAvIDMsIHBvcyAtIHN0YXJ0KTtcbiAgICAgIHJldHVybiBuZXcgTWFwUmVzdWx0KHJlc3VsdCwgYXNzb2MgPCAwID8gcG9zICE9IHN0YXJ0IDogcG9zICE9IGVuZCwgcmVjb3ZlcilcbiAgICB9XG4gICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgfVxuICByZXR1cm4gc2ltcGxlID8gcG9zICsgZGlmZiA6IG5ldyBNYXBSZXN1bHQocG9zICsgZGlmZilcbn07XG5cblN0ZXBNYXAucHJvdG90eXBlLnRvdWNoZXMgPSBmdW5jdGlvbiB0b3VjaGVzIChwb3MsIHJlY292ZXIpIHtcbiAgdmFyIGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleChyZWNvdmVyKTtcbiAgdmFyIG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgIHZhciBzdGFydCA9IHRoaXMucmFuZ2VzW2ldIC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCk7XG4gICAgaWYgKHN0YXJ0ID4gcG9zKSB7IGJyZWFrIH1cbiAgICB2YXIgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICBpZiAocG9zIDw9IGVuZCAmJiBpID09IGluZGV4ICogMykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgZGlmZiArPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdIC0gb2xkU2l6ZTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIDo6ICgob2xkU3RhcnQ6IG51bWJlciwgb2xkRW5kOiBudW1iZXIsIG5ld1N0YXJ0OiBudW1iZXIsIG5ld0VuZDogbnVtYmVyKSlcbi8vIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBvbiBlYWNoIG9mIHRoZSBjaGFuZ2VkIHJhbmdlcyBpbmNsdWRlZCBpblxuLy8gdGhpcyBtYXAuXG5TdGVwTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaCAoZikge1xuICB2YXIgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICBmb3IgKHZhciBpID0gMCwgZGlmZiA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgIHZhciBzdGFydCA9IHRoaXMucmFuZ2VzW2ldLCBvbGRTdGFydCA9IHN0YXJ0IC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCksIG5ld1N0YXJ0ID0gc3RhcnQgKyAodGhpcy5pbnZlcnRlZCA/IDAgOiBkaWZmKTtcbiAgICB2YXIgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdO1xuICAgIGYob2xkU3RhcnQsIG9sZFN0YXJ0ICsgb2xkU2l6ZSwgbmV3U3RhcnQsIG5ld1N0YXJ0ICsgbmV3U2l6ZSk7XG4gICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgfVxufTtcblxuLy8gOjogKCkg4oaSIFN0ZXBNYXBcbi8vIENyZWF0ZSBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoaXMgbWFwLiBUaGUgcmVzdWx0IGNhbiBiZSB1c2VkIHRvXG4vLyBtYXAgcG9zaXRpb25zIGluIHRoZSBwb3N0LXN0ZXAgZG9jdW1lbnQgdG8gdGhlIHByZS1zdGVwIGRvY3VtZW50LlxuU3RlcE1hcC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0ICgpIHtcbiAgcmV0dXJuIG5ldyBTdGVwTWFwKHRoaXMucmFuZ2VzLCAhdGhpcy5pbnZlcnRlZClcbn07XG5cblN0ZXBNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gKHRoaXMuaW52ZXJ0ZWQgPyBcIi1cIiA6IFwiXCIpICsgSlNPTi5zdHJpbmdpZnkodGhpcy5yYW5nZXMpXG59O1xuXG4vLyA6OiAobjogbnVtYmVyKSDihpIgU3RlcE1hcFxuLy8gQ3JlYXRlIGEgbWFwIHRoYXQgbW92ZXMgYWxsIHBvc2l0aW9ucyBieSBvZmZzZXQgYG5gICh3aGljaCBtYXkgYmVcbi8vIG5lZ2F0aXZlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gYXBwbHlpbmcgc3RlcHMgbWVhbnQgZm9yIGFcbi8vIHN1Yi1kb2N1bWVudCB0byBhIGxhcmdlciBkb2N1bWVudCwgb3IgdmljZS12ZXJzYS5cblN0ZXBNYXAub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0IChuKSB7XG4gIHJldHVybiBuID09IDAgPyBTdGVwTWFwLmVtcHR5IDogbmV3IFN0ZXBNYXAobiA8IDAgPyBbMCwgLW4sIDBdIDogWzAsIDAsIG5dKVxufTtcblxuU3RlcE1hcC5lbXB0eSA9IG5ldyBTdGVwTWFwKFtdKTtcblxuLy8gOjogY2xhc3MgZXh0ZW5kcyBNYXBwYWJsZVxuLy8gQSBtYXBwaW5nIHJlcHJlc2VudHMgYSBwaXBlbGluZSBvZiB6ZXJvIG9yIG1vcmUgW3N0ZXBcbi8vIG1hcHNdKCN0cmFuc2Zvcm0uU3RlcE1hcCkuIEl0IGhhcyBzcGVjaWFsIHByb3Zpc2lvbnMgZm9yIGxvc3NsZXNzbHlcbi8vIGhhbmRsaW5nIG1hcHBpbmcgcG9zaXRpb25zIHRocm91Z2ggYSBzZXJpZXMgb2Ygc3RlcHMgaW4gd2hpY2ggc29tZVxuLy8gc3RlcHMgYXJlIGludmVydGVkIHZlcnNpb25zIG9mIGVhcmxpZXIgc3RlcHMuIChUaGlzIGNvbWVzIHVwIHdoZW5cbi8vIOKAmFtyZWJhc2luZ10oL2RvY3MvZ3VpZGUvI3RyYW5zZm9ybS5yZWJhc2luZynigJkgc3RlcHMgZm9yXG4vLyBjb2xsYWJvcmF0aW9uIG9yIGhpc3RvcnkgbWFuYWdlbWVudC4pXG52YXIgTWFwcGluZyA9IGZ1bmN0aW9uIE1hcHBpbmcobWFwcywgbWlycm9yLCBmcm9tLCB0bykge1xuICAvLyA6OiBbU3RlcE1hcF1cbiAgLy8gVGhlIHN0ZXAgbWFwcyBpbiB0aGlzIG1hcHBpbmcuXG4gIHRoaXMubWFwcyA9IG1hcHMgfHwgW107XG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgc3RhcnRpbmcgcG9zaXRpb24gaW4gdGhlIGBtYXBzYCBhcnJheSwgdXNlZCB3aGVuIGBtYXBgIG9yXG4gIC8vIGBtYXBSZXN1bHRgIGlzIGNhbGxlZC5cbiAgdGhpcy5mcm9tID0gZnJvbSB8fCAwO1xuICAvLyA6OiBudW1iZXJcbiAgLy8gVGhlIGVuZCBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LlxuICB0aGlzLnRvID0gdG8gPT0gbnVsbCA/IHRoaXMubWFwcy5sZW5ndGggOiB0bztcbiAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XG59O1xuXG4vLyA6OiAoP251bWJlciwgP251bWJlcikg4oaSIE1hcHBpbmdcbi8vIENyZWF0ZSBhIG1hcHBpbmcgdGhhdCBtYXBzIG9ubHkgdGhyb3VnaCBhIHBhcnQgb2YgdGhpcyBvbmUuXG5NYXBwaW5nLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLm1hcHMubGVuZ3RoO1xuXG4gIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLm1hcHMsIHRoaXMubWlycm9yLCBmcm9tLCB0bylcbn07XG5cbk1hcHBpbmcucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcy5zbGljZSgpLCB0aGlzLm1pcnJvciAmJiB0aGlzLm1pcnJvci5zbGljZSgpLCB0aGlzLmZyb20sIHRoaXMudG8pXG59O1xuXG4vLyA6OiAoU3RlcE1hcCwgP251bWJlcilcbi8vIEFkZCBhIHN0ZXAgbWFwIHRvIHRoZSBlbmQgb2YgdGhpcyBtYXBwaW5nLiBJZiBgbWlycm9yc2AgaXNcbi8vIGdpdmVuLCBpdCBzaG91bGQgYmUgdGhlIGluZGV4IG9mIHRoZSBzdGVwIG1hcCB0aGF0IGlzIHRoZSBtaXJyb3Jcbi8vIGltYWdlIG9mIHRoaXMgb25lLlxuTWFwcGluZy5wcm90b3R5cGUuYXBwZW5kTWFwID0gZnVuY3Rpb24gYXBwZW5kTWFwIChtYXAsIG1pcnJvcnMpIHtcbiAgdGhpcy50byA9IHRoaXMubWFwcy5wdXNoKG1hcCk7XG4gIGlmIChtaXJyb3JzICE9IG51bGwpIHsgdGhpcy5zZXRNaXJyb3IodGhpcy5tYXBzLmxlbmd0aCAtIDEsIG1pcnJvcnMpOyB9XG59O1xuXG4vLyA6OiAoTWFwcGluZylcbi8vIEFkZCBhbGwgdGhlIHN0ZXAgbWFwcyBpbiBhIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUgKHByZXNlcnZpbmdcbi8vIG1pcnJvcmluZyBpbmZvcm1hdGlvbikuXG5NYXBwaW5nLnByb3RvdHlwZS5hcHBlbmRNYXBwaW5nID0gZnVuY3Rpb24gYXBwZW5kTWFwcGluZyAobWFwcGluZykge1xuICBmb3IgKHZhciBpID0gMCwgc3RhcnRTaXplID0gdGhpcy5tYXBzLmxlbmd0aDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtaXJyID0gbWFwcGluZy5nZXRNaXJyb3IoaSk7XG4gICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLCBtaXJyICE9IG51bGwgJiYgbWlyciA8IGkgPyBzdGFydFNpemUgKyBtaXJyIDogbnVsbCk7XG4gIH1cbn07XG5cbi8vIDo6IChudW1iZXIpIOKGkiA/bnVtYmVyXG4vLyBGaW5kcyB0aGUgb2Zmc2V0IG9mIHRoZSBzdGVwIG1hcCB0aGF0IG1pcnJvcnMgdGhlIG1hcCBhdCB0aGVcbi8vIGdpdmVuIG9mZnNldCwgaW4gdGhpcyBtYXBwaW5nIChhcyBwZXIgdGhlIHNlY29uZCBhcmd1bWVudCB0b1xuLy8gYGFwcGVuZE1hcGApLlxuTWFwcGluZy5wcm90b3R5cGUuZ2V0TWlycm9yID0gZnVuY3Rpb24gZ2V0TWlycm9yIChuKSB7XG4gIGlmICh0aGlzLm1pcnJvcikgeyBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWlycm9yLmxlbmd0aDsgaSsrKVxuICAgIHsgaWYgKHRoaXMubWlycm9yW2ldID09IG4pIHsgcmV0dXJuIHRoaXMubWlycm9yW2kgKyAoaSAlIDIgPyAtMSA6IDEpXSB9IH0gfVxufTtcblxuTWFwcGluZy5wcm90b3R5cGUuc2V0TWlycm9yID0gZnVuY3Rpb24gc2V0TWlycm9yIChuLCBtKSB7XG4gIGlmICghdGhpcy5taXJyb3IpIHsgdGhpcy5taXJyb3IgPSBbXTsgfVxuICB0aGlzLm1pcnJvci5wdXNoKG4sIG0pO1xufTtcblxuLy8gOjogKE1hcHBpbmcpXG4vLyBBcHBlbmQgdGhlIGludmVyc2Ugb2YgdGhlIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUuXG5NYXBwaW5nLnByb3RvdHlwZS5hcHBlbmRNYXBwaW5nSW52ZXJ0ZWQgPSBmdW5jdGlvbiBhcHBlbmRNYXBwaW5nSW52ZXJ0ZWQgKG1hcHBpbmcpIHtcbiAgZm9yICh2YXIgaSA9IG1hcHBpbmcubWFwcy5sZW5ndGggLSAxLCB0b3RhbFNpemUgPSB0aGlzLm1hcHMubGVuZ3RoICsgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgIHRoaXMuYXBwZW5kTWFwKG1hcHBpbmcubWFwc1tpXS5pbnZlcnQoKSwgbWlyciAhPSBudWxsICYmIG1pcnIgPiBpID8gdG90YWxTaXplIC0gbWlyciAtIDEgOiBudWxsKTtcbiAgfVxufTtcblxuLy8gOjogKCkg4oaSIE1hcHBpbmdcbi8vIENyZWF0ZSBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoaXMgbWFwcGluZy5cbk1hcHBpbmcucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uIGludmVydCAoKSB7XG4gIHZhciBpbnZlcnNlID0gbmV3IE1hcHBpbmc7XG4gIGludmVyc2UuYXBwZW5kTWFwcGluZ0ludmVydGVkKHRoaXMpO1xuICByZXR1cm4gaW52ZXJzZVxufTtcblxuLy8gOiAobnVtYmVyLCA/bnVtYmVyKSDihpIgbnVtYmVyXG4vLyBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZy5cbk1hcHBpbmcucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAocG9zLCBhc3NvYykge1xuICAgIGlmICggYXNzb2MgPT09IHZvaWQgMCApIGFzc29jID0gMTtcblxuICBpZiAodGhpcy5taXJyb3IpIHsgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCB0cnVlKSB9XG4gIGZvciAodmFyIGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspXG4gICAgeyBwb3MgPSB0aGlzLm1hcHNbaV0ubWFwKHBvcywgYXNzb2MpOyB9XG4gIHJldHVybiBwb3Ncbn07XG5cbi8vIDogKG51bWJlciwgP251bWJlcikg4oaSIE1hcFJlc3VsdFxuLy8gTWFwIGEgcG9zaXRpb24gdGhyb3VnaCB0aGlzIG1hcHBpbmcsIHJldHVybmluZyBhIG1hcHBpbmdcbi8vIHJlc3VsdC5cbk1hcHBpbmcucHJvdG90eXBlLm1hcFJlc3VsdCA9IGZ1bmN0aW9uIG1hcFJlc3VsdCAocG9zLCBhc3NvYykge1xuICBpZiAoIGFzc29jID09PSB2b2lkIDAgKSBhc3NvYyA9IDE7XG4gcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCBmYWxzZSkgfTtcblxuTWFwcGluZy5wcm90b3R5cGUuX21hcCA9IGZ1bmN0aW9uIF9tYXAgKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICB2YXIgZGVsZXRlZCA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspIHtcbiAgICB2YXIgbWFwID0gdGhpcy5tYXBzW2ldLCByZXN1bHQgPSBtYXAubWFwUmVzdWx0KHBvcywgYXNzb2MpO1xuICAgIGlmIChyZXN1bHQucmVjb3ZlciAhPSBudWxsKSB7XG4gICAgICB2YXIgY29yciA9IHRoaXMuZ2V0TWlycm9yKGkpO1xuICAgICAgaWYgKGNvcnIgIT0gbnVsbCAmJiBjb3JyID4gaSAmJiBjb3JyIDwgdGhpcy50bykge1xuICAgICAgICBpID0gY29ycjtcbiAgICAgICAgcG9zID0gdGhpcy5tYXBzW2NvcnJdLnJlY292ZXIocmVzdWx0LnJlY292ZXIpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHQuZGVsZXRlZCkgeyBkZWxldGVkID0gdHJ1ZTsgfVxuICAgIHBvcyA9IHJlc3VsdC5wb3M7XG4gIH1cblxuICByZXR1cm4gc2ltcGxlID8gcG9zIDogbmV3IE1hcFJlc3VsdChwb3MsIGRlbGV0ZWQpXG59O1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1FcnJvcihtZXNzYWdlKSB7XG4gIHZhciBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICBlcnIuX19wcm90b19fID0gVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlO1xuICByZXR1cm4gZXJyXG59XG5cblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYW5zZm9ybUVycm9yO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlRyYW5zZm9ybUVycm9yXCI7XG5cbi8vIDo6LSBBYnN0cmFjdGlvbiB0byBidWlsZCB1cCBhbmQgdHJhY2sgYW4gYXJyYXkgb2Zcbi8vIFtzdGVwc10oI3RyYW5zZm9ybS5TdGVwKSByZXByZXNlbnRpbmcgYSBkb2N1bWVudCB0cmFuc2Zvcm1hdGlvbi5cbi8vXG4vLyBNb3N0IHRyYW5zZm9ybWluZyBtZXRob2RzIHJldHVybiB0aGUgYFRyYW5zZm9ybWAgb2JqZWN0IGl0c2VsZiwgc29cbi8vIHRoYXQgdGhleSBjYW4gYmUgY2hhaW5lZC5cbnZhciBUcmFuc2Zvcm0gPSBmdW5jdGlvbiBUcmFuc2Zvcm0oZG9jKSB7XG4gIC8vIDo6IE5vZGVcbiAgLy8gVGhlIGN1cnJlbnQgZG9jdW1lbnQgKHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIHN0ZXBzIGluIHRoZVxuICAvLyB0cmFuc2Zvcm0pLlxuICB0aGlzLmRvYyA9IGRvYztcbiAgLy8gOjogW1N0ZXBdXG4gIC8vIFRoZSBzdGVwcyBpbiB0aGlzIHRyYW5zZm9ybS5cbiAgdGhpcy5zdGVwcyA9IFtdO1xuICAvLyA6OiBbTm9kZV1cbiAgLy8gVGhlIGRvY3VtZW50cyBiZWZvcmUgZWFjaCBvZiB0aGUgc3RlcHMuXG4gIHRoaXMuZG9jcyA9IFtdO1xuICAvLyA6OiBNYXBwaW5nXG4gIC8vIEEgbWFwcGluZyB3aXRoIHRoZSBtYXBzIGZvciBlYWNoIG9mIHRoZSBzdGVwcyBpbiB0aGlzIHRyYW5zZm9ybS5cbiAgdGhpcy5tYXBwaW5nID0gbmV3IE1hcHBpbmc7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBiZWZvcmU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZG9jQ2hhbmdlZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyA6OiBOb2RlIFRoZSBzdGFydGluZyBkb2N1bWVudC5cbnByb3RvdHlwZUFjY2Vzc29ycy5iZWZvcmUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kb2NzLmxlbmd0aCA/IHRoaXMuZG9jc1swXSA6IHRoaXMuZG9jIH07XG5cbi8vIDo6IChzdGVwOiBTdGVwKSDihpIgdGhpc1xuLy8gQXBwbHkgYSBuZXcgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybSwgc2F2aW5nIHRoZSByZXN1bHQuIFRocm93cyBhblxuLy8gZXJyb3Igd2hlbiB0aGUgc3RlcCBmYWlscy5cblRyYW5zZm9ybS5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uIHN0ZXAgKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5tYXliZVN0ZXAob2JqZWN0KTtcbiAgaWYgKHJlc3VsdC5mYWlsZWQpIHsgdGhyb3cgbmV3IFRyYW5zZm9ybUVycm9yKHJlc3VsdC5mYWlsZWQpIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIDo6IChTdGVwKSDihpIgU3RlcFJlc3VsdFxuLy8gVHJ5IHRvIGFwcGx5IGEgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybWF0aW9uLCBpZ25vcmluZyBpdCBpZiBpdFxuLy8gZmFpbHMuIFJldHVybnMgdGhlIHN0ZXAgcmVzdWx0LlxuVHJhbnNmb3JtLnByb3RvdHlwZS5tYXliZVN0ZXAgPSBmdW5jdGlvbiBtYXliZVN0ZXAgKHN0ZXApIHtcbiAgdmFyIHJlc3VsdCA9IHN0ZXAuYXBwbHkodGhpcy5kb2MpO1xuICBpZiAoIXJlc3VsdC5mYWlsZWQpIHsgdGhpcy5hZGRTdGVwKHN0ZXAsIHJlc3VsdC5kb2MpOyB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIDo6IGJvb2xcbi8vIFRydWUgd2hlbiB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gY2hhbmdlZCAod2hlbiB0aGVyZSBhcmUgYW55XG4vLyBzdGVwcykuXG5wcm90b3R5cGVBY2Nlc3NvcnMuZG9jQ2hhbmdlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnN0ZXBzLmxlbmd0aCA+IDBcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuYWRkU3RlcCA9IGZ1bmN0aW9uIGFkZFN0ZXAgKHN0ZXAsIGRvYykge1xuICB0aGlzLmRvY3MucHVzaCh0aGlzLmRvYyk7XG4gIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgdGhpcy5tYXBwaW5nLmFwcGVuZE1hcChzdGVwLmdldE1hcCgpKTtcbiAgdGhpcy5kb2MgPSBkb2M7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVHJhbnNmb3JtLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbmZ1bmN0aW9uIG11c3RPdmVycmlkZSgpIHsgdGhyb3cgbmV3IEVycm9yKFwiT3ZlcnJpZGUgbWVcIikgfVxuXG52YXIgc3RlcHNCeUlEID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLy8gOjotIEEgc3RlcCBvYmplY3QgcmVwcmVzZW50cyBhbiBhdG9taWMgY2hhbmdlLiBJdCBnZW5lcmFsbHkgYXBwbGllc1xuLy8gb25seSB0byB0aGUgZG9jdW1lbnQgaXQgd2FzIGNyZWF0ZWQgZm9yLCBzaW5jZSB0aGUgcG9zaXRpb25zXG4vLyBzdG9yZWQgaW4gaXQgd2lsbCBvbmx5IG1ha2Ugc2Vuc2UgZm9yIHRoYXQgZG9jdW1lbnQuXG4vL1xuLy8gTmV3IHN0ZXBzIGFyZSBkZWZpbmVkIGJ5IGNyZWF0aW5nIGNsYXNzZXMgdGhhdCBleHRlbmQgYFN0ZXBgLFxuLy8gb3ZlcnJpZGluZyB0aGUgYGFwcGx5YCwgYGludmVydGAsIGBtYXBgLCBgZ2V0TWFwYCBhbmQgYGZyb21KU09OYFxuLy8gbWV0aG9kcywgYW5kIHJlZ2lzdGVyaW5nIHlvdXIgY2xhc3Mgd2l0aCBhIHVuaXF1ZVxuLy8gSlNPTi1zZXJpYWxpemF0aW9uIGlkZW50aWZpZXIgdXNpbmdcbi8vIFtgU3RlcC5qc29uSURgXSgjdHJhbnNmb3JtLlN0ZXBeanNvbklEKS5cbnZhciBTdGVwID0gZnVuY3Rpb24gU3RlcCAoKSB7fTtcblxuU3RlcC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseSAoX2RvYykgeyByZXR1cm4gbXVzdE92ZXJyaWRlKCkgfTtcblxuLy8gOjogKCkg4oaSIFN0ZXBNYXBcbi8vIEdldCB0aGUgc3RlcCBtYXAgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG1hZGUgYnkgdGhpcyBzdGVwLFxuLy8gYW5kIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGUgb2xkXG4vLyBhbmQgdGhlIG5ldyBkb2N1bWVudC5cblN0ZXAucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uIGdldE1hcCAoKSB7IHJldHVybiBTdGVwTWFwLmVtcHR5IH07XG5cbi8vIDo6IChkb2M6IE5vZGUpIOKGkiBTdGVwXG4vLyBDcmVhdGUgYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGlzIHN0ZXAuIE5lZWRzIHRoZSBkb2N1bWVudCBhcyBpdFxuLy8gd2FzIGJlZm9yZSB0aGUgc3RlcCBhcyBhcmd1bWVudC5cblN0ZXAucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uIGludmVydCAoX2RvYykgeyByZXR1cm4gbXVzdE92ZXJyaWRlKCkgfTtcblxuLy8gOjogKG1hcHBpbmc6IE1hcHBhYmxlKSDihpIgP1N0ZXBcbi8vIE1hcCB0aGlzIHN0ZXAgdGhyb3VnaCBhIG1hcHBhYmxlIHRoaW5nLCByZXR1cm5pbmcgZWl0aGVyIGFcbi8vIHZlcnNpb24gb2YgdGhhdCBzdGVwIHdpdGggaXRzIHBvc2l0aW9ucyBhZGp1c3RlZCwgb3IgYG51bGxgIGlmXG4vLyB0aGUgc3RlcCB3YXMgZW50aXJlbHkgZGVsZXRlZCBieSB0aGUgbWFwcGluZy5cblN0ZXAucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAoX21hcHBpbmcpIHsgcmV0dXJuIG11c3RPdmVycmlkZSgpIH07XG5cbi8vIDo6IChvdGhlcjogU3RlcCkg4oaSID9TdGVwXG4vLyBUcnkgdG8gbWVyZ2UgdGhpcyBzdGVwIHdpdGggYW5vdGhlciBvbmUsIHRvIGJlIGFwcGxpZWQgZGlyZWN0bHlcbi8vIGFmdGVyIGl0LiBSZXR1cm5zIHRoZSBtZXJnZWQgc3RlcCB3aGVuIHBvc3NpYmxlLCBudWxsIGlmIHRoZVxuLy8gc3RlcHMgY2FuJ3QgYmUgbWVyZ2VkLlxuU3RlcC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSAoX290aGVyKSB7IHJldHVybiBudWxsIH07XG5cbi8vIDo6ICgpIOKGkiBPYmplY3Rcbi8vIENyZWF0ZSBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHN0ZXAuIFdoZW5cbi8vIGRlZmluaW5nIHRoaXMgZm9yIGEgY3VzdG9tIHN1YmNsYXNzLCBtYWtlIHN1cmUgdGhlIHJlc3VsdCBvYmplY3Rcbi8vIGluY2x1ZGVzIHRoZSBzdGVwIHR5cGUncyBbSlNPTiBpZF0oI3RyYW5zZm9ybS5TdGVwXmpzb25JRCkgdW5kZXJcbi8vIHRoZSBgc3RlcFR5cGVgIHByb3BlcnR5LlxuU3RlcC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHsgcmV0dXJuIG11c3RPdmVycmlkZSgpIH07XG5cbi8vIDo6IChTY2hlbWEsIE9iamVjdCkg4oaSIFN0ZXBcbi8vIERlc2VyaWFsaXplIGEgc3RlcCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBXaWxsIGNhbGxcbi8vIHRocm91Z2ggdG8gdGhlIHN0ZXAgY2xhc3MnIG93biBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZC5cblN0ZXAuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTiAoc2NoZW1hLCBqc29uKSB7XG4gIGlmICghanNvbiB8fCAhanNvbi5zdGVwVHlwZSkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFN0ZXAuZnJvbUpTT05cIikgfVxuICB2YXIgdHlwZSA9IHN0ZXBzQnlJRFtqc29uLnN0ZXBUeXBlXTtcbiAgaWYgKCF0eXBlKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKChcIk5vIHN0ZXAgdHlwZSBcIiArIChqc29uLnN0ZXBUeXBlKSArIFwiIGRlZmluZWRcIikpIH1cbiAgcmV0dXJuIHR5cGUuZnJvbUpTT04oc2NoZW1hLCBqc29uKVxufTtcblxuLy8gOjogKHN0cmluZywgY29uc3RydWN0b3I8U3RlcD4pXG4vLyBUbyBiZSBhYmxlIHRvIHNlcmlhbGl6ZSBzdGVwcyB0byBKU09OLCBlYWNoIHN0ZXAgbmVlZHMgYSBzdHJpbmdcbi8vIElEIHRvIGF0dGFjaCB0byBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVXNlIHRoaXMgbWV0aG9kIHRvXG4vLyByZWdpc3RlciBhbiBJRCBmb3IgeW91ciBzdGVwIGNsYXNzZXMuIFRyeSB0byBwaWNrIHNvbWV0aGluZ1xuLy8gdGhhdCdzIHVubGlrZWx5IHRvIGNsYXNoIHdpdGggc3RlcHMgZnJvbSBvdGhlciBtb2R1bGVzLlxuU3RlcC5qc29uSUQgPSBmdW5jdGlvbiBqc29uSUQgKGlkLCBzdGVwQ2xhc3MpIHtcbiAgaWYgKGlkIGluIHN0ZXBzQnlJRCkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cGxpY2F0ZSB1c2Ugb2Ygc3RlcCBKU09OIElEIFwiICsgaWQpIH1cbiAgc3RlcHNCeUlEW2lkXSA9IHN0ZXBDbGFzcztcbiAgc3RlcENsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgcmV0dXJuIHN0ZXBDbGFzc1xufTtcblxuLy8gOjotIFRoZSByZXN1bHQgb2YgW2FwcGx5aW5nXSgjdHJhbnNmb3JtLlN0ZXAuYXBwbHkpIGEgc3RlcC4gQ29udGFpbnMgZWl0aGVyIGFcbi8vIG5ldyBkb2N1bWVudCBvciBhIGZhaWx1cmUgdmFsdWUuXG52YXIgU3RlcFJlc3VsdCA9IGZ1bmN0aW9uIFN0ZXBSZXN1bHQoZG9jLCBmYWlsZWQpIHtcbiAgLy8gOjogP05vZGUgVGhlIHRyYW5zZm9ybWVkIGRvY3VtZW50LlxuICB0aGlzLmRvYyA9IGRvYztcbiAgLy8gOjogP3N0cmluZyBUZXh0IHByb3ZpZGluZyBpbmZvcm1hdGlvbiBhYm91dCBhIGZhaWxlZCBzdGVwLlxuICB0aGlzLmZhaWxlZCA9IGZhaWxlZDtcbn07XG5cbi8vIDo6IChOb2RlKSDihpIgU3RlcFJlc3VsdFxuLy8gQ3JlYXRlIGEgc3VjY2Vzc2Z1bCBzdGVwIHJlc3VsdC5cblN0ZXBSZXN1bHQub2sgPSBmdW5jdGlvbiBvayAoZG9jKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChkb2MsIG51bGwpIH07XG5cbi8vIDo6IChzdHJpbmcpIOKGkiBTdGVwUmVzdWx0XG4vLyBDcmVhdGUgYSBmYWlsZWQgc3RlcCByZXN1bHQuXG5TdGVwUmVzdWx0LmZhaWwgPSBmdW5jdGlvbiBmYWlsIChtZXNzYWdlKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChudWxsLCBtZXNzYWdlKSB9O1xuXG4vLyA6OiAoTm9kZSwgbnVtYmVyLCBudW1iZXIsIFNsaWNlKSDihpIgU3RlcFJlc3VsdFxuLy8gQ2FsbCBbYE5vZGUucmVwbGFjZWBdKCNtb2RlbC5Ob2RlLnJlcGxhY2UpIHdpdGggdGhlIGdpdmVuXG4vLyBhcmd1bWVudHMuIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgcmVzdWx0IGlmIGl0IHN1Y2NlZWRzLCBhbmQgYVxuLy8gZmFpbGVkIG9uZSBpZiBpdCB0aHJvd3MgYSBgUmVwbGFjZUVycm9yYC5cblN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UgPSBmdW5jdGlvbiBmcm9tUmVwbGFjZSAoZG9jLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gU3RlcFJlc3VsdC5vayhkb2MucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBSZXBsYWNlRXJyb3IpIHsgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChlLm1lc3NhZ2UpIH1cbiAgICB0aHJvdyBlXG4gIH1cbn07XG5cbi8vIDo6LSBSZXBsYWNlIGEgcGFydCBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIHNsaWNlIG9mIG5ldyBjb250ZW50LlxudmFyIFJlcGxhY2VTdGVwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU3RlcCkge1xuICBmdW5jdGlvbiBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UsIHN0cnVjdHVyZSkge1xuICAgIFN0ZXAuY2FsbCh0aGlzKTtcbiAgICAvLyA6OiBudW1iZXJcbiAgICAvLyBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgLy8gOjogbnVtYmVyXG4gICAgLy8gVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgdGhpcy50byA9IHRvO1xuICAgIC8vIDo6IFNsaWNlXG4gICAgLy8gVGhlIHNsaWNlIHRvIGluc2VydC5cbiAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgdGhpcy5zdHJ1Y3R1cmUgPSAhIXN0cnVjdHVyZTtcbiAgfVxuXG4gIGlmICggU3RlcCApIFJlcGxhY2VTdGVwLl9fcHJvdG9fXyA9IFN0ZXA7XG4gIFJlcGxhY2VTdGVwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFN0ZXAgJiYgU3RlcC5wcm90b3R5cGUgKTtcbiAgUmVwbGFjZVN0ZXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVwbGFjZVN0ZXA7XG5cbiAgUmVwbGFjZVN0ZXAucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkgKGRvYykge1xuICAgIGlmICh0aGlzLnN0cnVjdHVyZSAmJiBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZnJvbSwgdGhpcy50bykpXG4gICAgICB7IHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKSB9XG4gICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMuc2xpY2UpXG4gIH07XG5cbiAgUmVwbGFjZVN0ZXAucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uIGdldE1hcCAoKSB7XG4gICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMudG8gLSB0aGlzLmZyb20sIHRoaXMuc2xpY2Uuc2l6ZV0pXG4gIH07XG5cbiAgUmVwbGFjZVN0ZXAucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uIGludmVydCAoZG9jKSB7XG4gICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSwgZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bykpXG4gIH07XG5cbiAgUmVwbGFjZVN0ZXAucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGluZykge1xuICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgaWYgKGZyb20uZGVsZXRlZCAmJiB0by5kZWxldGVkKSB7IHJldHVybiBudWxsIH1cbiAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20ucG9zLCBNYXRoLm1heChmcm9tLnBvcywgdG8ucG9zKSwgdGhpcy5zbGljZSlcbiAgfTtcblxuICBSZXBsYWNlU3RlcC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwKSB8fCBvdGhlci5zdHJ1Y3R1cmUgfHwgdGhpcy5zdHJ1Y3R1cmUpIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgaWYgKHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSA9PSBvdGhlci5mcm9tICYmICF0aGlzLnNsaWNlLm9wZW5FbmQgJiYgIW90aGVyLnNsaWNlLm9wZW5TdGFydCkge1xuICAgICAgdmFyIHNsaWNlID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICA6IG5ldyBTbGljZSh0aGlzLnNsaWNlLmNvbnRlbnQuYXBwZW5kKG90aGVyLnNsaWNlLmNvbnRlbnQpLCB0aGlzLnNsaWNlLm9wZW5TdGFydCwgb3RoZXIuc2xpY2Uub3BlbkVuZCk7XG4gICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKHRoaXMuZnJvbSwgdGhpcy50byArIChvdGhlci50byAtIG90aGVyLmZyb20pLCBzbGljZSwgdGhpcy5zdHJ1Y3R1cmUpXG4gICAgfSBlbHNlIGlmIChvdGhlci50byA9PSB0aGlzLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlblN0YXJ0ICYmICFvdGhlci5zbGljZS5vcGVuRW5kKSB7XG4gICAgICB2YXIgc2xpY2UkMSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgOiBuZXcgU2xpY2Uob3RoZXIuc2xpY2UuY29udGVudC5hcHBlbmQodGhpcy5zbGljZS5jb250ZW50KSwgb3RoZXIuc2xpY2Uub3BlblN0YXJ0LCB0aGlzLnNsaWNlLm9wZW5FbmQpO1xuICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChvdGhlci5mcm9tLCB0aGlzLnRvLCBzbGljZSQxLCB0aGlzLnN0cnVjdHVyZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH07XG5cbiAgUmVwbGFjZVN0ZXAucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgdmFyIGpzb24gPSB7c3RlcFR5cGU6IFwicmVwbGFjZVwiLCBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvfTtcbiAgICBpZiAodGhpcy5zbGljZS5zaXplKSB7IGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpOyB9XG4gICAgaWYgKHRoaXMuc3RydWN0dXJlKSB7IGpzb24uc3RydWN0dXJlID0gdHJ1ZTsgfVxuICAgIHJldHVybiBqc29uXG4gIH07XG5cbiAgUmVwbGFjZVN0ZXAuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTiAoc2NoZW1hLCBqc29uKSB7XG4gICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VTdGVwLmZyb21KU09OXCIpIH1cbiAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGpzb24uZnJvbSwganNvbi50bywgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwgISFqc29uLnN0cnVjdHVyZSlcbiAgfTtcblxuICByZXR1cm4gUmVwbGFjZVN0ZXA7XG59KFN0ZXApKTtcblxuU3RlcC5qc29uSUQoXCJyZXBsYWNlXCIsIFJlcGxhY2VTdGVwKTtcblxuLy8gOjotIFJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgY29udGVudCwgYnV0XG4vLyBwcmVzZXJ2ZSBhIHJhbmdlIG9mIHRoZSByZXBsYWNlZCBjb250ZW50IGJ5IG1vdmluZyBpdCBpbnRvIHRoZVxuLy8gc2xpY2UuXG52YXIgUmVwbGFjZUFyb3VuZFN0ZXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTdGVwKSB7XG4gIGZ1bmN0aW9uIFJlcGxhY2VBcm91bmRTdGVwKGZyb20sIHRvLCBnYXBGcm9tLCBnYXBUbywgc2xpY2UsIGluc2VydCwgc3RydWN0dXJlKSB7XG4gICAgU3RlcC5jYWxsKHRoaXMpO1xuICAgIC8vIDo6IG51bWJlclxuICAgIC8vIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAvLyA6OiBudW1iZXJcbiAgICAvLyBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICB0aGlzLnRvID0gdG87XG4gICAgLy8gOjogbnVtYmVyXG4gICAgLy8gVGhlIHN0YXJ0IG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICB0aGlzLmdhcEZyb20gPSBnYXBGcm9tO1xuICAgIC8vIDo6IG51bWJlclxuICAgIC8vIFRoZSBlbmQgb2YgcHJlc2VydmVkIHJhbmdlLlxuICAgIHRoaXMuZ2FwVG8gPSBnYXBUbztcbiAgICAvLyA6OiBTbGljZVxuICAgIC8vIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgdGhpcy5zbGljZSA9IHNsaWNlO1xuICAgIC8vIDo6IG51bWJlclxuICAgIC8vIFRoZSBwb3NpdGlvbiBpbiB0aGUgc2xpY2Ugd2hlcmUgdGhlIHByZXNlcnZlZCByYW5nZSBzaG91bGQgYmVcbiAgICAvLyBpbnNlcnRlZC5cbiAgICB0aGlzLmluc2VydCA9IGluc2VydDtcbiAgICB0aGlzLnN0cnVjdHVyZSA9ICEhc3RydWN0dXJlO1xuICB9XG5cbiAgaWYgKCBTdGVwICkgUmVwbGFjZUFyb3VuZFN0ZXAuX19wcm90b19fID0gU3RlcDtcbiAgUmVwbGFjZUFyb3VuZFN0ZXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU3RlcCAmJiBTdGVwLnByb3RvdHlwZSApO1xuICBSZXBsYWNlQXJvdW5kU3RlcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXBsYWNlQXJvdW5kU3RlcDtcblxuICBSZXBsYWNlQXJvdW5kU3RlcC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseSAoZG9jKSB7XG4gICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIChjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZnJvbSwgdGhpcy5nYXBGcm9tKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmdhcFRvLCB0aGlzLnRvKSkpXG4gICAgICB7IHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgZ2FwLXJlcGxhY2Ugd291bGQgb3ZlcndyaXRlIGNvbnRlbnRcIikgfVxuXG4gICAgdmFyIGdhcCA9IGRvYy5zbGljZSh0aGlzLmdhcEZyb20sIHRoaXMuZ2FwVG8pO1xuICAgIGlmIChnYXAub3BlblN0YXJ0IHx8IGdhcC5vcGVuRW5kKVxuICAgICAgeyByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiR2FwIGlzIG5vdCBhIGZsYXQgcmFuZ2VcIikgfVxuICAgIHZhciBpbnNlcnRlZCA9IHRoaXMuc2xpY2UuaW5zZXJ0QXQodGhpcy5pbnNlcnQsIGdhcC5jb250ZW50KTtcbiAgICBpZiAoIWluc2VydGVkKSB7IHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJDb250ZW50IGRvZXMgbm90IGZpdCBpbiBnYXBcIikgfVxuICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBpbnNlcnRlZClcbiAgfTtcblxuICBSZXBsYWNlQXJvdW5kU3RlcC5wcm90b3R5cGUuZ2V0TWFwID0gZnVuY3Rpb24gZ2V0TWFwICgpIHtcbiAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmluc2VydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FwVG8sIHRoaXMudG8gLSB0aGlzLmdhcFRvLCB0aGlzLnNsaWNlLnNpemUgLSB0aGlzLmluc2VydF0pXG4gIH07XG5cbiAgUmVwbGFjZUFyb3VuZFN0ZXAucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uIGludmVydCAoZG9jKSB7XG4gICAgdmFyIGdhcCA9IHRoaXMuZ2FwVG8gLSB0aGlzLmdhcEZyb207XG4gICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSArIGdhcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0LCB0aGlzLmZyb20gKyB0aGlzLmluc2VydCArIGdhcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLnJlbW92ZUJldHdlZW4odGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmdhcFRvIC0gdGhpcy5mcm9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5zdHJ1Y3R1cmUpXG4gIH07XG5cbiAgUmVwbGFjZUFyb3VuZFN0ZXAucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGluZykge1xuICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgdmFyIGdhcEZyb20gPSBtYXBwaW5nLm1hcCh0aGlzLmdhcEZyb20sIC0xKSwgZ2FwVG8gPSBtYXBwaW5nLm1hcCh0aGlzLmdhcFRvLCAxKTtcbiAgICBpZiAoKGZyb20uZGVsZXRlZCAmJiB0by5kZWxldGVkKSB8fCBnYXBGcm9tIDwgZnJvbS5wb3MgfHwgZ2FwVG8gPiB0by5wb3MpIHsgcmV0dXJuIG51bGwgfVxuICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZnJvbS5wb3MsIHRvLnBvcywgZ2FwRnJvbSwgZ2FwVG8sIHRoaXMuc2xpY2UsIHRoaXMuaW5zZXJ0LCB0aGlzLnN0cnVjdHVyZSlcbiAgfTtcblxuICBSZXBsYWNlQXJvdW5kU3RlcC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICB2YXIganNvbiA9IHtzdGVwVHlwZTogXCJyZXBsYWNlQXJvdW5kXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8sXG4gICAgICAgICAgICAgICAgZ2FwRnJvbTogdGhpcy5nYXBGcm9tLCBnYXBUbzogdGhpcy5nYXBUbywgaW5zZXJ0OiB0aGlzLmluc2VydH07XG4gICAgaWYgKHRoaXMuc2xpY2Uuc2l6ZSkgeyBqc29uLnNsaWNlID0gdGhpcy5zbGljZS50b0pTT04oKTsgfVxuICAgIGlmICh0aGlzLnN0cnVjdHVyZSkgeyBqc29uLnN0cnVjdHVyZSA9IHRydWU7IH1cbiAgICByZXR1cm4ganNvblxuICB9O1xuXG4gIFJlcGxhY2VBcm91bmRTdGVwLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04gKHNjaGVtYSwganNvbikge1xuICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIiB8fFxuICAgICAgICB0eXBlb2YganNvbi5nYXBGcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uZ2FwVG8gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5pbnNlcnQgIT0gXCJudW1iZXJcIilcbiAgICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlQXJvdW5kU3RlcC5mcm9tSlNPTlwiKSB9XG4gICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChqc29uLmZyb20sIGpzb24udG8sIGpzb24uZ2FwRnJvbSwganNvbi5nYXBUbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksIGpzb24uaW5zZXJ0LCAhIWpzb24uc3RydWN0dXJlKVxuICB9O1xuXG4gIHJldHVybiBSZXBsYWNlQXJvdW5kU3RlcDtcbn0oU3RlcCkpO1xuXG5TdGVwLmpzb25JRChcInJlcGxhY2VBcm91bmRcIiwgUmVwbGFjZUFyb3VuZFN0ZXApO1xuXG5mdW5jdGlvbiBjb250ZW50QmV0d2Vlbihkb2MsIGZyb20sIHRvKSB7XG4gIHZhciAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20pLCBkaXN0ID0gdG8gLSBmcm9tLCBkZXB0aCA9ICRmcm9tLmRlcHRoO1xuICB3aGlsZSAoZGlzdCA+IDAgJiYgZGVwdGggPiAwICYmICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpID09ICRmcm9tLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpIHtcbiAgICBkZXB0aC0tO1xuICAgIGRpc3QtLTtcbiAgfVxuICBpZiAoZGlzdCA+IDApIHtcbiAgICB2YXIgbmV4dCA9ICRmcm9tLm5vZGUoZGVwdGgpLm1heWJlQ2hpbGQoJGZyb20uaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgIHdoaWxlIChkaXN0ID4gMCkge1xuICAgICAgaWYgKCFuZXh0IHx8IG5leHQuaXNMZWFmKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICBkaXN0LS07XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBjYW5DdXQobm9kZSwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKHN0YXJ0ID09IDAgfHwgbm9kZS5jYW5SZXBsYWNlKHN0YXJ0LCBub2RlLmNoaWxkQ291bnQpKSAmJlxuICAgIChlbmQgPT0gbm9kZS5jaGlsZENvdW50IHx8IG5vZGUuY2FuUmVwbGFjZSgwLCBlbmQpKVxufVxuXG4vLyA6OiAoTm9kZVJhbmdlKSDihpIgP251bWJlclxuLy8gVHJ5IHRvIGZpbmQgYSB0YXJnZXQgZGVwdGggdG8gd2hpY2ggdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlXG4vLyBjYW4gYmUgbGlmdGVkLiBXaWxsIG5vdCBnbyBhY3Jvc3Ncbi8vIFtpc29sYXRpbmddKCNtb2RlbC5Ob2RlU3BlYy5pc29sYXRpbmcpIHBhcmVudCBub2Rlcy5cbmZ1bmN0aW9uIGxpZnRUYXJnZXQocmFuZ2UpIHtcbiAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgdmFyIGNvbnRlbnQgPSBwYXJlbnQuY29udGVudC5jdXRCeUluZGV4KHJhbmdlLnN0YXJ0SW5kZXgsIHJhbmdlLmVuZEluZGV4KTtcbiAgZm9yICh2YXIgZGVwdGggPSByYW5nZS5kZXB0aDs7IC0tZGVwdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJhbmdlLiRmcm9tLm5vZGUoZGVwdGgpO1xuICAgIHZhciBpbmRleCA9IHJhbmdlLiRmcm9tLmluZGV4KGRlcHRoKSwgZW5kSW5kZXggPSByYW5nZS4kdG8uaW5kZXhBZnRlcihkZXB0aCk7XG4gICAgaWYgKGRlcHRoIDwgcmFuZ2UuZGVwdGggJiYgbm9kZS5jYW5SZXBsYWNlKGluZGV4LCBlbmRJbmRleCwgY29udGVudCkpXG4gICAgICB7IHJldHVybiBkZXB0aCB9XG4gICAgaWYgKGRlcHRoID09IDAgfHwgbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8ICFjYW5DdXQobm9kZSwgaW5kZXgsIGVuZEluZGV4KSkgeyBicmVhayB9XG4gIH1cbn1cblxuLy8gOjogKE5vZGVSYW5nZSwgbnVtYmVyKSDihpIgdGhpc1xuLy8gU3BsaXQgdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlIG9mZiBmcm9tIGl0cyBwYXJlbnQsIGlmIHRoZXJlXG4vLyBpcyBzaWJsaW5nIGNvbnRlbnQgYmVmb3JlIG9yIGFmdGVyIGl0LCBhbmQgbW92ZSBpdCB1cCB0aGUgdHJlZSB0b1xuLy8gdGhlIGRlcHRoIHNwZWNpZmllZCBieSBgdGFyZ2V0YC4gWW91J2xsIHByb2JhYmx5IHdhbnQgdG8gdXNlXG4vLyBbYGxpZnRUYXJnZXRgXSgjdHJhbnNmb3JtLmxpZnRUYXJnZXQpIHRvIGNvbXB1dGUgYHRhcmdldGAsIHRvIG1ha2Vcbi8vIHN1cmUgdGhlIGxpZnQgaXMgdmFsaWQuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbihyYW5nZSwgdGFyZ2V0KSB7XG4gIHZhciAkZnJvbSA9IHJhbmdlLiRmcm9tO1xuICB2YXIgJHRvID0gcmFuZ2UuJHRvO1xuICB2YXIgZGVwdGggPSByYW5nZS5kZXB0aDtcblxuICB2YXIgZ2FwU3RhcnQgPSAkZnJvbS5iZWZvcmUoZGVwdGggKyAxKSwgZ2FwRW5kID0gJHRvLmFmdGVyKGRlcHRoICsgMSk7XG4gIHZhciBzdGFydCA9IGdhcFN0YXJ0LCBlbmQgPSBnYXBFbmQ7XG5cbiAgdmFyIGJlZm9yZSA9IEZyYWdtZW50LmVtcHR5LCBvcGVuU3RhcnQgPSAwO1xuICBmb3IgKHZhciBkID0gZGVwdGgsIHNwbGl0dGluZyA9IGZhbHNlOyBkID4gdGFyZ2V0OyBkLS0pXG4gICAgeyBpZiAoc3BsaXR0aW5nIHx8ICRmcm9tLmluZGV4KGQpID4gMCkge1xuICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgb3BlblN0YXJ0Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0LS07XG4gICAgfSB9XG4gIHZhciBhZnRlciA9IEZyYWdtZW50LmVtcHR5LCBvcGVuRW5kID0gMDtcbiAgZm9yICh2YXIgZCQxID0gZGVwdGgsIHNwbGl0dGluZyQxID0gZmFsc2U7IGQkMSA+IHRhcmdldDsgZCQxLS0pXG4gICAgeyBpZiAoc3BsaXR0aW5nJDEgfHwgJHRvLmFmdGVyKGQkMSArIDEpIDwgJHRvLmVuZChkJDEpKSB7XG4gICAgICBzcGxpdHRpbmckMSA9IHRydWU7XG4gICAgICBhZnRlciA9IEZyYWdtZW50LmZyb20oJHRvLm5vZGUoZCQxKS5jb3B5KGFmdGVyKSk7XG4gICAgICBvcGVuRW5kKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCsrO1xuICAgIH0gfVxuXG4gIHJldHVybiB0aGlzLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIGdhcFN0YXJ0LCBnYXBFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgb3BlblN0YXJ0LCBvcGVuRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlLnNpemUgLSBvcGVuU3RhcnQsIHRydWUpKVxufTtcblxuLy8gOjogKE5vZGVSYW5nZSwgTm9kZVR5cGUsID9PYmplY3QsID9Ob2RlUmFuZ2UpIOKGkiA/W3t0eXBlOiBOb2RlVHlwZSwgYXR0cnM6ID9PYmplY3R9XVxuLy8gVHJ5IHRvIGZpbmQgYSB2YWxpZCB3YXkgdG8gd3JhcCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UgaW4gYVxuLy8gbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZS4gTWF5IGludHJvZHVjZSBleHRyYSBub2RlcyBhcm91bmQgYW5kIGluc2lkZVxuLy8gdGhlIHdyYXBwZXIgbm9kZSwgaWYgbmVjZXNzYXJ5LiBSZXR1cm5zIG51bGwgaWYgbm8gdmFsaWQgd3JhcHBpbmdcbi8vIGNvdWxkIGJlIGZvdW5kLiBXaGVuIGBpbm5lclJhbmdlYCBpcyBnaXZlbiwgdGhhdCByYW5nZSdzIGNvbnRlbnQgaXNcbi8vIHVzZWQgYXMgdGhlIGNvbnRlbnQgdG8gZml0IGludG8gdGhlIHdyYXBwaW5nLCBpbnN0ZWFkIG9mIHRoZVxuLy8gY29udGVudCBvZiBgcmFuZ2VgLlxuZnVuY3Rpb24gZmluZFdyYXBwaW5nKHJhbmdlLCBub2RlVHlwZSwgYXR0cnMsIGlubmVyUmFuZ2UpIHtcbiAgaWYgKCBpbm5lclJhbmdlID09PSB2b2lkIDAgKSBpbm5lclJhbmdlID0gcmFuZ2U7XG5cbiAgdmFyIGFyb3VuZCA9IGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIG5vZGVUeXBlKTtcbiAgdmFyIGlubmVyID0gYXJvdW5kICYmIGZpbmRXcmFwcGluZ0luc2lkZShpbm5lclJhbmdlLCBub2RlVHlwZSk7XG4gIGlmICghaW5uZXIpIHsgcmV0dXJuIG51bGwgfVxuICByZXR1cm4gYXJvdW5kLm1hcCh3aXRoQXR0cnMpLmNvbmNhdCh7dHlwZTogbm9kZVR5cGUsIGF0dHJzOiBhdHRyc30pLmNvbmNhdChpbm5lci5tYXAod2l0aEF0dHJzKSlcbn1cblxuZnVuY3Rpb24gd2l0aEF0dHJzKHR5cGUpIHsgcmV0dXJuIHt0eXBlOiB0eXBlLCBhdHRyczogbnVsbH0gfVxuXG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCB0eXBlKSB7XG4gIHZhciBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gIHZhciBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleDtcbiAgdmFyIGVuZEluZGV4ID0gcmFuZ2UuZW5kSW5kZXg7XG4gIHZhciBhcm91bmQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoc3RhcnRJbmRleCkuZmluZFdyYXBwaW5nKHR5cGUpO1xuICBpZiAoIWFyb3VuZCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBvdXRlciA9IGFyb3VuZC5sZW5ndGggPyBhcm91bmRbMF0gOiB0eXBlO1xuICByZXR1cm4gcGFyZW50LmNhblJlcGxhY2VXaXRoKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBvdXRlcikgPyBhcm91bmQgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ0luc2lkZShyYW5nZSwgdHlwZSkge1xuICB2YXIgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICB2YXIgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXg7XG4gIHZhciBlbmRJbmRleCA9IHJhbmdlLmVuZEluZGV4O1xuICB2YXIgaW5uZXIgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCk7XG4gIHZhciBpbnNpZGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5maW5kV3JhcHBpbmcoaW5uZXIudHlwZSk7XG4gIGlmICghaW5zaWRlKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGxhc3RUeXBlID0gaW5zaWRlLmxlbmd0aCA/IGluc2lkZVtpbnNpZGUubGVuZ3RoIC0gMV0gOiB0eXBlO1xuICB2YXIgaW5uZXJNYXRjaCA9IGxhc3RUeXBlLmNvbnRlbnRNYXRjaDtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGlubmVyTWF0Y2ggJiYgaSA8IGVuZEluZGV4OyBpKyspXG4gICAgeyBpbm5lck1hdGNoID0gaW5uZXJNYXRjaC5tYXRjaFR5cGUocGFyZW50LmNoaWxkKGkpLnR5cGUpOyB9XG4gIGlmICghaW5uZXJNYXRjaCB8fCAhaW5uZXJNYXRjaC52YWxpZEVuZCkgeyByZXR1cm4gbnVsbCB9XG4gIHJldHVybiBpbnNpZGVcbn1cblxuLy8gOjogKE5vZGVSYW5nZSwgW3t0eXBlOiBOb2RlVHlwZSwgYXR0cnM6ID9PYmplY3R9XSkg4oaSIHRoaXNcbi8vIFdyYXAgdGhlIGdpdmVuIFtyYW5nZV0oI21vZGVsLk5vZGVSYW5nZSkgaW4gdGhlIGdpdmVuIHNldCBvZiB3cmFwcGVycy5cbi8vIFRoZSB3cmFwcGVycyBhcmUgYXNzdW1lZCB0byBiZSB2YWxpZCBpbiB0aGlzIHBvc2l0aW9uLCBhbmQgc2hvdWxkXG4vLyBwcm9iYWJseSBiZSBjb21wdXRlZCB3aXRoIFtgZmluZFdyYXBwaW5nYF0oI3RyYW5zZm9ybS5maW5kV3JhcHBpbmcpLlxuVHJhbnNmb3JtLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24ocmFuZ2UsIHdyYXBwZXJzKSB7XG4gIHZhciBjb250ZW50ID0gRnJhZ21lbnQuZW1wdHk7XG4gIGZvciAodmFyIGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICB7IGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7IH1cblxuICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydCwgZW5kID0gcmFuZ2UuZW5kO1xuICByZXR1cm4gdGhpcy5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBzdGFydCwgZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpXG59O1xuXG4vLyA6OiAobnVtYmVyLCA/bnVtYmVyLCBOb2RlVHlwZSwgP09iamVjdCkg4oaSIHRoaXNcbi8vIFNldCB0aGUgdHlwZSBvZiBhbGwgdGV4dGJsb2NrcyAocGFydGx5KSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCB0b1xuLy8gdGhlIGdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRCbG9ja1R5cGUgPSBmdW5jdGlvbihmcm9tLCB0bywgdHlwZSwgYXR0cnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gZnJvbTtcblxuICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUeXBlIGdpdmVuIHRvIHNldEJsb2NrVHlwZSBzaG91bGQgYmUgYSB0ZXh0YmxvY2tcIikgfVxuICB2YXIgbWFwRnJvbSA9IHRoaXMuc3RlcHMubGVuZ3RoO1xuICB0aGlzLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGZ1bmN0aW9uIChub2RlLCBwb3MpIHtcbiAgICBpZiAobm9kZS5pc1RleHRibG9jayAmJiAhbm9kZS5oYXNNYXJrdXAodHlwZSwgYXR0cnMpICYmIGNhbkNoYW5nZVR5cGUodGhpcyQxLmRvYywgdGhpcyQxLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyksIHR5cGUpKSB7XG4gICAgICAvLyBFbnN1cmUgYWxsIG1hcmt1cCB0aGF0IGlzbid0IGFsbG93ZWQgaW4gdGhlIG5ldyBub2RlIHR5cGUgaXMgY2xlYXJlZFxuICAgICAgdGhpcyQxLmNsZWFySW5jb21wYXRpYmxlKHRoaXMkMS5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MsIDEpLCB0eXBlKTtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcyQxLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICB2YXIgc3RhcnRNID0gbWFwcGluZy5tYXAocG9zLCAxKSwgZW5kTSA9IG1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUsIDEpO1xuICAgICAgdGhpcyQxLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0TSwgZW5kTSwgc3RhcnRNICsgMSwgZW5kTSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKSksIDAsIDApLCAxLCB0cnVlKSk7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpc1xufTtcblxuZnVuY3Rpb24gY2FuQ2hhbmdlVHlwZShkb2MsIHBvcywgdHlwZSkge1xuICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICByZXR1cm4gJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgdHlwZSlcbn1cblxuLy8gOjogKG51bWJlciwgP05vZGVUeXBlLCA/T2JqZWN0LCA/W01hcmtdKSDihpIgdGhpc1xuLy8gQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG4vLyBXaGVuIGB0eXBlYCBpc24ndCBnaXZlbiwgdGhlIGV4aXN0aW5nIG5vZGUgdHlwZSBpcyBwcmVzZXJ2ZWQsXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldE5vZGVNYXJrdXAgPSBmdW5jdGlvbihwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICB2YXIgbm9kZSA9IHRoaXMuZG9jLm5vZGVBdChwb3MpO1xuICBpZiAoIW5vZGUpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXCIpIH1cbiAgaWYgKCF0eXBlKSB7IHR5cGUgPSBub2RlLnR5cGU7IH1cbiAgdmFyIG5ld05vZGUgPSB0eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbWFya3MgfHwgbm9kZS5tYXJrcyk7XG4gIGlmIChub2RlLmlzTGVhZilcbiAgICB7IHJldHVybiB0aGlzLnJlcGxhY2VXaXRoKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgbmV3Tm9kZSkgfVxuXG4gIGlmICghdHlwZS52YWxpZENvbnRlbnQobm9kZS5jb250ZW50KSlcbiAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIHR5cGUgXCIgKyB0eXBlLm5hbWUpIH1cblxuICByZXR1cm4gdGhpcy5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHBvcyArIDEsIHBvcyArIG5vZGUubm9kZVNpemUgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShuZXdOb2RlKSwgMCwgMCksIDEsIHRydWUpKVxufTtcblxuLy8gOjogKE5vZGUsIG51bWJlciwgbnVtYmVyLCA/Wz97dHlwZTogTm9kZVR5cGUsIGF0dHJzOiA/T2JqZWN0fV0pIOKGkiBib29sXG4vLyBDaGVjayB3aGV0aGVyIHNwbGl0dGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgYWxsb3dlZC5cbmZ1bmN0aW9uIGNhblNwbGl0KGRvYywgcG9zLCBkZXB0aCwgdHlwZXNBZnRlcikge1xuICBpZiAoIGRlcHRoID09PSB2b2lkIDAgKSBkZXB0aCA9IDE7XG5cbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBiYXNlID0gJHBvcy5kZXB0aCAtIGRlcHRoO1xuICB2YXIgaW5uZXJUeXBlID0gKHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclt0eXBlc0FmdGVyLmxlbmd0aCAtIDFdKSB8fCAkcG9zLnBhcmVudDtcbiAgaWYgKGJhc2UgPCAwIHx8ICRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkgfHxcbiAgICAgICFpbm5lclR5cGUudHlwZS52YWxpZENvbnRlbnQoJHBvcy5wYXJlbnQuY29udGVudC5jdXRCeUluZGV4KCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkpKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGggLSAxLCBpID0gZGVwdGggLSAyOyBkID4gYmFzZTsgZC0tLCBpLS0pIHtcbiAgICB2YXIgbm9kZSA9ICRwb3Mubm9kZShkKSwgaW5kZXgkMSA9ICRwb3MuaW5kZXgoZCk7XG4gICAgaWYgKG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZykgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciByZXN0ID0gbm9kZS5jb250ZW50LmN1dEJ5SW5kZXgoaW5kZXgkMSwgbm9kZS5jaGlsZENvdW50KTtcbiAgICB2YXIgYWZ0ZXIgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldKSB8fCBub2RlO1xuICAgIGlmIChhZnRlciAhPSBub2RlKSB7IHJlc3QgPSByZXN0LnJlcGxhY2VDaGlsZCgwLCBhZnRlci50eXBlLmNyZWF0ZShhZnRlci5hdHRycykpOyB9XG4gICAgaWYgKCFub2RlLmNhblJlcGxhY2UoaW5kZXgkMSArIDEsIG5vZGUuY2hpbGRDb3VudCkgfHwgIWFmdGVyLnR5cGUudmFsaWRDb250ZW50KHJlc3QpKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICB9XG4gIHZhciBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihiYXNlKTtcbiAgdmFyIGJhc2VUeXBlID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyWzBdO1xuICByZXR1cm4gJHBvcy5ub2RlKGJhc2UpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgYmFzZVR5cGUgPyBiYXNlVHlwZS50eXBlIDogJHBvcy5ub2RlKGJhc2UgKyAxKS50eXBlKVxufVxuXG4vLyA6OiAobnVtYmVyLCA/bnVtYmVyLCA/Wz97dHlwZTogTm9kZVR5cGUsIGF0dHJzOiA/T2JqZWN0fV0pIOKGkiB0aGlzXG4vLyBTcGxpdCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFuZCBvcHRpb25hbGx5LCBpZiBgZGVwdGhgIGlzXG4vLyBncmVhdGVyIHRoYW4gb25lLCBhbnkgbnVtYmVyIG9mIG5vZGVzIGFib3ZlIHRoYXQuIEJ5IGRlZmF1bHQsIHRoZVxuLy8gcGFydHMgc3BsaXQgb2ZmIHdpbGwgaW5oZXJpdCB0aGUgbm9kZSB0eXBlIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuLy8gVGhpcyBjYW4gYmUgY2hhbmdlZCBieSBwYXNzaW5nIGFuIGFycmF5IG9mIHR5cGVzIGFuZCBhdHRyaWJ1dGVzIHRvXG4vLyB1c2UgYWZ0ZXIgdGhlIHNwbGl0LlxuVHJhbnNmb3JtLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKHBvcywgZGVwdGgsIHR5cGVzQWZ0ZXIpIHtcbiAgaWYgKCBkZXB0aCA9PT0gdm9pZCAwICkgZGVwdGggPSAxO1xuXG4gIHZhciAkcG9zID0gdGhpcy5kb2MucmVzb2x2ZShwb3MpLCBiZWZvcmUgPSBGcmFnbWVudC5lbXB0eSwgYWZ0ZXIgPSBGcmFnbWVudC5lbXB0eTtcbiAgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGgsIGUgPSAkcG9zLmRlcHRoIC0gZGVwdGgsIGkgPSBkZXB0aCAtIDE7IGQgPiBlOyBkLS0sIGktLSkge1xuICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJHBvcy5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgdmFyIHR5cGVBZnRlciA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpXTtcbiAgICBhZnRlciA9IEZyYWdtZW50LmZyb20odHlwZUFmdGVyID8gdHlwZUFmdGVyLnR5cGUuY3JlYXRlKHR5cGVBZnRlci5hdHRycywgYWZ0ZXIpIDogJHBvcy5ub2RlKGQpLmNvcHkoYWZ0ZXIpKTtcbiAgfVxuICByZXR1cm4gdGhpcy5zdGVwKG5ldyBSZXBsYWNlU3RlcChwb3MsIHBvcywgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBkZXB0aCwgZGVwdGgpLCB0cnVlKSlcbn07XG5cbi8vIDo6IChOb2RlLCBudW1iZXIpIOKGkiBib29sXG4vLyBUZXN0IHdoZXRoZXIgdGhlIGJsb2NrcyBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gcG9zaXRpb24gY2FuIGJlXG4vLyBqb2luZWQuXG5mdW5jdGlvbiBjYW5Kb2luKGRvYywgcG9zKSB7XG4gIHZhciAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gIHJldHVybiBqb2luYWJsZSgkcG9zLm5vZGVCZWZvcmUsICRwb3Mubm9kZUFmdGVyKSAmJlxuICAgICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSlcbn1cblxuZnVuY3Rpb24gam9pbmFibGUoYSwgYikge1xuICByZXR1cm4gYSAmJiBiICYmICFhLmlzTGVhZiAmJiBhLmNhbkFwcGVuZChiKVxufVxuXG4vLyA6OiAoTm9kZSwgbnVtYmVyLCA/bnVtYmVyKSDihpIgP251bWJlclxuLy8gRmluZCBhbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gdGhhdCBjYW4gYmUgam9pbmVkIHRvIHRoZVxuLy8gYmxvY2sgYmVmb3JlIChvciBhZnRlciBpZiBgZGlyYCBpcyBwb3NpdGl2ZSkuIFJldHVybnMgdGhlIGpvaW5hYmxlXG4vLyBwb2ludCwgaWYgYW55LlxuZnVuY3Rpb24gam9pblBvaW50KGRvYywgcG9zLCBkaXIpIHtcbiAgaWYgKCBkaXIgPT09IHZvaWQgMCApIGRpciA9IC0xO1xuXG4gIHZhciAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGg7OyBkLS0pIHtcbiAgICB2YXIgYmVmb3JlID0gKHZvaWQgMCksIGFmdGVyID0gKHZvaWQgMCksIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICBpZiAoZCA9PSAkcG9zLmRlcHRoKSB7XG4gICAgICBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmU7XG4gICAgICBhZnRlciA9ICRwb3Mubm9kZUFmdGVyO1xuICAgIH0gZWxzZSBpZiAoZGlyID4gMCkge1xuICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgIGluZGV4Kys7XG4gICAgICBhZnRlciA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXggLSAxKTtcbiAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICB9XG4gICAgaWYgKGJlZm9yZSAmJiAhYmVmb3JlLmlzVGV4dGJsb2NrICYmIGpvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpICYmXG4gICAgICAgICRwb3Mubm9kZShkKS5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpKSB7IHJldHVybiBwb3MgfVxuICAgIGlmIChkID09IDApIHsgYnJlYWsgfVxuICAgIHBvcyA9IGRpciA8IDAgPyAkcG9zLmJlZm9yZShkKSA6ICRwb3MuYWZ0ZXIoZCk7XG4gIH1cbn1cblxuLy8gOjogKG51bWJlciwgP251bWJlcikg4oaSIHRoaXNcbi8vIEpvaW4gdGhlIGJsb2NrcyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uLiBJZiBkZXB0aCBpcyAyLCB0aGVpclxuLy8gbGFzdCBhbmQgZmlyc3Qgc2libGluZ3MgYXJlIGFsc28gam9pbmVkLCBhbmQgc28gb24uXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbihwb3MsIGRlcHRoKSB7XG4gIGlmICggZGVwdGggPT09IHZvaWQgMCApIGRlcHRoID0gMTtcblxuICB2YXIgc3RlcCA9IG5ldyBSZXBsYWNlU3RlcChwb3MgLSBkZXB0aCwgcG9zICsgZGVwdGgsIFNsaWNlLmVtcHR5LCB0cnVlKTtcbiAgcmV0dXJuIHRoaXMuc3RlcChzdGVwKVxufTtcblxuLy8gOjogKE5vZGUsIG51bWJlciwgTm9kZVR5cGUpIOKGkiA/bnVtYmVyXG4vLyBUcnkgdG8gZmluZCBhIHBvaW50IHdoZXJlIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSBjYW4gYmUgaW5zZXJ0ZWRcbi8vIG5lYXIgYHBvc2AsIGJ5IHNlYXJjaGluZyB1cCB0aGUgbm9kZSBoaWVyYXJjaHkgd2hlbiBgcG9zYCBpdHNlbGZcbi8vIGlzbid0IGEgdmFsaWQgcGxhY2UgYnV0IGlzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBub2RlLiBSZXR1cm5cbi8vIG51bGwgaWYgbm8gcG9zaXRpb24gd2FzIGZvdW5kLlxuZnVuY3Rpb24gaW5zZXJ0UG9pbnQoZG9jLCBwb3MsIG5vZGVUeXBlKSB7XG4gIHZhciAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgaWYgKCRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKCRwb3MuaW5kZXgoKSwgJHBvcy5pbmRleCgpLCBub2RlVHlwZSkpIHsgcmV0dXJuIHBvcyB9XG5cbiAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09IDApXG4gICAgeyBmb3IgKHZhciBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICB2YXIgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSkgeyByZXR1cm4gJHBvcy5iZWZvcmUoZCArIDEpIH1cbiAgICAgIGlmIChpbmRleCA+IDApIHsgcmV0dXJuIG51bGwgfVxuICAgIH0gfVxuICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT0gJHBvcy5wYXJlbnQuY29udGVudC5zaXplKVxuICAgIHsgZm9yICh2YXIgZCQxID0gJHBvcy5kZXB0aCAtIDE7IGQkMSA+PSAwOyBkJDEtLSkge1xuICAgICAgdmFyIGluZGV4JDEgPSAkcG9zLmluZGV4QWZ0ZXIoZCQxKTtcbiAgICAgIGlmICgkcG9zLm5vZGUoZCQxKS5jYW5SZXBsYWNlV2l0aChpbmRleCQxLCBpbmRleCQxLCBub2RlVHlwZSkpIHsgcmV0dXJuICRwb3MuYWZ0ZXIoZCQxICsgMSkgfVxuICAgICAgaWYgKGluZGV4JDEgPCAkcG9zLm5vZGUoZCQxKS5jaGlsZENvdW50KSB7IHJldHVybiBudWxsIH1cbiAgICB9IH1cbn1cblxuLy8gOjogKE5vZGUsIG51bWJlciwgU2xpY2UpIOKGkiA/bnVtYmVyXG4vLyBGaW5kcyBhIHBvc2l0aW9uIGF0IG9yIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2hlcmUgdGhlIGdpdmVuXG4vLyBzbGljZSBjYW4gYmUgaW5zZXJ0ZWQuIFdpbGwgbG9vayBhdCBwYXJlbnQgbm9kZXMnIG5lYXJlc3QgYm91bmRhcnlcbi8vIGFuZCB0cnkgdGhlcmUsIGV2ZW4gaWYgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIHdhc24ndCBkaXJlY3RseSBhdCB0aGVcbi8vIHN0YXJ0IG9yIGVuZCBvZiB0aGF0IG5vZGUuIFJldHVybnMgbnVsbCB3aGVuIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbmZ1bmN0aW9uIGRyb3BQb2ludChkb2MsIHBvcywgc2xpY2UpIHtcbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSkgeyByZXR1cm4gcG9zIH1cbiAgdmFyIGNvbnRlbnQgPSBzbGljZS5jb250ZW50O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlLm9wZW5TdGFydDsgaSsrKSB7IGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDsgfVxuICBmb3IgKHZhciBwYXNzID0gMTsgcGFzcyA8PSAoc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uuc2l6ZSA/IDIgOiAxKTsgcGFzcysrKSB7XG4gICAgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICB2YXIgYmlhcyA9IGQgPT0gJHBvcy5kZXB0aCA/IDAgOiAkcG9zLnBvcyA8PSAoJHBvcy5zdGFydChkICsgMSkgKyAkcG9zLmVuZChkICsgMSkpIC8gMiA/IC0xIDogMTtcbiAgICAgIHZhciBpbnNlcnRQb3MgPSAkcG9zLmluZGV4KGQpICsgKGJpYXMgPiAwID8gMSA6IDApO1xuICAgICAgdmFyIHBhcmVudCA9ICRwb3Mubm9kZShkKSwgZml0cyA9IGZhbHNlO1xuICAgICAgaWYgKHBhc3MgPT0gMSkge1xuICAgICAgICBmaXRzID0gcGFyZW50LmNhblJlcGxhY2UoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHdyYXBwaW5nID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KGluc2VydFBvcykuZmluZFdyYXBwaW5nKGNvbnRlbnQuZmlyc3RDaGlsZC50eXBlKTtcbiAgICAgICAgZml0cyA9IHdyYXBwaW5nICYmIHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbnNlcnRQb3MsIGluc2VydFBvcywgd3JhcHBpbmdbMF0pO1xuICAgICAgfVxuICAgICAgaWYgKGZpdHMpXG4gICAgICAgIHsgcmV0dXJuIGJpYXMgPT0gMCA/ICRwb3MucG9zIDogYmlhcyA8IDAgPyAkcG9zLmJlZm9yZShkICsgMSkgOiAkcG9zLmFmdGVyKGQgKyAxKSB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG1hcEZyYWdtZW50KGZyYWdtZW50LCBmLCBwYXJlbnQpIHtcbiAgdmFyIG1hcHBlZCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYWdtZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGZyYWdtZW50LmNoaWxkKGkpO1xuICAgIGlmIChjaGlsZC5jb250ZW50LnNpemUpIHsgY2hpbGQgPSBjaGlsZC5jb3B5KG1hcEZyYWdtZW50KGNoaWxkLmNvbnRlbnQsIGYsIGNoaWxkKSk7IH1cbiAgICBpZiAoY2hpbGQuaXNJbmxpbmUpIHsgY2hpbGQgPSBmKGNoaWxkLCBwYXJlbnQsIGkpOyB9XG4gICAgbWFwcGVkLnB1c2goY2hpbGQpO1xuICB9XG4gIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkobWFwcGVkKVxufVxuXG4vLyA6Oi0gQWRkIGEgbWFyayB0byBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxudmFyIEFkZE1hcmtTdGVwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU3RlcCkge1xuICBmdW5jdGlvbiBBZGRNYXJrU3RlcChmcm9tLCB0bywgbWFyaykge1xuICAgIFN0ZXAuY2FsbCh0aGlzKTtcbiAgICAvLyA6OiBudW1iZXJcbiAgICAvLyBUaGUgc3RhcnQgb2YgdGhlIG1hcmtlZCByYW5nZS5cbiAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIC8vIDo6IG51bWJlclxuICAgIC8vIFRoZSBlbmQgb2YgdGhlIG1hcmtlZCByYW5nZS5cbiAgICB0aGlzLnRvID0gdG87XG4gICAgLy8gOjogTWFya1xuICAgIC8vIFRoZSBtYXJrIHRvIGFkZC5cbiAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICB9XG5cbiAgaWYgKCBTdGVwICkgQWRkTWFya1N0ZXAuX19wcm90b19fID0gU3RlcDtcbiAgQWRkTWFya1N0ZXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU3RlcCAmJiBTdGVwLnByb3RvdHlwZSApO1xuICBBZGRNYXJrU3RlcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBZGRNYXJrU3RlcDtcblxuICBBZGRNYXJrU3RlcC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseSAoZG9jKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSwgJGZyb20gPSBkb2MucmVzb2x2ZSh0aGlzLmZyb20pO1xuICAgIHZhciBwYXJlbnQgPSAkZnJvbS5ub2RlKCRmcm9tLnNoYXJlZERlcHRoKHRoaXMudG8pKTtcbiAgICB2YXIgc2xpY2UgPSBuZXcgU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgICAgaWYgKCFub2RlLmlzQXRvbSB8fCAhcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUodGhpcyQxLm1hcmsudHlwZSkpIHsgcmV0dXJuIG5vZGUgfVxuICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzJDEubWFyay5hZGRUb1NldChub2RlLm1hcmtzKSlcbiAgICB9LCBwYXJlbnQpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSlcbiAgfTtcblxuICBBZGRNYXJrU3RlcC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0ICgpIHtcbiAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5tYXJrKVxuICB9O1xuXG4gIEFkZE1hcmtTdGVwLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBpbmcpIHtcbiAgICB2YXIgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpIHsgcmV0dXJuIG51bGwgfVxuICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKVxuICB9O1xuXG4gIEFkZE1hcmtTdGVwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlIChvdGhlcikge1xuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEFkZE1hcmtTdGVwICYmXG4gICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgeyByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKE1hdGgubWluKHRoaXMuZnJvbSwgb3RoZXIuZnJvbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHRoaXMudG8sIG90aGVyLnRvKSwgdGhpcy5tYXJrKSB9XG4gIH07XG5cbiAgQWRkTWFya1N0ZXAucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHtzdGVwVHlwZTogXCJhZGRNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG99XG4gIH07XG5cbiAgQWRkTWFya1N0ZXAuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTiAoc2NoZW1hLCBqc29uKSB7XG4gICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEFkZE1hcmtTdGVwLmZyb21KU09OXCIpIH1cbiAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKGpzb24uZnJvbSwganNvbi50bywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKVxuICB9O1xuXG4gIHJldHVybiBBZGRNYXJrU3RlcDtcbn0oU3RlcCkpO1xuXG5TdGVwLmpzb25JRChcImFkZE1hcmtcIiwgQWRkTWFya1N0ZXApO1xuXG4vLyA6Oi0gUmVtb3ZlIGEgbWFyayBmcm9tIGFsbCBpbmxpbmUgY29udGVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMuXG52YXIgUmVtb3ZlTWFya1N0ZXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTdGVwKSB7XG4gIGZ1bmN0aW9uIFJlbW92ZU1hcmtTdGVwKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgU3RlcC5jYWxsKHRoaXMpO1xuICAgIC8vIDo6IG51bWJlclxuICAgIC8vIFRoZSBzdGFydCBvZiB0aGUgdW5tYXJrZWQgcmFuZ2UuXG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAvLyA6OiBudW1iZXJcbiAgICAvLyBUaGUgZW5kIG9mIHRoZSB1bm1hcmtlZCByYW5nZS5cbiAgICB0aGlzLnRvID0gdG87XG4gICAgLy8gOjogTWFya1xuICAgIC8vIFRoZSBtYXJrIHRvIHJlbW92ZS5cbiAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICB9XG5cbiAgaWYgKCBTdGVwICkgUmVtb3ZlTWFya1N0ZXAuX19wcm90b19fID0gU3RlcDtcbiAgUmVtb3ZlTWFya1N0ZXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU3RlcCAmJiBTdGVwLnByb3RvdHlwZSApO1xuICBSZW1vdmVNYXJrU3RlcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZW1vdmVNYXJrU3RlcDtcblxuICBSZW1vdmVNYXJrU3RlcC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseSAoZG9jKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB2YXIgc2xpY2UgPSBuZXcgU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLm1hcmsodGhpcyQxLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSlcbiAgICB9KSwgb2xkU2xpY2Uub3BlblN0YXJ0LCBvbGRTbGljZS5vcGVuRW5kKTtcbiAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpXG4gIH07XG5cbiAgUmVtb3ZlTWFya1N0ZXAucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uIGludmVydCAoKSB7XG4gICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyaylcbiAgfTtcblxuICBSZW1vdmVNYXJrU3RlcC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nKSB7XG4gICAgdmFyIGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKSB7IHJldHVybiBudWxsIH1cbiAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKGZyb20ucG9zLCB0by5wb3MsIHRoaXMubWFyaylcbiAgfTtcblxuICBSZW1vdmVNYXJrU3RlcC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSAob3RoZXIpIHtcbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBSZW1vdmVNYXJrU3RlcCAmJlxuICAgICAgICBvdGhlci5tYXJrLmVxKHRoaXMubWFyaykgJiZcbiAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgIHsgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyaykgfVxuICB9O1xuXG4gIFJlbW92ZU1hcmtTdGVwLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB7c3RlcFR5cGU6IFwicmVtb3ZlTWFya1wiLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCksXG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvfVxuICB9O1xuXG4gIFJlbW92ZU1hcmtTdGVwLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04gKHNjaGVtYSwganNvbikge1xuICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVNYXJrU3RlcC5mcm9tSlNPTlwiKSB9XG4gICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSlcbiAgfTtcblxuICByZXR1cm4gUmVtb3ZlTWFya1N0ZXA7XG59KFN0ZXApKTtcblxuU3RlcC5qc29uSUQoXCJyZW1vdmVNYXJrXCIsIFJlbW92ZU1hcmtTdGVwKTtcblxuLy8gOjogKG51bWJlciwgbnVtYmVyLCBNYXJrKSDihpIgdGhpc1xuLy8gQWRkIHRoZSBnaXZlbiBtYXJrIHRvIHRoZSBpbmxpbmUgY29udGVudCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cblRyYW5zZm9ybS5wcm90b3R5cGUuYWRkTWFyayA9IGZ1bmN0aW9uKGZyb20sIHRvLCBtYXJrKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciByZW1vdmVkID0gW10sIGFkZGVkID0gW10sIHJlbW92aW5nID0gbnVsbCwgYWRkaW5nID0gbnVsbDtcbiAgdGhpcy5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zLCBwYXJlbnQpIHtcbiAgICBpZiAoIW5vZGUuaXNJbmxpbmUpIHsgcmV0dXJuIH1cbiAgICB2YXIgbWFya3MgPSBub2RlLm1hcmtzO1xuICAgIGlmICghbWFyay5pc0luU2V0KG1hcmtzKSAmJiBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpKSB7XG4gICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICB2YXIgbmV3U2V0ID0gbWFyay5hZGRUb1NldChtYXJrcyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFtYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpIHtcbiAgICAgICAgICBpZiAocmVtb3ZpbmcgJiYgcmVtb3ZpbmcudG8gPT0gc3RhcnQgJiYgcmVtb3ZpbmcubWFyay5lcShtYXJrc1tpXSkpXG4gICAgICAgICAgICB7IHJlbW92aW5nLnRvID0gZW5kOyB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgeyByZW1vdmVkLnB1c2gocmVtb3ZpbmcgPSBuZXcgUmVtb3ZlTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFya3NbaV0pKTsgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRpbmcgJiYgYWRkaW5nLnRvID09IHN0YXJ0KVxuICAgICAgICB7IGFkZGluZy50byA9IGVuZDsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IGFkZGVkLnB1c2goYWRkaW5nID0gbmV3IEFkZE1hcmtTdGVwKHN0YXJ0LCBlbmQsIG1hcmspKTsgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiB0aGlzJDEuc3RlcChzKTsgfSk7XG4gIGFkZGVkLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHRoaXMkMS5zdGVwKHMpOyB9KTtcbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlciwgP3VuaW9uPE1hcmssIE1hcmtUeXBlPikg4oaSIHRoaXNcbi8vIFJlbW92ZSBtYXJrcyBmcm9tIGlubGluZSBub2RlcyBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC4gV2hlbiBgbWFya2Bcbi8vIGlzIGEgc2luZ2xlIG1hcmssIHJlbW92ZSBwcmVjaXNlbHkgdGhhdCBtYXJrLiBXaGVuIGl0IGlzIGEgbWFyayB0eXBlLFxuLy8gcmVtb3ZlIGFsbCBtYXJrcyBvZiB0aGF0IHR5cGUuIFdoZW4gaXQgaXMgbnVsbCwgcmVtb3ZlIGFsbCBtYXJrcyBvZlxuLy8gYW55IHR5cGUuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnJlbW92ZU1hcmsgPSBmdW5jdGlvbihmcm9tLCB0bywgbWFyaykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcbiAgaWYgKCBtYXJrID09PSB2b2lkIDAgKSBtYXJrID0gbnVsbDtcblxuICB2YXIgbWF0Y2hlZCA9IFtdLCBzdGVwID0gMDtcbiAgdGhpcy5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgaWYgKCFub2RlLmlzSW5saW5lKSB7IHJldHVybiB9XG4gICAgc3RlcCsrO1xuICAgIHZhciB0b1JlbW92ZSA9IG51bGw7XG4gICAgaWYgKG1hcmsgaW5zdGFuY2VvZiBNYXJrVHlwZSkge1xuICAgICAgdmFyIHNldCA9IG5vZGUubWFya3MsIGZvdW5kO1xuICAgICAgd2hpbGUgKGZvdW5kID0gbWFyay5pc0luU2V0KHNldCkpIHtcbih0b1JlbW92ZSB8fCAodG9SZW1vdmUgPSBbXSkpLnB1c2goZm91bmQpO1xuICAgICAgICBzZXQgPSBmb3VuZC5yZW1vdmVGcm9tU2V0KHNldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtYXJrKSB7XG4gICAgICBpZiAobWFyay5pc0luU2V0KG5vZGUubWFya3MpKSB7IHRvUmVtb3ZlID0gW21hcmtdOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvUmVtb3ZlID0gbm9kZS5tYXJrcztcbiAgICB9XG4gICAgaWYgKHRvUmVtb3ZlICYmIHRvUmVtb3ZlLmxlbmd0aCkge1xuICAgICAgdmFyIGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdG9SZW1vdmVbaV0sIGZvdW5kJDEgPSAodm9pZCAwKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIG0gPSBtYXRjaGVkW2pdO1xuICAgICAgICAgIGlmIChtLnN0ZXAgPT0gc3RlcCAtIDEgJiYgc3R5bGUuZXEobWF0Y2hlZFtqXS5zdHlsZSkpIHsgZm91bmQkMSA9IG07IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmQkMSkge1xuICAgICAgICAgIGZvdW5kJDEudG8gPSBlbmQ7XG4gICAgICAgICAgZm91bmQkMS5zdGVwID0gc3RlcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaGVkLnB1c2goe3N0eWxlOiBzdHlsZSwgZnJvbTogTWF0aC5tYXgocG9zLCBmcm9tKSwgdG86IGVuZCwgc3RlcDogc3RlcH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgbWF0Y2hlZC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldHVybiB0aGlzJDEuc3RlcChuZXcgUmVtb3ZlTWFya1N0ZXAobS5mcm9tLCBtLnRvLCBtLnN0eWxlKSk7IH0pO1xuICByZXR1cm4gdGhpc1xufTtcblxuLy8gOjogKG51bWJlciwgTm9kZVR5cGUsID9Db250ZW50TWF0Y2gpIOKGkiB0aGlzXG4vLyBSZW1vdmVzIGFsbCBtYXJrcyBhbmQgbm9kZXMgZnJvbSB0aGUgY29udGVudCBvZiB0aGUgbm9kZSBhdCBgcG9zYFxuLy8gdGhhdCBkb24ndCBtYXRjaCB0aGUgZ2l2ZW4gbmV3IHBhcmVudCBub2RlIHR5cGUuIEFjY2VwdHMgYW5cbi8vIG9wdGlvbmFsIHN0YXJ0aW5nIFtjb250ZW50IG1hdGNoXSgjbW9kZWwuQ29udGVudE1hdGNoKSBhcyB0aGlyZFxuLy8gYXJndW1lbnQuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmNsZWFySW5jb21wYXRpYmxlID0gZnVuY3Rpb24ocG9zLCBwYXJlbnRUeXBlLCBtYXRjaCkge1xuICBpZiAoIG1hdGNoID09PSB2b2lkIDAgKSBtYXRjaCA9IHBhcmVudFR5cGUuY29udGVudE1hdGNoO1xuXG4gIHZhciBub2RlID0gdGhpcy5kb2Mubm9kZUF0KHBvcyk7XG4gIHZhciBkZWxTdGVwcyA9IFtdLCBjdXIgPSBwb3MgKyAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZChpKSwgZW5kID0gY3VyICsgY2hpbGQubm9kZVNpemU7XG4gICAgdmFyIGFsbG93ZWQgPSBtYXRjaC5tYXRjaFR5cGUoY2hpbGQudHlwZSwgY2hpbGQuYXR0cnMpO1xuICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgZGVsU3RlcHMucHVzaChuZXcgUmVwbGFjZVN0ZXAoY3VyLCBlbmQsIFNsaWNlLmVtcHR5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gYWxsb3dlZDtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGQubWFya3MubGVuZ3RoOyBqKyspIHsgaWYgKCFwYXJlbnRUeXBlLmFsbG93c01hcmtUeXBlKGNoaWxkLm1hcmtzW2pdLnR5cGUpKVxuICAgICAgICB7IHRoaXMuc3RlcChuZXcgUmVtb3ZlTWFya1N0ZXAoY3VyLCBlbmQsIGNoaWxkLm1hcmtzW2pdKSk7IH0gfVxuICAgIH1cbiAgICBjdXIgPSBlbmQ7XG4gIH1cbiAgaWYgKCFtYXRjaC52YWxpZEVuZCkge1xuICAgIHZhciBmaWxsID0gbWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgdGhpcy5yZXBsYWNlKGN1ciwgY3VyLCBuZXcgU2xpY2UoZmlsbCwgMCwgMCkpO1xuICB9XG4gIGZvciAodmFyIGkkMSA9IGRlbFN0ZXBzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkgeyB0aGlzLnN0ZXAoZGVsU3RlcHNbaSQxXSk7IH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIDo6IChOb2RlLCBudW1iZXIsID9udW1iZXIsID9TbGljZSkg4oaSID9TdGVwXG4vLyDigJhGaXTigJkgYSBzbGljZSBpbnRvIGEgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LCBwcm9kdWNpbmcgYVxuLy8gW3N0ZXBdKCN0cmFuc2Zvcm0uU3RlcCkgdGhhdCBpbnNlcnRzIGl0LiBXaWxsIHJldHVybiBudWxsIGlmXG4vLyB0aGVyZSdzIG5vIG1lYW5pbmdmdWwgd2F5IHRvIGluc2VydCB0aGUgc2xpY2UgaGVyZSwgb3IgaW5zZXJ0aW5nIGl0XG4vLyB3b3VsZCBiZSBhIG5vLW9wIChhbiBlbXB0eSBzbGljZSBvdmVyIGFuIGVtcHR5IHJhbmdlKS5cbmZ1bmN0aW9uIHJlcGxhY2VTdGVwKGRvYywgZnJvbSwgdG8sIHNsaWNlKSB7XG4gIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gZnJvbTtcbiAgaWYgKCBzbGljZSA9PT0gdm9pZCAwICkgc2xpY2UgPSBTbGljZS5lbXB0eTtcblxuICBpZiAoZnJvbSA9PSB0byAmJiAhc2xpY2Uuc2l6ZSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgdmFyICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksICR0byA9IGRvYy5yZXNvbHZlKHRvKTtcbiAgLy8gT3B0aW1pemF0aW9uIC0tIGF2b2lkIHdvcmsgaWYgaXQncyBvYnZpb3VzIHRoYXQgaXQncyBub3QgbmVlZGVkLlxuICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpIHsgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UpIH1cbiAgcmV0dXJuIG5ldyBGaXR0ZXIoJGZyb20sICR0bywgc2xpY2UpLmZpdCgpXG59XG5cbi8vIDo6IChudW1iZXIsID9udW1iZXIsID9TbGljZSkg4oaSIHRoaXNcbi8vIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHdpdGggdGhlXG4vLyBnaXZlbiBgc2xpY2VgLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oZnJvbSwgdG8sIHNsaWNlKSB7XG4gIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gZnJvbTtcbiAgaWYgKCBzbGljZSA9PT0gdm9pZCAwICkgc2xpY2UgPSBTbGljZS5lbXB0eTtcblxuICB2YXIgc3RlcCA9IHJlcGxhY2VTdGVwKHRoaXMuZG9jLCBmcm9tLCB0bywgc2xpY2UpO1xuICBpZiAoc3RlcCkgeyB0aGlzLnN0ZXAoc3RlcCk7IH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlciwgdW5pb248RnJhZ21lbnQsIE5vZGUsIFtOb2RlXT4pIOKGkiB0aGlzXG4vLyBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50LCB3aGljaCBtYXkgYmUgYVxuLy8gZnJhZ21lbnQsIG5vZGUsIG9yIGFycmF5IG9mIG5vZGVzLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5yZXBsYWNlV2l0aCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBjb250ZW50KSB7XG4gIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCAwLCAwKSlcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlcikg4oaSIHRoaXNcbi8vIERlbGV0ZSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIFNsaWNlLmVtcHR5KVxufTtcblxuLy8gOjogKG51bWJlciwgdW5pb248RnJhZ21lbnQsIE5vZGUsIFtOb2RlXT4pIOKGkiB0aGlzXG4vLyBJbnNlcnQgdGhlIGdpdmVuIGNvbnRlbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihwb3MsIGNvbnRlbnQpIHtcbiAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgocG9zLCBwb3MsIGNvbnRlbnQpXG59O1xuXG5mdW5jdGlvbiBmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gIHJldHVybiAhc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLnN0YXJ0KCkgPT0gJHRvLnN0YXJ0KCkgJiZcbiAgICAkZnJvbS5wYXJlbnQuY2FuUmVwbGFjZSgkZnJvbS5pbmRleCgpLCAkdG8uaW5kZXgoKSwgc2xpY2UuY29udGVudClcbn1cblxuLy8gQWxnb3JpdGhtIGZvciAncGxhY2luZycgdGhlIGVsZW1lbnRzIG9mIGEgc2xpY2UgaW50byBhIGdhcDpcbi8vXG4vLyBXZSBjb25zaWRlciB0aGUgY29udGVudCBvZiBlYWNoIG5vZGUgdGhhdCBpcyBvcGVuIHRvIHRoZSBsZWZ0IHRvIGJlXG4vLyBpbmRlcGVuZGVudGx5IHBsYWNlYWJsZS4gSS5lLiBpbiA8cChcImZvb1wiKSwgcChcImJhclwiKT4sIHdoZW4gdGhlXG4vLyBwYXJhZ3JhcGggb24gdGhlIGxlZnQgaXMgb3BlbiwgXCJmb29cIiBjYW4gYmUgcGxhY2VkIChzb21ld2hlcmUgb25cbi8vIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHJlcGxhY2VtZW50IGdhcCkgaW5kZXBlbmRlbnRseSBmcm9tIHAoXCJiYXJcIikuXG4vL1xuLy8gVGhpcyBjbGFzcyB0cmFja3MgdGhlIHN0YXRlIG9mIHRoZSBwbGFjZW1lbnQgcHJvZ3Jlc3MgaW4gdGhlXG4vLyBmb2xsb3dpbmcgcHJvcGVydGllczpcbi8vXG4vLyAgLSBgZnJvbnRpZXJgIGhvbGRzIGEgc3RhY2sgb2YgYHt0eXBlLCBtYXRjaH1gIG9iamVjdHMgdGhhdFxuLy8gICAgcmVwcmVzZW50IHRoZSBvcGVuIHNpZGUgb2YgdGhlIHJlcGxhY2VtZW50LiBJdCBzdGFydHMgYXRcbi8vICAgIGAkZnJvbWAsIHRoZW4gbW92ZXMgZm9yd2FyZCBhcyBjb250ZW50IGlzIHBsYWNlZCwgYW5kIGlzIGZpbmFsbHlcbi8vICAgIHJlY29uY2lsZWQgd2l0aCBgJHRvYC5cbi8vXG4vLyAgLSBgdW5wbGFjZWRgIGlzIGEgc2xpY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50IHRoYXQgaGFzbid0XG4vLyAgICBiZWVuIHBsYWNlZCB5ZXQuXG4vL1xuLy8gIC0gYHBsYWNlZGAgaXMgYSBmcmFnbWVudCBvZiBwbGFjZWQgY29udGVudC4gSXRzIG9wZW4tc3RhcnQgdmFsdWVcbi8vICAgIGlzIGltcGxpY2l0IGluIGAkZnJvbWAsIGFuZCBpdHMgb3Blbi1lbmQgdmFsdWUgaW4gYGZyb250aWVyYC5cbnZhciBGaXR0ZXIgPSBmdW5jdGlvbiBGaXR0ZXIoJGZyb20sICR0bywgc2xpY2UpIHtcbiAgdGhpcy4kdG8gPSAkdG87XG4gIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgdGhpcy51bnBsYWNlZCA9IHNsaWNlO1xuXG4gIHRoaXMuZnJvbnRpZXIgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gJGZyb20uZGVwdGg7IGkrKykge1xuICAgIHZhciBub2RlID0gJGZyb20ubm9kZShpKTtcbiAgICB0aGlzLmZyb250aWVyLnB1c2goe1xuICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcihpKSlcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZW1wdHk7XG4gIGZvciAodmFyIGkkMSA9ICRmcm9tLmRlcHRoOyBpJDEgPiAwOyBpJDEtLSlcbiAgICB7IHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGkkMSkuY29weSh0aGlzLnBsYWNlZCkpOyB9XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEgPSB7IGRlcHRoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLmRlcHRoLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZnJvbnRpZXIubGVuZ3RoIC0gMSB9O1xuXG5GaXR0ZXIucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uIGZpdCAoKSB7XG4gIC8vIEFzIGxvbmcgYXMgdGhlcmUncyB1bnBsYWNlZCBjb250ZW50LCB0cnkgdG8gcGxhY2Ugc29tZSBvZiBpdC5cbiAgLy8gSWYgdGhhdCBmYWlscywgZWl0aGVyIGluY3JlYXNlIHRoZSBvcGVuIHNjb3JlIG9mIHRoZSB1bnBsYWNlZFxuICAvLyBzbGljZSwgb3IgZHJvcCBub2RlcyBmcm9tIGl0LCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gIHdoaWxlICh0aGlzLnVucGxhY2VkLnNpemUpIHtcbiAgICB2YXIgZml0ID0gdGhpcy5maW5kRml0dGFibGUoKTtcbiAgICBpZiAoZml0KSB7IHRoaXMucGxhY2VOb2RlcyhmaXQpOyB9XG4gICAgZWxzZSB7IHRoaXMub3Blbk1vcmUoKSB8fCB0aGlzLmRyb3BOb2RlKCk7IH1cbiAgfVxuICAvLyBXaGVuIHRoZXJlJ3MgaW5saW5lIGNvbnRlbnQgZGlyZWN0bHkgYWZ0ZXIgdGhlIGZyb250aWVyIF9hbmRfXG4gIC8vIGRpcmVjdGx5IGFmdGVyIGB0aGlzLiR0b2AsIHdlIG11c3QgZ2VuZXJhdGUgYSBgUmVwbGFjZUFyb3VuZGBcbiAgLy8gc3RlcCB0aGF0IHB1bGxzIHRoYXQgY29udGVudCBpbnRvIHRoZSBub2RlIGFmdGVyIHRoZSBmcm9udGllci5cbiAgLy8gVGhhdCBtZWFucyB0aGUgZml0dGluZyBtdXN0IGJlIGRvbmUgdG8gdGhlIGVuZCBvZiB0aGUgdGV4dGJsb2NrXG4gIC8vIG5vZGUgYWZ0ZXIgYHRoaXMuJHRvYCwgbm90IGB0aGlzLiR0b2AgaXRzZWxmLlxuICB2YXIgbW92ZUlubGluZSA9IHRoaXMubXVzdE1vdmVJbmxpbmUoKSwgcGxhY2VkU2l6ZSA9IHRoaXMucGxhY2VkLnNpemUgLSB0aGlzLmRlcHRoIC0gdGhpcy4kZnJvbS5kZXB0aDtcbiAgdmFyICRmcm9tID0gdGhpcy4kZnJvbSwgJHRvID0gdGhpcy5jbG9zZShtb3ZlSW5saW5lIDwgMCA/IHRoaXMuJHRvIDogJGZyb20uZG9jLnJlc29sdmUobW92ZUlubGluZSkpO1xuICBpZiAoISR0bykgeyByZXR1cm4gbnVsbCB9XG5cbiAgLy8gSWYgY2xvc2luZyB0byBgJHRvYCBzdWNjZWVkZWQsIGNyZWF0ZSBhIHN0ZXBcbiAgdmFyIGNvbnRlbnQgPSB0aGlzLnBsYWNlZCwgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGgsIG9wZW5FbmQgPSAkdG8uZGVwdGg7XG4gIHdoaWxlIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSkgeyAvLyBOb3JtYWxpemUgYnkgZHJvcHBpbmcgb3BlbiBwYXJlbnQgbm9kZXNcbiAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgb3BlblN0YXJ0LS07IG9wZW5FbmQtLTtcbiAgfVxuICB2YXIgc2xpY2UgPSBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgaWYgKG1vdmVJbmxpbmUgPiAtMSlcbiAgICB7IHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGZyb20ucG9zLCBtb3ZlSW5saW5lLCB0aGlzLiR0by5wb3MsIHRoaXMuJHRvLmVuZCgpLCBzbGljZSwgcGxhY2VkU2l6ZSkgfVxuICBpZiAoc2xpY2Uuc2l6ZSB8fCAkZnJvbS5wb3MgIT0gdGhpcy4kdG8ucG9zKSAvLyBEb24ndCBnZW5lcmF0ZSBuby1vcCBzdGVwc1xuICAgIHsgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCgkZnJvbS5wb3MsICR0by5wb3MsIHNsaWNlKSB9XG59O1xuXG4vLyBGaW5kIGEgcG9zaXRpb24gb24gdGhlIHN0YXJ0IHNwaW5lIG9mIGB0aGlzLnVucGxhY2VkYCB0aGF0IGhhc1xuLy8gY29udGVudCB0aGF0IGNhbiBiZSBtb3ZlZCBzb21ld2hlcmUgb24gdGhlIGZyb250aWVyLiBSZXR1cm5zIHR3b1xuLy8gZGVwdGhzLCBvbmUgZm9yIHRoZSBzbGljZSBhbmQgb25lIGZvciB0aGUgZnJvbnRpZXIuXG5GaXR0ZXIucHJvdG90eXBlLmZpbmRGaXR0YWJsZSA9IGZ1bmN0aW9uIGZpbmRGaXR0YWJsZSAoKSB7XG4gIC8vIE9ubHkgdHJ5IHdyYXBwaW5nIG5vZGVzIChwYXNzIDIpIGFmdGVyIGZpbmRpbmcgYSBwbGFjZSB3aXRob3V0XG4gIC8vIHdyYXBwaW5nIGZhaWxlZC5cbiAgZm9yICh2YXIgcGFzcyA9IDE7IHBhc3MgPD0gMjsgcGFzcysrKSB7XG4gICAgZm9yICh2YXIgc2xpY2VEZXB0aCA9IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0OyBzbGljZURlcHRoID49IDA7IHNsaWNlRGVwdGgtLSkge1xuICAgICAgdmFyIGZyYWdtZW50ID0gKHZvaWQgMCksIHBhcmVudCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHNsaWNlRGVwdGgpIHtcbiAgICAgICAgcGFyZW50ID0gY29udGVudEF0KHRoaXMudW5wbGFjZWQuY29udGVudCwgc2xpY2VEZXB0aCAtIDEpLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZyYWdtZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudCA9IHRoaXMudW5wbGFjZWQuY29udGVudDtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICBmb3IgKHZhciBmcm9udGllckRlcHRoID0gdGhpcy5kZXB0aDsgZnJvbnRpZXJEZXB0aCA+PSAwOyBmcm9udGllckRlcHRoLS0pIHtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF07XG4gICAgICAgICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSByZWYubWF0Y2g7XG4gICAgICAgICAgdmFyIHdyYXAgPSAodm9pZCAwKSwgaW5qZWN0ID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIEluIHBhc3MgMSwgaWYgdGhlIG5leHQgbm9kZSBtYXRjaGVzLCBvciB0aGVyZSBpcyBubyBuZXh0XG4gICAgICAgIC8vIG5vZGUgYnV0IHRoZSBwYXJlbnRzIGxvb2sgY29tcGF0aWJsZSwgd2UndmUgZm91bmQgYVxuICAgICAgICAvLyBwbGFjZS5cbiAgICAgICAgaWYgKHBhc3MgPT0gMSAmJiAoZmlyc3QgPyBtYXRjaC5tYXRjaFR5cGUoZmlyc3QudHlwZSkgfHwgKGluamVjdCA9IG1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShmaXJzdCksIGZhbHNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlLmNvbXBhdGlibGVDb250ZW50KHBhcmVudC50eXBlKSkpXG4gICAgICAgICAgeyByZXR1cm4ge3NsaWNlRGVwdGg6IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGg6IGZyb250aWVyRGVwdGgsIHBhcmVudDogcGFyZW50LCBpbmplY3Q6IGluamVjdH0gfVxuICAgICAgICAvLyBJbiBwYXNzIDIsIGxvb2sgZm9yIGEgc2V0IG9mIHdyYXBwaW5nIG5vZGVzIHRoYXQgbWFrZVxuICAgICAgICAvLyBgZmlyc3RgIGZpdCBoZXJlLlxuICAgICAgICBlbHNlIGlmIChwYXNzID09IDIgJiYgZmlyc3QgJiYgKHdyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcoZmlyc3QudHlwZSkpKVxuICAgICAgICAgIHsgcmV0dXJuIHtzbGljZURlcHRoOiBzbGljZURlcHRoLCBmcm9udGllckRlcHRoOiBmcm9udGllckRlcHRoLCBwYXJlbnQ6IHBhcmVudCwgd3JhcDogd3JhcH0gfVxuICAgICAgICAvLyBEb24ndCBjb250aW51ZSBsb29raW5nIGZ1cnRoZXIgdXAgaWYgdGhlIHBhcmVudCBub2RlXG4gICAgICAgIC8vIHdvdWxkIGZpdCBoZXJlLlxuICAgICAgICBpZiAocGFyZW50ICYmIG1hdGNoLm1hdGNoVHlwZShwYXJlbnQudHlwZSkpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuRml0dGVyLnByb3RvdHlwZS5vcGVuTW9yZSA9IGZ1bmN0aW9uIG9wZW5Nb3JlICgpIHtcbiAgdmFyIHJlZiA9IHRoaXMudW5wbGFjZWQ7XG4gICAgdmFyIGNvbnRlbnQgPSByZWYuY29udGVudDtcbiAgICB2YXIgb3BlblN0YXJ0ID0gcmVmLm9wZW5TdGFydDtcbiAgICB2YXIgb3BlbkVuZCA9IHJlZi5vcGVuRW5kO1xuICB2YXIgaW5uZXIgPSBjb250ZW50QXQoY29udGVudCwgb3BlblN0YXJ0KTtcbiAgaWYgKCFpbm5lci5jaGlsZENvdW50IHx8IGlubmVyLmZpcnN0Q2hpbGQuaXNMZWFmKSB7IHJldHVybiBmYWxzZSB9XG4gIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChvcGVuRW5kLCBpbm5lci5zaXplICsgb3BlblN0YXJ0ID49IGNvbnRlbnQuc2l6ZSAtIG9wZW5FbmQgPyBvcGVuU3RhcnQgKyAxIDogMCkpO1xuICByZXR1cm4gdHJ1ZVxufTtcblxuRml0dGVyLnByb3RvdHlwZS5kcm9wTm9kZSA9IGZ1bmN0aW9uIGRyb3BOb2RlICgpIHtcbiAgdmFyIHJlZiA9IHRoaXMudW5wbGFjZWQ7XG4gICAgdmFyIGNvbnRlbnQgPSByZWYuY29udGVudDtcbiAgICB2YXIgb3BlblN0YXJ0ID0gcmVmLm9wZW5TdGFydDtcbiAgICB2YXIgb3BlbkVuZCA9IHJlZi5vcGVuRW5kO1xuICB2YXIgaW5uZXIgPSBjb250ZW50QXQoY29udGVudCwgb3BlblN0YXJ0KTtcbiAgaWYgKGlubmVyLmNoaWxkQ291bnQgPD0gMSAmJiBvcGVuU3RhcnQgPiAwKSB7XG4gICAgdmFyIG9wZW5BdEVuZCA9IGNvbnRlbnQuc2l6ZSAtIG9wZW5TdGFydCA8PSBvcGVuU3RhcnQgKyBpbm5lci5zaXplO1xuICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChjb250ZW50LCBvcGVuU3RhcnQgLSAxLCAxKSwgb3BlblN0YXJ0IC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5BdEVuZCA/IG9wZW5TdGFydCAtIDEgOiBvcGVuRW5kKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0LCAxKSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgfVxufTtcblxuLy8gOiAoe3NsaWNlRGVwdGg6IG51bWJlciwgZnJvbnRpZXJEZXB0aDogbnVtYmVyLCBwYXJlbnQ6ID9Ob2RlLCB3cmFwOiA/W05vZGVUeXBlXSwgaW5qZWN0OiA/RnJhZ21lbnR9KVxuLy8gTW92ZSBjb250ZW50IGZyb20gdGhlIHVucGxhY2VkIHNsaWNlIGF0IGBzbGljZURlcHRoYCB0byB0aGVcbi8vIGZyb250aWVyIG5vZGUgYXQgYGZyb250aWVyRGVwdGhgLiBDbG9zZSB0aGF0IGZyb250aWVyIG5vZGUgd2hlblxuLy8gYXBwbGljYWJsZS5cbkZpdHRlci5wcm90b3R5cGUucGxhY2VOb2RlcyA9IGZ1bmN0aW9uIHBsYWNlTm9kZXMgKHJlZikge1xuICAgIHZhciBzbGljZURlcHRoID0gcmVmLnNsaWNlRGVwdGg7XG4gICAgdmFyIGZyb250aWVyRGVwdGggPSByZWYuZnJvbnRpZXJEZXB0aDtcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcbiAgICB2YXIgaW5qZWN0ID0gcmVmLmluamVjdDtcbiAgICB2YXIgd3JhcCA9IHJlZi53cmFwO1xuXG4gIHdoaWxlICh0aGlzLmRlcHRoID4gZnJvbnRpZXJEZXB0aCkgeyB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7IH1cbiAgaWYgKHdyYXApIHsgZm9yICh2YXIgaSA9IDA7IGkgPCB3cmFwLmxlbmd0aDsgaSsrKSB7IHRoaXMub3BlbkZyb250aWVyTm9kZSh3cmFwW2ldKTsgfSB9XG5cbiAgdmFyIHNsaWNlID0gdGhpcy51bnBsYWNlZCwgZnJhZ21lbnQgPSBwYXJlbnQgPyBwYXJlbnQuY29udGVudCA6IHNsaWNlLmNvbnRlbnQ7XG4gIHZhciBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQgLSBzbGljZURlcHRoO1xuICB2YXIgdGFrZW4gPSAwLCBhZGQgPSBbXTtcbiAgdmFyIHJlZiQxID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXTtcbiAgICB2YXIgbWF0Y2ggPSByZWYkMS5tYXRjaDtcbiAgICB2YXIgdHlwZSA9IHJlZiQxLnR5cGU7XG4gIGlmIChpbmplY3QpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBpbmplY3QuY2hpbGRDb3VudDsgaSQxKyspIHsgYWRkLnB1c2goaW5qZWN0LmNoaWxkKGkkMSkpOyB9XG4gICAgbWF0Y2ggPSBtYXRjaC5tYXRjaEZyYWdtZW50KGluamVjdCk7XG4gIH1cbiAgLy8gQ29tcHV0ZXMgdGhlIGFtb3VudCBvZiAoZW5kKSBvcGVuIG5vZGVzIGF0IHRoZSBlbmQgb2YgdGhlXG4gIC8vIGZyYWdtZW50LiBXaGVuIDAsIHRoZSBwYXJlbnQgaXMgb3BlbiwgYnV0IG5vIG1vcmUuIFdoZW5cbiAgLy8gbmVnYXRpdmUsIG5vdGhpbmcgaXMgb3Blbi5cbiAgdmFyIG9wZW5FbmRDb3VudCA9IChmcmFnbWVudC5zaXplICsgc2xpY2VEZXB0aCkgLSAoc2xpY2UuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCk7XG4gIC8vIFNjYW4gb3ZlciB0aGUgZnJhZ21lbnQsIGZpdHRpbmcgYXMgbWFueSBjaGlsZCBub2RlcyBhc1xuICAvLyBwb3NzaWJsZS5cbiAgd2hpbGUgKHRha2VuIDwgZnJhZ21lbnQuY2hpbGRDb3VudCkge1xuICAgIHZhciBuZXh0ID0gZnJhZ21lbnQuY2hpbGQodGFrZW4pLCBtYXRjaGVzID0gbWF0Y2gubWF0Y2hUeXBlKG5leHQudHlwZSk7XG4gICAgaWYgKCFtYXRjaGVzKSB7IGJyZWFrIH1cbiAgICB0YWtlbisrO1xuICAgIGlmICh0YWtlbiA+IDEgfHwgb3BlblN0YXJ0ID09IDAgfHwgbmV4dC5jb250ZW50LnNpemUpIHsgLy8gRHJvcCBlbXB0eSBvcGVuIG5vZGVzXG4gICAgICBtYXRjaCA9IG1hdGNoZXM7XG4gICAgICBhZGQucHVzaChjbG9zZU5vZGVTdGFydChuZXh0Lm1hcmsodHlwZS5hbGxvd2VkTWFya3MobmV4dC5tYXJrcykpLCB0YWtlbiA9PSAxID8gb3BlblN0YXJ0IDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQgPyBvcGVuRW5kQ291bnQgOiAtMSkpO1xuICAgIH1cbiAgfVxuICB2YXIgdG9FbmQgPSB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50O1xuICBpZiAoIXRvRW5kKSB7IG9wZW5FbmRDb3VudCA9IC0xOyB9XG5cbiAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBmcm9udGllckRlcHRoLCBGcmFnbWVudC5mcm9tKGFkZCkpO1xuICB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLm1hdGNoID0gbWF0Y2g7XG5cbiAgLy8gSWYgdGhlIHBhcmVudCB0eXBlcyBtYXRjaCwgYW5kIHRoZSBlbnRpcmUgbm9kZSB3YXMgbW92ZWQsIGFuZFxuICAvLyBpdCdzIG5vdCBvcGVuLCBjbG9zZSB0aGlzIGZyb250aWVyIG5vZGUgcmlnaHQgYXdheS5cbiAgaWYgKHRvRW5kICYmIG9wZW5FbmRDb3VudCA8IDAgJiYgcGFyZW50ICYmIHBhcmVudC50eXBlID09IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF0udHlwZSAmJiB0aGlzLmZyb250aWVyLmxlbmd0aCA+IDEpXG4gICAgeyB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7IH1cblxuICAvLyBBZGQgbmV3IGZyb250aWVyIG5vZGVzIGZvciBhbnkgb3BlbiBub2RlcyBhdCB0aGUgZW5kLlxuICBmb3IgKHZhciBpJDIgPSAwLCBjdXIgPSBmcmFnbWVudDsgaSQyIDwgb3BlbkVuZENvdW50OyBpJDIrKykge1xuICAgIHZhciBub2RlID0gY3VyLmxhc3RDaGlsZDtcbiAgICB0aGlzLmZyb250aWVyLnB1c2goe3R5cGU6IG5vZGUudHlwZSwgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KX0pO1xuICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBgdGhpcy51bnBsYWNlZGAuIERyb3AgdGhlIGVudGlyZSBub2RlIGZyb20gd2hpY2ggd2VcbiAgLy8gcGxhY2VkIGl0IHdlIGdvdCB0byBpdHMgZW5kLCBvdGhlcndpc2UganVzdCBkcm9wIHRoZSBwbGFjZWRcbiAgLy8gbm9kZXMuXG4gIHRoaXMudW5wbGFjZWQgPSAhdG9FbmQgPyBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoLCB0YWtlbiksIHNsaWNlLm9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZClcbiAgICA6IHNsaWNlRGVwdGggPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgOiBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoIC0gMSwgMSksXG4gICAgICAgICAgICAgICAgc2xpY2VEZXB0aCAtIDEsIG9wZW5FbmRDb3VudCA8IDAgPyBzbGljZS5vcGVuRW5kIDogc2xpY2VEZXB0aCAtIDEpO1xufTtcblxuRml0dGVyLnByb3RvdHlwZS5tdXN0TW92ZUlubGluZSA9IGZ1bmN0aW9uIG11c3RNb3ZlSW5saW5lICgpIHtcbiAgaWYgKCF0aGlzLiR0by5wYXJlbnQuaXNUZXh0YmxvY2sgfHwgdGhpcy4kdG8uZW5kKCkgPT0gdGhpcy4kdG8ucG9zKSB7IHJldHVybiAtMSB9XG4gIHZhciB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLCBsZXZlbDtcbiAgaWYgKCF0b3AudHlwZS5pc1RleHRibG9jayB8fCAhY29udGVudEFmdGVyRml0cyh0aGlzLiR0bywgdGhpcy4kdG8uZGVwdGgsIHRvcC50eXBlLCB0b3AubWF0Y2gsIGZhbHNlKSB8fFxuICAgICAgKHRoaXMuJHRvLmRlcHRoID09IHRoaXMuZGVwdGggJiYgKGxldmVsID0gdGhpcy5maW5kQ2xvc2VMZXZlbCh0aGlzLiR0bykpICYmIGxldmVsLmRlcHRoID09IHRoaXMuZGVwdGgpKSB7IHJldHVybiAtMSB9XG5cbiAgdmFyIHJlZiA9IHRoaXMuJHRvO1xuICAgIHZhciBkZXB0aCA9IHJlZi5kZXB0aDtcbiAgICB2YXIgYWZ0ZXIgPSB0aGlzLiR0by5hZnRlcihkZXB0aCk7XG4gIHdoaWxlIChkZXB0aCA+IDEgJiYgYWZ0ZXIgPT0gdGhpcy4kdG8uZW5kKC0tZGVwdGgpKSB7ICsrYWZ0ZXI7IH1cbiAgcmV0dXJuIGFmdGVyXG59O1xuXG5GaXR0ZXIucHJvdG90eXBlLmZpbmRDbG9zZUxldmVsID0gZnVuY3Rpb24gZmluZENsb3NlTGV2ZWwgKCR0bykge1xuICBzY2FuOiBmb3IgKHZhciBpID0gTWF0aC5taW4odGhpcy5kZXB0aCwgJHRvLmRlcHRoKTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcmVmID0gdGhpcy5mcm9udGllcltpXTtcbiAgICAgIHZhciBtYXRjaCA9IHJlZi5tYXRjaDtcbiAgICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIGRyb3BJbm5lciA9IGkgPCAkdG8uZGVwdGggJiYgJHRvLmVuZChpICsgMSkgPT0gJHRvLnBvcyArICgkdG8uZGVwdGggLSAoaSArIDEpKTtcbiAgICB2YXIgZml0ID0gY29udGVudEFmdGVyRml0cygkdG8sIGksIHR5cGUsIG1hdGNoLCBkcm9wSW5uZXIpO1xuICAgIGlmICghZml0KSB7IGNvbnRpbnVlIH1cbiAgICBmb3IgKHZhciBkID0gaSAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICB2YXIgcmVmJDEgPSB0aGlzLmZyb250aWVyW2RdO1xuICAgICAgICB2YXIgbWF0Y2gkMSA9IHJlZiQxLm1hdGNoO1xuICAgICAgICB2YXIgdHlwZSQxID0gcmVmJDEudHlwZTtcbiAgICAgIHZhciBtYXRjaGVzID0gY29udGVudEFmdGVyRml0cygkdG8sIGQsIHR5cGUkMSwgbWF0Y2gkMSwgdHJ1ZSk7XG4gICAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5jaGlsZENvdW50KSB7IGNvbnRpbnVlIHNjYW4gfVxuICAgIH1cbiAgICByZXR1cm4ge2RlcHRoOiBpLCBmaXQ6IGZpdCwgbW92ZTogZHJvcElubmVyID8gJHRvLmRvYy5yZXNvbHZlKCR0by5hZnRlcihpICsgMSkpIDogJHRvfVxuICB9XG59O1xuXG5GaXR0ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UgKCR0bykge1xuICB2YXIgY2xvc2UgPSB0aGlzLmZpbmRDbG9zZUxldmVsKCR0byk7XG4gIGlmICghY2xvc2UpIHsgcmV0dXJuIG51bGwgfVxuXG4gIHdoaWxlICh0aGlzLmRlcHRoID4gY2xvc2UuZGVwdGgpIHsgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpOyB9XG4gIGlmIChjbG9zZS5maXQuY2hpbGRDb3VudCkgeyB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGNsb3NlLmRlcHRoLCBjbG9zZS5maXQpOyB9XG4gICR0byA9IGNsb3NlLm1vdmU7XG4gIGZvciAodmFyIGQgPSBjbG9zZS5kZXB0aCArIDE7IGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICB2YXIgbm9kZSA9ICR0by5ub2RlKGQpLCBhZGQgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCAkdG8uaW5kZXgoZCkpO1xuICAgIHRoaXMub3BlbkZyb250aWVyTm9kZShub2RlLnR5cGUsIG5vZGUuYXR0cnMsIGFkZCk7XG4gIH1cbiAgcmV0dXJuICR0b1xufTtcblxuRml0dGVyLnByb3RvdHlwZS5vcGVuRnJvbnRpZXJOb2RlID0gZnVuY3Rpb24gb3BlbkZyb250aWVyTm9kZSAodHlwZSwgYXR0cnMsIGNvbnRlbnQpIHtcbiAgdmFyIHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF07XG4gIHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5kZXB0aCwgRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhdHRycywgY29udGVudCkpKTtcbiAgdGhpcy5mcm9udGllci5wdXNoKHt0eXBlOiB0eXBlLCBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2h9KTtcbn07XG5cbkZpdHRlci5wcm90b3R5cGUuY2xvc2VGcm9udGllck5vZGUgPSBmdW5jdGlvbiBjbG9zZUZyb250aWVyTm9kZSAoKSB7XG4gIHZhciBvcGVuID0gdGhpcy5mcm9udGllci5wb3AoKTtcbiAgdmFyIGFkZCA9IG9wZW4ubWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gIGlmIChhZGQuY2hpbGRDb3VudCkgeyB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZnJvbnRpZXIubGVuZ3RoLCBhZGQpOyB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggRml0dGVyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDEgKTtcblxuZnVuY3Rpb24gZHJvcEZyb21GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvdW50KSB7XG4gIGlmIChkZXB0aCA9PSAwKSB7IHJldHVybiBmcmFnbWVudC5jdXRCeUluZGV4KGNvdW50KSB9XG4gIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZnJhZ21lbnQuZmlyc3RDaGlsZC5jb3B5KGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvdW50KSkpXG59XG5cbmZ1bmN0aW9uIGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBjb250ZW50KSB7XG4gIGlmIChkZXB0aCA9PSAwKSB7IHJldHVybiBmcmFnbWVudC5hcHBlbmQoY29udGVudCkgfVxuICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50Lmxhc3RDaGlsZC5jb3B5KGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQubGFzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY29udGVudCkpKVxufVxuXG5mdW5jdGlvbiBjb250ZW50QXQoZnJhZ21lbnQsIGRlcHRoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwdGg7IGkrKykgeyBmcmFnbWVudCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudDsgfVxuICByZXR1cm4gZnJhZ21lbnRcbn1cblxuZnVuY3Rpb24gY2xvc2VOb2RlU3RhcnQobm9kZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gIGlmIChvcGVuU3RhcnQgPD0gMCkgeyByZXR1cm4gbm9kZSB9XG4gIHZhciBmcmFnID0gbm9kZS5jb250ZW50O1xuICBpZiAob3BlblN0YXJ0ID4gMSlcbiAgICB7IGZyYWcgPSBmcmFnLnJlcGxhY2VDaGlsZCgwLCBjbG9zZU5vZGVTdGFydChmcmFnLmZpcnN0Q2hpbGQsIG9wZW5TdGFydCAtIDEsIGZyYWcuY2hpbGRDb3VudCA9PSAxID8gb3BlbkVuZCAtIDEgOiAwKSk7IH1cbiAgaWYgKG9wZW5TdGFydCA+IDApIHtcbiAgICBmcmFnID0gbm9kZS50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGZyYWcpLmFwcGVuZChmcmFnKTtcbiAgICBpZiAob3BlbkVuZCA8PSAwKSB7IGZyYWcgPSBmcmFnLmFwcGVuZChub2RlLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZnJhZykuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpOyB9XG4gIH1cbiAgcmV0dXJuIG5vZGUuY29weShmcmFnKVxufVxuXG5mdW5jdGlvbiBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZGVwdGgsIHR5cGUsIG1hdGNoLCBvcGVuKSB7XG4gIHZhciBub2RlID0gJHRvLm5vZGUoZGVwdGgpLCBpbmRleCA9IG9wZW4gPyAkdG8uaW5kZXhBZnRlcihkZXB0aCkgOiAkdG8uaW5kZXgoZGVwdGgpO1xuICBpZiAoaW5kZXggPT0gbm9kZS5jaGlsZENvdW50ICYmICF0eXBlLmNvbXBhdGlibGVDb250ZW50KG5vZGUudHlwZSkpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgZml0ID0gbWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsIGluZGV4KTtcbiAgcmV0dXJuIGZpdCAmJiAhaW52YWxpZE1hcmtzKHR5cGUsIG5vZGUuY29udGVudCwgaW5kZXgpID8gZml0IDogbnVsbFxufVxuXG5mdW5jdGlvbiBpbnZhbGlkTWFya3ModHlwZSwgZnJhZ21lbnQsIHN0YXJ0KSB7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGZyYWdtZW50LmNoaWxkQ291bnQ7IGkrKylcbiAgICB7IGlmICghdHlwZS5hbGxvd3NNYXJrcyhmcmFnbWVudC5jaGlsZChpKS5tYXJrcykpIHsgcmV0dXJuIHRydWUgfSB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyA6OiAobnVtYmVyLCBudW1iZXIsIFNsaWNlKSDihpIgdGhpc1xuLy8gUmVwbGFjZSBhIHJhbmdlIG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgZ2l2ZW4gc2xpY2UsIHVzaW5nIGBmcm9tYCxcbi8vIGB0b2AsIGFuZCB0aGUgc2xpY2UncyBbYG9wZW5TdGFydGBdKCNtb2RlbC5TbGljZS5vcGVuU3RhcnQpIHByb3BlcnR5XG4vLyBhcyBoaW50cywgcmF0aGVyIHRoYW4gZml4ZWQgc3RhcnQgYW5kIGVuZCBwb2ludHMuIFRoaXMgbWV0aG9kIG1heVxuLy8gZ3JvdyB0aGUgcmVwbGFjZWQgYXJlYSBvciBjbG9zZSBvcGVuIG5vZGVzIGluIHRoZSBzbGljZSBpbiBvcmRlciB0b1xuLy8gZ2V0IGEgZml0IHRoYXQgaXMgbW9yZSBpbiBsaW5lIHdpdGggV1lTSVdZRyBleHBlY3RhdGlvbnMsIGJ5XG4vLyBkcm9wcGluZyBmdWxseSBjb3ZlcmVkIHBhcmVudCBub2RlcyBvZiB0aGUgcmVwbGFjZWQgcmVnaW9uIHdoZW5cbi8vIHRoZXkgYXJlIG1hcmtlZCBbbm9uLWRlZmluaW5nXSgjbW9kZWwuTm9kZVNwZWMuZGVmaW5pbmcpLCBvclxuLy8gaW5jbHVkaW5nIGFuIG9wZW4gcGFyZW50IG5vZGUgZnJvbSB0aGUgc2xpY2UgdGhhdCBfaXNfIG1hcmtlZCBhc1xuLy8gW2RlZmluaW5nXSgjbW9kZWwuTm9kZVNwZWMuZGVmaW5pbmcpLlxuLy9cbi8vIFRoaXMgaXMgdGhlIG1ldGhvZCwgZm9yIGV4YW1wbGUsIHRvIGhhbmRsZSBwYXN0ZS4gVGhlIHNpbWlsYXJcbi8vIFtgcmVwbGFjZWBdKCN0cmFuc2Zvcm0uVHJhbnNmb3JtLnJlcGxhY2UpIG1ldGhvZCBpcyBhIG1vcmVcbi8vIHByaW1pdGl2ZSB0b29sIHdoaWNoIHdpbGwgX25vdF8gbW92ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiBpdHMgZ2l2ZW5cbi8vIHJhbmdlLCBhbmQgaXMgdXNlZnVsIGluIHNpdHVhdGlvbnMgd2hlcmUgeW91IG5lZWQgbW9yZSBwcmVjaXNlXG4vLyBjb250cm9sIG92ZXIgd2hhdCBoYXBwZW5zLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5yZXBsYWNlUmFuZ2UgPSBmdW5jdGlvbihmcm9tLCB0bywgc2xpY2UpIHtcbiAgaWYgKCFzbGljZS5zaXplKSB7IHJldHVybiB0aGlzLmRlbGV0ZVJhbmdlKGZyb20sIHRvKSB9XG5cbiAgdmFyICRmcm9tID0gdGhpcy5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdGhpcy5kb2MucmVzb2x2ZSh0byk7XG4gIGlmIChmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSlcbiAgICB7IHJldHVybiB0aGlzLnN0ZXAobmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSkpIH1cblxuICB2YXIgdGFyZ2V0RGVwdGhzID0gY292ZXJlZERlcHRocygkZnJvbSwgdGhpcy5kb2MucmVzb2x2ZSh0bykpO1xuICAvLyBDYW4ndCByZXBsYWNlIHRoZSB3aG9sZSBkb2N1bWVudCwgc28gcmVtb3ZlIDAgaWYgaXQncyBwcmVzZW50XG4gIGlmICh0YXJnZXREZXB0aHNbdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDFdID09IDApIHsgdGFyZ2V0RGVwdGhzLnBvcCgpOyB9XG4gIC8vIE5lZ2F0aXZlIG51bWJlcnMgcmVwcmVzZW50IG5vdCBleHBhbnNpb24gb3ZlciB0aGUgd2hvbGUgbm9kZSBhdFxuICAvLyB0aGF0IGRlcHRoLCBidXQgcmVwbGFjaW5nIGZyb20gJGZyb20uYmVmb3JlKC1EKSB0byAkdG8ucG9zLlxuICB2YXIgcHJlZmVycmVkVGFyZ2V0ID0gLSgkZnJvbS5kZXB0aCArIDEpO1xuICB0YXJnZXREZXB0aHMudW5zaGlmdChwcmVmZXJyZWRUYXJnZXQpO1xuICAvLyBUaGlzIGxvb3AgcGlja3MgYSBwcmVmZXJyZWQgdGFyZ2V0IGRlcHRoLCBpZiBvbmUgb2YgdGhlIGNvdmVyaW5nXG4gIC8vIGRlcHRocyBpcyBub3Qgb3V0c2lkZSBvZiBhIGRlZmluaW5nIG5vZGUsIGFuZCBhZGRzIG5lZ2F0aXZlXG4gIC8vIGRlcHRocyBmb3IgYW55IGRlcHRoIHRoYXQgaGFzICRmcm9tIGF0IGl0cyBzdGFydCBhbmQgZG9lcyBub3RcbiAgLy8gY3Jvc3MgYSBkZWZpbmluZyBub2RlLlxuICBmb3IgKHZhciBkID0gJGZyb20uZGVwdGgsIHBvcyA9ICRmcm9tLnBvcyAtIDE7IGQgPiAwOyBkLS0sIHBvcy0tKSB7XG4gICAgdmFyIHNwZWMgPSAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYztcbiAgICBpZiAoc3BlYy5kZWZpbmluZyB8fCBzcGVjLmlzb2xhdGluZykgeyBicmVhayB9XG4gICAgaWYgKHRhcmdldERlcHRocy5pbmRleE9mKGQpID4gLTEpIHsgcHJlZmVycmVkVGFyZ2V0ID0gZDsgfVxuICAgIGVsc2UgaWYgKCRmcm9tLmJlZm9yZShkKSA9PSBwb3MpIHsgdGFyZ2V0RGVwdGhzLnNwbGljZSgxLCAwLCAtZCk7IH1cbiAgfVxuICAvLyBUcnkgdG8gZml0IGVhY2ggcG9zc2libGUgZGVwdGggb2YgdGhlIHNsaWNlIGludG8gZWFjaCBwb3NzaWJsZVxuICAvLyB0YXJnZXQgZGVwdGgsIHN0YXJ0aW5nIHdpdGggdGhlIHByZWZlcnJlZCBkZXB0aHMuXG4gIHZhciBwcmVmZXJyZWRUYXJnZXRJbmRleCA9IHRhcmdldERlcHRocy5pbmRleE9mKHByZWZlcnJlZFRhcmdldCk7XG5cbiAgdmFyIGxlZnROb2RlcyA9IFtdLCBwcmVmZXJyZWREZXB0aCA9IHNsaWNlLm9wZW5TdGFydDtcbiAgZm9yICh2YXIgY29udGVudCA9IHNsaWNlLmNvbnRlbnQsIGkgPSAwOzsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgbGVmdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgaWYgKGkgPT0gc2xpY2Uub3BlblN0YXJ0KSB7IGJyZWFrIH1cbiAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICB9XG4gIC8vIEJhY2sgdXAgaWYgdGhlIG5vZGUgZGlyZWN0bHkgYWJvdmUgb3BlblN0YXJ0LCBvciB0aGUgbm9kZSBhYm92ZVxuICAvLyB0aGF0IHNlcGFyYXRlZCBvbmx5IGJ5IGEgbm9uLWRlZmluaW5nIHRleHRibG9jayBub2RlLCBpcyBkZWZpbmluZy5cbiAgaWYgKHByZWZlcnJlZERlcHRoID4gMCAmJiBsZWZ0Tm9kZXNbcHJlZmVycmVkRGVwdGggLSAxXS50eXBlLnNwZWMuZGVmaW5pbmcgJiZcbiAgICAgICRmcm9tLm5vZGUocHJlZmVycmVkVGFyZ2V0SW5kZXgpLnR5cGUgIT0gbGVmdE5vZGVzW3ByZWZlcnJlZERlcHRoIC0gMV0udHlwZSlcbiAgICB7IHByZWZlcnJlZERlcHRoIC09IDE7IH1cbiAgZWxzZSBpZiAocHJlZmVycmVkRGVwdGggPj0gMiAmJiBsZWZ0Tm9kZXNbcHJlZmVycmVkRGVwdGggLSAxXS5pc1RleHRibG9jayAmJiBsZWZ0Tm9kZXNbcHJlZmVycmVkRGVwdGggLSAyXS50eXBlLnNwZWMuZGVmaW5pbmcgJiZcbiAgICAgICAgICAgJGZyb20ubm9kZShwcmVmZXJyZWRUYXJnZXRJbmRleCkudHlwZSAhPSBsZWZ0Tm9kZXNbcHJlZmVycmVkRGVwdGggLSAyXS50eXBlKVxuICAgIHsgcHJlZmVycmVkRGVwdGggLT0gMjsgfVxuXG4gIGZvciAodmFyIGogPSBzbGljZS5vcGVuU3RhcnQ7IGogPj0gMDsgai0tKSB7XG4gICAgdmFyIG9wZW5EZXB0aCA9IChqICsgcHJlZmVycmVkRGVwdGggKyAxKSAlIChzbGljZS5vcGVuU3RhcnQgKyAxKTtcbiAgICB2YXIgaW5zZXJ0ID0gbGVmdE5vZGVzW29wZW5EZXB0aF07XG4gICAgaWYgKCFpbnNlcnQpIHsgY29udGludWUgfVxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRhcmdldERlcHRocy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAvLyBMb29wIG92ZXIgcG9zc2libGUgZXhwYW5zaW9uIGxldmVscywgc3RhcnRpbmcgd2l0aCB0aGVcbiAgICAgIC8vIHByZWZlcnJlZCBvbmVcbiAgICAgIHZhciB0YXJnZXREZXB0aCA9IHRhcmdldERlcHRoc1soaSQxICsgcHJlZmVycmVkVGFyZ2V0SW5kZXgpICUgdGFyZ2V0RGVwdGhzLmxlbmd0aF0sIGV4cGFuZCA9IHRydWU7XG4gICAgICBpZiAodGFyZ2V0RGVwdGggPCAwKSB7IGV4cGFuZCA9IGZhbHNlOyB0YXJnZXREZXB0aCA9IC10YXJnZXREZXB0aDsgfVxuICAgICAgdmFyIHBhcmVudCA9ICRmcm9tLm5vZGUodGFyZ2V0RGVwdGggLSAxKSwgaW5kZXggPSAkZnJvbS5pbmRleCh0YXJnZXREZXB0aCAtIDEpO1xuICAgICAgaWYgKHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIGluc2VydC50eXBlLCBpbnNlcnQubWFya3MpKVxuICAgICAgICB7IHJldHVybiB0aGlzLnJlcGxhY2UoJGZyb20uYmVmb3JlKHRhcmdldERlcHRoKSwgZXhwYW5kID8gJHRvLmFmdGVyKHRhcmdldERlcHRoKSA6IHRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTbGljZShjbG9zZUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIDAsIHNsaWNlLm9wZW5TdGFydCwgb3BlbkRlcHRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkRlcHRoLCBzbGljZS5vcGVuRW5kKSkgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBzdGFydFN0ZXBzID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gIGZvciAodmFyIGkkMiA9IHRhcmdldERlcHRocy5sZW5ndGggLSAxOyBpJDIgPj0gMDsgaSQyLS0pIHtcbiAgICB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKTtcbiAgICBpZiAodGhpcy5zdGVwcy5sZW5ndGggPiBzdGFydFN0ZXBzKSB7IGJyZWFrIH1cbiAgICB2YXIgZGVwdGggPSB0YXJnZXREZXB0aHNbaSQyXTtcbiAgICBpZiAoZGVwdGggPCAwKSB7IGNvbnRpbnVlIH1cbiAgICBmcm9tID0gJGZyb20uYmVmb3JlKGRlcHRoKTsgdG8gPSAkdG8uYWZ0ZXIoZGVwdGgpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5mdW5jdGlvbiBjbG9zZUZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgb2xkT3BlbiwgbmV3T3BlbiwgcGFyZW50KSB7XG4gIGlmIChkZXB0aCA8IG9sZE9wZW4pIHtcbiAgICB2YXIgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgIGZyYWdtZW50ID0gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZpcnN0LmNvcHkoY2xvc2VGcmFnbWVudChmaXJzdC5jb250ZW50LCBkZXB0aCArIDEsIG9sZE9wZW4sIG5ld09wZW4sIGZpcnN0KSkpO1xuICB9XG4gIGlmIChkZXB0aCA+IG5ld09wZW4pIHtcbiAgICB2YXIgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoMCk7XG4gICAgdmFyIHN0YXJ0ID0gbWF0Y2guZmlsbEJlZm9yZShmcmFnbWVudCkuYXBwZW5kKGZyYWdtZW50KTtcbiAgICBmcmFnbWVudCA9IHN0YXJ0LmFwcGVuZChtYXRjaC5tYXRjaEZyYWdtZW50KHN0YXJ0KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gIH1cbiAgcmV0dXJuIGZyYWdtZW50XG59XG5cbi8vIDo6IChudW1iZXIsIG51bWJlciwgTm9kZSkg4oaSIHRoaXNcbi8vIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlIHdpdGggYSBub2RlLCBidXQgdXNlIGBmcm9tYCBhbmQgYHRvYCBhc1xuLy8gaGludHMsIHJhdGhlciB0aGFuIHByZWNpc2UgcG9zaXRpb25zLiBXaGVuIGZyb20gYW5kIHRvIGFyZSB0aGUgc2FtZVxuLy8gYW5kIGFyZSBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgcGFyZW50IG5vZGUgaW4gd2hpY2ggdGhlIGdpdmVuXG4vLyBub2RlIGRvZXNuJ3QgZml0LCB0aGlzIG1ldGhvZCBtYXkgX21vdmVfIHRoZW0gb3V0IHRvd2FyZHMgYSBwYXJlbnRcbi8vIHRoYXQgZG9lcyBhbGxvdyB0aGUgZ2l2ZW4gbm9kZSB0byBiZSBwbGFjZWQuIFdoZW4gdGhlIGdpdmVuIHJhbmdlXG4vLyBjb21wbGV0ZWx5IGNvdmVycyBhIHBhcmVudCBub2RlLCB0aGlzIG1ldGhvZCBtYXkgY29tcGxldGVseSByZXBsYWNlXG4vLyB0aGF0IHBhcmVudCBub2RlLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5yZXBsYWNlUmFuZ2VXaXRoID0gZnVuY3Rpb24oZnJvbSwgdG8sIG5vZGUpIHtcbiAgaWYgKCFub2RlLmlzSW5saW5lICYmIGZyb20gPT0gdG8gJiYgdGhpcy5kb2MucmVzb2x2ZShmcm9tKS5wYXJlbnQuY29udGVudC5zaXplKSB7XG4gICAgdmFyIHBvaW50ID0gaW5zZXJ0UG9pbnQodGhpcy5kb2MsIGZyb20sIG5vZGUudHlwZSk7XG4gICAgaWYgKHBvaW50ICE9IG51bGwpIHsgZnJvbSA9IHRvID0gcG9pbnQ7IH1cbiAgfVxuICByZXR1cm4gdGhpcy5yZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSlcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlcikg4oaSIHRoaXNcbi8vIERlbGV0ZSB0aGUgZ2l2ZW4gcmFuZ2UsIGV4cGFuZGluZyBpdCB0byBjb3ZlciBmdWxseSBjb3ZlcmVkXG4vLyBwYXJlbnQgbm9kZXMgdW50aWwgYSB2YWxpZCByZXBsYWNlIGlzIGZvdW5kLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5kZWxldGVSYW5nZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIHZhciAkZnJvbSA9IHRoaXMuZG9jLnJlc29sdmUoZnJvbSksICR0byA9IHRoaXMuZG9jLnJlc29sdmUodG8pO1xuICB2YXIgY292ZXJlZCA9IGNvdmVyZWREZXB0aHMoJGZyb20sICR0byk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY292ZXJlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXB0aCA9IGNvdmVyZWRbaV0sIGxhc3QgPSBpID09IGNvdmVyZWQubGVuZ3RoIC0gMTtcbiAgICBpZiAoKGxhc3QgJiYgZGVwdGggPT0gMCkgfHwgJGZyb20ubm9kZShkZXB0aCkudHlwZS5jb250ZW50TWF0Y2gudmFsaWRFbmQpXG4gICAgICB7IHJldHVybiB0aGlzLmRlbGV0ZSgkZnJvbS5zdGFydChkZXB0aCksICR0by5lbmQoZGVwdGgpKSB9XG4gICAgaWYgKGRlcHRoID4gMCAmJiAobGFzdCB8fCAkZnJvbS5ub2RlKGRlcHRoIC0gMSkuY2FuUmVwbGFjZSgkZnJvbS5pbmRleChkZXB0aCAtIDEpLCAkdG8uaW5kZXhBZnRlcihkZXB0aCAtIDEpKSkpXG4gICAgICB7IHJldHVybiB0aGlzLmRlbGV0ZSgkZnJvbS5iZWZvcmUoZGVwdGgpLCAkdG8uYWZ0ZXIoZGVwdGgpKSB9XG4gIH1cbiAgZm9yICh2YXIgZCA9IDE7IGQgPD0gJGZyb20uZGVwdGggJiYgZCA8PSAkdG8uZGVwdGg7IGQrKykge1xuICAgIGlmIChmcm9tIC0gJGZyb20uc3RhcnQoZCkgPT0gJGZyb20uZGVwdGggLSBkICYmIHRvID4gJGZyb20uZW5kKGQpICYmICR0by5lbmQoZCkgLSB0byAhPSAkdG8uZGVwdGggLSBkKVxuICAgICAgeyByZXR1cm4gdGhpcy5kZWxldGUoJGZyb20uYmVmb3JlKGQpLCB0bykgfVxuICB9XG4gIHJldHVybiB0aGlzLmRlbGV0ZShmcm9tLCB0bylcbn07XG5cbi8vIDogKFJlc29sdmVkUG9zLCBSZXNvbHZlZFBvcykg4oaSIFtudW1iZXJdXG4vLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBkZXB0aHMgZm9yIHdoaWNoICRmcm9tIC0gJHRvIHNwYW5zIHRoZVxuLy8gd2hvbGUgY29udGVudCBvZiB0aGUgbm9kZXMgYXQgdGhhdCBkZXB0aC5cbmZ1bmN0aW9uIGNvdmVyZWREZXB0aHMoJGZyb20sICR0bykge1xuICB2YXIgcmVzdWx0ID0gW10sIG1pbkRlcHRoID0gTWF0aC5taW4oJGZyb20uZGVwdGgsICR0by5kZXB0aCk7XG4gIGZvciAodmFyIGQgPSBtaW5EZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICB2YXIgc3RhcnQgPSAkZnJvbS5zdGFydChkKTtcbiAgICBpZiAoc3RhcnQgPCAkZnJvbS5wb3MgLSAoJGZyb20uZGVwdGggLSBkKSB8fFxuICAgICAgICAkdG8uZW5kKGQpID4gJHRvLnBvcyArICgkdG8uZGVwdGggLSBkKSB8fFxuICAgICAgICAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICAgJHRvLm5vZGUoZCkudHlwZS5zcGVjLmlzb2xhdGluZykgeyBicmVhayB9XG4gICAgaWYgKHN0YXJ0ID09ICR0by5zdGFydChkKSB8fFxuICAgICAgICAoZCA9PSAkZnJvbS5kZXB0aCAmJiBkID09ICR0by5kZXB0aCAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQgJiZcbiAgICAgICAgIGQgJiYgJHRvLnN0YXJ0KGQgLSAxKSA9PSBzdGFydCAtIDEpKVxuICAgICAgeyByZXN1bHQucHVzaChkKTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IHsgQWRkTWFya1N0ZXAsIE1hcFJlc3VsdCwgTWFwcGluZywgUmVtb3ZlTWFya1N0ZXAsIFJlcGxhY2VBcm91bmRTdGVwLCBSZXBsYWNlU3RlcCwgU3RlcCwgU3RlcE1hcCwgU3RlcFJlc3VsdCwgVHJhbnNmb3JtLCBUcmFuc2Zvcm1FcnJvciwgY2FuSm9pbiwgY2FuU3BsaXQsIGRyb3BQb2ludCwgZmluZFdyYXBwaW5nLCBpbnNlcnRQb2ludCwgam9pblBvaW50LCBsaWZ0VGFyZ2V0LCByZXBsYWNlU3RlcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uLCBTZWxlY3Rpb24sIEFsbFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBET01QYXJzZXIsIFNsaWNlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgZHJvcFBvaW50IH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxudmFyIHJlc3VsdCA9IHt9O1xuXG5pZiAodHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIHZhciBpZV9lZGdlID0gL0VkZ2VcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBpZV91cHRvMTAgPSAvTVNJRSBcXGQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBpZV8xMXVwID0gL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIHZhciBpZSA9IHJlc3VsdC5pZSA9ICEhKGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGllX2VkZ2UpO1xuICByZXN1bHQuaWVfdmVyc2lvbiA9IGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogbnVsbDtcbiAgcmVzdWx0LmdlY2tvID0gIWllICYmIC9nZWNrb1xcLyhcXGQrKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHJlc3VsdC5nZWNrb192ZXJzaW9uID0gcmVzdWx0LmdlY2tvICYmICsoL0ZpcmVmb3hcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXTtcbiAgdmFyIGNocm9tZSA9ICFpZSAmJiAvQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICByZXN1bHQuY2hyb21lID0gISFjaHJvbWU7XG4gIHJlc3VsdC5jaHJvbWVfdmVyc2lvbiA9IGNocm9tZSAmJiArY2hyb21lWzFdO1xuICAvLyBJcyB0cnVlIGZvciBib3RoIGlPUyBhbmQgaVBhZE9TIGZvciBjb252ZW5pZW5jZVxuICByZXN1bHQuc2FmYXJpID0gIWllICYmIC9BcHBsZSBDb21wdXRlci8udGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcbiAgcmVzdWx0LmlvcyA9IHJlc3VsdC5zYWZhcmkgJiYgKC9Nb2JpbGVcXC9cXHcrLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDIpO1xuICByZXN1bHQubWFjID0gcmVzdWx0LmlvcyB8fCAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG4gIHJlc3VsdC5hbmRyb2lkID0gL0FuZHJvaWQgXFxkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICByZXN1bHQud2Via2l0ID0gXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuICByZXN1bHQud2Via2l0X3ZlcnNpb24gPSByZXN1bHQud2Via2l0ICYmICsoL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV07XG59XG5cbnZhciBkb21JbmRleCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgZm9yICh2YXIgaW5kZXggPSAwOzsgaW5kZXgrKykge1xuICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICBpZiAoIW5vZGUpIHsgcmV0dXJuIGluZGV4IH1cbiAgfVxufTtcblxudmFyIHBhcmVudE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBwYXJlbnQgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09IDExID8gcGFyZW50Lmhvc3QgOiBwYXJlbnRcbn07XG5cbnZhciByZXVzZWRSYW5nZSA9IG51bGw7XG5cbi8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgc2FtZSByYW5nZSwgYmVjYXVzZSBET00gcmFuZ2Vcbi8vIG9iamVjdHMgYXJlIGV2ZXJ5IGV4cGVuc2l2ZSwgYW5kIGtlZXAgc2xvd2luZyBkb3duIHN1YnNlcXVlbnQgRE9NXG4vLyB1cGRhdGVzLCBmb3Igc29tZSByZWFzb24uXG52YXIgdGV4dFJhbmdlID0gZnVuY3Rpb24obm9kZSwgZnJvbSwgdG8pIHtcbiAgdmFyIHJhbmdlID0gcmV1c2VkUmFuZ2UgfHwgKHJldXNlZFJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSk7XG4gIHJhbmdlLnNldEVuZChub2RlLCB0byA9PSBudWxsID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogdG8pO1xuICByYW5nZS5zZXRTdGFydChub2RlLCBmcm9tIHx8IDApO1xuICByZXR1cm4gcmFuZ2Vcbn07XG5cbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbnZhciBpc0VxdWl2YWxlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gIHJldHVybiB0YXJnZXROb2RlICYmIChzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAtMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKVxufTtcblxudmFyIGF0b21FbGVtZW50cyA9IC9eKGltZ3xicnxpbnB1dHx0ZXh0YXJlYXxocikkL2k7XG5cbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgIT0gMSB8fCBoYXNCbG9ja0Rlc2Mobm9kZSkgfHwgYXRvbUVsZW1lbnRzLnRlc3Qobm9kZS5ub2RlTmFtZSkgfHwgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgb2ZmID0gZGlyIDwgMCA/IG5vZGVTaXplKG5vZGUpIDogMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vZGVTaXplKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNPbkVkZ2Uobm9kZSwgb2Zmc2V0LCBwYXJlbnQpIHtcbiAgZm9yICh2YXIgYXRTdGFydCA9IG9mZnNldCA9PSAwLCBhdEVuZCA9IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKTsgYXRTdGFydCB8fCBhdEVuZDspIHtcbiAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHsgcmV0dXJuIHRydWUgfVxuICAgIHZhciBpbmRleCA9IGRvbUluZGV4KG5vZGUpO1xuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgaWYgKCFub2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgYXRTdGFydCA9IGF0U3RhcnQgJiYgaW5kZXggPT0gMDtcbiAgICBhdEVuZCA9IGF0RW5kICYmIGluZGV4ID09IG5vZGVTaXplKG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0Jsb2NrRGVzYyhkb20pIHtcbiAgdmFyIGRlc2M7XG4gIGZvciAodmFyIGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkgeyBpZiAoZGVzYyA9IGN1ci5wbVZpZXdEZXNjKSB7IGJyZWFrIH0gfVxuICByZXR1cm4gZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2sgJiYgKGRlc2MuZG9tID09IGRvbSB8fCBkZXNjLmNvbnRlbnRET00gPT0gZG9tKVxufVxuXG4vLyBXb3JrIGFyb3VuZCBDaHJvbWUgaXNzdWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3NTIzXG4vLyAoaXNDb2xsYXBzZWQgaW5hcHByb3ByaWF0ZWx5IHJldHVybnMgdHJ1ZSBpbiBzaGFkb3cgZG9tKVxudmFyIHNlbGVjdGlvbkNvbGxhcHNlZCA9IGZ1bmN0aW9uKGRvbVNlbCkge1xuICB2YXIgY29sbGFwc2VkID0gZG9tU2VsLmlzQ29sbGFwc2VkO1xuICBpZiAoY29sbGFwc2VkICYmIHJlc3VsdC5jaHJvbWUgJiYgZG9tU2VsLnJhbmdlQ291bnQgJiYgIWRvbVNlbC5nZXRSYW5nZUF0KDApLmNvbGxhcHNlZClcbiAgICB7IGNvbGxhcHNlZCA9IGZhbHNlOyB9XG4gIHJldHVybiBjb2xsYXBzZWRcbn07XG5cbmZ1bmN0aW9uIGtleUV2ZW50KGtleUNvZGUsIGtleSkge1xuICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICBldmVudC5pbml0RXZlbnQoXCJrZXlkb3duXCIsIHRydWUsIHRydWUpO1xuICBldmVudC5rZXlDb2RlID0ga2V5Q29kZTtcbiAgZXZlbnQua2V5ID0gZXZlbnQuY29kZSA9IGtleTtcbiAgcmV0dXJuIGV2ZW50XG59XG5cbmZ1bmN0aW9uIHdpbmRvd1JlY3QoZG9jKSB7XG4gIHJldHVybiB7bGVmdDogMCwgcmlnaHQ6IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgdG9wOiAwLCBib3R0b206IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0fVxufVxuXG5mdW5jdGlvbiBnZXRTaWRlKHZhbHVlLCBzaWRlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IHZhbHVlIDogdmFsdWVbc2lkZV1cbn1cblxuZnVuY3Rpb24gY2xpZW50UmVjdChub2RlKSB7XG4gIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgLy8gQWRqdXN0IGZvciBlbGVtZW50cyB3aXRoIHN0eWxlIFwidHJhbnNmb3JtOiBzY2FsZSgpXCJcbiAgdmFyIHNjYWxlWCA9IChyZWN0LndpZHRoIC8gbm9kZS5vZmZzZXRXaWR0aCkgfHwgMTtcbiAgdmFyIHNjYWxlWSA9IChyZWN0LmhlaWdodCAvIG5vZGUub2Zmc2V0SGVpZ2h0KSB8fCAxO1xuICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcbiAgcmV0dXJuIHtsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBub2RlLmNsaWVudFdpZHRoICogc2NhbGVYLFxuICAgICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBub2RlLmNsaWVudEhlaWdodCAqIHNjYWxlWX1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KHZpZXcsIHJlY3QsIHN0YXJ0RE9NKSB7XG4gIHZhciBzY3JvbGxUaHJlc2hvbGQgPSB2aWV3LnNvbWVQcm9wKFwic2Nyb2xsVGhyZXNob2xkXCIpIHx8IDAsIHNjcm9sbE1hcmdpbiA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxNYXJnaW5cIikgfHwgNTtcbiAgdmFyIGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gIGZvciAodmFyIHBhcmVudCA9IHN0YXJ0RE9NIHx8IHZpZXcuZG9tOzsgcGFyZW50ID0gcGFyZW50Tm9kZShwYXJlbnQpKSB7XG4gICAgaWYgKCFwYXJlbnQpIHsgYnJlYWsgfVxuICAgIGlmIChwYXJlbnQubm9kZVR5cGUgIT0gMSkgeyBjb250aW51ZSB9XG4gICAgdmFyIGF0VG9wID0gcGFyZW50ID09IGRvYy5ib2R5IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxO1xuICAgIHZhciBib3VuZGluZyA9IGF0VG9wID8gd2luZG93UmVjdChkb2MpIDogY2xpZW50UmVjdChwYXJlbnQpO1xuICAgIHZhciBtb3ZlWCA9IDAsIG1vdmVZID0gMDtcbiAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3AgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJ0b3BcIikpXG4gICAgICB7IG1vdmVZID0gLShib3VuZGluZy50b3AgLSByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSk7IH1cbiAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImJvdHRvbVwiKSlcbiAgICAgIHsgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImJvdHRvbVwiKTsgfVxuICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwibGVmdFwiKSlcbiAgICAgIHsgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgLSByZWN0LmxlZnQgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJsZWZ0XCIpKTsgfVxuICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInJpZ2h0XCIpKVxuICAgICAgeyBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInJpZ2h0XCIpOyB9XG4gICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICBpZiAoYXRUb3ApIHtcbiAgICAgICAgZG9jLmRlZmF1bHRWaWV3LnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RhcnRYID0gcGFyZW50LnNjcm9sbExlZnQsIHN0YXJ0WSA9IHBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgIGlmIChtb3ZlWSkgeyBwYXJlbnQuc2Nyb2xsVG9wICs9IG1vdmVZOyB9XG4gICAgICAgIGlmIChtb3ZlWCkgeyBwYXJlbnQuc2Nyb2xsTGVmdCArPSBtb3ZlWDsgfVxuICAgICAgICB2YXIgZFggPSBwYXJlbnQuc2Nyb2xsTGVmdCAtIHN0YXJ0WCwgZFkgPSBwYXJlbnQuc2Nyb2xsVG9wIC0gc3RhcnRZO1xuICAgICAgICByZWN0ID0ge2xlZnQ6IHJlY3QubGVmdCAtIGRYLCB0b3A6IHJlY3QudG9wIC0gZFksIHJpZ2h0OiByZWN0LnJpZ2h0IC0gZFgsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBkWX07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdFRvcCkgeyBicmVhayB9XG4gIH1cbn1cblxuLy8gU3RvcmUgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzLCBhbG9uZyB3aXRoXG4vLyB0aGUgdG9wIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgbmVhciB0aGUgdG9wIG9mIHRoZSBlZGl0b3IsIHdoaWNoXG4vLyB3aWxsIGJlIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHJlbWFpbnMgc3RhYmxlIGV2ZW5cbi8vIHdoZW4gdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgYWJvdmUgY2hhbmdlcy5cbmZ1bmN0aW9uIHN0b3JlU2Nyb2xsUG9zKHZpZXcpIHtcbiAgdmFyIHJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRZID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApO1xuICB2YXIgcmVmRE9NLCByZWZUb3A7XG4gIGZvciAodmFyIHggPSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCB5ID0gc3RhcnRZICsgMTtcbiAgICAgICB5IDwgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHJlY3QuYm90dG9tKTsgeSArPSA1KSB7XG4gICAgdmFyIGRvbSA9IHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIGlmIChkb20gPT0gdmlldy5kb20gfHwgIXZpZXcuZG9tLmNvbnRhaW5zKGRvbSkpIHsgY29udGludWUgfVxuICAgIHZhciBsb2NhbFJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGxvY2FsUmVjdC50b3AgPj0gc3RhcnRZIC0gMjApIHtcbiAgICAgIHJlZkRPTSA9IGRvbTtcbiAgICAgIHJlZlRvcCA9IGxvY2FsUmVjdC50b3A7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4ge3JlZkRPTTogcmVmRE9NLCByZWZUb3A6IHJlZlRvcCwgc3RhY2s6IHNjcm9sbFN0YWNrKHZpZXcuZG9tKX1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsU3RhY2soZG9tKSB7XG4gIHZhciBzdGFjayA9IFtdLCBkb2MgPSBkb20ub3duZXJEb2N1bWVudDtcbiAgZm9yICg7IGRvbTsgZG9tID0gcGFyZW50Tm9kZShkb20pKSB7XG4gICAgc3RhY2sucHVzaCh7ZG9tOiBkb20sIHRvcDogZG9tLnNjcm9sbFRvcCwgbGVmdDogZG9tLnNjcm9sbExlZnR9KTtcbiAgICBpZiAoZG9tID09IGRvYykgeyBicmVhayB9XG4gIH1cbiAgcmV0dXJuIHN0YWNrXG59XG5cbi8vIFJlc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvcidzIHBhcmVudCBub2RlcyB0byB0aGF0IHdoYXRcbi8vIGl0IHdhcyBiZWZvcmUsIHdoZW4gc3RvcmVTY3JvbGxQb3Mgd2FzIGNhbGxlZC5cbmZ1bmN0aW9uIHJlc2V0U2Nyb2xsUG9zKHJlZikge1xuICB2YXIgcmVmRE9NID0gcmVmLnJlZkRPTTtcbiAgdmFyIHJlZlRvcCA9IHJlZi5yZWZUb3A7XG4gIHZhciBzdGFjayA9IHJlZi5zdGFjaztcblxuICB2YXIgbmV3UmVmVG9wID0gcmVmRE9NID8gcmVmRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IDA7XG4gIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgbmV3UmVmVG9wID09IDAgPyAwIDogbmV3UmVmVG9wIC0gcmVmVG9wKTtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZVNjcm9sbFN0YWNrKHN0YWNrLCBkVG9wKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVmID0gc3RhY2tbaV07XG4gICAgdmFyIGRvbSA9IHJlZi5kb207XG4gICAgdmFyIHRvcCA9IHJlZi50b3A7XG4gICAgdmFyIGxlZnQgPSByZWYubGVmdDtcbiAgICBpZiAoZG9tLnNjcm9sbFRvcCAhPSB0b3AgKyBkVG9wKSB7IGRvbS5zY3JvbGxUb3AgPSB0b3AgKyBkVG9wOyB9XG4gICAgaWYgKGRvbS5zY3JvbGxMZWZ0ICE9IGxlZnQpIHsgZG9tLnNjcm9sbExlZnQgPSBsZWZ0OyB9XG4gIH1cbn1cblxudmFyIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xuLy8gYSBmYWxsYmFjayBrbHVkZ2Ugd2hlbiBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZm9jdXNQcmV2ZW50U2Nyb2xsKGRvbSkge1xuICBpZiAoZG9tLnNldEFjdGl2ZSkgeyByZXR1cm4gZG9tLnNldEFjdGl2ZSgpIH0gLy8gaW4gSUVcbiAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHsgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB9XG5cbiAgdmFyIHN0b3JlZCA9IHNjcm9sbFN0YWNrKGRvbSk7XG4gIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0ge3ByZXZlbnRTY3JvbGw6IHRydWV9O1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0gOiB1bmRlZmluZWQpO1xuICBpZiAoIXByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHtcbiAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgcmVzdG9yZVNjcm9sbFN0YWNrKHN0b3JlZCwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZE9mZnNldEluTm9kZShub2RlLCBjb29yZHMpIHtcbiAgdmFyIGNsb3Nlc3QsIGR4Q2xvc2VzdCA9IDJlOCwgY29vcmRzQ2xvc2VzdCwgb2Zmc2V0ID0gMDtcbiAgdmFyIHJvd0JvdCA9IGNvb3Jkcy50b3AsIHJvd1RvcCA9IGNvb3Jkcy50b3A7XG4gIGZvciAodmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkLCBjaGlsZEluZGV4ID0gMDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcsIGNoaWxkSW5kZXgrKykge1xuICAgIHZhciByZWN0cyA9ICh2b2lkIDApO1xuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKSB7IHJlY3RzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTsgfVxuICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpIHsgcmVjdHMgPSB0ZXh0UmFuZ2UoY2hpbGQpLmdldENsaWVudFJlY3RzKCk7IH1cbiAgICBlbHNlIHsgY29udGludWUgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlY3QgPSByZWN0c1tpXTtcbiAgICAgIGlmIChyZWN0LnRvcCA8PSByb3dCb3QgJiYgcmVjdC5ib3R0b20gPj0gcm93VG9wKSB7XG4gICAgICAgIHJvd0JvdCA9IE1hdGgubWF4KHJlY3QuYm90dG9tLCByb3dCb3QpO1xuICAgICAgICByb3dUb3AgPSBNYXRoLm1pbihyZWN0LnRvcCwgcm93VG9wKTtcbiAgICAgICAgdmFyIGR4ID0gcmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgPyByZWN0LmxlZnQgLSBjb29yZHMubGVmdFxuICAgICAgICAgICAgOiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyBjb29yZHMubGVmdCAtIHJlY3QucmlnaHQgOiAwO1xuICAgICAgICBpZiAoZHggPCBkeENsb3Nlc3QpIHtcbiAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgZHhDbG9zZXN0ID0gZHg7XG4gICAgICAgICAgY29vcmRzQ2xvc2VzdCA9IGR4ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMyA/IHtsZWZ0OiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0LCB0b3A6IGNvb3Jkcy50b3B9IDogY29vcmRzO1xuICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxICYmIGR4KVxuICAgICAgICAgICAgeyBvZmZzZXQgPSBjaGlsZEluZGV4ICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCk7IH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNsb3Nlc3QgJiYgKGNvb3Jkcy5sZWZ0ID49IHJlY3QucmlnaHQgJiYgY29vcmRzLnRvcCA+PSByZWN0LnRvcCB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgJiYgY29vcmRzLnRvcCA+PSByZWN0LmJvdHRvbSkpXG4gICAgICAgIHsgb2Zmc2V0ID0gY2hpbGRJbmRleCArIDE7IH1cbiAgICB9XG4gIH1cbiAgaWYgKGNsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzKSB7IHJldHVybiBmaW5kT2Zmc2V0SW5UZXh0KGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpIH1cbiAgaWYgKCFjbG9zZXN0IHx8IChkeENsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAxKSkgeyByZXR1cm4ge25vZGU6IG5vZGUsIG9mZnNldDogb2Zmc2V0fSB9XG4gIHJldHVybiBmaW5kT2Zmc2V0SW5Ob2RlKGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpXG59XG5cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJblRleHQobm9kZSwgY29vcmRzKSB7XG4gIHZhciBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgaSArIDEpO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGkpO1xuICAgIHZhciByZWN0ID0gc2luZ2xlUmVjdChyYW5nZSwgMSk7XG4gICAgaWYgKHJlY3QudG9wID09IHJlY3QuYm90dG9tKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpXG4gICAgICB7IHJldHVybiB7bm9kZTogbm9kZSwgb2Zmc2V0OiBpICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCl9IH1cbiAgfVxuICByZXR1cm4ge25vZGU6IG5vZGUsIG9mZnNldDogMH1cbn1cblxuZnVuY3Rpb24gaW5SZWN0KGNvb3JkcywgcmVjdCkge1xuICByZXR1cm4gY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0IC0gMSAmJiBjb29yZHMubGVmdCA8PSByZWN0LnJpZ2h0ICsgMSYmXG4gICAgY29vcmRzLnRvcCA+PSByZWN0LnRvcCAtIDEgJiYgY29vcmRzLnRvcCA8PSByZWN0LmJvdHRvbSArIDFcbn1cblxuZnVuY3Rpb24gdGFyZ2V0S2x1ZGdlKGRvbSwgY29vcmRzKSB7XG4gIHZhciBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiAvXmxpJC9pLnRlc3QocGFyZW50Lm5vZGVOYW1lKSAmJiBjb29yZHMubGVmdCA8IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KVxuICAgIHsgcmV0dXJuIHBhcmVudCB9XG4gIHJldHVybiBkb21cbn1cblxuZnVuY3Rpb24gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpIHtcbiAgdmFyIHJlZiA9IGZpbmRPZmZzZXRJbk5vZGUoZWx0LCBjb29yZHMpO1xuICB2YXIgbm9kZSA9IHJlZi5ub2RlO1xuICB2YXIgb2Zmc2V0ID0gcmVmLm9mZnNldDtcbiAgdmFyIGJpYXMgPSAtMTtcbiAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiAhbm9kZS5maXJzdENoaWxkKSB7XG4gICAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGJpYXMgPSByZWN0LmxlZnQgIT0gcmVjdC5yaWdodCAmJiBjb29yZHMubGVmdCA+IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcylcbn1cblxuZnVuY3Rpb24gcG9zRnJvbUNhcmV0KHZpZXcsIG5vZGUsIG9mZnNldCwgY29vcmRzKSB7XG4gIC8vIEJyb3dzZXIgKGluIGNhcmV0UG9zaXRpb24vUmFuZ2VGcm9tUG9pbnQpIHdpbGwgYWdyZXNzaXZlbHlcbiAgLy8gbm9ybWFsaXplIHRvd2FyZHMgbmVhcmJ5IGlubGluZSBub2Rlcy4gU2luY2Ugd2UgYXJlIGludGVyZXN0ZWQgaW5cbiAgLy8gcG9zaXRpb25zIGJldHdlZW4gYmxvY2sgbm9kZXMgdG9vLCB3ZSBmaXJzdCB3YWxrIHVwIHRoZSBoaWVyYXJjaHlcbiAgLy8gb2Ygbm9kZXMgdG8gc2VlIGlmIHRoZXJlIGFyZSBibG9jayBub2RlcyB0aGF0IHRoZSBjb29yZGluYXRlc1xuICAvLyBmYWxsIG91dHNpZGUgb2YuIElmIHNvLCB3ZSB0YWtlIHRoZSBwb3NpdGlvbiBiZWZvcmUvYWZ0ZXIgdGhhdFxuICAvLyBibG9jay4gSWYgbm90LCB3ZSBjYWxsIGBwb3NGcm9tRE9NYCBvbiB0aGUgcmF3IG5vZGUvb2Zmc2V0LlxuICB2YXIgb3V0c2lkZSA9IC0xO1xuICBmb3IgKHZhciBjdXIgPSBub2RlOzspIHtcbiAgICBpZiAoY3VyID09IHZpZXcuZG9tKSB7IGJyZWFrIH1cbiAgICB2YXIgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjdXIsIHRydWUpO1xuICAgIGlmICghZGVzYykgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50KSB7XG4gICAgICB2YXIgcmVjdCA9IGRlc2MuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0IHx8IHJlY3QudG9wID4gY29vcmRzLnRvcCkgeyBvdXRzaWRlID0gZGVzYy5wb3NCZWZvcmU7IH1cbiAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCB8fCByZWN0LmJvdHRvbSA8IGNvb3Jkcy50b3ApIHsgb3V0c2lkZSA9IGRlc2MucG9zQWZ0ZXI7IH1cbiAgICAgIGVsc2UgeyBicmVhayB9XG4gICAgfVxuICAgIGN1ciA9IGRlc2MuZG9tLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG91dHNpZGUgPiAtMSA/IG91dHNpZGUgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRGcm9tUG9pbnQoZWxlbWVudCwgY29vcmRzLCBib3gpIHtcbiAgdmFyIGxlbiA9IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7XG4gIGlmIChsZW4gJiYgYm94LnRvcCA8IGJveC5ib3R0b20pIHtcbiAgICBmb3IgKHZhciBzdGFydEkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsZW4gLSAxLCBNYXRoLmZsb29yKGxlbiAqIChjb29yZHMudG9wIC0gYm94LnRvcCkgLyAoYm94LmJvdHRvbSAtIGJveC50b3ApKSAtIDIpKSwgaSA9IHN0YXJ0STs7KSB7XG4gICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICB2YXIgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpIHsgcmV0dXJuIGVsZW1lbnRGcm9tUG9pbnQoY2hpbGQsIGNvb3JkcywgcmVjdCkgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKGkgPSAoaSArIDEpICUgbGVuKSA9PSBzdGFydEkpIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudFxufVxuXG4vLyBHaXZlbiBhbiB4LHkgcG9zaXRpb24gb24gdGhlIGVkaXRvciwgZ2V0IHRoZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCBjb29yZHMpIHtcbiAgdmFyIGFzc2lnbiwgYXNzaWduJDE7XG5cbiAgdmFyIGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQsIG5vZGUsIG9mZnNldDtcbiAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgdHJ5IHsgLy8gRmlyZWZveCB0aHJvd3MgZm9yIHRoaXMgY2FsbCBpbiBoYXJkLXRvLXByZWRpY3QgY2lyY3Vtc3RhbmNlcyAoIzk5NClcbiAgICAgIHZhciBwb3MkMSA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICAgIGlmIChwb3MkMSkgeyAoKGFzc2lnbiA9IHBvcyQxLCBub2RlID0gYXNzaWduLm9mZnNldE5vZGUsIG9mZnNldCA9IGFzc2lnbi5vZmZzZXQpKTsgfVxuICAgIH0gY2F0Y2ggKF8pIHt9XG4gIH1cbiAgaWYgKCFub2RlICYmIGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgdmFyIHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xuICAgIGlmIChyYW5nZSkgeyAoKGFzc2lnbiQxID0gcmFuZ2UsIG5vZGUgPSBhc3NpZ24kMS5zdGFydENvbnRhaW5lciwgb2Zmc2V0ID0gYXNzaWduJDEuc3RhcnRPZmZzZXQpKTsgfVxuICB9XG5cbiAgdmFyIGVsdCA9ICh2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCA/IHZpZXcucm9vdCA6IGRvYykuZWxlbWVudEZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCArIDEpLCBwb3M7XG4gIGlmICghZWx0IHx8ICF2aWV3LmRvbS5jb250YWlucyhlbHQubm9kZVR5cGUgIT0gMSA/IGVsdC5wYXJlbnROb2RlIDogZWx0KSkge1xuICAgIHZhciBib3ggPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIWluUmVjdChjb29yZHMsIGJveCkpIHsgcmV0dXJuIG51bGwgfVxuICAgIGVsdCA9IGVsZW1lbnRGcm9tUG9pbnQodmlldy5kb20sIGNvb3JkcywgYm94KTtcbiAgICBpZiAoIWVsdCkgeyByZXR1cm4gbnVsbCB9XG4gIH1cbiAgLy8gU2FmYXJpJ3MgY2FyZXRSYW5nZUZyb21Qb2ludCByZXR1cm5zIG5vbnNlbnNlIHdoZW4gb24gYSBkcmFnZ2FibGUgZWxlbWVudFxuICBpZiAocmVzdWx0LnNhZmFyaSkge1xuICAgIGZvciAodmFyIHAgPSBlbHQ7IG5vZGUgJiYgcDsgcCA9IHBhcmVudE5vZGUocCkpXG4gICAgICB7IGlmIChwLmRyYWdnYWJsZSkgeyBub2RlID0gb2Zmc2V0ID0gbnVsbDsgfSB9XG4gIH1cbiAgZWx0ID0gdGFyZ2V0S2x1ZGdlKGVsdCwgY29vcmRzKTtcbiAgaWYgKG5vZGUpIHtcbiAgICBpZiAocmVzdWx0LmdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgLy8gRmlyZWZveCB3aWxsIHNvbWV0aW1lcyByZXR1cm4gb2Zmc2V0cyBpbnRvIDxpbnB1dD4gbm9kZXMsIHdoaWNoXG4gICAgICAvLyBoYXZlIG5vIGFjdHVhbCBjaGlsZHJlbiwgZnJvbSBjYXJldFBvc2l0aW9uRnJvbVBvaW50ICgjOTUzKVxuICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgIC8vIEl0J2xsIGFsc28gbW92ZSB0aGUgcmV0dXJuZWQgcG9zaXRpb24gYmVmb3JlIGltYWdlIG5vZGVzLFxuICAgICAgLy8gZXZlbiBpZiB0aG9zZSBhcmUgYmVoaW5kIGl0LlxuICAgICAgaWYgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSwgYm94JDE7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVOYW1lID09IFwiSU1HXCIgJiYgKGJveCQxID0gbmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkucmlnaHQgPD0gY29vcmRzLmxlZnQgJiZcbiAgICAgICAgICAgIGJveCQxLmJvdHRvbSA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgeyBvZmZzZXQrKzsgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBTdXNwaWNpb3VzbHkgc3BlY2lmaWMga2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGNhcmV0KkZyb21Qb2ludFxuICAgIC8vIG5ldmVyIHJldHVybmluZyBhIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgaWYgKG5vZGUgPT0gdmlldy5kb20gJiYgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxICYmIG5vZGUubGFzdENoaWxkLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgY29vcmRzLnRvcCA+IG5vZGUubGFzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSlcbiAgICAgIHsgcG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplOyB9XG4gICAgLy8gSWdub3JlIHBvc2l0aW9ucyBkaXJlY3RseSBhZnRlciBhIEJSLCBzaW5jZSBjYXJldCpGcm9tUG9pbnRcbiAgICAvLyAncm91bmQgdXAnIHBvc2l0aW9ucyB0aGF0IHdvdWxkIGJlIG1vcmUgYWNjdXJhdGVseSBwbGFjZWRcbiAgICAvLyBiZWZvcmUgdGhlIEJSIG5vZGUuXG4gICAgZWxzZSBpZiAob2Zmc2V0ID09IDAgfHwgbm9kZS5ub2RlVHlwZSAhPSAxIHx8IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICB7IHBvcyA9IHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcyk7IH1cbiAgfVxuICBpZiAocG9zID09IG51bGwpIHsgcG9zID0gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpOyB9XG5cbiAgdmFyIGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZWx0LCB0cnVlKTtcbiAgcmV0dXJuIHtwb3M6IHBvcywgaW5zaWRlOiBkZXNjID8gZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIgOiAtMX1cbn1cblxuZnVuY3Rpb24gc2luZ2xlUmVjdChvYmplY3QsIGJpYXMpIHtcbiAgdmFyIHJlY3RzID0gb2JqZWN0LmdldENsaWVudFJlY3RzKCk7XG4gIHJldHVybiAhcmVjdHMubGVuZ3RoID8gb2JqZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogcmVjdHNbYmlhcyA8IDAgPyAwIDogcmVjdHMubGVuZ3RoIC0gMV1cbn1cblxudmFyIEJJREkgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY10vO1xuXG4vLyA6IChFZGl0b3JWaWV3LCBudW1iZXIsIG51bWJlcikg4oaSIHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlcn1cbi8vIEdpdmVuIGEgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50IG1vZGVsLCBnZXQgYSBib3VuZGluZyBib3ggb2YgdGhlXG4vLyBjaGFyYWN0ZXIgYXQgdGhhdCBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIHdpbmRvdy5cbmZ1bmN0aW9uIGNvb3Jkc0F0UG9zKHZpZXcsIHBvcywgc2lkZSkge1xuICB2YXIgcmVmID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlIDwgMCA/IC0xIDogMSk7XG4gIHZhciBub2RlID0gcmVmLm5vZGU7XG4gIHZhciBvZmZzZXQgPSByZWYub2Zmc2V0O1xuXG4gIHZhciBzdXBwb3J0RW1wdHlSYW5nZSA9IHJlc3VsdC53ZWJraXQgfHwgcmVzdWx0LmdlY2tvO1xuICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgLy8gVGhlc2UgYnJvd3NlcnMgc3VwcG9ydCBxdWVyeWluZyBlbXB0eSB0ZXh0IHJhbmdlcy4gUHJlZmVyIHRoYXQgaW5cbiAgICAvLyBiaWRpIGNvbnRleHQgb3Igd2hlbiBhdCB0aGUgZW5kIG9mIGEgbm9kZS5cbiAgICBpZiAoc3VwcG9ydEVtcHR5UmFuZ2UgJiYgKEJJREkudGVzdChub2RlLm5vZGVWYWx1ZSkgfHwgKHNpZGUgPCAwID8gIW9mZnNldCA6IG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKSkge1xuICAgICAgdmFyIHJlY3QgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCksIHNpZGUpO1xuICAgICAgLy8gRmlyZWZveCByZXR1cm5zIGJhZCByZXN1bHRzICh0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBzcGFjZSlcbiAgICAgIC8vIHdoZW4gcXVlcnlpbmcgYSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciBsaW5lLWJyb2tlblxuICAgICAgLy8gd2hpdGVzcGFjZS4gRGV0ZWN0IHRoaXMgc2l0dWF0aW9uIGFuZCBhbmQga2x1ZGdlIGFyb3VuZCBpdFxuICAgICAgaWYgKHJlc3VsdC5nZWNrbyAmJiBvZmZzZXQgJiYgL1xccy8udGVzdChub2RlLm5vZGVWYWx1ZVtvZmZzZXQgLSAxXSkgJiYgb2Zmc2V0IDwgbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZWN0QmVmb3JlID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0IC0gMSwgb2Zmc2V0IC0gMSksIC0xKTtcbiAgICAgICAgaWYgKHJlY3RCZWZvcmUudG9wID09IHJlY3QudG9wKSB7XG4gICAgICAgICAgdmFyIHJlY3RBZnRlciA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0ICsgMSksIC0xKTtcbiAgICAgICAgICBpZiAocmVjdEFmdGVyLnRvcCAhPSByZWN0LnRvcClcbiAgICAgICAgICAgIHsgcmV0dXJuIGZsYXR0ZW5WKHJlY3RBZnRlciwgcmVjdEFmdGVyLmxlZnQgPCByZWN0QmVmb3JlLmxlZnQpIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlY3RcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZyb20gPSBvZmZzZXQsIHRvID0gb2Zmc2V0LCB0YWtlU2lkZSA9IHNpZGUgPCAwID8gMSA6IC0xO1xuICAgICAgaWYgKHNpZGUgPCAwICYmICFvZmZzZXQpIHsgdG8rKzsgdGFrZVNpZGUgPSAtMTsgfVxuICAgICAgZWxzZSBpZiAoc2lkZSA+PSAwICYmIG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHsgZnJvbS0tOyB0YWtlU2lkZSA9IDE7IH1cbiAgICAgIGVsc2UgaWYgKHNpZGUgPCAwKSB7IGZyb20tLTsgfVxuICAgICAgZWxzZSB7IHRvICsrOyB9XG4gICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8pLCB0YWtlU2lkZSksIHRha2VTaWRlIDwgMClcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gYSBob3Jpem9udGFsIGxpbmUgaW4gYmxvY2sgY29udGV4dFxuICBpZiAoIXZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgIGlmIChvZmZzZXQgJiYgKHNpZGUgPCAwIHx8IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKSkpIHtcbiAgICAgIHZhciBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDEpIHsgcmV0dXJuIGZsYXR0ZW5IKGJlZm9yZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZmFsc2UpIH1cbiAgICB9XG4gICAgaWYgKG9mZnNldCA8IG5vZGVTaXplKG5vZGUpKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgIGlmIChhZnRlci5ub2RlVHlwZSA9PSAxKSB7IHJldHVybiBmbGF0dGVuSChhZnRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJ1ZSkgfVxuICAgIH1cbiAgICByZXR1cm4gZmxhdHRlbkgobm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc2lkZSA+PSAwKVxuICB9XG5cbiAgLy8gSW5saW5lLCBub3QgaW4gdGV4dCBub2RlICh0aGlzIGlzIG5vdCBCaWRpLXNhZmUpXG4gIGlmIChvZmZzZXQgJiYgKHNpZGUgPCAwIHx8IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKSkpIHtcbiAgICB2YXIgYmVmb3JlJDEgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgdmFyIHRhcmdldCA9IGJlZm9yZSQxLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYmVmb3JlJDEsIG5vZGVTaXplKGJlZm9yZSQxKSAtIChzdXBwb3J0RW1wdHlSYW5nZSA/IDAgOiAxKSlcbiAgICAgICAgLy8gQlIgbm9kZXMgdGVuZCB0byBvbmx5IHJldHVybiB0aGUgcmVjdGFuZ2xlIGJlZm9yZSB0aGVtLlxuICAgICAgICAvLyBPbmx5IHVzZSB0aGVtIGlmIHRoZXkgYXJlIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlaXIgcGFyZW50XG4gICAgICAgIDogYmVmb3JlJDEubm9kZVR5cGUgPT0gMSAmJiAoYmVmb3JlJDEubm9kZU5hbWUgIT0gXCJCUlwiIHx8ICFiZWZvcmUkMS5uZXh0U2libGluZykgPyBiZWZvcmUkMSA6IG51bGw7XG4gICAgaWYgKHRhcmdldCkgeyByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIDEpLCBmYWxzZSkgfVxuICB9XG4gIGlmIChvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgIHZhciBhZnRlciQxID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgd2hpbGUgKGFmdGVyJDEucG1WaWV3RGVzYyAmJiBhZnRlciQxLnBtVmlld0Rlc2MuaWdub3JlRm9yQ29vcmRzKSB7IGFmdGVyJDEgPSBhZnRlciQxLm5leHRTaWJsaW5nOyB9XG4gICAgdmFyIHRhcmdldCQxID0gIWFmdGVyJDEgPyBudWxsIDogYWZ0ZXIkMS5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKGFmdGVyJDEsIDAsIChzdXBwb3J0RW1wdHlSYW5nZSA/IDAgOiAxKSlcbiAgICAgICAgOiBhZnRlciQxLm5vZGVUeXBlID09IDEgPyBhZnRlciQxIDogbnVsbDtcbiAgICBpZiAodGFyZ2V0JDEpIHsgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3QodGFyZ2V0JDEsIC0xKSwgdHJ1ZSkgfVxuICB9XG4gIC8vIEFsbCBlbHNlIGZhaWxlZCwganVzdCB0cnkgdG8gZ2V0IGEgcmVjdGFuZ2xlIGZvciB0aGUgdGFyZ2V0IG5vZGVcbiAgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3Qobm9kZS5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKG5vZGUpIDogbm9kZSwgLXNpZGUpLCBzaWRlID49IDApXG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5WKHJlY3QsIGxlZnQpIHtcbiAgaWYgKHJlY3Qud2lkdGggPT0gMCkgeyByZXR1cm4gcmVjdCB9XG4gIHZhciB4ID0gbGVmdCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gIHJldHVybiB7dG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LmJvdHRvbSwgbGVmdDogeCwgcmlnaHQ6IHh9XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5IKHJlY3QsIHRvcCkge1xuICBpZiAocmVjdC5oZWlnaHQgPT0gMCkgeyByZXR1cm4gcmVjdCB9XG4gIHZhciB5ID0gdG9wID8gcmVjdC50b3AgOiByZWN0LmJvdHRvbTtcbiAgcmV0dXJuIHt0b3A6IHksIGJvdHRvbTogeSwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodH1cbn1cblxuZnVuY3Rpb24gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZikge1xuICB2YXIgdmlld1N0YXRlID0gdmlldy5zdGF0ZSwgYWN0aXZlID0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpIHsgdmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7IH1cbiAgaWYgKGFjdGl2ZSAhPSB2aWV3LmRvbSkgeyB2aWV3LmZvY3VzKCk7IH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZigpXG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHZpZXdTdGF0ZSAhPSBzdGF0ZSkgeyB2aWV3LnVwZGF0ZVN0YXRlKHZpZXdTdGF0ZSk7IH1cbiAgICBpZiAoYWN0aXZlICE9IHZpZXcuZG9tICYmIGFjdGl2ZSkgeyBhY3RpdmUuZm9jdXMoKTsgfVxuICB9XG59XG5cbi8vIDogKEVkaXRvclZpZXcsIG51bWJlciwgbnVtYmVyKVxuLy8gV2hldGhlciB2ZXJ0aWNhbCBwb3NpdGlvbiBtb3Rpb24gaW4gYSBnaXZlbiBkaXJlY3Rpb25cbi8vIGZyb20gYSBwb3NpdGlvbiB3b3VsZCBsZWF2ZSBhIHRleHQgYmxvY2suXG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgdmFyIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyICRwb3MgPSBkaXIgPT0gXCJ1cFwiID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MoJHBvcy5wb3MsIGRpciA9PSBcInVwXCIgPyAtMSA6IDEpO1xuICAgIHZhciBkb20gPSByZWYubm9kZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgbmVhcmVzdCA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhkb20sIHRydWUpO1xuICAgICAgaWYgKCFuZWFyZXN0KSB7IGJyZWFrIH1cbiAgICAgIGlmIChuZWFyZXN0Lm5vZGUuaXNCbG9jaykgeyBkb20gPSBuZWFyZXN0LmRvbTsgYnJlYWsgfVxuICAgICAgZG9tID0gbmVhcmVzdC5kb20ucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgdmFyIGNvb3JkcyA9IGNvb3Jkc0F0UG9zKHZpZXcsICRwb3MucG9zLCAxKTtcbiAgICBmb3IgKHZhciBjaGlsZCA9IGRvbS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgdmFyIGJveGVzID0gKHZvaWQgMCk7XG4gICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSkgeyBib3hlcyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7IH1cbiAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpIHsgYm94ZXMgPSB0ZXh0UmFuZ2UoY2hpbGQsIDAsIGNoaWxkLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7IH1cbiAgICAgIGVsc2UgeyBjb250aW51ZSB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgaWYgKGJveC5ib3R0b20gPiBib3gudG9wICsgMSAmJlxuICAgICAgICAgICAgKGRpciA9PSBcInVwXCIgPyBjb29yZHMudG9wIC0gYm94LnRvcCA+IChib3guYm90dG9tIC0gY29vcmRzLnRvcCkgKiAyXG4gICAgICAgICAgICAgOiBib3guYm90dG9tIC0gY29vcmRzLmJvdHRvbSA+IChjb29yZHMuYm90dG9tIC0gYm94LnRvcCkgKiAyKSlcbiAgICAgICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH0pXG59XG5cbnZhciBtYXliZVJUTCA9IC9bXFx1MDU5MC1cXHUwOGFjXS87XG5cbmZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrSG9yaXpvbnRhbCh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIHZhciAkaGVhZCA9IHJlZi4kaGVhZDtcbiAgaWYgKCEkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIG9mZnNldCA9ICRoZWFkLnBhcmVudE9mZnNldCwgYXRTdGFydCA9ICFvZmZzZXQsIGF0RW5kID0gb2Zmc2V0ID09ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemU7XG4gIHZhciBzZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIC8vIElmIHRoZSB0ZXh0YmxvY2sgaXMgYWxsIExUUiwgb3IgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0XG4gIC8vIFNlbGVjdGlvbi5tb2RpZnkgKEVkZ2UpLCBmYWxsIGJhY2sgdG8gYSBwcmltaXRpdmUgYXBwcm9hY2hcbiAgaWYgKCFtYXliZVJUTC50ZXN0KCRoZWFkLnBhcmVudC50ZXh0Q29udGVudCkgfHwgIXNlbC5tb2RpZnkpXG4gICAgeyByZXR1cm4gZGlyID09IFwibGVmdFwiIHx8IGRpciA9PSBcImJhY2t3YXJkXCIgPyBhdFN0YXJ0IDogYXRFbmQgfVxuXG4gIHJldHVybiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhpcyBpcyBhIGh1Z2UgaGFjaywgYnV0IGFwcGVhcnMgdG8gYmUgdGhlIGJlc3Qgd2UgY2FuXG4gICAgLy8gY3VycmVudGx5IGRvOiB1c2UgYFNlbGVjdGlvbi5tb2RpZnlgIHRvIG1vdmUgdGhlIHNlbGVjdGlvbiBieVxuICAgIC8vIG9uZSBjaGFyYWN0ZXIsIGFuZCBzZWUgaWYgdGhhdCBtb3ZlcyB0aGUgY3Vyc29yIG91dCBvZiB0aGVcbiAgICAvLyB0ZXh0YmxvY2sgKG9yIGRvZXNuJ3QgbW92ZSBpdCBhdCBhbGwsIHdoZW4gYXQgdGhlIHN0YXJ0L2VuZCBvZlxuICAgIC8vIHRoZSBkb2N1bWVudCkuXG4gICAgdmFyIG9sZFJhbmdlID0gc2VsLmdldFJhbmdlQXQoMCksIG9sZE5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvbGRPZmYgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgdmFyIG9sZEJpZGlMZXZlbCA9IHNlbC5jYXJldEJpZGlMZXZlbDsgLy8gT25seSBmb3IgRmlyZWZveFxuICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGRpciwgXCJjaGFyYWN0ZXJcIik7XG4gICAgdmFyIHBhcmVudERPTSA9ICRoZWFkLmRlcHRoID8gdmlldy5kb2NWaWV3LmRvbUFmdGVyUG9zKCRoZWFkLmJlZm9yZSgpKSA6IHZpZXcuZG9tO1xuICAgIHZhciByZXN1bHQgPSAhcGFyZW50RE9NLmNvbnRhaW5zKHNlbC5mb2N1c05vZGUubm9kZVR5cGUgPT0gMSA/IHNlbC5mb2N1c05vZGUgOiBzZWwuZm9jdXNOb2RlLnBhcmVudE5vZGUpIHx8XG4gICAgICAgIChvbGROb2RlID09IHNlbC5mb2N1c05vZGUgJiYgb2xkT2ZmID09IHNlbC5mb2N1c09mZnNldCk7XG4gICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShvbGRSYW5nZSk7XG4gICAgaWYgKG9sZEJpZGlMZXZlbCAhPSBudWxsKSB7IHNlbC5jYXJldEJpZGlMZXZlbCA9IG9sZEJpZGlMZXZlbDsgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSlcbn1cblxudmFyIGNhY2hlZFN0YXRlID0gbnVsbCwgY2FjaGVkRGlyID0gbnVsbCwgY2FjaGVkUmVzdWx0ID0gZmFsc2U7XG5mdW5jdGlvbiBlbmRPZlRleHRibG9jayh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gIGlmIChjYWNoZWRTdGF0ZSA9PSBzdGF0ZSAmJiBjYWNoZWREaXIgPT0gZGlyKSB7IHJldHVybiBjYWNoZWRSZXN1bHQgfVxuICBjYWNoZWRTdGF0ZSA9IHN0YXRlOyBjYWNoZWREaXIgPSBkaXI7XG4gIHJldHVybiBjYWNoZWRSZXN1bHQgPSBkaXIgPT0gXCJ1cFwiIHx8IGRpciA9PSBcImRvd25cIlxuICAgID8gZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCh2aWV3LCBzdGF0ZSwgZGlyKVxuICAgIDogZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpXG59XG5cbi8vIE5vZGVWaWV3OjogaW50ZXJmYWNlXG4vL1xuLy8gQnkgZGVmYXVsdCwgZG9jdW1lbnQgbm9kZXMgYXJlIHJlbmRlcmVkIHVzaW5nIHRoZSByZXN1bHQgb2YgdGhlXG4vLyBbYHRvRE9NYF0oI21vZGVsLk5vZGVTcGVjLnRvRE9NKSBtZXRob2Qgb2YgdGhlaXIgc3BlYywgYW5kIG1hbmFnZWRcbi8vIGVudGlyZWx5IGJ5IHRoZSBlZGl0b3IuIEZvciBzb21lIHVzZSBjYXNlcywgc3VjaCBhcyBlbWJlZGRlZFxuLy8gbm9kZS1zcGVjaWZpYyBlZGl0aW5nIGludGVyZmFjZXMsIHlvdSB3YW50IG1vcmUgY29udHJvbCBvdmVyXG4vLyB0aGUgYmVoYXZpb3Igb2YgYSBub2RlJ3MgaW4tZWRpdG9yIHJlcHJlc2VudGF0aW9uLCBhbmQgbmVlZCB0b1xuLy8gW2RlZmluZV0oI3ZpZXcuRWRpdG9yUHJvcHMubm9kZVZpZXdzKSBhIGN1c3RvbSBub2RlIHZpZXcuXG4vL1xuLy8gTWFyayB2aWV3cyBvbmx5IHN1cHBvcnQgYGRvbWAgYW5kIGBjb250ZW50RE9NYCwgYW5kIGRvbid0IHN1cHBvcnRcbi8vIGFueSBvZiB0aGUgbm9kZSB2aWV3IG1ldGhvZHMuXG4vL1xuLy8gT2JqZWN0cyByZXR1cm5lZCBhcyBub2RlIHZpZXdzIG11c3QgY29uZm9ybSB0byB0aGlzIGludGVyZmFjZS5cbi8vXG4vLyAgIGRvbTo6ID9kb20uTm9kZVxuLy8gICBUaGUgb3V0ZXIgRE9NIG5vZGUgdGhhdCByZXByZXNlbnRzIHRoZSBkb2N1bWVudCBub2RlLiBXaGVuIG5vdFxuLy8gICBnaXZlbiwgdGhlIGRlZmF1bHQgc3RyYXRlZ3kgaXMgdXNlZCB0byBjcmVhdGUgYSBET00gbm9kZS5cbi8vXG4vLyAgIGNvbnRlbnRET006OiA/ZG9tLk5vZGVcbi8vICAgVGhlIERPTSBub2RlIHRoYXQgc2hvdWxkIGhvbGQgdGhlIG5vZGUncyBjb250ZW50LiBPbmx5IG1lYW5pbmdmdWxcbi8vICAgaWYgdGhlIG5vZGUgdmlldyBhbHNvIGRlZmluZXMgYSBgZG9tYCBwcm9wZXJ0eSBhbmQgaWYgaXRzIG5vZGVcbi8vICAgdHlwZSBpcyBub3QgYSBsZWFmIG5vZGUgdHlwZS4gV2hlbiB0aGlzIGlzIHByZXNlbnQsIFByb3NlTWlycm9yXG4vLyAgIHdpbGwgdGFrZSBjYXJlIG9mIHJlbmRlcmluZyB0aGUgbm9kZSdzIGNoaWxkcmVuIGludG8gaXQuIFdoZW4gaXRcbi8vICAgaXMgbm90IHByZXNlbnQsIHRoZSBub2RlIHZpZXcgaXRzZWxmIGlzIHJlc3BvbnNpYmxlIGZvciByZW5kZXJpbmdcbi8vICAgKG9yIGRlY2lkaW5nIG5vdCB0byByZW5kZXIpIGl0cyBjaGlsZCBub2Rlcy5cbi8vXG4vLyAgIHVwZGF0ZTo6ID8obm9kZTogTm9kZSwgZGVjb3JhdGlvbnM6IFtEZWNvcmF0aW9uXSwgaW5uZXJEZWNvcmF0aW9uczogRGVjb3JhdGlvblNvdXJjZSkg4oaSIGJvb2xcbi8vICAgV2hlbiBnaXZlbiwgdGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB2aWV3IGlzIHVwZGF0aW5nIGl0c2VsZi5cbi8vICAgSXQgd2lsbCBiZSBnaXZlbiBhIG5vZGUgKHBvc3NpYmx5IG9mIGEgZGlmZmVyZW50IHR5cGUpLCBhbiBhcnJheVxuLy8gICBvZiBhY3RpdmUgZGVjb3JhdGlvbnMgYXJvdW5kIHRoZSBub2RlICh3aGljaCBhcmUgYXV0b21hdGljYWxseVxuLy8gICBkcmF3biwgYW5kIHRoZSBub2RlIHZpZXcgbWF5IGlnbm9yZSBpZiBpdCBpc24ndCBpbnRlcmVzdGVkIGluXG4vLyAgIHRoZW0pLCBhbmQgYSBbZGVjb3JhdGlvbiBzb3VyY2VdKCN2aWV3LkRlY29yYXRpb25Tb3VyY2UpIHRoYXRcbi8vICAgcmVwcmVzZW50cyBhbnkgZGVjb3JhdGlvbnMgdGhhdCBhcHBseSB0byB0aGUgY29udGVudCBvZiB0aGUgbm9kZVxuLy8gICAod2hpY2ggYWdhaW4gbWF5IGJlIGlnbm9yZWQpLiBJdCBzaG91bGQgcmV0dXJuIHRydWUgaWYgaXQgd2FzXG4vLyAgIGFibGUgdG8gdXBkYXRlIHRvIHRoYXQgbm9kZSwgYW5kIGZhbHNlIG90aGVyd2lzZS4gSWYgdGhlIG5vZGVcbi8vICAgdmlldyBoYXMgYSBgY29udGVudERPTWAgcHJvcGVydHkgKG9yIG5vIGBkb21gIHByb3BlcnR5KSwgdXBkYXRpbmdcbi8vICAgaXRzIGNoaWxkIG5vZGVzIHdpbGwgYmUgaGFuZGxlZCBieSBQcm9zZU1pcnJvci5cbi8vXG4vLyAgIHNlbGVjdE5vZGU6OiA/KClcbi8vICAgQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIHdheSB0aGUgbm9kZSdzIHNlbGVjdGVkIHN0YXR1cyAoYXMgYVxuLy8gICBub2RlIHNlbGVjdGlvbikgaXMgZGlzcGxheWVkLlxuLy9cbi8vICAgZGVzZWxlY3ROb2RlOjogPygpXG4vLyAgIFdoZW4gZGVmaW5pbmcgYSBgc2VsZWN0Tm9kZWAgbWV0aG9kLCB5b3Ugc2hvdWxkIGFsc28gcHJvdmlkZSBhXG4vLyAgIGBkZXNlbGVjdE5vZGVgIG1ldGhvZCB0byByZW1vdmUgdGhlIGVmZmVjdCBhZ2Fpbi5cbi8vXG4vLyAgIHNldFNlbGVjdGlvbjo6ID8oYW5jaG9yOiBudW1iZXIsIGhlYWQ6IG51bWJlciwgcm9vdDogZG9tLkRvY3VtZW50KVxuLy8gICBUaGlzIHdpbGwgYmUgY2FsbGVkIHRvIGhhbmRsZSBzZXR0aW5nIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZVxuLy8gICBub2RlLiBUaGUgYGFuY2hvcmAgYW5kIGBoZWFkYCBwb3NpdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydFxuLy8gICBvZiB0aGUgbm9kZS4gQnkgZGVmYXVsdCwgYSBET00gc2VsZWN0aW9uIHdpbGwgYmUgY3JlYXRlZCBiZXR3ZWVuXG4vLyAgIHRoZSBET00gcG9zaXRpb25zIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2UgcG9zaXRpb25zLCBidXQgaWYgeW91XG4vLyAgIG92ZXJyaWRlIGl0IHlvdSBjYW4gZG8gc29tZXRoaW5nIGVsc2UuXG4vL1xuLy8gICBzdG9wRXZlbnQ6OiA/KGV2ZW50OiBkb20uRXZlbnQpIOKGkiBib29sXG4vLyAgIENhbiBiZSB1c2VkIHRvIHByZXZlbnQgdGhlIGVkaXRvciB2aWV3IGZyb20gdHJ5aW5nIHRvIGhhbmRsZSBzb21lXG4vLyAgIG9yIGFsbCBET00gZXZlbnRzIHRoYXQgYnViYmxlIHVwIGZyb20gdGhlIG5vZGUgdmlldy4gRXZlbnRzIGZvclxuLy8gICB3aGljaCB0aGlzIHJldHVybnMgdHJ1ZSBhcmUgbm90IGhhbmRsZWQgYnkgdGhlIGVkaXRvci5cbi8vXG4vLyAgIGlnbm9yZU11dGF0aW9uOjogPyhkb20uTXV0YXRpb25SZWNvcmQpIOKGkiBib29sXG4vLyAgIENhbGxlZCB3aGVuIGEgRE9NXG4vLyAgIFttdXRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL011dGF0aW9uT2JzZXJ2ZXIpXG4vLyAgIG9yIGEgc2VsZWN0aW9uIGNoYW5nZSBoYXBwZW5zIHdpdGhpbiB0aGUgdmlldy4gV2hlbiB0aGUgY2hhbmdlIGlzXG4vLyAgIGEgc2VsZWN0aW9uIGNoYW5nZSwgdGhlIHJlY29yZCB3aWxsIGhhdmUgYSBgdHlwZWAgcHJvcGVydHkgb2Zcbi8vICAgYFwic2VsZWN0aW9uXCJgICh3aGljaCBkb2Vzbid0IG9jY3VyIGZvciBuYXRpdmUgbXV0YXRpb24gcmVjb3JkcykuXG4vLyAgIFJldHVybiBmYWxzZSBpZiB0aGUgZWRpdG9yIHNob3VsZCByZS1yZWFkIHRoZSBzZWxlY3Rpb24gb3Jcbi8vICAgcmUtcGFyc2UgdGhlIHJhbmdlIGFyb3VuZCB0aGUgbXV0YXRpb24sIHRydWUgaWYgaXQgY2FuIHNhZmVseSBiZVxuLy8gICBpZ25vcmVkLlxuLy9cbi8vICAgZGVzdHJveTo6ID8oKVxuLy8gICBDYWxsZWQgd2hlbiB0aGUgbm9kZSB2aWV3IGlzIHJlbW92ZWQgZnJvbSB0aGUgZWRpdG9yIG9yIHRoZSB3aG9sZVxuLy8gICBlZGl0b3IgaXMgZGVzdHJveWVkLiAoTm90IGF2YWlsYWJsZSBmb3IgbWFya3MuKVxuXG4vLyBWaWV3IGRlc2NyaXB0aW9ucyBhcmUgZGF0YSBzdHJ1Y3R1cmVzIHRoYXQgZGVzY3JpYmUgdGhlIERPTSB0aGF0IGlzXG4vLyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZWRpdG9yJ3MgY29udGVudC4gVGhleSBhcmUgdXNlZCBmb3I6XG4vL1xuLy8gLSBJbmNyZW1lbnRhbCByZWRyYXdpbmcgd2hlbiB0aGUgZG9jdW1lbnQgY2hhbmdlc1xuLy9cbi8vIC0gRmlndXJpbmcgb3V0IHdoYXQgcGFydCBvZiB0aGUgZG9jdW1lbnQgYSBnaXZlbiBET00gcG9zaXRpb25cbi8vICAgY29ycmVzcG9uZHMgdG9cbi8vXG4vLyAtIFdpcmluZyBpbiBjdXN0b20gaW1wbGVtZW50YXRpb25zIG9mIHRoZSBlZGl0aW5nIGludGVyZmFjZSBmb3IgYVxuLy8gICBnaXZlbiBub2RlXG4vL1xuLy8gVGhleSBmb3JtIGEgZG91Ymx5LWxpbmtlZCBtdXRhYmxlIHRyZWUsIHN0YXJ0aW5nIGF0IGB2aWV3LmRvY1ZpZXdgLlxuXG52YXIgTk9UX0RJUlRZID0gMCwgQ0hJTERfRElSVFkgPSAxLCBDT05URU5UX0RJUlRZID0gMiwgTk9ERV9ESVJUWSA9IDM7XG5cbi8vIFN1cGVyY2xhc3MgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIGRlc2NyaXB0aW9ucy4gRGVmaW5lcyB0aGVpclxuLy8gYmFzaWMgc3RydWN0dXJlIGFuZCBzaGFyZWQgbWV0aG9kcy5cbnZhciBWaWV3RGVzYyA9IGZ1bmN0aW9uIFZpZXdEZXNjKHBhcmVudCwgY2hpbGRyZW4sIGRvbSwgY29udGVudERPTSkge1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLmRvbSA9IGRvbTtcbiAgLy8gQW4gZXhwYW5kbyBwcm9wZXJ0eSBvbiB0aGUgRE9NIG5vZGUgcHJvdmlkZXMgYSBsaW5rIGJhY2sgdG8gaXRzXG4gIC8vIGRlc2NyaXB0aW9uLlxuICBkb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gIC8vIFRoaXMgaXMgdGhlIG5vZGUgdGhhdCBob2xkcyB0aGUgY2hpbGQgdmlld3MuIEl0IG1heSBiZSBudWxsIGZvclxuICAvLyBkZXNjcyB0aGF0IGRvbid0IGhhdmUgY2hpbGRyZW4uXG4gIHRoaXMuY29udGVudERPTSA9IGNvbnRlbnRET007XG4gIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBzaXplOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGJvcmRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxwb3NCZWZvcmU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0scG9zQXRTdGFydDogeyBjb25maWd1cmFibGU6IHRydWUgfSxwb3NBZnRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxwb3NBdEVuZDogeyBjb25maWd1cmFibGU6IHRydWUgfSxjb250ZW50TG9zdDogeyBjb25maWd1cmFibGU6IHRydWUgfSxkb21BdG9tOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlnbm9yZUZvckNvb3JkczogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBVc2VkIHRvIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiBkZXNjcmlwdGlvbiBjb3JyZXNwb25kcyB0byBhXG4vLyB3aWRnZXQvbWFyay9ub2RlLlxuVmlld0Rlc2MucHJvdG90eXBlLm1hdGNoZXNXaWRnZXQgPSBmdW5jdGlvbiBtYXRjaGVzV2lkZ2V0ICgpIHsgcmV0dXJuIGZhbHNlIH07XG5WaWV3RGVzYy5wcm90b3R5cGUubWF0Y2hlc01hcmsgPSBmdW5jdGlvbiBtYXRjaGVzTWFyayAoKSB7IHJldHVybiBmYWxzZSB9O1xuVmlld0Rlc2MucHJvdG90eXBlLm1hdGNoZXNOb2RlID0gZnVuY3Rpb24gbWF0Y2hlc05vZGUgKCkgeyByZXR1cm4gZmFsc2UgfTtcblZpZXdEZXNjLnByb3RvdHlwZS5tYXRjaGVzSGFjayA9IGZ1bmN0aW9uIG1hdGNoZXNIYWNrIChfbm9kZU5hbWUpIHsgcmV0dXJuIGZhbHNlIH07XG5cbi8vIDogKCkg4oaSID9QYXJzZVJ1bGVcbi8vIFdoZW4gcGFyc2luZyBpbi1lZGl0b3IgY29udGVudCAoaW4gZG9tY2hhbmdlLmpzKSwgd2UgYWxsb3dcbi8vIGRlc2NyaXB0aW9ucyB0byBkZXRlcm1pbmUgdGhlIHBhcnNlIHJ1bGVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG9cbi8vIHBhcnNlIHRoZW0uXG5WaWV3RGVzYy5wcm90b3R5cGUucGFyc2VSdWxlID0gZnVuY3Rpb24gcGFyc2VSdWxlICgpIHsgcmV0dXJuIG51bGwgfTtcblxuLy8gOiAoZG9tLkV2ZW50KSDihpIgYm9vbFxuLy8gVXNlZCBieSB0aGUgZWRpdG9yJ3MgZXZlbnQgaGFuZGxlciB0byBpZ25vcmUgZXZlbnRzIHRoYXQgY29tZVxuLy8gZnJvbSBjZXJ0YWluIGRlc2NzLlxuVmlld0Rlc2MucHJvdG90eXBlLnN0b3BFdmVudCA9IGZ1bmN0aW9uIHN0b3BFdmVudCAoKSB7IHJldHVybiBmYWxzZSB9O1xuXG4vLyBUaGUgc2l6ZSBvZiB0aGUgY29udGVudCByZXByZXNlbnRlZCBieSB0aGlzIGRlc2MuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7IHNpemUgKz0gdGhpcy5jaGlsZHJlbltpXS5zaXplOyB9XG4gIHJldHVybiBzaXplXG59O1xuXG4vLyBGb3IgYmxvY2sgbm9kZXMsIHRoaXMgcmVwcmVzZW50cyB0aGUgc3BhY2UgdGFrZW4gdXAgYnkgdGhlaXJcbi8vIHN0YXJ0L2VuZCB0b2tlbnMuXG5wcm90b3R5cGVBY2Nlc3NvcnMuYm9yZGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuVmlld0Rlc2MucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICBpZiAodGhpcy5kb20ucG1WaWV3RGVzYyA9PSB0aGlzKSB7IHRoaXMuZG9tLnBtVmlld0Rlc2MgPSBudWxsOyB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICB7IHRoaXMuY2hpbGRyZW5baV0uZGVzdHJveSgpOyB9XG59O1xuXG5WaWV3RGVzYy5wcm90b3R5cGUucG9zQmVmb3JlQ2hpbGQgPSBmdW5jdGlvbiBwb3NCZWZvcmVDaGlsZCAoY2hpbGQpIHtcbiAgZm9yICh2YXIgaSA9IDAsIHBvcyA9IHRoaXMucG9zQXRTdGFydDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VyID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY3VyID09IGNoaWxkKSB7IHJldHVybiBwb3MgfVxuICAgIHBvcyArPSBjdXIuc2l6ZTtcbiAgfVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnBvc0JlZm9yZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnBvc0F0U3RhcnQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKSArIHRoaXMuYm9yZGVyIDogMFxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnBvc0FmdGVyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucG9zQmVmb3JlICsgdGhpcy5zaXplXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMucG9zQXRFbmQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5zaXplIC0gMiAqIHRoaXMuYm9yZGVyXG59O1xuXG4vLyA6IChkb20uTm9kZSwgbnVtYmVyLCA/bnVtYmVyKSDihpIgbnVtYmVyXG5WaWV3RGVzYy5wcm90b3R5cGUubG9jYWxQb3NGcm9tRE9NID0gZnVuY3Rpb24gbG9jYWxQb3NGcm9tRE9NIChkb20sIG9mZnNldCwgYmlhcykge1xuICAvLyBJZiB0aGUgRE9NIHBvc2l0aW9uIGlzIGluIHRoZSBjb250ZW50LCB1c2UgdGhlIGNoaWxkIGRlc2MgYWZ0ZXJcbiAgLy8gaXQgdG8gZmlndXJlIG91dCBhIHBvc2l0aW9uLlxuICBpZiAodGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTS5jb250YWlucyhkb20ubm9kZVR5cGUgPT0gMSA/IGRvbSA6IGRvbS5wYXJlbnROb2RlKSkge1xuICAgIGlmIChiaWFzIDwgMCkge1xuICAgICAgdmFyIGRvbUJlZm9yZSwgZGVzYztcbiAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgIGRvbUJlZm9yZSA9IGRvbS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSkgeyBkb20gPSBkb20ucGFyZW50Tm9kZTsgfVxuICAgICAgICBkb21CZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGRvbUJlZm9yZSAmJiAhKChkZXNjID0gZG9tQmVmb3JlLnBtVmlld0Rlc2MpICYmIGRlc2MucGFyZW50ID09IHRoaXMpKSB7IGRvbUJlZm9yZSA9IGRvbUJlZm9yZS5wcmV2aW91c1NpYmxpbmc7IH1cbiAgICAgIHJldHVybiBkb21CZWZvcmUgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKGRlc2MpICsgZGVzYy5zaXplIDogdGhpcy5wb3NBdFN0YXJ0XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkb21BZnRlciwgZGVzYyQxO1xuICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgZG9tQWZ0ZXIgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSkgeyBkb20gPSBkb20ucGFyZW50Tm9kZTsgfVxuICAgICAgICBkb21BZnRlciA9IGRvbS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHdoaWxlIChkb21BZnRlciAmJiAhKChkZXNjJDEgPSBkb21BZnRlci5wbVZpZXdEZXNjKSAmJiBkZXNjJDEucGFyZW50ID09IHRoaXMpKSB7IGRvbUFmdGVyID0gZG9tQWZ0ZXIubmV4dFNpYmxpbmc7IH1cbiAgICAgIHJldHVybiBkb21BZnRlciA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYyQxKSA6IHRoaXMucG9zQXRFbmRcbiAgICB9XG4gIH1cbiAgLy8gT3RoZXJ3aXNlLCB1c2UgdmFyaW91cyBoZXVyaXN0aWNzLCBmYWxsaW5nIGJhY2sgb24gdGhlIGJpYXNcbiAgLy8gcGFyYW1ldGVyLCB0byBkZXRlcm1pbmUgd2hldGhlciB0byByZXR1cm4gdGhlIHBvc2l0aW9uIGF0IHRoZVxuICAvLyBzdGFydCBvciBhdCB0aGUgZW5kIG9mIHRoaXMgdmlldyBkZXNjLlxuICB2YXIgYXRFbmQ7XG4gIGlmIChkb20gPT0gdGhpcy5kb20gJiYgdGhpcy5jb250ZW50RE9NKSB7XG4gICAgYXRFbmQgPSBvZmZzZXQgPiBkb21JbmRleCh0aGlzLmNvbnRlbnRET00pO1xuICB9IGVsc2UgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKSkge1xuICAgIGF0RW5kID0gZG9tLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuY29udGVudERPTSkgJiAyO1xuICB9IGVsc2UgaWYgKHRoaXMuZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICBpZiAob2Zmc2V0ID09IDApIHsgZm9yICh2YXIgc2VhcmNoID0gZG9tOzsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHsgYXRFbmQgPSBmYWxzZTsgYnJlYWsgfVxuICAgICAgaWYgKHNlYXJjaC5wYXJlbnROb2RlLmZpcnN0Q2hpbGQgIT0gc2VhcmNoKSB7IGJyZWFrIH1cbiAgICB9IH1cbiAgICBpZiAoYXRFbmQgPT0gbnVsbCAmJiBvZmZzZXQgPT0gZG9tLmNoaWxkTm9kZXMubGVuZ3RoKSB7IGZvciAodmFyIHNlYXJjaCQxID0gZG9tOzsgc2VhcmNoJDEgPSBzZWFyY2gkMS5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoc2VhcmNoJDEgPT0gdGhpcy5kb20pIHsgYXRFbmQgPSB0cnVlOyBicmVhayB9XG4gICAgICBpZiAoc2VhcmNoJDEucGFyZW50Tm9kZS5sYXN0Q2hpbGQgIT0gc2VhcmNoJDEpIHsgYnJlYWsgfVxuICAgIH0gfVxuICB9XG4gIHJldHVybiAoYXRFbmQgPT0gbnVsbCA/IGJpYXMgPiAwIDogYXRFbmQpID8gdGhpcy5wb3NBdEVuZCA6IHRoaXMucG9zQXRTdGFydFxufTtcblxuLy8gU2NhbiB1cCB0aGUgZG9tIGZpbmRpbmcgdGhlIGZpcnN0IGRlc2MgdGhhdCBpcyBhIGRlc2NlbmRhbnQgb2Zcbi8vIHRoaXMgb25lLlxuVmlld0Rlc2MucHJvdG90eXBlLm5lYXJlc3REZXNjID0gZnVuY3Rpb24gbmVhcmVzdERlc2MgKGRvbSwgb25seU5vZGVzKSB7XG4gIGZvciAodmFyIGZpcnN0ID0gdHJ1ZSwgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGRlc2MgPSB0aGlzLmdldERlc2MoY3VyKTtcbiAgICBpZiAoZGVzYyAmJiAoIW9ubHlOb2RlcyB8fCBkZXNjLm5vZGUpKSB7XG4gICAgICAvLyBJZiBkb20gaXMgb3V0c2lkZSBvZiB0aGlzIGRlc2MncyBub2RlRE9NLCBkb24ndCBjb3VudCBpdC5cbiAgICAgIGlmIChmaXJzdCAmJiBkZXNjLm5vZGVET00gJiZcbiAgICAgICAgICAhKGRlc2Mubm9kZURPTS5ub2RlVHlwZSA9PSAxID8gZGVzYy5ub2RlRE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpIDogZGVzYy5ub2RlRE9NID09IGRvbSkpXG4gICAgICAgIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJldHVybiBkZXNjIH1cbiAgICB9XG4gIH1cbn07XG5cblZpZXdEZXNjLnByb3RvdHlwZS5nZXREZXNjID0gZnVuY3Rpb24gZ2V0RGVzYyAoZG9tKSB7XG4gIHZhciBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gIGZvciAodmFyIGN1ciA9IGRlc2M7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkgeyBpZiAoY3VyID09IHRoaXMpIHsgcmV0dXJuIGRlc2MgfSB9XG59O1xuXG5WaWV3RGVzYy5wcm90b3R5cGUucG9zRnJvbURPTSA9IGZ1bmN0aW9uIHBvc0Zyb21ET00gKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gIGZvciAodmFyIHNjYW4gPSBkb207IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICB2YXIgZGVzYyA9IHRoaXMuZ2V0RGVzYyhzY2FuKTtcbiAgICBpZiAoZGVzYykgeyByZXR1cm4gZGVzYy5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIH1cbiAgfVxuICByZXR1cm4gLTFcbn07XG5cbi8vIDogKG51bWJlcikg4oaSID9Ob2RlVmlld0Rlc2Ncbi8vIEZpbmQgdGhlIGRlc2MgZm9yIHRoZSBub2RlIGFmdGVyIHRoZSBnaXZlbiBwb3MsIGlmIGFueS4gKFdoZW4gYVxuLy8gcGFyZW50IG5vZGUgb3ZlcnJvZGUgcmVuZGVyaW5nLCB0aGVyZSBtaWdodCBub3QgYmUgb25lLilcblZpZXdEZXNjLnByb3RvdHlwZS5kZXNjQXQgPSBmdW5jdGlvbiBkZXNjQXQgKHBvcykge1xuICBmb3IgKHZhciBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgIGlmIChvZmZzZXQgPT0gcG9zICYmIGVuZCAhPSBvZmZzZXQpIHtcbiAgICAgIHdoaWxlICghY2hpbGQuYm9yZGVyICYmIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkgeyBjaGlsZCA9IGNoaWxkLmNoaWxkcmVuWzBdOyB9XG4gICAgICByZXR1cm4gY2hpbGRcbiAgICB9XG4gICAgaWYgKHBvcyA8IGVuZCkgeyByZXR1cm4gY2hpbGQuZGVzY0F0KHBvcyAtIG9mZnNldCAtIGNoaWxkLmJvcmRlcikgfVxuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxufTtcblxuLy8gOiAobnVtYmVyLCBudW1iZXIpIOKGkiB7bm9kZTogZG9tLk5vZGUsIG9mZnNldDogbnVtYmVyfVxuVmlld0Rlc2MucHJvdG90eXBlLmRvbUZyb21Qb3MgPSBmdW5jdGlvbiBkb21Gcm9tUG9zIChwb3MsIHNpZGUpIHtcbiAgaWYgKCF0aGlzLmNvbnRlbnRET00pIHsgcmV0dXJuIHtub2RlOiB0aGlzLmRvbSwgb2Zmc2V0OiAwfSB9XG4gIC8vIEZpcnN0IGZpbmQgdGhlIHBvc2l0aW9uIGluIHRoZSBjaGlsZCBhcnJheVxuICB2YXIgaSA9IDAsIG9mZnNldCA9IDA7XG4gIGZvciAodmFyIGN1clBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gY3VyUG9zICsgY2hpbGQuc2l6ZTtcbiAgICBpZiAoZW5kID4gcG9zIHx8IGNoaWxkIGluc3RhbmNlb2YgVHJhaWxpbmdIYWNrVmlld0Rlc2MpIHsgb2Zmc2V0ID0gcG9zIC0gY3VyUG9zOyBicmVhayB9XG4gICAgY3VyUG9zID0gZW5kO1xuICB9XG4gIC8vIElmIHRoaXMgcG9pbnRzIGludG8gdGhlIG1pZGRsZSBvZiBhIGNoaWxkLCBjYWxsIHRocm91Z2hcbiAgaWYgKG9mZnNldCkgeyByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21Gcm9tUG9zKG9mZnNldCAtIHRoaXMuY2hpbGRyZW5baV0uYm9yZGVyLCBzaWRlKSB9XG4gIC8vIEdvIGJhY2sgaWYgdGhlcmUgd2VyZSBhbnkgemVyby1sZW5ndGggd2lkZ2V0cyB3aXRoIHNpZGUgPj0gMCBiZWZvcmUgdGhpcyBwb2ludFxuICBmb3IgKHZhciBwcmV2ID0gKHZvaWQgMCk7IGkgJiYgIShwcmV2ID0gdGhpcy5jaGlsZHJlbltpIC0gMV0pLnNpemUgJiYgcHJldiBpbnN0YW5jZW9mIFdpZGdldFZpZXdEZXNjICYmIHByZXYud2lkZ2V0LnR5cGUuc2lkZSA+PSAwOyBpLS0pIHt9XG4gIC8vIFNjYW4gdG93YXJkcyB0aGUgZmlyc3QgdXNlYWJsZSBub2RlXG4gIGlmIChzaWRlIDw9IDApIHtcbiAgICB2YXIgcHJldiQxLCBlbnRlciA9IHRydWU7XG4gICAgZm9yICg7OyBpLS0sIGVudGVyID0gZmFsc2UpIHtcbiAgICAgIHByZXYkMSA9IGkgPyB0aGlzLmNoaWxkcmVuW2kgLSAxXSA6IG51bGw7XG4gICAgICBpZiAoIXByZXYkMSB8fCBwcmV2JDEuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKSB7IGJyZWFrIH1cbiAgICB9XG4gICAgaWYgKHByZXYkMSAmJiBzaWRlICYmIGVudGVyICYmICFwcmV2JDEuYm9yZGVyICYmICFwcmV2JDEuZG9tQXRvbSkgeyByZXR1cm4gcHJldiQxLmRvbUZyb21Qb3MocHJldiQxLnNpemUsIHNpZGUpIH1cbiAgICByZXR1cm4ge25vZGU6IHRoaXMuY29udGVudERPTSwgb2Zmc2V0OiBwcmV2JDEgPyBkb21JbmRleChwcmV2JDEuZG9tKSArIDEgOiAwfVxuICB9IGVsc2Uge1xuICAgIHZhciBuZXh0LCBlbnRlciQxID0gdHJ1ZTtcbiAgICBmb3IgKDs7IGkrKywgZW50ZXIkMSA9IGZhbHNlKSB7XG4gICAgICBuZXh0ID0gaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5jaGlsZHJlbltpXSA6IG51bGw7XG4gICAgICBpZiAoIW5leHQgfHwgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pIHsgYnJlYWsgfVxuICAgIH1cbiAgICBpZiAobmV4dCAmJiBlbnRlciQxICYmICFuZXh0LmJvcmRlciAmJiAhbmV4dC5kb21BdG9tKSB7IHJldHVybiBuZXh0LmRvbUZyb21Qb3MoMCwgc2lkZSkgfVxuICAgIHJldHVybiB7bm9kZTogdGhpcy5jb250ZW50RE9NLCBvZmZzZXQ6IG5leHQgPyBkb21JbmRleChuZXh0LmRvbSkgOiB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGh9XG4gIH1cbn07XG5cbi8vIFVzZWQgdG8gZmluZCBhIERPTSByYW5nZSBpbiBhIHNpbmdsZSBwYXJlbnQgZm9yIGEgZ2l2ZW4gY2hhbmdlZFxuLy8gcmFuZ2UuXG5WaWV3RGVzYy5wcm90b3R5cGUucGFyc2VSYW5nZSA9IGZ1bmN0aW9uIHBhcnNlUmFuZ2UgKGZyb20sIHRvLCBiYXNlKSB7XG4gICAgaWYgKCBiYXNlID09PSB2b2lkIDAgKSBiYXNlID0gMDtcblxuICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMClcbiAgICB7IHJldHVybiB7bm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tOiBmcm9tLCB0bzogdG8sIGZyb21PZmZzZXQ6IDAsIHRvT2Zmc2V0OiB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGh9IH1cblxuICB2YXIgZnJvbU9mZnNldCA9IC0xLCB0b09mZnNldCA9IC0xO1xuICBmb3IgKHZhciBvZmZzZXQgPSBiYXNlLCBpID0gMDs7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgaWYgKGZyb21PZmZzZXQgPT0gLTEgJiYgZnJvbSA8PSBlbmQpIHtcbiAgICAgIHZhciBjaGlsZEJhc2UgPSBvZmZzZXQgKyBjaGlsZC5ib3JkZXI7XG4gICAgICAvLyBGSVhNRSBtYXliZSBkZXNjZW5kIG1hcmsgdmlld3MgdG8gcGFyc2UgYSBuYXJyb3dlciByYW5nZT9cbiAgICAgIGlmIChmcm9tID49IGNoaWxkQmFzZSAmJiB0byA8PSBlbmQgLSBjaGlsZC5ib3JkZXIgJiYgY2hpbGQubm9kZSAmJlxuICAgICAgICAgIGNoaWxkLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGNoaWxkLmNvbnRlbnRET00pKVxuICAgICAgICB7IHJldHVybiBjaGlsZC5wYXJzZVJhbmdlKGZyb20sIHRvLCBjaGlsZEJhc2UpIH1cblxuICAgICAgZnJvbSA9IG9mZnNldDtcbiAgICAgIGZvciAodmFyIGogPSBpOyBqID4gMDsgai0tKSB7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5jaGlsZHJlbltqIC0gMV07XG4gICAgICAgIGlmIChwcmV2LnNpemUgJiYgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIXByZXYuZW1wdHlDaGlsZEF0KDEpKSB7XG4gICAgICAgICAgZnJvbU9mZnNldCA9IGRvbUluZGV4KHByZXYuZG9tKSArIDE7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBmcm9tIC09IHByZXYuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xKSB7IGZyb21PZmZzZXQgPSAwOyB9XG4gICAgfVxuICAgIGlmIChmcm9tT2Zmc2V0ID4gLTEgJiYgKGVuZCA+IHRvIHx8IGkgPT0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSkge1xuICAgICAgdG8gPSBlbmQ7XG4gICAgICBmb3IgKHZhciBqJDEgPSBpICsgMTsgaiQxIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGokMSsrKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5jaGlsZHJlbltqJDFdO1xuICAgICAgICBpZiAobmV4dC5zaXplICYmIG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFuZXh0LmVtcHR5Q2hpbGRBdCgtMSkpIHtcbiAgICAgICAgICB0b09mZnNldCA9IGRvbUluZGV4KG5leHQuZG9tKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHRvICs9IG5leHQuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b09mZnNldCA9PSAtMSkgeyB0b09mZnNldCA9IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aDsgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiB7bm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tOiBmcm9tLCB0bzogdG8sIGZyb21PZmZzZXQ6IGZyb21PZmZzZXQsIHRvT2Zmc2V0OiB0b09mZnNldH1cbn07XG5cblZpZXdEZXNjLnByb3RvdHlwZS5lbXB0eUNoaWxkQXQgPSBmdW5jdGlvbiBlbXB0eUNoaWxkQXQgKHNpZGUpIHtcbiAgaWYgKHRoaXMuYm9yZGVyIHx8ICF0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bc2lkZSA8IDAgPyAwIDogdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGNoaWxkLnNpemUgPT0gMCB8fCBjaGlsZC5lbXB0eUNoaWxkQXQoc2lkZSlcbn07XG5cbi8vIDogKG51bWJlcikg4oaSIGRvbS5Ob2RlXG5WaWV3RGVzYy5wcm90b3R5cGUuZG9tQWZ0ZXJQb3MgPSBmdW5jdGlvbiBkb21BZnRlclBvcyAocG9zKSB7XG4gIHZhciByZWYgPSB0aGlzLmRvbUZyb21Qb3MocG9zLCAwKTtcbiAgICB2YXIgbm9kZSA9IHJlZi5ub2RlO1xuICAgIHZhciBvZmZzZXQgPSByZWYub2Zmc2V0O1xuICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxIHx8IG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGFmdGVyIHBvcyBcIiArIHBvcykgfVxuICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW29mZnNldF1cbn07XG5cbi8vIDogKG51bWJlciwgbnVtYmVyLCBkb20uRG9jdW1lbnQpXG4vLyBWaWV3IGRlc2NzIGFyZSByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbnkgc2VsZWN0aW9uIHRoYXQgZmFsbHNcbi8vIGVudGlyZWx5IGluc2lkZSBvZiB0aGVtLCBzbyB0aGF0IGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgY2FuIGRvXG4vLyBjdXN0b20gdGhpbmdzIHdpdGggdGhlIHNlbGVjdGlvbi4gTm90ZSB0aGF0IHRoaXMgZmFsbHMgYXBhcnQgd2hlblxuLy8gYSBzZWxlY3Rpb24gc3RhcnRzIGluIHN1Y2ggYSBub2RlIGFuZCBlbmRzIGluIGFub3RoZXIsIGluIHdoaWNoXG4vLyBjYXNlIHdlIGp1c3QgdXNlIHdoYXRldmVyIGRvbUZyb21Qb3MgcHJvZHVjZXMgYXMgYSBiZXN0IGVmZm9ydC5cblZpZXdEZXNjLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiBzZXRTZWxlY3Rpb24gKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UpIHtcbiAgLy8gSWYgdGhlIHNlbGVjdGlvbiBmYWxscyBlbnRpcmVseSBpbiBhIGNoaWxkLCBnaXZlIGl0IHRvIHRoYXQgY2hpbGRcbiAgdmFyIGZyb20gPSBNYXRoLm1pbihhbmNob3IsIGhlYWQpLCB0byA9IE1hdGgubWF4KGFuY2hvciwgaGVhZCk7XG4gIGZvciAodmFyIGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgaWYgKGZyb20gPiBvZmZzZXQgJiYgdG8gPCBlbmQpXG4gICAgICB7IHJldHVybiBjaGlsZC5zZXRTZWxlY3Rpb24oYW5jaG9yIC0gb2Zmc2V0IC0gY2hpbGQuYm9yZGVyLCBoZWFkIC0gb2Zmc2V0IC0gY2hpbGQuYm9yZGVyLCByb290LCBmb3JjZSkgfVxuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuXG4gIHZhciBhbmNob3JET00gPSB0aGlzLmRvbUZyb21Qb3MoYW5jaG9yLCBhbmNob3IgPyAtMSA6IDEpO1xuICB2YXIgaGVhZERPTSA9IGhlYWQgPT0gYW5jaG9yID8gYW5jaG9yRE9NIDogdGhpcy5kb21Gcm9tUG9zKGhlYWQsIGhlYWQgPyAtMSA6IDEpO1xuICB2YXIgZG9tU2VsID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcblxuICB2YXIgYnJLbHVkZ2UgPSBmYWxzZTtcbiAgLy8gT24gRmlyZWZveCwgdXNpbmcgU2VsZWN0aW9uLmNvbGxhcHNlIHRvIHB1dCB0aGUgY3Vyc29yIGFmdGVyIGFcbiAgLy8gQlIgbm9kZSBmb3Igc29tZSByZWFzb24gZG9lc24ndCBhbHdheXMgd29yayAoIzEwNzMpLiBPbiBTYWZhcmksXG4gIC8vIHRoZSBjdXJzb3Igc29tZXRpbWVzIGluZXhwbGljYWJsZSB2aXN1YWxseSBsYWdzIGJlaGluZCBpdHNcbiAgLy8gcmVwb3J0ZWQgcG9zaXRpb24gaW4gc3VjaCBzaXR1YXRpb25zICgjMTA5MikuXG4gIGlmICgocmVzdWx0LmdlY2tvIHx8IHJlc3VsdC5zYWZhcmkpICYmIGFuY2hvciA9PSBoZWFkKSB7XG4gICAgdmFyIG5vZGUgPSBhbmNob3JET00ubm9kZTtcbiAgICAgIHZhciBvZmZzZXQkMSA9IGFuY2hvckRPTS5vZmZzZXQ7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgYnJLbHVkZ2UgPSBvZmZzZXQkMSAmJiBub2RlLm5vZGVWYWx1ZVtvZmZzZXQkMSAtIDFdID09IFwiXFxuXCI7XG4gICAgICAvLyBJc3N1ZSAjMTEyOFxuICAgICAgaWYgKGJyS2x1ZGdlICYmIG9mZnNldCQxID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBzY2FuID0gbm9kZSwgYWZ0ZXIgPSAodm9pZCAwKTsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGlmIChhZnRlciA9IHNjYW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChhZnRlci5ub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgIHsgYW5jaG9yRE9NID0gaGVhZERPTSA9IHtub2RlOiBhZnRlci5wYXJlbnROb2RlLCBvZmZzZXQ6IGRvbUluZGV4KGFmdGVyKSArIDF9OyB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGVzYyA9IHNjYW4ucG1WaWV3RGVzYztcbiAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2spIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCQxIC0gMV07XG4gICAgICBicktsdWRnZSA9IHByZXYgJiYgKHByZXYubm9kZU5hbWUgPT0gXCJCUlwiIHx8IHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG4gICAgfVxuICB9XG4gIC8vIEZpcmVmb3ggY2FuIGFjdCBzdHJhbmdlbHkgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGZyb250IG9mIGFuXG4gIC8vIHVuZWRpdGFibGUgbm9kZS4gU2VlICMxMTYzIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzA5NTM2XG4gIGlmIChyZXN1bHQuZ2Vja28gJiYgZG9tU2VsLmZvY3VzTm9kZSAmJiBkb21TZWwuZm9jdXNOb2RlICE9IGhlYWRET00ubm9kZSAmJiBkb21TZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICB2YXIgYWZ0ZXIkMSA9IGRvbVNlbC5mb2N1c05vZGUuY2hpbGROb2Rlc1tkb21TZWwuZm9jdXNPZmZzZXRdO1xuICAgIGlmIChhZnRlciQxICYmIGFmdGVyJDEuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgeyBmb3JjZSA9IHRydWU7IH1cbiAgfVxuXG4gIGlmICghKGZvcmNlIHx8IGJyS2x1ZGdlICYmIHJlc3VsdC5zYWZhcmkpICYmXG4gICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpICYmXG4gICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0LCBkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpKVxuICAgIHsgcmV0dXJuIH1cblxuICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICB2YXIgZG9tU2VsRXh0ZW5kZWQgPSBmYWxzZTtcbiAgaWYgKChkb21TZWwuZXh0ZW5kIHx8IGFuY2hvciA9PSBoZWFkKSAmJiAhYnJLbHVkZ2UpIHtcbiAgICBkb21TZWwuY29sbGFwc2UoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoYW5jaG9yICE9IGhlYWQpIHsgZG9tU2VsLmV4dGVuZChoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0KTsgfVxuICAgICAgZG9tU2VsRXh0ZW5kZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSW4gc29tZSBjYXNlcyB3aXRoIENocm9tZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNvbGxhcHNlLCBldmVuIHdoZW4gaXQgc2hvdWxkIGJlIHZhbGlkLiBUaGlzIGFwcGVhcnMgdG8gYmUgYSBidWcsIGJ1dFxuICAgICAgLy8gaXQgaXMgZGlmZmljdWx0IHRvIGlzb2xhdGUuIElmIHRoaXMgaGFwcGVucyBmYWxsYmFjayB0byB0aGUgb2xkIHBhdGhcbiAgICAgIC8vIHdpdGhvdXQgdXNpbmcgZXh0ZW5kLlxuICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSkgeyB0aHJvdyBlcnIgfVxuICAgICAgLy8gZGVjbGFyZSBnbG9iYWw6IERPTUV4Y2VwdGlvblxuICAgIH1cbiAgfVxuICBpZiAoIWRvbVNlbEV4dGVuZGVkKSB7XG4gICAgaWYgKGFuY2hvciA+IGhlYWQpIHsgdmFyIHRtcCA9IGFuY2hvckRPTTsgYW5jaG9yRE9NID0gaGVhZERPTTsgaGVhZERPTSA9IHRtcDsgfVxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0KTtcbiAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgfVxufTtcblxuLy8gOiAoZG9tLk11dGF0aW9uUmVjb3JkKSDihpIgYm9vbFxuVmlld0Rlc2MucHJvdG90eXBlLmlnbm9yZU11dGF0aW9uID0gZnVuY3Rpb24gaWdub3JlTXV0YXRpb24gKG11dGF0aW9uKSB7XG4gIHJldHVybiAhdGhpcy5jb250ZW50RE9NICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIlxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmNvbnRlbnRMb3N0LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgIXRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSlcbn07XG5cbi8vIFJlbW92ZSBhIHN1YnRyZWUgb2YgdGhlIGVsZW1lbnQgdHJlZSB0aGF0IGhhcyBiZWVuIHRvdWNoZWRcbi8vIGJ5IGEgRE9NIGNoYW5nZSwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCByZWRyYXcgaXQuXG5WaWV3RGVzYy5wcm90b3R5cGUubWFya0RpcnR5ID0gZnVuY3Rpb24gbWFya0RpcnR5IChmcm9tLCB0bykge1xuICBmb3IgKHZhciBvZmZzZXQgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgIGlmIChvZmZzZXQgPT0gZW5kID8gZnJvbSA8PSBlbmQgJiYgdG8gPj0gb2Zmc2V0IDogZnJvbSA8IGVuZCAmJiB0byA+IG9mZnNldCkge1xuICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gb2Zmc2V0ICsgY2hpbGQuYm9yZGVyLCBlbmRJbnNpZGUgPSBlbmQgLSBjaGlsZC5ib3JkZXI7XG4gICAgICBpZiAoZnJvbSA+PSBzdGFydEluc2lkZSAmJiB0byA8PSBlbmRJbnNpZGUpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZyb20gPT0gb2Zmc2V0IHx8IHRvID09IGVuZCA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgaWYgKGZyb20gPT0gc3RhcnRJbnNpZGUgJiYgdG8gPT0gZW5kSW5zaWRlICYmXG4gICAgICAgICAgICAoY2hpbGQuY29udGVudExvc3QgfHwgY2hpbGQuZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKSkgeyBjaGlsZC5kaXJ0eSA9IE5PREVfRElSVFk7IH1cbiAgICAgICAgZWxzZSB7IGNoaWxkLm1hcmtEaXJ0eShmcm9tIC0gc3RhcnRJbnNpZGUsIHRvIC0gc3RhcnRJbnNpZGUpOyB9XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQuZGlydHkgPSBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gPyBDT05URU5UX0RJUlRZIDogTk9ERV9ESVJUWTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHRoaXMuZGlydHkgPSBDT05URU5UX0RJUlRZO1xufTtcblxuVmlld0Rlc2MucHJvdG90eXBlLm1hcmtQYXJlbnRzRGlydHkgPSBmdW5jdGlvbiBtYXJrUGFyZW50c0RpcnR5ICgpIHtcbiAgdmFyIGxldmVsID0gMTtcbiAgZm9yICh2YXIgbm9kZSA9IHRoaXMucGFyZW50OyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnQsIGxldmVsKyspIHtcbiAgICB2YXIgZGlydHkgPSBsZXZlbCA9PSAxID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgIGlmIChub2RlLmRpcnR5IDwgZGlydHkpIHsgbm9kZS5kaXJ0eSA9IGRpcnR5OyB9XG4gIH1cbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5kb21BdG9tLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pZ25vcmVGb3JDb29yZHMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2UgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZpZXdEZXNjLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbi8vIFJldXNlZCBhcnJheSB0byBhdm9pZCBhbGxvY2F0aW5nIGZyZXNoIGFycmF5cyBmb3IgdGhpbmdzIHRoYXQgd2lsbFxuLy8gc3RheSBlbXB0eSBhbnl3YXkuXG52YXIgbm90aGluZyA9IFtdO1xuXG4vLyBBIHdpZGdldCBkZXNjIHJlcHJlc2VudHMgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggaXMgYSBET00gbm9kZVxuLy8gZHJhd24gYmV0d2VlbiB0aGUgZG9jdW1lbnQgbm9kZXMuXG52YXIgV2lkZ2V0Vmlld0Rlc2MgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChWaWV3RGVzYykge1xuICBmdW5jdGlvbiBXaWRnZXRWaWV3RGVzYyhwYXJlbnQsIHdpZGdldCwgdmlldywgcG9zKSB7XG4gICAgdmFyIHNlbGYsIGRvbSA9IHdpZGdldC50eXBlLnRvRE9NO1xuICAgIGlmICh0eXBlb2YgZG9tID09IFwiZnVuY3Rpb25cIikgeyBkb20gPSBkb20odmlldywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzZWxmKSB7IHJldHVybiBwb3MgfVxuICAgICAgaWYgKHNlbGYucGFyZW50KSB7IHJldHVybiBzZWxmLnBhcmVudC5wb3NCZWZvcmVDaGlsZChzZWxmKSB9XG4gICAgfSk7IH1cbiAgICBpZiAoIXdpZGdldC50eXBlLnNwZWMucmF3KSB7XG4gICAgICBpZiAoZG9tLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgdmFyIHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICBkb20gPSB3cmFwO1xuICAgICAgfVxuICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci13aWRnZXRcIik7XG4gICAgfVxuICAgIFZpZXdEZXNjLmNhbGwodGhpcywgcGFyZW50LCBub3RoaW5nLCBkb20sIG51bGwpO1xuICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgIHNlbGYgPSB0aGlzO1xuICB9XG5cbiAgaWYgKCBWaWV3RGVzYyApIFdpZGdldFZpZXdEZXNjLl9fcHJvdG9fXyA9IFZpZXdEZXNjO1xuICBXaWRnZXRWaWV3RGVzYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBWaWV3RGVzYyAmJiBWaWV3RGVzYy5wcm90b3R5cGUgKTtcbiAgV2lkZ2V0Vmlld0Rlc2MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2lkZ2V0Vmlld0Rlc2M7XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxID0geyBkb21BdG9tOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgV2lkZ2V0Vmlld0Rlc2MucHJvdG90eXBlLm1hdGNoZXNXaWRnZXQgPSBmdW5jdGlvbiBtYXRjaGVzV2lkZ2V0ICh3aWRnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgd2lkZ2V0LnR5cGUuZXEodGhpcy53aWRnZXQudHlwZSlcbiAgfTtcblxuICBXaWRnZXRWaWV3RGVzYy5wcm90b3R5cGUucGFyc2VSdWxlID0gZnVuY3Rpb24gcGFyc2VSdWxlICgpIHsgcmV0dXJuIHtpZ25vcmU6IHRydWV9IH07XG5cbiAgV2lkZ2V0Vmlld0Rlc2MucHJvdG90eXBlLnN0b3BFdmVudCA9IGZ1bmN0aW9uIHN0b3BFdmVudCAoZXZlbnQpIHtcbiAgICB2YXIgc3RvcCA9IHRoaXMud2lkZ2V0LnNwZWMuc3RvcEV2ZW50O1xuICAgIHJldHVybiBzdG9wID8gc3RvcChldmVudCkgOiBmYWxzZVxuICB9O1xuXG4gIFdpZGdldFZpZXdEZXNjLnByb3RvdHlwZS5pZ25vcmVNdXRhdGlvbiA9IGZ1bmN0aW9uIGlnbm9yZU11dGF0aW9uIChtdXRhdGlvbikge1xuICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCIgfHwgdGhpcy53aWRnZXQuc3BlYy5pZ25vcmVTZWxlY3Rpb25cbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMkMS5kb21BdG9tLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggV2lkZ2V0Vmlld0Rlc2MucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG4gIHJldHVybiBXaWRnZXRWaWV3RGVzYztcbn0oVmlld0Rlc2MpKTtcblxudmFyIENvbXBvc2l0aW9uVmlld0Rlc2MgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChWaWV3RGVzYykge1xuICBmdW5jdGlvbiBDb21wb3NpdGlvblZpZXdEZXNjKHBhcmVudCwgZG9tLCB0ZXh0RE9NLCB0ZXh0KSB7XG4gICAgVmlld0Rlc2MuY2FsbCh0aGlzLCBwYXJlbnQsIG5vdGhpbmcsIGRvbSwgbnVsbCk7XG4gICAgdGhpcy50ZXh0RE9NID0gdGV4dERPTTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG5cbiAgaWYgKCBWaWV3RGVzYyApIENvbXBvc2l0aW9uVmlld0Rlc2MuX19wcm90b19fID0gVmlld0Rlc2M7XG4gIENvbXBvc2l0aW9uVmlld0Rlc2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVmlld0Rlc2MgJiYgVmlld0Rlc2MucHJvdG90eXBlICk7XG4gIENvbXBvc2l0aW9uVmlld0Rlc2MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tcG9zaXRpb25WaWV3RGVzYztcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzJDIgPSB7IHNpemU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMkMi5zaXplLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGggfTtcblxuICBDb21wb3NpdGlvblZpZXdEZXNjLnByb3RvdHlwZS5sb2NhbFBvc0Zyb21ET00gPSBmdW5jdGlvbiBsb2NhbFBvc0Zyb21ET00gKGRvbSwgb2Zmc2V0KSB7XG4gICAgaWYgKGRvbSAhPSB0aGlzLnRleHRET00pIHsgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIChvZmZzZXQgPyB0aGlzLnNpemUgOiAwKSB9XG4gICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIG9mZnNldFxuICB9O1xuXG4gIENvbXBvc2l0aW9uVmlld0Rlc2MucHJvdG90eXBlLmRvbUZyb21Qb3MgPSBmdW5jdGlvbiBkb21Gcm9tUG9zIChwb3MpIHtcbiAgICByZXR1cm4ge25vZGU6IHRoaXMudGV4dERPTSwgb2Zmc2V0OiBwb3N9XG4gIH07XG5cbiAgQ29tcG9zaXRpb25WaWV3RGVzYy5wcm90b3R5cGUuaWdub3JlTXV0YXRpb24gPSBmdW5jdGlvbiBpZ25vcmVNdXRhdGlvbiAobXV0KSB7XG4gICAgcmV0dXJuIG11dC50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0LnRhcmdldC5ub2RlVmFsdWUgPT0gbXV0Lm9sZFZhbHVlXG4gICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb21wb3NpdGlvblZpZXdEZXNjLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDIgKTtcblxuICByZXR1cm4gQ29tcG9zaXRpb25WaWV3RGVzYztcbn0oVmlld0Rlc2MpKTtcblxuLy8gQSBtYXJrIGRlc2MgcmVwcmVzZW50cyBhIG1hcmsuIE1heSBoYXZlIG11bHRpcGxlIGNoaWxkcmVuLFxuLy8gZGVwZW5kaW5nIG9uIGhvdyB0aGUgbWFyayBpcyBzcGxpdC4gTm90ZSB0aGF0IG1hcmtzIGFyZSBkcmF3biB1c2luZ1xuLy8gYSBmaXhlZCBuZXN0aW5nIG9yZGVyLCBmb3Igc2ltcGxpY2l0eSBhbmQgcHJlZGljdGFiaWxpdHksIHNvIGluXG4vLyBzb21lIGNhc2VzIHRoZXkgd2lsbCBiZSBzcGxpdCBtb3JlIG9mdGVuIHRoYW4gd291bGQgYXBwZWFyXG4vLyBuZWNlc3NhcnkuXG52YXIgTWFya1ZpZXdEZXNjID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoVmlld0Rlc2MpIHtcbiAgZnVuY3Rpb24gTWFya1ZpZXdEZXNjKHBhcmVudCwgbWFyaywgZG9tLCBjb250ZW50RE9NKSB7XG4gICAgVmlld0Rlc2MuY2FsbCh0aGlzLCBwYXJlbnQsIFtdLCBkb20sIGNvbnRlbnRET00pO1xuICAgIHRoaXMubWFyayA9IG1hcms7XG4gIH1cblxuICBpZiAoIFZpZXdEZXNjICkgTWFya1ZpZXdEZXNjLl9fcHJvdG9fXyA9IFZpZXdEZXNjO1xuICBNYXJrVmlld0Rlc2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVmlld0Rlc2MgJiYgVmlld0Rlc2MucHJvdG90eXBlICk7XG4gIE1hcmtWaWV3RGVzYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXJrVmlld0Rlc2M7XG5cbiAgTWFya1ZpZXdEZXNjLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAocGFyZW50LCBtYXJrLCBpbmxpbmUsIHZpZXcpIHtcbiAgICB2YXIgY3VzdG9tID0gdmlldy5ub2RlVmlld3NbbWFyay50eXBlLm5hbWVdO1xuICAgIHZhciBzcGVjID0gY3VzdG9tICYmIGN1c3RvbShtYXJrLCB2aWV3LCBpbmxpbmUpO1xuICAgIGlmICghc3BlYyB8fCAhc3BlYy5kb20pXG4gICAgICB7IHNwZWMgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG1hcmsudHlwZS5zcGVjLnRvRE9NKG1hcmssIGlubGluZSkpOyB9XG4gICAgcmV0dXJuIG5ldyBNYXJrVmlld0Rlc2MocGFyZW50LCBtYXJrLCBzcGVjLmRvbSwgc3BlYy5jb250ZW50RE9NIHx8IHNwZWMuZG9tKVxuICB9O1xuXG4gIE1hcmtWaWV3RGVzYy5wcm90b3R5cGUucGFyc2VSdWxlID0gZnVuY3Rpb24gcGFyc2VSdWxlICgpIHsgcmV0dXJuIHttYXJrOiB0aGlzLm1hcmsudHlwZS5uYW1lLCBhdHRyczogdGhpcy5tYXJrLmF0dHJzLCBjb250ZW50RWxlbWVudDogdGhpcy5jb250ZW50RE9NfSB9O1xuXG4gIE1hcmtWaWV3RGVzYy5wcm90b3R5cGUubWF0Y2hlc01hcmsgPSBmdW5jdGlvbiBtYXRjaGVzTWFyayAobWFyaykgeyByZXR1cm4gdGhpcy5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHRoaXMubWFyay5lcShtYXJrKSB9O1xuXG4gIE1hcmtWaWV3RGVzYy5wcm90b3R5cGUubWFya0RpcnR5ID0gZnVuY3Rpb24gbWFya0RpcnR5IChmcm9tLCB0bykge1xuICAgIFZpZXdEZXNjLnByb3RvdHlwZS5tYXJrRGlydHkuY2FsbCh0aGlzLCBmcm9tLCB0byk7XG4gICAgLy8gTW92ZSBkaXJ0eSBpbmZvIHRvIG5lYXJlc3Qgbm9kZSB2aWV3XG4gICAgaWYgKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICB3aGlsZSAoIXBhcmVudC5ub2RlKSB7IHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7IH1cbiAgICAgIGlmIChwYXJlbnQuZGlydHkgPCB0aGlzLmRpcnR5KSB7IHBhcmVudC5kaXJ0eSA9IHRoaXMuZGlydHk7IH1cbiAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgfVxuICB9O1xuXG4gIE1hcmtWaWV3RGVzYy5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoZnJvbSwgdG8sIHZpZXcpIHtcbiAgICB2YXIgY29weSA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy5wYXJlbnQsIHRoaXMubWFyaywgdHJ1ZSwgdmlldyk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5jaGlsZHJlbiwgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBpZiAodG8gPCBzaXplKSB7IG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCB0bywgc2l6ZSwgdmlldyk7IH1cbiAgICBpZiAoZnJvbSA+IDApIHsgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIDAsIGZyb20sIHZpZXcpOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykgeyBub2Rlc1tpXS5wYXJlbnQgPSBjb3B5OyB9XG4gICAgY29weS5jaGlsZHJlbiA9IG5vZGVzO1xuICAgIHJldHVybiBjb3B5XG4gIH07XG5cbiAgcmV0dXJuIE1hcmtWaWV3RGVzYztcbn0oVmlld0Rlc2MpKTtcblxuLy8gTm9kZSB2aWV3IGRlc2NzIGFyZSB0aGUgbWFpbiwgbW9zdCBjb21tb24gdHlwZSBvZiB2aWV3IGRlc2MsIGFuZFxuLy8gY29ycmVzcG9uZCB0byBhbiBhY3R1YWwgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFVubGlrZSBtYXJrIGRlc2NzLFxuLy8gdGhleSBwb3B1bGF0ZSB0aGVpciBjaGlsZCBhcnJheSB0aGVtc2VsdmVzLlxudmFyIE5vZGVWaWV3RGVzYyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFZpZXdEZXNjKSB7XG4gIGZ1bmN0aW9uIE5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00sIG5vZGVET00sIHZpZXcsIHBvcykge1xuICAgIFZpZXdEZXNjLmNhbGwodGhpcywgcGFyZW50LCBub2RlLmlzTGVhZiA/IG5vdGhpbmcgOiBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICB0aGlzLm5vZGVET00gPSBub2RlRE9NO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgdGhpcy5pbm5lckRlY28gPSBpbm5lckRlY287XG4gICAgaWYgKGNvbnRlbnRET00pIHsgdGhpcy51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MpOyB9XG4gIH1cblxuICBpZiAoIFZpZXdEZXNjICkgTm9kZVZpZXdEZXNjLl9fcHJvdG9fXyA9IFZpZXdEZXNjO1xuICBOb2RlVmlld0Rlc2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVmlld0Rlc2MgJiYgVmlld0Rlc2MucHJvdG90eXBlICk7XG4gIE5vZGVWaWV3RGVzYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOb2RlVmlld0Rlc2M7XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyQzID0geyBzaXplOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGJvcmRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxkb21BdG9tOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgYSBub2RlIGlzIHJlbmRlcmVkIHVzaW5nIHRoZSBgdG9ET01gIG1ldGhvZCBmcm9tIHRoZVxuICAvLyBub2RlIHR5cGUgc3BlYy4gQnV0IGNsaWVudCBjb2RlIGNhbiB1c2UgdGhlIGBub2RlVmlld3NgIHNwZWMgdG9cbiAgLy8gc3VwcGx5IGEgY3VzdG9tIG5vZGUgdmlldywgd2hpY2ggY2FuIGluZmx1ZW5jZSB2YXJpb3VzIGFzcGVjdHMgb2ZcbiAgLy8gdGhlIHdheSB0aGUgbm9kZSB3b3Jrcy5cbiAgLy9cbiAgLy8gKFVzaW5nIHN1YmNsYXNzaW5nIGZvciB0aGlzIHdhcyBpbnRlbnRpb25hbGx5IGRlY2lkZWQgYWdhaW5zdCxcbiAgLy8gc2luY2UgaXQnZCByZXF1aXJlIGV4cG9zaW5nIGEgd2hvbGUgc2xldyBvZiBmaW5pY2t5XG4gIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbHMgdG8gdGhlIHVzZXIgY29kZSB0aGF0IHRoZXkgcHJvYmFibHkgd2lsbFxuICAvLyBuZXZlciBuZWVkLilcbiAgTm9kZVZpZXdEZXNjLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgdmFyIGFzc2lnbjtcblxuICAgIHZhciBjdXN0b20gPSB2aWV3Lm5vZGVWaWV3c1tub2RlLnR5cGUubmFtZV0sIGRlc2NPYmo7XG4gICAgdmFyIHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG5vZGUsIHZpZXcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIChUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGN1c3RvbSB2aWV3IHRvIGZpbmQgaXRzXG4gICAgICAvLyBvd24gcG9zaXRpb24pXG4gICAgICBpZiAoIWRlc2NPYmopIHsgcmV0dXJuIHBvcyB9XG4gICAgICBpZiAoZGVzY09iai5wYXJlbnQpIHsgcmV0dXJuIGRlc2NPYmoucGFyZW50LnBvc0JlZm9yZUNoaWxkKGRlc2NPYmopIH1cbiAgICB9LCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG5cbiAgICB2YXIgZG9tID0gc3BlYyAmJiBzcGVjLmRvbSwgY29udGVudERPTSA9IHNwZWMgJiYgc3BlYy5jb250ZW50RE9NO1xuICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgaWYgKCFkb20pIHsgZG9tID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS50ZXh0KTsgfVxuICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlICE9IDMpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZXh0IG11c3QgYmUgcmVuZGVyZWQgYXMgYSBET00gdGV4dCBub2RlXCIpIH1cbiAgICB9IGVsc2UgaWYgKCFkb20pIHtcbigoYXNzaWduID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBub2RlLnR5cGUuc3BlYy50b0RPTShub2RlKSksIGRvbSA9IGFzc2lnbi5kb20sIGNvbnRlbnRET00gPSBhc3NpZ24uY29udGVudERPTSkpO1xuICAgIH1cbiAgICBpZiAoIWNvbnRlbnRET00gJiYgIW5vZGUuaXNUZXh0ICYmIGRvbS5ub2RlTmFtZSAhPSBcIkJSXCIpIHsgLy8gQ2hyb21lIGdldHMgY29uZnVzZWQgYnkgPGJyIGNvbnRlbnRlZGl0YWJsZT1mYWxzZT5cbiAgICAgIGlmICghZG9tLmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSkgeyBkb20uY29udGVudEVkaXRhYmxlID0gZmFsc2U7IH1cbiAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpIHsgZG9tLmRyYWdnYWJsZSA9IHRydWU7IH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZURPTSA9IGRvbTtcbiAgICBkb20gPSBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgbm9kZSk7XG5cbiAgICBpZiAoc3BlYylcbiAgICAgIHsgcmV0dXJuIGRlc2NPYmogPSBuZXcgQ3VzdG9tTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjLCB2aWV3LCBwb3MgKyAxKSB9XG4gICAgZWxzZSBpZiAobm9kZS5pc1RleHQpXG4gICAgICB7IHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldykgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIG5ldyBOb2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MgKyAxKSB9XG4gIH07XG5cbiAgTm9kZVZpZXdEZXNjLnByb3RvdHlwZS5wYXJzZVJ1bGUgPSBmdW5jdGlvbiBwYXJzZVJ1bGUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgLy8gRXhwZXJpbWVudGFsIGtsdWRnZSB0byBhbGxvdyBvcHQtaW4gcmUtcGFyc2luZyBvZiBub2Rlc1xuICAgIGlmICh0aGlzLm5vZGUudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpIHsgcmV0dXJuIG51bGwgfVxuICAgIC8vIEZJWE1FIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBjYW4gYWx3YXlzIHJldHVybiB0aGUgY3VycmVudFxuICAgIC8vIGF0dHJzIG1lYW5zIHRoYXQgaWYgdGhlIHVzZXIgc29tZWhvdyBtYW5hZ2VzIHRvIGNoYW5nZSB0aGVcbiAgICAvLyBhdHRycyBpbiB0aGUgZG9tLCB0aGF0IHdvbid0IGJlIHBpY2tlZCB1cC4gTm90IGVudGlyZWx5IHN1cmVcbiAgICAvLyB3aGV0aGVyIHRoaXMgaXMgYSBwcm9ibGVtXG4gICAgdmFyIHJ1bGUgPSB7bm9kZTogdGhpcy5ub2RlLnR5cGUubmFtZSwgYXR0cnM6IHRoaXMubm9kZS5hdHRyc307XG4gICAgaWYgKHRoaXMubm9kZS50eXBlLnNwZWMuY29kZSkgeyBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSA9IFwiZnVsbFwiOyB9XG4gICAgaWYgKHRoaXMuY29udGVudERPTSAmJiAhdGhpcy5jb250ZW50TG9zdCkgeyBydWxlLmNvbnRlbnRFbGVtZW50ID0gdGhpcy5jb250ZW50RE9NOyB9XG4gICAgZWxzZSB7IHJ1bGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5jb250ZW50RE9NID8gRnJhZ21lbnQuZW1wdHkgOiB0aGlzJDEubm9kZS5jb250ZW50OyB9OyB9XG4gICAgcmV0dXJuIHJ1bGVcbiAgfTtcblxuICBOb2RlVmlld0Rlc2MucHJvdG90eXBlLm1hdGNoZXNOb2RlID0gZnVuY3Rpb24gbWF0Y2hlc05vZGUgKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIG5vZGUuZXEodGhpcy5ub2RlKSAmJlxuICAgICAgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSAmJiBpbm5lckRlY28uZXEodGhpcy5pbm5lckRlY28pXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzJDMuc2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5vZGUubm9kZVNpemUgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMkMy5ib3JkZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ub2RlLmlzTGVhZiA/IDAgOiAxIH07XG5cbiAgLy8gU3luY3MgYHRoaXMuY2hpbGRyZW5gIHRvIG1hdGNoIGB0aGlzLm5vZGUuY29udGVudGAgYW5kIHRoZSBsb2NhbFxuICAvLyBkZWNvcmF0aW9ucywgcG9zc2libHkgaW50cm9kdWNpbmcgbmVzdGluZyBmb3IgbWFya3MuIFRoZW4sIGluIGFcbiAgLy8gc2VwYXJhdGUgc3RlcCwgc3luY3MgdGhlIERPTSBpbnNpZGUgYHRoaXMuY29udGVudERPTWAgdG9cbiAgLy8gYHRoaXMuY2hpbGRyZW5gLlxuICBOb2RlVmlld0Rlc2MucHJvdG90eXBlLnVwZGF0ZUNoaWxkcmVuID0gZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHZpZXcsIHBvcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGlubGluZSA9IHRoaXMubm9kZS5pbmxpbmVDb250ZW50LCBvZmYgPSBwb3M7XG4gICAgdmFyIGNvbXBvc2l0aW9uID0gdmlldy5jb21wb3NpbmcgJiYgdGhpcy5sb2NhbENvbXBvc2l0aW9uSW5mbyh2aWV3LCBwb3MpO1xuICAgIHZhciBsb2NhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucG9zID4gLTEgPyBjb21wb3NpdGlvbiA6IG51bGw7XG4gICAgdmFyIGNvbXBvc2l0aW9uSW5DaGlsZCA9IGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnBvcyA8IDA7XG4gICAgdmFyIHVwZGF0ZXIgPSBuZXcgVmlld1RyZWVVcGRhdGVyKHRoaXMsIGxvY2FsQ29tcG9zaXRpb24gJiYgbG9jYWxDb21wb3NpdGlvbi5ub2RlKTtcbiAgICBpdGVyRGVjbyh0aGlzLm5vZGUsIHRoaXMuaW5uZXJEZWNvLCBmdW5jdGlvbiAod2lkZ2V0LCBpLCBpbnNpZGVOb2RlKSB7XG4gICAgICBpZiAod2lkZ2V0LnNwZWMubWFya3MpXG4gICAgICAgIHsgdXBkYXRlci5zeW5jVG9NYXJrcyh3aWRnZXQuc3BlYy5tYXJrcywgaW5saW5lLCB2aWV3KTsgfVxuICAgICAgZWxzZSBpZiAod2lkZ2V0LnR5cGUuc2lkZSA+PSAwICYmICFpbnNpZGVOb2RlKVxuICAgICAgICB7IHVwZGF0ZXIuc3luY1RvTWFya3MoaSA9PSB0aGlzJDEubm9kZS5jaGlsZENvdW50ID8gTWFyay5ub25lIDogdGhpcyQxLm5vZGUuY2hpbGQoaSkubWFya3MsIGlubGluZSwgdmlldyk7IH1cbiAgICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgYSBkZXNjIG1hdGNoaW5nIHRoaXMgd2lkZ2V0LCByZXVzZSBpdCxcbiAgICAgIC8vIG90aGVyd2lzZSBpbnNlcnQgdGhlIHdpZGdldCBhcyBhIG5ldyB2aWV3IGRlc2MuXG4gICAgICB1cGRhdGVyLnBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgb2ZmKTtcbiAgICB9LCBmdW5jdGlvbiAoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIHdyYXBwaW5nIG1hcmsgZGVzY3MgbWF0Y2ggdGhlIG5vZGUncyBtYXJrcy5cbiAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoY2hpbGQubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAvLyBUcnkgc2V2ZXJhbCBzdHJhdGVnaWVzIGZvciBkcmF3aW5nIHRoaXMgbm9kZVxuICAgICAgdmFyIGNvbXBJbmRleDtcbiAgICAgIGlmICh1cGRhdGVyLmZpbmROb2RlTWF0Y2goY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpKSkgOyBlbHNlIGlmIChjb21wb3NpdGlvbkluQ2hpbGQgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+IG9mZiAmJlxuICAgICAgICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8IG9mZiArIGNoaWxkLm5vZGVTaXplICYmXG4gICAgICAgICAgICAgICAgIChjb21wSW5kZXggPSB1cGRhdGVyLmZpbmRJbmRleFdpdGhDaGlsZChjb21wb3NpdGlvbi5ub2RlKSkgPiAtMSAmJlxuICAgICAgICAgICAgICAgICB1cGRhdGVyLnVwZGF0ZU5vZGVBdChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGNvbXBJbmRleCwgdmlldykpIDsgZWxzZSBpZiAodXBkYXRlci51cGRhdGVOZXh0Tm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGkpKSA7IGVsc2Uge1xuICAgICAgICAvLyBBZGQgaXQgYXMgYSBuZXcgdmlld1xuICAgICAgICB1cGRhdGVyLmFkZE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBvZmYpO1xuICAgICAgfVxuICAgICAgb2ZmICs9IGNoaWxkLm5vZGVTaXplO1xuICAgIH0pO1xuICAgIC8vIERyb3AgYWxsIHJlbWFpbmluZyBkZXNjcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICB1cGRhdGVyLnN5bmNUb01hcmtzKG5vdGhpbmcsIGlubGluZSwgdmlldyk7XG4gICAgaWYgKHRoaXMubm9kZS5pc1RleHRibG9jaykgeyB1cGRhdGVyLmFkZFRleHRibG9ja0hhY2tzKCk7IH1cbiAgICB1cGRhdGVyLmRlc3Ryb3lSZXN0KCk7XG5cbiAgICAvLyBTeW5jIHRoZSBET00gaWYgYW55dGhpbmcgY2hhbmdlZFxuICAgIGlmICh1cGRhdGVyLmNoYW5nZWQgfHwgdGhpcy5kaXJ0eSA9PSBDT05URU5UX0RJUlRZKSB7XG4gICAgICAvLyBNYXkgaGF2ZSB0byBwcm90ZWN0IGZvY3VzZWQgRE9NIGZyb20gYmVpbmcgY2hhbmdlZCBpZiBhIGNvbXBvc2l0aW9uIGlzIGFjdGl2ZVxuICAgICAgaWYgKGxvY2FsQ29tcG9zaXRpb24pIHsgdGhpcy5wcm90ZWN0TG9jYWxDb21wb3NpdGlvbih2aWV3LCBsb2NhbENvbXBvc2l0aW9uKTsgfVxuICAgICAgcmVuZGVyRGVzY3ModGhpcy5jb250ZW50RE9NLCB0aGlzLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgIGlmIChyZXN1bHQuaW9zKSB7IGlvc0hhY2tzKHRoaXMuZG9tKTsgfVxuICAgIH1cbiAgfTtcblxuICBOb2RlVmlld0Rlc2MucHJvdG90eXBlLmxvY2FsQ29tcG9zaXRpb25JbmZvID0gZnVuY3Rpb24gbG9jYWxDb21wb3NpdGlvbkluZm8gKHZpZXcsIHBvcykge1xuICAgIC8vIE9ubHkgZG8gc29tZXRoaW5nIGlmIGJvdGggdGhlIHNlbGVjdGlvbiBhbmQgYSBmb2N1c2VkIHRleHQgbm9kZVxuICAgIC8vIGFyZSBpbnNpZGUgb2YgdGhpcyBub2RlXG4gICAgdmFyIHJlZiA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIHZhciBmcm9tID0gcmVmLmZyb207XG4gICAgdmFyIHRvID0gcmVmLnRvO1xuICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgZnJvbSA8IHBvcyB8fCB0byA+IHBvcyArIHRoaXMubm9kZS5jb250ZW50LnNpemUpIHsgcmV0dXJuIH1cbiAgICB2YXIgc2VsID0gdmlldy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgaWYgKCF0ZXh0Tm9kZSB8fCAhdGhpcy5kb20uY29udGFpbnModGV4dE5vZGUucGFyZW50Tm9kZSkpIHsgcmV0dXJuIH1cblxuICAgIGlmICh0aGlzLm5vZGUuaW5saW5lQ29udGVudCkge1xuICAgICAgLy8gRmluZCB0aGUgdGV4dCBpbiB0aGUgZm9jdXNlZCBub2RlIGluIHRoZSBub2RlLCBzdG9wIGlmIGl0J3Mgbm90XG4gICAgICAvLyB0aGVyZSAobWF5IGhhdmUgYmVlbiBtb2RpZmllZCB0aHJvdWdoIG90aGVyIG1lYW5zLCBpbiB3aGljaFxuICAgICAgLy8gY2FzZSBpdCBzaG91bGQgb3ZlcndyaXR0ZW4pXG4gICAgICB2YXIgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgIHZhciB0ZXh0UG9zID0gZmluZFRleHRJbkZyYWdtZW50KHRoaXMubm9kZS5jb250ZW50LCB0ZXh0LCBmcm9tIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICByZXR1cm4gdGV4dFBvcyA8IDAgPyBudWxsIDoge25vZGU6IHRleHROb2RlLCBwb3M6IHRleHRQb3MsIHRleHQ6IHRleHR9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7bm9kZTogdGV4dE5vZGUsIHBvczogLTF9XG4gICAgfVxuICB9O1xuXG4gIE5vZGVWaWV3RGVzYy5wcm90b3R5cGUucHJvdGVjdExvY2FsQ29tcG9zaXRpb24gPSBmdW5jdGlvbiBwcm90ZWN0TG9jYWxDb21wb3NpdGlvbiAodmlldywgcmVmKSB7XG4gICAgdmFyIG5vZGUgPSByZWYubm9kZTtcbiAgICB2YXIgcG9zID0gcmVmLnBvcztcbiAgICB2YXIgdGV4dCA9IHJlZi50ZXh0O1xuXG4gICAgLy8gVGhlIG5vZGUgaXMgYWxyZWFkeSBwYXJ0IG9mIGEgbG9jYWwgdmlldyBkZXNjLCBsZWF2ZSBpdCB0aGVyZVxuICAgIGlmICh0aGlzLmdldERlc2Mobm9kZSkpIHsgcmV0dXJuIH1cblxuICAgIC8vIENyZWF0ZSBhIGNvbXBvc2l0aW9uIHZpZXcgZm9yIHRoZSBvcnBoYW5lZCBub2Rlc1xuICAgIHZhciB0b3BOb2RlID0gbm9kZTtcbiAgICBmb3IgKDs7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmICh0b3BOb2RlLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKSB7IGJyZWFrIH1cbiAgICAgIHdoaWxlICh0b3BOb2RlLnByZXZpb3VzU2libGluZykgeyB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5wcmV2aW91c1NpYmxpbmcpOyB9XG4gICAgICB3aGlsZSAodG9wTm9kZS5uZXh0U2libGluZykgeyB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5uZXh0U2libGluZyk7IH1cbiAgICAgIGlmICh0b3BOb2RlLnBtVmlld0Rlc2MpIHsgdG9wTm9kZS5wbVZpZXdEZXNjID0gbnVsbDsgfVxuICAgIH1cbiAgICB2YXIgZGVzYyA9IG5ldyBDb21wb3NpdGlvblZpZXdEZXNjKHRoaXMsIHRvcE5vZGUsIG5vZGUsIHRleHQpO1xuICAgIHZpZXcuY29tcG9zaXRpb25Ob2Rlcy5wdXNoKGRlc2MpO1xuXG4gICAgLy8gUGF0Y2ggdXAgdGhpcy5jaGlsZHJlbiB0byBjb250YWluIHRoZSBjb21wb3NpdGlvbiB2aWV3XG4gICAgdGhpcy5jaGlsZHJlbiA9IHJlcGxhY2VOb2Rlcyh0aGlzLmNoaWxkcmVuLCBwb3MsIHBvcyArIHRleHQubGVuZ3RoLCB2aWV3LCBkZXNjKTtcbiAgfTtcblxuICAvLyA6IChOb2RlLCBbRGVjb3JhdGlvbl0sIERlY29yYXRpb25Tb3VyY2UsIEVkaXRvclZpZXcpIOKGkiBib29sXG4gIC8vIElmIHRoaXMgZGVzYyBiZSB1cGRhdGVkIHRvIG1hdGNoIHRoZSBnaXZlbiBub2RlIGRlY29yYXRpb24sXG4gIC8vIGRvIHNvIGFuZCByZXR1cm4gdHJ1ZS5cbiAgTm9kZVZpZXdEZXNjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSB8fFxuICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB0aGlzLnVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIE5vZGVWaWV3RGVzYy5wcm90b3R5cGUudXBkYXRlSW5uZXIgPSBmdW5jdGlvbiB1cGRhdGVJbm5lciAobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5pbm5lckRlY28gPSBpbm5lckRlY287XG4gICAgaWYgKHRoaXMuY29udGVudERPTSkgeyB0aGlzLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHRoaXMucG9zQXRTdGFydCk7IH1cbiAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICB9O1xuXG4gIE5vZGVWaWV3RGVzYy5wcm90b3R5cGUudXBkYXRlT3V0ZXJEZWNvID0gZnVuY3Rpb24gdXBkYXRlT3V0ZXJEZWNvIChvdXRlckRlY28pIHtcbiAgICBpZiAoc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSkgeyByZXR1cm4gfVxuICAgIHZhciBuZWVkc1dyYXAgPSB0aGlzLm5vZGVET00ubm9kZVR5cGUgIT0gMTtcbiAgICB2YXIgb2xkRE9NID0gdGhpcy5kb207XG4gICAgdGhpcy5kb20gPSBwYXRjaE91dGVyRGVjbyh0aGlzLmRvbSwgdGhpcy5ub2RlRE9NLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZU91dGVyRGVjbyh0aGlzLm91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMubm9kZSwgbmVlZHNXcmFwKSk7XG4gICAgaWYgKHRoaXMuZG9tICE9IG9sZERPTSkge1xuICAgICAgb2xkRE9NLnBtVmlld0Rlc2MgPSBudWxsO1xuICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICB9O1xuXG4gIC8vIE1hcmsgdGhpcyBub2RlIGFzIGJlaW5nIHRoZSBzZWxlY3RlZCBub2RlLlxuICBOb2RlVmlld0Rlc2MucHJvdG90eXBlLnNlbGVjdE5vZGUgPSBmdW5jdGlvbiBzZWxlY3ROb2RlICgpIHtcbiAgICB0aGlzLm5vZGVET00uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSkgeyB0aGlzLmRvbS5kcmFnZ2FibGUgPSB0cnVlOyB9XG4gIH07XG5cbiAgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGUgbWFya2luZyBmcm9tIHRoaXMgbm9kZS5cbiAgTm9kZVZpZXdEZXNjLnByb3RvdHlwZS5kZXNlbGVjdE5vZGUgPSBmdW5jdGlvbiBkZXNlbGVjdE5vZGUgKCkge1xuICAgIHRoaXMubm9kZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKSB7IHRoaXMuZG9tLnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTsgfVxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycyQzLmRvbUF0b20uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ub2RlLmlzQXRvbSB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBOb2RlVmlld0Rlc2MucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMyApO1xuXG4gIHJldHVybiBOb2RlVmlld0Rlc2M7XG59KFZpZXdEZXNjKSk7XG5cbi8vIENyZWF0ZSBhIHZpZXcgZGVzYyBmb3IgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBub2RlLCB0byBiZSBleHBvcnRlZFxuLy8gYW5kIHVzZWQgYnkgdGhlIHZpZXcgY2xhc3MuXG5mdW5jdGlvbiBkb2NWaWV3RGVzYyhkb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIHZpZXcpIHtcbiAgYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIGRvYyk7XG4gIHJldHVybiBuZXcgTm9kZVZpZXdEZXNjKG51bGwsIGRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgZG9tLCBkb20sIHZpZXcsIDApXG59XG5cbnZhciBUZXh0Vmlld0Rlc2MgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChOb2RlVmlld0Rlc2MpIHtcbiAgZnVuY3Rpb24gVGV4dFZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldykge1xuICAgIE5vZGVWaWV3RGVzYy5jYWxsKHRoaXMsIHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbnVsbCwgbm9kZURPTSwgdmlldyk7XG4gIH1cblxuICBpZiAoIE5vZGVWaWV3RGVzYyApIFRleHRWaWV3RGVzYy5fX3Byb3RvX18gPSBOb2RlVmlld0Rlc2M7XG4gIFRleHRWaWV3RGVzYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBOb2RlVmlld0Rlc2MgJiYgTm9kZVZpZXdEZXNjLnByb3RvdHlwZSApO1xuICBUZXh0Vmlld0Rlc2MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dFZpZXdEZXNjO1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMkNCA9IHsgZG9tQXRvbTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIFRleHRWaWV3RGVzYy5wcm90b3R5cGUucGFyc2VSdWxlID0gZnVuY3Rpb24gcGFyc2VSdWxlICgpIHtcbiAgICB2YXIgc2tpcCA9IHRoaXMubm9kZURPTS5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChza2lwICYmIHNraXAgIT0gdGhpcy5kb20gJiYgIXNraXAucG1Jc0RlY28pIHsgc2tpcCA9IHNraXAucGFyZW50Tm9kZTsgfVxuICAgIHJldHVybiB7c2tpcDogc2tpcCB8fCB0cnVlfVxuICB9O1xuXG4gIFRleHRWaWV3RGVzYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChub2RlLCBvdXRlckRlY28sIF8sIHZpZXcpIHtcbiAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8ICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSAmJiAhdGhpcy5pblBhcmVudCgpKSB8fFxuICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgIGlmICgodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkgfHwgbm9kZS50ZXh0ICE9IHRoaXMubm9kZS50ZXh0KSAmJiBub2RlLnRleHQgIT0gdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSkge1xuICAgICAgdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSA9IG5vZGUudGV4dDtcbiAgICAgIGlmICh2aWV3LnRyYWNrV3JpdGVzID09IHRoaXMubm9kZURPTSkgeyB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDsgfVxuICAgIH1cbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICBUZXh0Vmlld0Rlc2MucHJvdG90eXBlLmluUGFyZW50ID0gZnVuY3Rpb24gaW5QYXJlbnQgKCkge1xuICAgIHZhciBwYXJlbnRET00gPSB0aGlzLnBhcmVudC5jb250ZW50RE9NO1xuICAgIGZvciAodmFyIG4gPSB0aGlzLm5vZGVET007IG47IG4gPSBuLnBhcmVudE5vZGUpIHsgaWYgKG4gPT0gcGFyZW50RE9NKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIFRleHRWaWV3RGVzYy5wcm90b3R5cGUuZG9tRnJvbVBvcyA9IGZ1bmN0aW9uIGRvbUZyb21Qb3MgKHBvcykge1xuICAgIHJldHVybiB7bm9kZTogdGhpcy5ub2RlRE9NLCBvZmZzZXQ6IHBvc31cbiAgfTtcblxuICBUZXh0Vmlld0Rlc2MucHJvdG90eXBlLmxvY2FsUG9zRnJvbURPTSA9IGZ1bmN0aW9uIGxvY2FsUG9zRnJvbURPTSAoZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICBpZiAoZG9tID09IHRoaXMubm9kZURPTSkgeyByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgTWF0aC5taW4ob2Zmc2V0LCB0aGlzLm5vZGUudGV4dC5sZW5ndGgpIH1cbiAgICByZXR1cm4gTm9kZVZpZXdEZXNjLnByb3RvdHlwZS5sb2NhbFBvc0Zyb21ET00uY2FsbCh0aGlzLCBkb20sIG9mZnNldCwgYmlhcylcbiAgfTtcblxuICBUZXh0Vmlld0Rlc2MucHJvdG90eXBlLmlnbm9yZU11dGF0aW9uID0gZnVuY3Rpb24gaWdub3JlTXV0YXRpb24gKG11dGF0aW9uKSB7XG4gICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgIT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbXV0YXRpb24udHlwZSAhPSBcInNlbGVjdGlvblwiXG4gIH07XG5cbiAgVGV4dFZpZXdEZXNjLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChmcm9tLCB0bywgdmlldykge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlLmN1dChmcm9tLCB0byksIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgcmV0dXJuIG5ldyBUZXh0Vmlld0Rlc2ModGhpcy5wYXJlbnQsIG5vZGUsIHRoaXMub3V0ZXJEZWNvLCB0aGlzLmlubmVyRGVjbywgZG9tLCBkb20sIHZpZXcpXG4gIH07XG5cbiAgVGV4dFZpZXdEZXNjLnByb3RvdHlwZS5tYXJrRGlydHkgPSBmdW5jdGlvbiBtYXJrRGlydHkgKGZyb20sIHRvKSB7XG4gICAgTm9kZVZpZXdEZXNjLnByb3RvdHlwZS5tYXJrRGlydHkuY2FsbCh0aGlzLCBmcm9tLCB0byk7XG4gICAgaWYgKHRoaXMuZG9tICE9IHRoaXMubm9kZURPTSAmJiAoZnJvbSA9PSAwIHx8IHRvID09IHRoaXMubm9kZURPTS5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgIHsgdGhpcy5kaXJ0eSA9IE5PREVfRElSVFk7IH1cbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMkNC5kb21BdG9tLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRleHRWaWV3RGVzYy5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQ0ICk7XG5cbiAgcmV0dXJuIFRleHRWaWV3RGVzYztcbn0oTm9kZVZpZXdEZXNjKSk7XG5cbi8vIEEgZHVtbXkgZGVzYyB1c2VkIHRvIHRhZyB0cmFpbGluZyBCUiBvciBJTUcgbm9kZXMgY3JlYXRlZCB0byB3b3JrXG4vLyBhcm91bmQgY29udGVudEVkaXRhYmxlIHRlcnJpYmxlbmVzcy5cbnZhciBUcmFpbGluZ0hhY2tWaWV3RGVzYyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFZpZXdEZXNjKSB7XG4gIGZ1bmN0aW9uIFRyYWlsaW5nSGFja1ZpZXdEZXNjICgpIHtcbiAgICBWaWV3RGVzYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCBWaWV3RGVzYyApIFRyYWlsaW5nSGFja1ZpZXdEZXNjLl9fcHJvdG9fXyA9IFZpZXdEZXNjO1xuICBUcmFpbGluZ0hhY2tWaWV3RGVzYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBWaWV3RGVzYyAmJiBWaWV3RGVzYy5wcm90b3R5cGUgKTtcbiAgVHJhaWxpbmdIYWNrVmlld0Rlc2MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhaWxpbmdIYWNrVmlld0Rlc2M7XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyQ1ID0geyBkb21BdG9tOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlnbm9yZUZvckNvb3JkczogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIFRyYWlsaW5nSGFja1ZpZXdEZXNjLnByb3RvdHlwZS5wYXJzZVJ1bGUgPSBmdW5jdGlvbiBwYXJzZVJ1bGUgKCkgeyByZXR1cm4ge2lnbm9yZTogdHJ1ZX0gfTtcbiAgVHJhaWxpbmdIYWNrVmlld0Rlc2MucHJvdG90eXBlLm1hdGNoZXNIYWNrID0gZnVuY3Rpb24gbWF0Y2hlc0hhY2sgKG5vZGVOYW1lKSB7IHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBub2RlTmFtZSB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMkNS5kb21BdG9tLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcbiAgcHJvdG90eXBlQWNjZXNzb3JzJDUuaWdub3JlRm9yQ29vcmRzLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZG9tLm5vZGVOYW1lID09IFwiSU1HXCIgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVHJhaWxpbmdIYWNrVmlld0Rlc2MucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkNSApO1xuXG4gIHJldHVybiBUcmFpbGluZ0hhY2tWaWV3RGVzYztcbn0oVmlld0Rlc2MpKTtcblxuLy8gQSBzZXBhcmF0ZSBzdWJjbGFzcyBpcyB1c2VkIGZvciBjdXN0b21pemVkIG5vZGUgdmlld3MsIHNvIHRoYXQgdGhlXG4vLyBleHRyYSBjaGVja3Mgb25seSBoYXZlIHRvIGJlIG1hZGUgZm9yIG5vZGVzIHRoYXQgYXJlIGFjdHVhbGx5XG4vLyBjdXN0b21pemVkLlxudmFyIEN1c3RvbU5vZGVWaWV3RGVzYyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE5vZGVWaWV3RGVzYykge1xuICBmdW5jdGlvbiBDdXN0b21Ob2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MpIHtcbiAgICBOb2RlVmlld0Rlc2MuY2FsbCh0aGlzLCBwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00sIG5vZGVET00sIHZpZXcsIHBvcyk7XG4gICAgdGhpcy5zcGVjID0gc3BlYztcbiAgfVxuXG4gIGlmICggTm9kZVZpZXdEZXNjICkgQ3VzdG9tTm9kZVZpZXdEZXNjLl9fcHJvdG9fXyA9IE5vZGVWaWV3RGVzYztcbiAgQ3VzdG9tTm9kZVZpZXdEZXNjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE5vZGVWaWV3RGVzYyAmJiBOb2RlVmlld0Rlc2MucHJvdG90eXBlICk7XG4gIEN1c3RvbU5vZGVWaWV3RGVzYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdXN0b21Ob2RlVmlld0Rlc2M7XG5cbiAgLy8gQSBjdXN0b20gYHVwZGF0ZWAgbWV0aG9kIGdldHMgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHVwZGF0ZSBnb2VzXG4gIC8vIHRocm91Z2guIElmIGl0IGRvZXMsIGFuZCB0aGVyZSdzIGEgYGNvbnRlbnRET01gIG5vZGUsIG91ciBsb2dpY1xuICAvLyB1cGRhdGVzIHRoZSBjaGlsZHJlbi5cbiAgQ3VzdG9tTm9kZVZpZXdEZXNjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0aGlzLnNwZWMudXBkYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zcGVjLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICBpZiAocmVzdWx0KSB7IHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpOyB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBlbHNlIGlmICghdGhpcy5jb250ZW50RE9NICYmICFub2RlLmlzTGVhZikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBOb2RlVmlld0Rlc2MucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KVxuICAgIH1cbiAgfTtcblxuICBDdXN0b21Ob2RlVmlld0Rlc2MucHJvdG90eXBlLnNlbGVjdE5vZGUgPSBmdW5jdGlvbiBzZWxlY3ROb2RlICgpIHtcbiAgICB0aGlzLnNwZWMuc2VsZWN0Tm9kZSA/IHRoaXMuc3BlYy5zZWxlY3ROb2RlKCkgOiBOb2RlVmlld0Rlc2MucHJvdG90eXBlLnNlbGVjdE5vZGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBDdXN0b21Ob2RlVmlld0Rlc2MucHJvdG90eXBlLmRlc2VsZWN0Tm9kZSA9IGZ1bmN0aW9uIGRlc2VsZWN0Tm9kZSAoKSB7XG4gICAgdGhpcy5zcGVjLmRlc2VsZWN0Tm9kZSA/IHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUoKSA6IE5vZGVWaWV3RGVzYy5wcm90b3R5cGUuZGVzZWxlY3ROb2RlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgQ3VzdG9tTm9kZVZpZXdEZXNjLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiBzZXRTZWxlY3Rpb24gKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UpIHtcbiAgICB0aGlzLnNwZWMuc2V0U2VsZWN0aW9uID8gdGhpcy5zcGVjLnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHJvb3QpXG4gICAgICA6IE5vZGVWaWV3RGVzYy5wcm90b3R5cGUuc2V0U2VsZWN0aW9uLmNhbGwodGhpcywgYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSk7XG4gIH07XG5cbiAgQ3VzdG9tTm9kZVZpZXdEZXNjLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KSB7IHRoaXMuc3BlYy5kZXN0cm95KCk7IH1cbiAgICBOb2RlVmlld0Rlc2MucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBDdXN0b21Ob2RlVmlld0Rlc2MucHJvdG90eXBlLnN0b3BFdmVudCA9IGZ1bmN0aW9uIHN0b3BFdmVudCAoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5zcGVjLnN0b3BFdmVudCA/IHRoaXMuc3BlYy5zdG9wRXZlbnQoZXZlbnQpIDogZmFsc2VcbiAgfTtcblxuICBDdXN0b21Ob2RlVmlld0Rlc2MucHJvdG90eXBlLmlnbm9yZU11dGF0aW9uID0gZnVuY3Rpb24gaWdub3JlTXV0YXRpb24gKG11dGF0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBOb2RlVmlld0Rlc2MucHJvdG90eXBlLmlnbm9yZU11dGF0aW9uLmNhbGwodGhpcywgbXV0YXRpb24pXG4gIH07XG5cbiAgcmV0dXJuIEN1c3RvbU5vZGVWaWV3RGVzYztcbn0oTm9kZVZpZXdEZXNjKSk7XG5cbi8vIDogKGRvbS5Ob2RlLCBbVmlld0Rlc2NdKVxuLy8gU3luYyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgd2l0aCB0aGUgbm9kZXMgYXNzb2NpYXRlZFxuLy8gd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgdmlldyBkZXNjcywgcmVjdXJzaW5nIGludG8gbWFyayBkZXNjc1xuLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBzeW5jIHRoZSBzdWJ0cmVlIGZvciBhIHdob2xlIG5vZGUgYXQgYSB0aW1lLlxuZnVuY3Rpb24gcmVuZGVyRGVzY3MocGFyZW50RE9NLCBkZXNjcywgdmlldykge1xuICB2YXIgZG9tID0gcGFyZW50RE9NLmZpcnN0Q2hpbGQsIHdyaXR0ZW4gPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXNjcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjID0gZGVzY3NbaV0sIGNoaWxkRE9NID0gZGVzYy5kb207XG4gICAgaWYgKGNoaWxkRE9NLnBhcmVudE5vZGUgPT0gcGFyZW50RE9NKSB7XG4gICAgICB3aGlsZSAoY2hpbGRET00gIT0gZG9tKSB7IGRvbSA9IHJtKGRvbSk7IHdyaXR0ZW4gPSB0cnVlOyB9XG4gICAgICBkb20gPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgcGFyZW50RE9NLmluc2VydEJlZm9yZShjaGlsZERPTSwgZG9tKTtcbiAgICB9XG4gICAgaWYgKGRlc2MgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgIHZhciBwb3MgPSBkb20gPyBkb20ucHJldmlvdXNTaWJsaW5nIDogcGFyZW50RE9NLmxhc3RDaGlsZDtcbiAgICAgIHJlbmRlckRlc2NzKGRlc2MuY29udGVudERPTSwgZGVzYy5jaGlsZHJlbiwgdmlldyk7XG4gICAgICBkb20gPSBwb3MgPyBwb3MubmV4dFNpYmxpbmcgOiBwYXJlbnRET00uZmlyc3RDaGlsZDtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGRvbSkgeyBkb20gPSBybShkb20pOyB3cml0dGVuID0gdHJ1ZTsgfVxuICBpZiAod3JpdHRlbiAmJiB2aWV3LnRyYWNrV3JpdGVzID09IHBhcmVudERPTSkgeyB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDsgfVxufVxuXG5mdW5jdGlvbiBPdXRlckRlY29MZXZlbChub2RlTmFtZSkge1xuICBpZiAobm9kZU5hbWUpIHsgdGhpcy5ub2RlTmFtZSA9IG5vZGVOYW1lOyB9XG59XG5PdXRlckRlY29MZXZlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG52YXIgbm9EZWNvID0gW25ldyBPdXRlckRlY29MZXZlbF07XG5cbmZ1bmN0aW9uIGNvbXB1dGVPdXRlckRlY28ob3V0ZXJEZWNvLCBub2RlLCBuZWVkc1dyYXApIHtcbiAgaWYgKG91dGVyRGVjby5sZW5ndGggPT0gMCkgeyByZXR1cm4gbm9EZWNvIH1cblxuICB2YXIgdG9wID0gbmVlZHNXcmFwID8gbm9EZWNvWzBdIDogbmV3IE91dGVyRGVjb0xldmVsLCByZXN1bHQgPSBbdG9wXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG91dGVyRGVjby5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRycyA9IG91dGVyRGVjb1tpXS50eXBlLmF0dHJzO1xuICAgIGlmICghYXR0cnMpIHsgY29udGludWUgfVxuICAgIGlmIChhdHRycy5ub2RlTmFtZSlcbiAgICAgIHsgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKGF0dHJzLm5vZGVOYW1lKSk7IH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgIHZhciB2YWwgPSBhdHRyc1tuYW1lXTtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkgeyBjb250aW51ZSB9XG4gICAgICBpZiAobmVlZHNXcmFwICYmIHJlc3VsdC5sZW5ndGggPT0gMSlcbiAgICAgICAgeyByZXN1bHQucHVzaCh0b3AgPSBuZXcgT3V0ZXJEZWNvTGV2ZWwobm9kZS5pc0lubGluZSA/IFwic3BhblwiIDogXCJkaXZcIikpOyB9XG4gICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIpIHsgdG9wLmNsYXNzID0gKHRvcC5jbGFzcyA/IHRvcC5jbGFzcyArIFwiIFwiIDogXCJcIikgKyB2YWw7IH1cbiAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKSB7IHRvcC5zdHlsZSA9ICh0b3Auc3R5bGUgPyB0b3Auc3R5bGUgKyBcIjtcIiA6IFwiXCIpICsgdmFsOyB9XG4gICAgICBlbHNlIGlmIChuYW1lICE9IFwibm9kZU5hbWVcIikgeyB0b3BbbmFtZV0gPSB2YWw7IH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHBhdGNoT3V0ZXJEZWNvKG91dGVyRE9NLCBub2RlRE9NLCBwcmV2Q29tcHV0ZWQsIGN1ckNvbXB1dGVkKSB7XG4gIC8vIFNob3J0Y3V0IGZvciB0cml2aWFsIGNhc2VcbiAgaWYgKHByZXZDb21wdXRlZCA9PSBub0RlY28gJiYgY3VyQ29tcHV0ZWQgPT0gbm9EZWNvKSB7IHJldHVybiBub2RlRE9NIH1cblxuICB2YXIgY3VyRE9NID0gbm9kZURPTTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJDb21wdXRlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZWNvID0gY3VyQ29tcHV0ZWRbaV0sIHByZXYgPSBwcmV2Q29tcHV0ZWRbaV07XG4gICAgaWYgKGkpIHtcbiAgICAgIHZhciBwYXJlbnQgPSAodm9pZCAwKTtcbiAgICAgIGlmIChwcmV2ICYmIHByZXYubm9kZU5hbWUgPT0gZGVjby5ub2RlTmFtZSAmJiBjdXJET00gIT0gb3V0ZXJET00gJiZcbiAgICAgICAgICAocGFyZW50ID0gY3VyRE9NLnBhcmVudE5vZGUpICYmIHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gZGVjby5ub2RlTmFtZSkge1xuICAgICAgICBjdXJET00gPSBwYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGRlY28ubm9kZU5hbWUpO1xuICAgICAgICBwYXJlbnQucG1Jc0RlY28gPSB0cnVlO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VyRE9NKTtcbiAgICAgICAgcHJldiA9IG5vRGVjb1swXTtcbiAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBwYXRjaEF0dHJpYnV0ZXMoY3VyRE9NLCBwcmV2IHx8IG5vRGVjb1swXSwgZGVjbyk7XG4gIH1cbiAgcmV0dXJuIGN1ckRPTVxufVxuXG5mdW5jdGlvbiBwYXRjaEF0dHJpYnV0ZXMoZG9tLCBwcmV2LCBjdXIpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiBwcmV2KVxuICAgIHsgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmICEobmFtZSBpbiBjdXIpKVxuICAgICAgeyBkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpOyB9IH1cbiAgZm9yICh2YXIgbmFtZSQxIGluIGN1cilcbiAgICB7IGlmIChuYW1lJDEgIT0gXCJjbGFzc1wiICYmIG5hbWUkMSAhPSBcInN0eWxlXCIgJiYgbmFtZSQxICE9IFwibm9kZU5hbWVcIiAmJiBjdXJbbmFtZSQxXSAhPSBwcmV2W25hbWUkMV0pXG4gICAgICB7IGRvbS5zZXRBdHRyaWJ1dGUobmFtZSQxLCBjdXJbbmFtZSQxXSk7IH0gfVxuICBpZiAocHJldi5jbGFzcyAhPSBjdXIuY2xhc3MpIHtcbiAgICB2YXIgcHJldkxpc3QgPSBwcmV2LmNsYXNzID8gcHJldi5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogbm90aGluZztcbiAgICB2YXIgY3VyTGlzdCA9IGN1ci5jbGFzcyA/IGN1ci5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogbm90aGluZztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZMaXN0Lmxlbmd0aDsgaSsrKSB7IGlmIChjdXJMaXN0LmluZGV4T2YocHJldkxpc3RbaV0pID09IC0xKVxuICAgICAgeyBkb20uY2xhc3NMaXN0LnJlbW92ZShwcmV2TGlzdFtpXSk7IH0gfVxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGN1ckxpc3QubGVuZ3RoOyBpJDErKykgeyBpZiAocHJldkxpc3QuaW5kZXhPZihjdXJMaXN0W2kkMV0pID09IC0xKVxuICAgICAgeyBkb20uY2xhc3NMaXN0LmFkZChjdXJMaXN0W2kkMV0pOyB9IH1cbiAgfVxuICBpZiAocHJldi5zdHlsZSAhPSBjdXIuc3R5bGUpIHtcbiAgICBpZiAocHJldi5zdHlsZSkge1xuICAgICAgdmFyIHByb3AgPSAvXFxzKihbXFx3XFwtXFx4YTEtXFx1ZmZmZl0rKVxccyo6KD86XCIoPzpcXFxcLnxbXlwiXSkqXCJ8Jyg/OlxcXFwufFteJ10pKid8XFwoLio/XFwpfFteO10pKi9nLCBtO1xuICAgICAgd2hpbGUgKG0gPSBwcm9wLmV4ZWMocHJldi5zdHlsZSkpXG4gICAgICAgIHsgZG9tLnN0eWxlLnJlbW92ZVByb3BlcnR5KG1bMV0pOyB9XG4gICAgfVxuICAgIGlmIChjdXIuc3R5bGUpXG4gICAgICB7IGRvbS5zdHlsZS5jc3NUZXh0ICs9IGN1ci5zdHlsZTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5T3V0ZXJEZWNvKGRvbSwgZGVjbywgbm9kZSkge1xuICByZXR1cm4gcGF0Y2hPdXRlckRlY28oZG9tLCBkb20sIG5vRGVjbywgY29tcHV0ZU91dGVyRGVjbyhkZWNvLCBub2RlLCBkb20ubm9kZVR5cGUgIT0gMSkpXG59XG5cbi8vIDogKFtEZWNvcmF0aW9uXSwgW0RlY29yYXRpb25dKSDihpIgYm9vbFxuZnVuY3Rpb24gc2FtZU91dGVyRGVjbyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHsgaWYgKCFhW2ldLnR5cGUuZXEoYltpXS50eXBlKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIFJlbW92ZSBhIERPTSBub2RlIGFuZCByZXR1cm4gaXRzIG5leHQgc2libGluZy5cbmZ1bmN0aW9uIHJtKGRvbSkge1xuICB2YXIgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgcmV0dXJuIG5leHRcbn1cblxuLy8gSGVscGVyIGNsYXNzIGZvciBpbmNyZW1lbnRhbGx5IHVwZGF0aW5nIGEgdHJlZSBvZiBtYXJrIGRlc2NzIGFuZFxuLy8gdGhlIHdpZGdldCBhbmQgbm9kZSBkZXNjcyBpbnNpZGUgb2YgdGhlbS5cbnZhciBWaWV3VHJlZVVwZGF0ZXIgPSBmdW5jdGlvbiBWaWV3VHJlZVVwZGF0ZXIodG9wLCBsb2NrZWROb2RlKSB7XG4gIHRoaXMudG9wID0gdG9wO1xuICB0aGlzLmxvY2sgPSBsb2NrZWROb2RlO1xuICAvLyBJbmRleCBpbnRvIGB0aGlzLnRvcGAncyBjaGlsZCBhcnJheSwgcmVwcmVzZW50cyB0aGUgY3VycmVudFxuICAvLyB1cGRhdGUgcG9zaXRpb24uXG4gIHRoaXMuaW5kZXggPSAwO1xuICAvLyBXaGVuIGVudGVyaW5nIGEgbWFyaywgdGhlIGN1cnJlbnQgdG9wIGFuZCBpbmRleCBhcmUgcHVzaGVkXG4gIC8vIG9udG8gdGhpcy5cbiAgdGhpcy5zdGFjayA9IFtdO1xuICAvLyBUcmFja3Mgd2hldGhlciBhbnl0aGluZyB3YXMgY2hhbmdlZFxuICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcblxuICB0aGlzLnByZU1hdGNoID0gcHJlTWF0Y2godG9wLm5vZGUuY29udGVudCwgdG9wLmNoaWxkcmVuKTtcbn07XG5cbi8vIERlc3Ryb3kgYW5kIHJlbW92ZSB0aGUgY2hpbGRyZW4gYmV0d2VlbiB0aGUgZ2l2ZW4gaW5kaWNlcyBpblxuLy8gYHRoaXMudG9wYC5cblZpZXdUcmVlVXBkYXRlci5wcm90b3R5cGUuZGVzdHJveUJldHdlZW4gPSBmdW5jdGlvbiBkZXN0cm95QmV0d2VlbiAoc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT0gZW5kKSB7IHJldHVybiB9XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7IHRoaXMudG9wLmNoaWxkcmVuW2ldLmRlc3Ryb3koKTsgfVxuICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbiAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbn07XG5cbi8vIERlc3Ryb3kgYWxsIHJlbWFpbmluZyBjaGlsZHJlbiBpbiBgdGhpcy50b3BgLlxuVmlld1RyZWVVcGRhdGVyLnByb3RvdHlwZS5kZXN0cm95UmVzdCA9IGZ1bmN0aW9uIGRlc3Ryb3lSZXN0ICgpIHtcbiAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpO1xufTtcblxuLy8gOiAoW01hcmtdLCBFZGl0b3JWaWV3KVxuLy8gU3luYyB0aGUgY3VycmVudCBzdGFjayBvZiBtYXJrIGRlc2NzIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mXG4vLyBtYXJrcywgcmV1c2luZyBleGlzdGluZyBtYXJrIGRlc2NzIHdoZW4gcG9zc2libGUuXG5WaWV3VHJlZVVwZGF0ZXIucHJvdG90eXBlLnN5bmNUb01hcmtzID0gZnVuY3Rpb24gc3luY1RvTWFya3MgKG1hcmtzLCBpbmxpbmUsIHZpZXcpIHtcbiAgdmFyIGtlZXAgPSAwLCBkZXB0aCA9IHRoaXMuc3RhY2subGVuZ3RoID4+IDE7XG4gIHZhciBtYXhLZWVwID0gTWF0aC5taW4oZGVwdGgsIG1hcmtzLmxlbmd0aCk7XG4gIHdoaWxlIChrZWVwIDwgbWF4S2VlcCAmJlxuICAgICAgICAgKGtlZXAgPT0gZGVwdGggLSAxID8gdGhpcy50b3AgOiB0aGlzLnN0YWNrWyhrZWVwICsgMSkgPDwgMV0pLm1hdGNoZXNNYXJrKG1hcmtzW2tlZXBdKSAmJiBtYXJrc1trZWVwXS50eXBlLnNwZWMuc3Bhbm5pbmcgIT09IGZhbHNlKVxuICAgIHsga2VlcCsrOyB9XG5cbiAgd2hpbGUgKGtlZXAgPCBkZXB0aCkge1xuICAgIHRoaXMuZGVzdHJveVJlc3QoKTtcbiAgICB0aGlzLnRvcC5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICB0aGlzLnRvcCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgZGVwdGgtLTtcbiAgfVxuICB3aGlsZSAoZGVwdGggPCBtYXJrcy5sZW5ndGgpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2godGhpcy50b3AsIHRoaXMuaW5kZXggKyAxKTtcbiAgICB2YXIgZm91bmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5pbmRleDsgaSA8IE1hdGgubWluKHRoaXMuaW5kZXggKyAzLCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnRvcC5jaGlsZHJlbltpXS5tYXRjaGVzTWFyayhtYXJrc1tkZXB0aF0pKSB7IGZvdW5kID0gaTsgYnJlYWsgfVxuICAgIH1cbiAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgaWYgKGZvdW5kID4gdGhpcy5pbmRleCkge1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9wID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXJrRGVzYyA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG1hcmtzW2RlcHRoXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4LCAwLCBtYXJrRGVzYyk7XG4gICAgICB0aGlzLnRvcCA9IG1hcmtEZXNjO1xuICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgZGVwdGgrKztcbiAgfVxufTtcblxuLy8gOiAoTm9kZSwgW0RlY29yYXRpb25dLCBEZWNvcmF0aW9uU291cmNlKSDihpIgYm9vbFxuLy8gVHJ5IHRvIGZpbmQgYSBub2RlIGRlc2MgbWF0Y2hpbmcgdGhlIGdpdmVuIGRhdGEuIFNraXAgb3ZlciBpdCBhbmRcbi8vIHJldHVybiB0cnVlIHdoZW4gc3VjY2Vzc2Z1bC5cblZpZXdUcmVlVXBkYXRlci5wcm90b3R5cGUuZmluZE5vZGVNYXRjaCA9IGZ1bmN0aW9uIGZpbmROb2RlTWF0Y2ggKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCkge1xuICB2YXIgY2hpbGRyZW4gPSB0aGlzLnRvcC5jaGlsZHJlbiwgZm91bmQgPSAtMTtcbiAgaWYgKGluZGV4ID49IHRoaXMucHJlTWF0Y2guaW5kZXgpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5pbmRleDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7IGlmIChjaGlsZHJlbltpXS5tYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykpIHtcbiAgICAgIGZvdW5kID0gaTtcbiAgICAgIGJyZWFrXG4gICAgfSB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSQxID0gdGhpcy5pbmRleCwgZSA9IE1hdGgubWluKGNoaWxkcmVuLmxlbmd0aCwgaSQxICsgMSk7IGkkMSA8IGU7IGkkMSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpJDFdO1xuICAgICAgaWYgKGNoaWxkLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSAmJiAhdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgZm91bmQgPSBpJDE7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChmb3VuZCA8IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gIHRoaXMuaW5kZXgrKztcbiAgcmV0dXJuIHRydWVcbn07XG5cblZpZXdUcmVlVXBkYXRlci5wcm90b3R5cGUudXBkYXRlTm9kZUF0ID0gZnVuY3Rpb24gdXBkYXRlTm9kZUF0IChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgsIHZpZXcpIHtcbiAgdmFyIGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baW5kZXhdO1xuICBpZiAoIWNoaWxkLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBpbmRleCk7XG4gIHRoaXMuaW5kZXggPSBpbmRleCArIDE7XG4gIHJldHVybiB0cnVlXG59O1xuXG5WaWV3VHJlZVVwZGF0ZXIucHJvdG90eXBlLmZpbmRJbmRleFdpdGhDaGlsZCA9IGZ1bmN0aW9uIGZpbmRJbmRleFdpdGhDaGlsZCAoZG9tTm9kZSkge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudCkgeyByZXR1cm4gLTEgfVxuICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AuY29udGVudERPTSkge1xuICAgICAgdmFyIGRlc2MgPSBkb21Ob2RlLnBtVmlld0Rlc2M7XG4gICAgICBpZiAoZGVzYykgeyBmb3IgKHZhciBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnRvcC5jaGlsZHJlbltpXSA9PSBkZXNjKSB7IHJldHVybiBpIH1cbiAgICAgIH0gfVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIGRvbU5vZGUgPSBwYXJlbnQ7XG4gIH1cbn07XG5cbi8vIDogKE5vZGUsIFtEZWNvcmF0aW9uXSwgRGVjb3JhdGlvblNvdXJjZSwgRWRpdG9yVmlldywgRnJhZ21lbnQsIG51bWJlcikg4oaSIGJvb2xcbi8vIFRyeSB0byB1cGRhdGUgdGhlIG5leHQgbm9kZSwgaWYgYW55LCB0byB0aGUgZ2l2ZW4gZGF0YS4gQ2hlY2tzXG4vLyBwcmUtbWF0Y2hlcyB0byBhdm9pZCBvdmVyd3JpdGluZyBub2RlcyB0aGF0IGNvdWxkIHN0aWxsIGJlIHVzZWQuXG5WaWV3VHJlZVVwZGF0ZXIucHJvdG90eXBlLnVwZGF0ZU5leHROb2RlID0gZnVuY3Rpb24gdXBkYXRlTmV4dE5vZGUgKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICBpZiAobmV4dCBpbnN0YW5jZW9mIE5vZGVWaWV3RGVzYykge1xuICAgICAgdmFyIHByZU1hdGNoID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmdldChuZXh0KTtcbiAgICAgIGlmIChwcmVNYXRjaCAhPSBudWxsICYmIHByZU1hdGNoICE9IGluZGV4KSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgbmV4dERPTSA9IG5leHQuZG9tO1xuXG4gICAgICAvLyBDYW4ndCB1cGRhdGUgaWYgbmV4dERPTSBpcyBvciBjb250YWlucyB0aGlzLmxvY2ssIGV4Y2VwdCBpZlxuICAgICAgLy8gaXQncyBhIHRleHQgbm9kZSB3aG9zZSBjb250ZW50IGFscmVhZHkgbWF0Y2hlcyB0aGUgbmV3IHRleHRcbiAgICAgIC8vIGFuZCB3aG9zZSBkZWNvcmF0aW9ucyBtYXRjaCB0aGUgbmV3IG9uZXMuXG4gICAgICB2YXIgbG9ja2VkID0gdGhpcy5sb2NrICYmIChuZXh0RE9NID09IHRoaXMubG9jayB8fCBuZXh0RE9NLm5vZGVUeXBlID09IDEgJiYgbmV4dERPTS5jb250YWlucyh0aGlzLmxvY2sucGFyZW50Tm9kZSkpICYmXG4gICAgICAgICAgIShub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGUgJiYgbmV4dC5ub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGVET00ubm9kZVZhbHVlID09IG5vZGUudGV4dCAmJlxuICAgICAgICAgICAgbmV4dC5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykpO1xuICAgICAgaWYgKCFsb2NrZWQgJiYgbmV4dC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaSk7XG4gICAgICAgIGlmIChuZXh0LmRvbSAhPSBuZXh0RE9NKSB7IHRoaXMuY2hhbmdlZCA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyA6IChOb2RlLCBbRGVjb3JhdGlvbl0sIERlY29yYXRpb25Tb3VyY2UsIEVkaXRvclZpZXcpXG4vLyBJbnNlcnQgdGhlIG5vZGUgYXMgYSBuZXdseSBjcmVhdGVkIG5vZGUgZGVzYy5cblZpZXdUcmVlVXBkYXRlci5wcm90b3R5cGUuYWRkTm9kZSA9IGZ1bmN0aW9uIGFkZE5vZGUgKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgTm9kZVZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykpO1xuICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xufTtcblxuVmlld1RyZWVVcGRhdGVyLnByb3RvdHlwZS5wbGFjZVdpZGdldCA9IGZ1bmN0aW9uIHBsYWNlV2lkZ2V0ICh3aWRnZXQsIHZpZXcsIHBvcykge1xuICB2YXIgbmV4dCA9IHRoaXMuaW5kZXggPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA6IG51bGw7XG4gIGlmIChuZXh0ICYmIG5leHQubWF0Y2hlc1dpZGdldCh3aWRnZXQpICYmICh3aWRnZXQgPT0gbmV4dC53aWRnZXQgfHwgIW5leHQud2lkZ2V0LnR5cGUudG9ET00ucGFyZW50Tm9kZSkpIHtcbiAgICB0aGlzLmluZGV4Kys7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlc2MgPSBuZXcgV2lkZ2V0Vmlld0Rlc2ModGhpcy50b3AsIHdpZGdldCwgdmlldywgcG9zKTtcbiAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBkZXNjKTtcbiAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICB9XG59O1xuXG4vLyBNYWtlIHN1cmUgYSB0ZXh0YmxvY2sgbG9va3MgYW5kIGJlaGF2ZXMgY29ycmVjdGx5IGluXG4vLyBjb250ZW50RWRpdGFibGUuXG5WaWV3VHJlZVVwZGF0ZXIucHJvdG90eXBlLmFkZFRleHRibG9ja0hhY2tzID0gZnVuY3Rpb24gYWRkVGV4dGJsb2NrSGFja3MgKCkge1xuICB2YXIgbGFzdENoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleCAtIDFdO1xuICB3aGlsZSAobGFzdENoaWxkIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7IGxhc3RDaGlsZCA9IGxhc3RDaGlsZC5jaGlsZHJlbltsYXN0Q2hpbGQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07IH1cblxuICBpZiAoIWxhc3RDaGlsZCB8fCAvLyBFbXB0eSB0ZXh0YmxvY2tcbiAgICAgICEobGFzdENoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXdEZXNjKSB8fFxuICAgICAgL1xcbiQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkpIHtcbiAgICAvLyBBdm9pZCBidWdzIGluIFNhZmFyaSdzIGN1cnNvciBkcmF3aW5nICgjMTE2NSkgYW5kIENocm9tZSdzIG1vdXNlIHNlbGVjdGlvbiAoIzExNTIpXG4gICAgaWYgKChyZXN1bHQuc2FmYXJpIHx8IHJlc3VsdC5jaHJvbWUpICYmIGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuZG9tLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICB7IHRoaXMuYWRkSGFja05vZGUoXCJJTUdcIik7IH1cbiAgICB0aGlzLmFkZEhhY2tOb2RlKFwiQlJcIik7XG4gIH1cbn07XG5cblZpZXdUcmVlVXBkYXRlci5wcm90b3R5cGUuYWRkSGFja05vZGUgPSBmdW5jdGlvbiBhZGRIYWNrTm9kZSAobm9kZU5hbWUpIHtcbiAgaWYgKHRoaXMuaW5kZXggPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGggJiYgdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0ubWF0Y2hlc0hhY2sobm9kZU5hbWUpKSB7XG4gICAgdGhpcy5pbmRleCsrO1xuICB9IGVsc2Uge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICBpZiAobm9kZU5hbWUgPT0gXCJJTUdcIikgeyBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjsgfVxuICAgIGlmIChub2RlTmFtZSA9PSBcIkJSXCIpIHsgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVha1wiOyB9XG4gICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgbmV3IFRyYWlsaW5nSGFja1ZpZXdEZXNjKHRoaXMudG9wLCBub3RoaW5nLCBkb20sIG51bGwpKTtcbiAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICB9XG59O1xuXG4vLyA6IChGcmFnbWVudCwgW1ZpZXdEZXNjXSkg4oaSIHtpbmRleDogbnVtYmVyLCBtYXRjaGVkOiBNYXA8Vmlld0Rlc2MsIG51bWJlcj59XG4vLyBJdGVyYXRlIGZyb20gdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgYW5kIGFycmF5IG9mIGRlc2NzIHRvIGZpbmRcbi8vIGRpcmVjdGx5IG1hdGNoaW5nIG9uZXMsIGluIG9yZGVyIHRvIGF2b2lkIG92ZXJlYWdlcmx5IHJldXNpbmcgdGhvc2Vcbi8vIGZvciBvdGhlciBub2Rlcy4gUmV0dXJucyB0aGUgZnJhZ21lbnQgaW5kZXggb2YgdGhlIGZpcnN0IG5vZGUgdGhhdFxuLy8gaXMgcGFydCBvZiB0aGUgc2VxdWVuY2Ugb2YgbWF0Y2hlZCBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuLy8gZnJhZ21lbnQuXG5mdW5jdGlvbiBwcmVNYXRjaChmcmFnLCBkZXNjcykge1xuICB2YXIgZkkgPSBmcmFnLmNoaWxkQ291bnQsIGRJID0gZGVzY3MubGVuZ3RoLCBtYXRjaGVkID0gbmV3IE1hcDtcbiAgZm9yICg7IGZJID4gMCAmJiBkSSA+IDA7IGRJLS0pIHtcbiAgICB2YXIgZGVzYyA9IGRlc2NzW2RJIC0gMV0sIG5vZGUgPSBkZXNjLm5vZGU7XG4gICAgaWYgKCFub2RlKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAobm9kZSAhPSBmcmFnLmNoaWxkKGZJIC0gMSkpIHsgYnJlYWsgfVxuICAgIC0tZkk7XG4gICAgbWF0Y2hlZC5zZXQoZGVzYywgZkkpO1xuICB9XG4gIHJldHVybiB7aW5kZXg6IGZJLCBtYXRjaGVkOiBtYXRjaGVkfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlU2lkZShhLCBiKSB7IHJldHVybiBhLnR5cGUuc2lkZSAtIGIudHlwZS5zaWRlIH1cblxuLy8gOiAoVmlld0Rlc2MsIERlY29yYXRpb25Tb3VyY2UsIChEZWNvcmF0aW9uLCBudW1iZXIpLCAoTm9kZSwgW0RlY29yYXRpb25dLCBEZWNvcmF0aW9uU291cmNlLCBudW1iZXIpKVxuLy8gVGhpcyBmdW5jdGlvbiBhYnN0cmFjdHMgaXRlcmF0aW5nIG92ZXIgdGhlIG5vZGVzIGFuZCBkZWNvcmF0aW9ucyBpblxuLy8gYSBmcmFnbWVudC4gQ2FsbHMgYG9uTm9kZWAgZm9yIGVhY2ggbm9kZSwgd2l0aCBpdHMgbG9jYWwgYW5kIGNoaWxkXG4vLyBkZWNvcmF0aW9ucy4gU3BsaXRzIHRleHQgbm9kZXMgd2hlbiB0aGVyZSBpcyBhIGRlY29yYXRpb24gc3RhcnRpbmdcbi8vIG9yIGVuZGluZyBpbnNpZGUgb2YgdGhlbS4gQ2FsbHMgYG9uV2lkZ2V0YCBmb3IgZWFjaCB3aWRnZXQuXG5mdW5jdGlvbiBpdGVyRGVjbyhwYXJlbnQsIGRlY28sIG9uV2lkZ2V0LCBvbk5vZGUpIHtcbiAgdmFyIGxvY2FscyA9IGRlY28ubG9jYWxzKHBhcmVudCksIG9mZnNldCA9IDA7XG4gIC8vIFNpbXBsZSwgY2hlYXAgdmFyaWFudCBmb3Igd2hlbiB0aGVyZSBhcmUgbm8gbG9jYWwgZGVjb3JhdGlvbnNcbiAgaWYgKGxvY2Fscy5sZW5ndGggPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkKGkpO1xuICAgICAgb25Ob2RlKGNoaWxkLCBsb2NhbHMsIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGkpO1xuICAgICAgb2Zmc2V0ICs9IGNoaWxkLm5vZGVTaXplO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBkZWNvSW5kZXggPSAwLCBhY3RpdmUgPSBbXSwgcmVzdE5vZGUgPSBudWxsO1xuICBmb3IgKHZhciBwYXJlbnRJbmRleCA9IDA7Oykge1xuICAgIGlmIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID09IG9mZnNldCkge1xuICAgICAgdmFyIHdpZGdldCA9IGxvY2Fsc1tkZWNvSW5kZXgrK10sIHdpZGdldHMgPSAodm9pZCAwKTtcbiAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID09IG9mZnNldClcbiAgICAgICAgeyAod2lkZ2V0cyB8fCAod2lkZ2V0cyA9IFt3aWRnZXRdKSkucHVzaChsb2NhbHNbZGVjb0luZGV4KytdKTsgfVxuICAgICAgaWYgKHdpZGdldHMpIHtcbiAgICAgICAgd2lkZ2V0cy5zb3J0KGNvbXBhcmVTaWRlKTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgd2lkZ2V0cy5sZW5ndGg7IGkkMSsrKSB7IG9uV2lkZ2V0KHdpZGdldHNbaSQxXSwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpOyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbldpZGdldCh3aWRnZXQsIHBhcmVudEluZGV4LCAhIXJlc3ROb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGQkMSA9ICh2b2lkIDApLCBpbmRleCA9ICh2b2lkIDApO1xuICAgIGlmIChyZXN0Tm9kZSkge1xuICAgICAgaW5kZXggPSAtMTtcbiAgICAgIGNoaWxkJDEgPSByZXN0Tm9kZTtcbiAgICAgIHJlc3ROb2RlID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHBhcmVudEluZGV4IDwgcGFyZW50LmNoaWxkQ291bnQpIHtcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICBjaGlsZCQxID0gcGFyZW50LmNoaWxkKHBhcmVudEluZGV4KyspO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGFjdGl2ZS5sZW5ndGg7IGkkMisrKSB7IGlmIChhY3RpdmVbaSQyXS50byA8PSBvZmZzZXQpIHsgYWN0aXZlLnNwbGljZShpJDItLSwgMSk7IH0gfVxuICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPD0gb2Zmc2V0ICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID4gb2Zmc2V0KVxuICAgICAgeyBhY3RpdmUucHVzaChsb2NhbHNbZGVjb0luZGV4KytdKTsgfVxuXG4gICAgdmFyIGVuZCA9IG9mZnNldCArIGNoaWxkJDEubm9kZVNpemU7XG4gICAgaWYgKGNoaWxkJDEuaXNUZXh0KSB7XG4gICAgICB2YXIgY3V0QXQgPSBlbmQ7XG4gICAgICBpZiAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDwgY3V0QXQpIHsgY3V0QXQgPSBsb2NhbHNbZGVjb0luZGV4XS5mcm9tOyB9XG4gICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBhY3RpdmUubGVuZ3RoOyBpJDMrKykgeyBpZiAoYWN0aXZlW2kkM10udG8gPCBjdXRBdCkgeyBjdXRBdCA9IGFjdGl2ZVtpJDNdLnRvOyB9IH1cbiAgICAgIGlmIChjdXRBdCA8IGVuZCkge1xuICAgICAgICByZXN0Tm9kZSA9IGNoaWxkJDEuY3V0KGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgY2hpbGQkMSA9IGNoaWxkJDEuY3V0KDAsIGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgZW5kID0gY3V0QXQ7XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG91dGVyRGVjbyA9ICFhY3RpdmUubGVuZ3RoID8gbm90aGluZ1xuICAgICAgICA6IGNoaWxkJDEuaXNJbmxpbmUgJiYgIWNoaWxkJDEuaXNMZWFmID8gYWN0aXZlLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gIWQuaW5saW5lOyB9KVxuICAgICAgICA6IGFjdGl2ZS5zbGljZSgpO1xuICAgIG9uTm9kZShjaGlsZCQxLCBvdXRlckRlY28sIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCQxKSwgaW5kZXgpO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxufVxuXG4vLyBMaXN0IG1hcmtlcnMgaW4gTW9iaWxlIFNhZmFyaSB3aWxsIG15c3RlcmlvdXNseSBkaXNhcHBlYXJcbi8vIHNvbWV0aW1lcy4gVGhpcyB3b3JrcyBhcm91bmQgdGhhdC5cbmZ1bmN0aW9uIGlvc0hhY2tzKGRvbSkge1xuICBpZiAoZG9tLm5vZGVOYW1lID09IFwiVUxcIiB8fCBkb20ubm9kZU5hbWUgPT0gXCJPTFwiKSB7XG4gICAgdmFyIG9sZENTUyA9IGRvbS5zdHlsZS5jc3NUZXh0O1xuICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTICsgXCI7IGxpc3Qtc3R5bGU6IHNxdWFyZSAhaW1wb3J0YW50XCI7XG4gICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tKS5saXN0U3R5bGU7XG4gICAgZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVhcmJ5VGV4dE5vZGUobm9kZSwgb2Zmc2V0KSB7XG4gIGZvciAoOzspIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7IHJldHVybiBub2RlIH1cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDApIHtcbiAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gb2Zmc2V0ICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLm5vZGVUeXBlID09IDMpXG4gICAgICAgIHsgcmV0dXJuIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdIH1cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICBvZmZzZXQgPSBub2RlU2l6ZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxufVxuXG4vLyBGaW5kIGEgcGllY2Ugb2YgdGV4dCBpbiBhbiBpbmxpbmUgZnJhZ21lbnQsIG92ZXJsYXBwaW5nIGZyb20tdG9cbmZ1bmN0aW9uIGZpbmRUZXh0SW5GcmFnbWVudChmcmFnLCB0ZXh0LCBmcm9tLCB0bykge1xuICBmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgaSA8IGZyYWcuY2hpbGRDb3VudCAmJiBwb3MgPD0gdG87KSB7XG4gICAgdmFyIGNoaWxkID0gZnJhZy5jaGlsZChpKyspLCBjaGlsZFN0YXJ0ID0gcG9zO1xuICAgIHBvcyArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICBpZiAoIWNoaWxkLmlzVGV4dCkgeyBjb250aW51ZSB9XG4gICAgdmFyIHN0ciA9IGNoaWxkLnRleHQ7XG4gICAgd2hpbGUgKGkgPCBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgIHZhciBuZXh0ID0gZnJhZy5jaGlsZChpKyspO1xuICAgICAgcG9zICs9IG5leHQubm9kZVNpemU7XG4gICAgICBpZiAoIW5leHQuaXNUZXh0KSB7IGJyZWFrIH1cbiAgICAgIHN0ciArPSBuZXh0LnRleHQ7XG4gICAgfVxuICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgdmFyIGZvdW5kID0gc3RyLmxhc3RJbmRleE9mKHRleHQsIHRvIC0gY2hpbGRTdGFydCk7XG4gICAgICBpZiAoZm91bmQgPj0gMCAmJiBmb3VuZCArIHRleHQubGVuZ3RoICsgY2hpbGRTdGFydCA+PSBmcm9tKVxuICAgICAgICB7IHJldHVybiBjaGlsZFN0YXJ0ICsgZm91bmQgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLy8gUmVwbGFjZSByYW5nZSBmcm9tLXRvIGluIGFuIGFycmF5IG9mIHZpZXcgZGVzY3Mgd2l0aCByZXBsYWNlbWVudFxuLy8gKG1heSBiZSBudWxsIHRvIGp1c3QgZGVsZXRlKS4gVGhpcyBnb2VzIHZlcnkgbXVjaCBhZ2FpbnN0IHRoZSBncmFpblxuLy8gb2YgdGhlIHJlc3Qgb2YgdGhpcyBjb2RlLCB3aGljaCB0ZW5kcyB0byBjcmVhdGUgbm9kZXMgd2l0aCB0aGVcbi8vIHJpZ2h0IHNoYXBlIGluIG9uZSBnbywgcmF0aGVyIHRoYW4gbWVzc2luZyB3aXRoIHRoZW0gYWZ0ZXJcbi8vIGNyZWF0aW9uLCBidXQgaXMgbmVjZXNzYXJ5IGluIHRoZSBjb21wb3NpdGlvbiBoYWNrLlxuZnVuY3Rpb24gcmVwbGFjZU5vZGVzKG5vZGVzLCBmcm9tLCB0bywgdmlldywgcmVwbGFjZW1lbnQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgb2ZmID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZXNbaV0sIHN0YXJ0ID0gb2ZmLCBlbmQgPSBvZmYgKz0gY2hpbGQuc2l6ZTtcbiAgICBpZiAoc3RhcnQgPj0gdG8gfHwgZW5kIDw9IGZyb20pIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXJ0IDwgZnJvbSkgeyByZXN1bHQucHVzaChjaGlsZC5zbGljZSgwLCBmcm9tIC0gc3RhcnQsIHZpZXcpKTsgfVxuICAgICAgaWYgKHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJlcGxhY2VtZW50KTtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA+IHRvKSB7IHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKHRvIC0gc3RhcnQsIGNoaWxkLnNpemUsIHZpZXcpKTsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luKSB7XG4gIHZhciBkb21TZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCksIGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICBpZiAoIWRvbVNlbC5mb2N1c05vZGUpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgbmVhcmVzdERlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tU2VsLmZvY3VzTm9kZSksIGluV2lkZ2V0ID0gbmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2Muc2l6ZSA9PSAwO1xuICB2YXIgaGVhZCA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCk7XG4gIGlmIChoZWFkIDwgMCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciAkaGVhZCA9IGRvYy5yZXNvbHZlKGhlYWQpLCAkYW5jaG9yLCBzZWxlY3Rpb247XG4gIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoZG9tU2VsKSkge1xuICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICB3aGlsZSAobmVhcmVzdERlc2MgJiYgIW5lYXJlc3REZXNjLm5vZGUpIHsgbmVhcmVzdERlc2MgPSBuZWFyZXN0RGVzYy5wYXJlbnQ7IH1cbiAgICBpZiAobmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2Mubm9kZS5pc0F0b20gJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobmVhcmVzdERlc2Mubm9kZSkgJiYgbmVhcmVzdERlc2MucGFyZW50XG4gICAgICAgICYmICEobmVhcmVzdERlc2Mubm9kZS5pc0lubGluZSAmJiBpc09uRWRnZShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIG5lYXJlc3REZXNjLmRvbSkpKSB7XG4gICAgICB2YXIgcG9zID0gbmVhcmVzdERlc2MucG9zQmVmb3JlO1xuICAgICAgc2VsZWN0aW9uID0gbmV3IE5vZGVTZWxlY3Rpb24oaGVhZCA9PSBwb3MgPyAkaGVhZCA6IGRvYy5yZXNvbHZlKHBvcykpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5jaG9yID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xuICAgIGlmIChhbmNob3IgPCAwKSB7IHJldHVybiBudWxsIH1cbiAgICAkYW5jaG9yID0gZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgfVxuXG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgdmFyIGJpYXMgPSBvcmlnaW4gPT0gXCJwb2ludGVyXCIgfHwgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQgPCAkaGVhZC5wb3MgJiYgIWluV2lkZ2V0KSA/IDEgOiAtMTtcbiAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKTtcbiAgfVxuICByZXR1cm4gc2VsZWN0aW9uXG59XG5cbmZ1bmN0aW9uIGVkaXRvck93bnNTZWxlY3Rpb24odmlldykge1xuICByZXR1cm4gdmlldy5lZGl0YWJsZSA/IHZpZXcuaGFzRm9jdXMoKSA6XG4gICAgaGFzU2VsZWN0aW9uKHZpZXcpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jb250YWlucyh2aWV3LmRvbSlcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uVG9ET00odmlldywgZm9yY2UpIHtcbiAgdmFyIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICBzeW5jTm9kZVNlbGVjdGlvbih2aWV3LCBzZWwpO1xuXG4gIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSkgeyByZXR1cm4gfVxuXG4gIGlmICghZm9yY2UgJiYgdmlldy5tb3VzZURvd24gJiYgdmlldy5tb3VzZURvd24uYWxsb3dEZWZhdWx0KSB7XG4gICAgdmlldy5tb3VzZURvd24uZGVsYXllZFNlbGVjdGlvblN5bmMgPSB0cnVlO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2aWV3LmRvbU9ic2VydmVyLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcblxuICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKSB7XG4gICAgc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5jaG9yID0gc2VsLmFuY2hvcjtcbiAgICB2YXIgaGVhZCA9IHNlbC5oZWFkO1xuICAgIHZhciByZXNldEVkaXRhYmxlRnJvbSwgcmVzZXRFZGl0YWJsZVRvO1xuICAgIGlmIChicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSAmJiAhKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgeyByZXNldEVkaXRhYmxlRnJvbSA9IHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHNlbC5mcm9tKTsgfVxuICAgICAgaWYgKCFzZWwuZW1wdHkgJiYgIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgeyByZXNldEVkaXRhYmxlVG8gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwudG8pOyB9XG4gICAgfVxuICAgIHZpZXcuZG9jVmlldy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LnJvb3QsIGZvcmNlKTtcbiAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUpIHtcbiAgICAgIGlmIChyZXNldEVkaXRhYmxlRnJvbSkgeyByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVGcm9tKTsgfVxuICAgICAgaWYgKHJlc2V0RWRpdGFibGVUbykgeyByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVUbyk7IH1cbiAgICB9XG4gICAgaWYgKHNlbC52aXNpYmxlKSB7XG4gICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICBpZiAoXCJvbnNlbGVjdGlvbmNoYW5nZVwiIGluIGRvY3VtZW50KSB7IHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldyk7IH1cbiAgICB9XG4gIH1cblxuICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICB2aWV3LmRvbU9ic2VydmVyLmNvbm5lY3RTZWxlY3Rpb24oKTtcbn1cblxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIFdlYmtpdCBub3QgYWxsb3dpbmcgYSBzZWxlY3Rpb24gdG8gc3RhcnQvZW5kXG4vLyBiZXR3ZWVuIG5vbi1lZGl0YWJsZSBibG9jayBub2Rlcy4gV2UgYnJpZWZseSBtYWtlIHNvbWV0aGluZ1xuLy8gZWRpdGFibGUsIHNldCB0aGUgc2VsZWN0aW9uLCB0aGVuIHNldCBpdCB1bmVkaXRhYmxlIGFnYWluLlxuXG52YXIgYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgPSByZXN1bHQuc2FmYXJpIHx8IHJlc3VsdC5jaHJvbWUgJiYgcmVzdWx0LmNocm9tZV92ZXJzaW9uIDwgNjM7XG5cbmZ1bmN0aW9uIHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHBvcykge1xuICB2YXIgcmVmID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCAwKTtcbiAgdmFyIG5vZGUgPSByZWYubm9kZTtcbiAgdmFyIG9mZnNldCA9IHJlZi5vZmZzZXQ7XG4gIHZhciBhZnRlciA9IG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSA6IG51bGw7XG4gIHZhciBiZWZvcmUgPSBvZmZzZXQgPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0gOiBudWxsO1xuICBpZiAocmVzdWx0LnNhZmFyaSAmJiBhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSB7IHJldHVybiBzZXRFZGl0YWJsZShhZnRlcikgfVxuICBpZiAoKCFhZnRlciB8fCBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSAmJiAoIWJlZm9yZSB8fCBiZWZvcmUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikpIHtcbiAgICBpZiAoYWZ0ZXIpIHsgcmV0dXJuIHNldEVkaXRhYmxlKGFmdGVyKSB9XG4gICAgZWxzZSBpZiAoYmVmb3JlKSB7IHJldHVybiBzZXRFZGl0YWJsZShiZWZvcmUpIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7XG4gIGlmIChyZXN1bHQuc2FmYXJpICYmIGVsZW1lbnQuZHJhZ2dhYmxlKSB7IGVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7IGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gdHJ1ZTsgfVxuICByZXR1cm4gZWxlbWVudFxufVxuXG5mdW5jdGlvbiByZXNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gIGlmIChlbGVtZW50Lndhc0RyYWdnYWJsZSkgeyBlbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7IGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gbnVsbDsgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlKHZpZXcpIHtcbiAgdmFyIGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgdmFyIGRvbVNlbCA9IHZpZXcucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIG5vZGUgPSBkb21TZWwuYW5jaG9yTm9kZSwgb2Zmc2V0ID0gZG9tU2VsLmFuY2hvck9mZnNldDtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5oaWRlU2VsZWN0aW9uR3VhcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICE9IG5vZGUgfHwgZG9tU2VsLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpIHtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWVkaXRvck93bnNTZWxlY3Rpb24odmlldykgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSlcbiAgICAgICAgICB7IHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpOyB9XG4gICAgICB9LCAyMCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gIHZhciBkb21TZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIG5vZGUgPSB2aWV3LmN1cnNvcldyYXBwZXIuZG9tLCBpbWcgPSBub2RlLm5vZGVOYW1lID09IFwiSU1HXCI7XG4gIGlmIChpbWcpIHsgcmFuZ2Uuc2V0RW5kKG5vZGUucGFyZW50Tm9kZSwgZG9tSW5kZXgobm9kZSkgKyAxKTsgfVxuICBlbHNlIHsgcmFuZ2Uuc2V0RW5kKG5vZGUsIDApOyB9XG4gIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAvLyBLbHVkZ2UgdG8ga2lsbCAnY29udHJvbCBzZWxlY3Rpb24nIGluIElFMTEgd2hlbiBzZWxlY3RpbmcgYW5cbiAgLy8gaW52aXNpYmxlIGN1cnNvciB3cmFwcGVyLCBzaW5jZSB0aGF0IHdvdWxkIHJlc3VsdCBpbiB0aG9zZSB3ZWlyZFxuICAvLyByZXNpemUgaGFuZGxlcyBhbmQgYSBzZWxlY3Rpb24gdGhhdCBjb25zaWRlcnMgdGhlIGFic29sdXRlbHlcbiAgLy8gcG9zaXRpb25lZCB3cmFwcGVyLCByYXRoZXIgdGhhbiB0aGUgcm9vdCBlZGl0YWJsZSBub2RlLCB0aGVcbiAgLy8gZm9jdXNlZCBlbGVtZW50LlxuICBpZiAoIWltZyAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJiByZXN1bHQuaWUgJiYgcmVzdWx0LmllX3ZlcnNpb24gPD0gMTEpIHtcbiAgICBub2RlLmRpc2FibGVkID0gdHJ1ZTtcbiAgICBub2RlLmRpc2FibGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKSB7XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgdmFyIGRlc2MgPSB2aWV3LmRvY1ZpZXcuZGVzY0F0KHNlbC5mcm9tKTtcbiAgICBpZiAoZGVzYyAhPSB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjKSB7XG4gICAgICBjbGVhck5vZGVTZWxlY3Rpb24odmlldyk7XG4gICAgICBpZiAoZGVzYykgeyBkZXNjLnNlbGVjdE5vZGUoKTsgfVxuICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IGRlc2M7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgfVxufVxuXG4vLyBDbGVhciBhbGwgRE9NIHN0YXRlZnVsbmVzcyBvZiB0aGUgbGFzdCBub2RlIHNlbGVjdGlvbi5cbmZ1bmN0aW9uIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KSB7XG4gIGlmICh2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjKSB7XG4gICAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MucGFyZW50KVxuICAgICAgeyB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLmRlc2VsZWN0Tm9kZSgpOyB9XG4gICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcykge1xuICByZXR1cm4gdmlldy5zb21lUHJvcChcImNyZWF0ZVNlbGVjdGlvbkJldHdlZW5cIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywgJGFuY2hvciwgJGhlYWQpOyB9KVxuICAgIHx8IFRleHRTZWxlY3Rpb24uYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcylcbn1cblxuZnVuY3Rpb24gaGFzRm9jdXNBbmRTZWxlY3Rpb24odmlldykge1xuICBpZiAodmlldy5lZGl0YWJsZSAmJiB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB2aWV3LmRvbSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gaGFzU2VsZWN0aW9uKHZpZXcpXG59XG5cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbih2aWV3KSB7XG4gIHZhciBzZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghc2VsLmFuY2hvck5vZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdHJ5IHtcbiAgICAvLyBGaXJlZm94IHdpbGwgcmFpc2UgJ3Blcm1pc3Npb24gZGVuaWVkJyBlcnJvcnMgd2hlbiBhY2Nlc3NpbmdcbiAgICAvLyBwcm9wZXJ0aWVzIG9mIGBzZWwuYW5jaG9yTm9kZWAgd2hlbiBpdCdzIGluIGEgZ2VuZXJhdGVkIENTU1xuICAgIC8vIGVsZW1lbnQuXG4gICAgcmV0dXJuIHZpZXcuZG9tLmNvbnRhaW5zKHNlbC5hbmNob3JOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuYW5jaG9yTm9kZS5wYXJlbnROb2RlIDogc2VsLmFuY2hvck5vZGUpICYmXG4gICAgICAodmlldy5lZGl0YWJsZSB8fCB2aWV3LmRvbS5jb250YWlucyhzZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuZm9jdXNOb2RlLnBhcmVudE5vZGUgOiBzZWwuZm9jdXNOb2RlKSlcbiAgfSBjYXRjaChfKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gYW5jaG9ySW5SaWdodFBsYWNlKHZpZXcpIHtcbiAgdmFyIGFuY2hvckRPTSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciwgMCk7XG4gIHZhciBkb21TZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIHJldHVybiBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpXG59XG5cbmZ1bmN0aW9uIG1vdmVTZWxlY3Rpb25CbG9jayhzdGF0ZSwgZGlyKSB7XG4gIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIHZhciAkYW5jaG9yID0gcmVmLiRhbmNob3I7XG4gIHZhciAkaGVhZCA9IHJlZi4kaGVhZDtcbiAgdmFyICRzaWRlID0gZGlyID4gMCA/ICRhbmNob3IubWF4KCRoZWFkKSA6ICRhbmNob3IubWluKCRoZWFkKTtcbiAgdmFyICRzdGFydCA9ICEkc2lkZS5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRzaWRlIDogJHNpZGUuZGVwdGggPyBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHNpZGUuYWZ0ZXIoKSA6ICRzaWRlLmJlZm9yZSgpKSA6IG51bGw7XG4gIHJldHVybiAkc3RhcnQgJiYgU2VsZWN0aW9uLmZpbmRGcm9tKCRzdGFydCwgZGlyKVxufVxuXG5mdW5jdGlvbiBhcHBseSh2aWV3LCBzZWwpIHtcbiAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gIHZhciBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICBpZiAoIXNlbC5lbXB0eSB8fCBtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXIgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpKSB7XG4gICAgICB2YXIgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgaWYgKG5leHQgJiYgKG5leHQgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSkgeyByZXR1cm4gYXBwbHkodmlldywgbmV4dCkgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmICghKHJlc3VsdC5tYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKSkge1xuICAgICAgdmFyICRoZWFkID0gc2VsLiRoZWFkLCBub2RlID0gJGhlYWQudGV4dE9mZnNldCA/IG51bGwgOiBkaXIgPCAwID8gJGhlYWQubm9kZUJlZm9yZSA6ICRoZWFkLm5vZGVBZnRlciwgZGVzYztcbiAgICAgIGlmICghbm9kZSB8fCBub2RlLmlzVGV4dCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgdmFyIG5vZGVQb3MgPSBkaXIgPCAwID8gJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSA6ICRoZWFkLnBvcztcbiAgICAgIGlmICghKG5vZGUuaXNBdG9tIHx8IChkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChub2RlUG9zKSkgJiYgIWRlc2MuY29udGVudERPTSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IE5vZGVTZWxlY3Rpb24oZGlyIDwgMCA/IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSkgOiAkaGVhZCkpXG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdC53ZWJraXQpIHtcbiAgICAgICAgLy8gQ2hyb21lIGFuZCBTYWZhcmkgd2lsbCBpbnRyb2R1Y2UgZXh0cmEgcG9pbnRsZXNzIGN1cnNvclxuICAgICAgICAvLyBwb3NpdGlvbnMgYXJvdW5kIGlubGluZSB1bmVkaXRhYmxlIG5vZGVzLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgIC8vIHRha2Ugb3ZlciBhbmQgbW92ZSB0aGUgY3Vyc29yIHBhc3QgdGhlbSAoIzkzNylcbiAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZGlyIDwgMCA/IG5vZGVQb3MgOiBub2RlUG9zICsgbm9kZS5ub2RlU2l6ZSkpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsLm5vZGUuaXNJbmxpbmUpIHtcbiAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24oZGlyID4gMCA/IHNlbC4kdG8gOiBzZWwuJGZyb20pKVxuICB9IGVsc2Uge1xuICAgIHZhciBuZXh0JDEgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICBpZiAobmV4dCQxKSB7IHJldHVybiBhcHBseSh2aWV3LCBuZXh0JDEpIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBub2RlTGVuKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNJZ25vcmFibGUoZG9tKSB7XG4gIHZhciBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gIHJldHVybiBkZXNjICYmIGRlc2Muc2l6ZSA9PSAwICYmIChkb20ubmV4dFNpYmxpbmcgfHwgZG9tLm5vZGVOYW1lICE9IFwiQlJcIilcbn1cblxuLy8gTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXNuJ3QgZGlyZWN0bHkgYWZ0ZXIgb25lIG9yIG1vcmUgaWdub3JlZFxuLy8gbm9kZXMsIHdoaWNoIHdpbGwgY29uZnVzZSB0aGUgYnJvd3NlcidzIGN1cnNvciBtb3Rpb24gbG9naWMuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzTGVmdCh2aWV3KSB7XG4gIHZhciBzZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICBpZiAoIW5vZGUpIHsgcmV0dXJuIH1cbiAgdmFyIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0LCBmb3JjZSA9IGZhbHNlO1xuICAvLyBHZWNrbyB3aWxsIGRvIG9kZCB0aGluZ3Mgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGRpcmVjdGx5IGluIGZyb250XG4gIC8vIG9mIGEgbm9uLWVkaXRhYmxlIG5vZGUsIHNvIGluIHRoYXQgY2FzZSwgbW92ZSBpdCBpbnRvIHRoZSBuZXh0XG4gIC8vIG5vZGUgaWYgcG9zc2libGUuIElzc3VlIHByb3NlbWlycm9yL3Byb3NlbWlycm9yIzgzMi5cbiAgaWYgKHJlc3VsdC5nZWNrbyAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZUxlbihub2RlKSAmJiBpc0lnbm9yYWJsZShub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSkpIHsgZm9yY2UgPSB0cnVlOyB9XG4gIGZvciAoOzspIHtcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgaWYgKGlzSWdub3JhYmxlKGJlZm9yZSkpIHtcbiAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgbW92ZU9mZnNldCA9IC0tb2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICBvZmZzZXQgPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJldiA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgd2hpbGUgKHByZXYgJiYgaXNJZ25vcmFibGUocHJldikpIHtcbiAgICAgICAgbW92ZU5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChwcmV2KTtcbiAgICAgICAgcHJldiA9IHByZXYucHJldmlvdXNTaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKSB7IGJyZWFrIH1cbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICBvZmZzZXQgPSBub2RlTGVuKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZm9yY2UpIHsgc2V0U2VsRm9jdXModmlldywgc2VsLCBub2RlLCBvZmZzZXQpOyB9XG4gIGVsc2UgaWYgKG1vdmVOb2RlKSB7IHNldFNlbEZvY3VzKHZpZXcsIHNlbCwgbW92ZU5vZGUsIG1vdmVPZmZzZXQpOyB9XG59XG5cbi8vIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzbid0IGRpcmVjdGx5IGJlZm9yZSBvbmUgb3IgbW9yZSBpZ25vcmVkXG4vLyBub2Rlcy5cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXNSaWdodCh2aWV3KSB7XG4gIHZhciBzZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICBpZiAoIW5vZGUpIHsgcmV0dXJuIH1cbiAgdmFyIGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gIHZhciBtb3ZlTm9kZSwgbW92ZU9mZnNldDtcbiAgZm9yICg7Oykge1xuICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpIHsgYnJlYWsgfVxuICAgICAgdmFyIGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICBpZiAoaXNJZ25vcmFibGUoYWZ0ZXIpKSB7XG4gICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgbW92ZU9mZnNldCA9ICsrb2Zmc2V0O1xuICAgICAgfVxuICAgICAgZWxzZSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB3aGlsZSAobmV4dCAmJiBpc0lnbm9yYWJsZShuZXh0KSkge1xuICAgICAgICBtb3ZlTm9kZSA9IG5leHQucGFyZW50Tm9kZTtcbiAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KG5leHQpICsgMTtcbiAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pIHsgYnJlYWsgfVxuICAgICAgICBvZmZzZXQgPSBsZW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChtb3ZlTm9kZSkgeyBzZXRTZWxGb2N1cyh2aWV3LCBzZWwsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTsgfVxufVxuXG5mdW5jdGlvbiBpc0Jsb2NrTm9kZShkb20pIHtcbiAgdmFyIGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrXG59XG5cbmZ1bmN0aW9uIHNldFNlbEZvY3VzKHZpZXcsIHNlbCwgbm9kZSwgb2Zmc2V0KSB7XG4gIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoc2VsKSkge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgfSBlbHNlIGlmIChzZWwuZXh0ZW5kKSB7XG4gICAgc2VsLmV4dGVuZChub2RlLCBvZmZzZXQpO1xuICB9XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gIHZhciBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBlbmRzIHVwIGhhcHBlbmluZywgcmVzZXQgdGhlIHNlbGVjdGlvbi5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZpZXcuc3RhdGUgPT0gc3RhdGUpIHsgc2VsZWN0aW9uVG9ET00odmlldyk7IH1cbiAgfSwgNTApO1xufVxuXG4vLyA6IChFZGl0b3JTdGF0ZSwgbnVtYmVyKVxuLy8gQ2hlY2sgd2hldGhlciB2ZXJ0aWNhbCBzZWxlY3Rpb24gbW90aW9uIHdvdWxkIGludm9sdmUgbm9kZVxuLy8gc2VsZWN0aW9ucy4gSWYgc28sIGFwcGx5IGl0IChpZiBub3QsIHRoZSByZXN1bHQgaXMgbGVmdCB0byB0aGVcbi8vIGJyb3dzZXIpXG5mdW5jdGlvbiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICB2YXIgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgfHwgbW9kcy5pbmRleE9mKFwic1wiKSA+IC0xKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChyZXN1bHQubWFjICYmIG1vZHMuaW5kZXhPZihcIm1cIikgPiAtMSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgJGZyb20gPSBzZWwuJGZyb207XG4gIHZhciAkdG8gPSBzZWwuJHRvO1xuXG4gIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdmlldy5lbmRPZlRleHRibG9jayhkaXIgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIpKSB7XG4gICAgdmFyIG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgeyByZXR1cm4gYXBwbHkodmlldywgbmV4dCkgfVxuICB9XG4gIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICB2YXIgc2lkZSA9IGRpciA8IDAgPyAkZnJvbSA6ICR0bztcbiAgICB2YXIgYmV5b25kID0gc2VsIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uID8gU2VsZWN0aW9uLm5lYXIoc2lkZSwgZGlyKSA6IFNlbGVjdGlvbi5maW5kRnJvbShzaWRlLCBkaXIpO1xuICAgIHJldHVybiBiZXlvbmQgPyBhcHBseSh2aWV3LCBiZXlvbmQpIDogZmFsc2VcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgZGlyKSB7XG4gIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgcmVmID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gIHZhciAkaGVhZCA9IHJlZi4kaGVhZDtcbiAgdmFyICRhbmNob3IgPSByZWYuJGFuY2hvcjtcbiAgdmFyIGVtcHR5ID0gcmVmLmVtcHR5O1xuICBpZiAoISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoIWVtcHR5KSB7IHJldHVybiBmYWxzZSB9XG4gIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgbmV4dE5vZGUgPSAhJGhlYWQudGV4dE9mZnNldCAmJiAoZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIpO1xuICBpZiAobmV4dE5vZGUgJiYgIW5leHROb2RlLmlzVGV4dCkge1xuICAgIHZhciB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgaWYgKGRpciA8IDApIHsgdHIuZGVsZXRlKCRoZWFkLnBvcyAtIG5leHROb2RlLm5vZGVTaXplLCAkaGVhZC5wb3MpOyB9XG4gICAgZWxzZSB7IHRyLmRlbGV0ZSgkaGVhZC5wb3MsICRoZWFkLnBvcyArIG5leHROb2RlLm5vZGVTaXplKTsgfVxuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHN3aXRjaEVkaXRhYmxlKHZpZXcsIG5vZGUsIHN0YXRlKSB7XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IHN0YXRlO1xuICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG59XG5cbi8vIElzc3VlICM4NjcgLyAjMTA5MCAvIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkwMzgyMVxuLy8gSW4gd2hpY2ggU2FmYXJpIChhbmQgYXQgc29tZSBwb2ludCBpbiB0aGUgcGFzdCwgQ2hyb21lKSBkb2VzIHJlYWxseVxuLy8gd3JvbmcgdGhpbmdzIHdoZW4gdGhlIGRvd24gYXJyb3cgaXMgcHJlc3NlZCB3aGVuIHRoZSBjdXJzb3IgaXNcbi8vIGRpcmVjdGx5IGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBhbmQgaGFzIGFuIHVuZWRpdGFibGUgbm9kZVxuLy8gYWZ0ZXIgaXRcbmZ1bmN0aW9uIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB7XG4gIGlmICghcmVzdWx0LnNhZmFyaSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5wYXJlbnRPZmZzZXQgPiAwKSB7IHJldHVybiB9XG4gIHZhciByZWYgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBmb2N1c05vZGUgPSByZWYuZm9jdXNOb2RlO1xuICB2YXIgZm9jdXNPZmZzZXQgPSByZWYuZm9jdXNPZmZzZXQ7XG4gIGlmIChmb2N1c05vZGUgJiYgZm9jdXNOb2RlLm5vZGVUeXBlID09IDEgJiYgZm9jdXNPZmZzZXQgPT0gMCAmJlxuICAgICAgZm9jdXNOb2RlLmZpcnN0Q2hpbGQgJiYgZm9jdXNOb2RlLmZpcnN0Q2hpbGQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikge1xuICAgIHZhciBjaGlsZCA9IGZvY3VzTm9kZS5maXJzdENoaWxkO1xuICAgIHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCB0cnVlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBmYWxzZSk7IH0sIDIwKTtcbiAgfVxufVxuXG4vLyBBIGJhY2tkcm9wIGtleSBtYXBwaW5nIHVzZWQgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBzdXBwcmVzcyBrZXlzXG4vLyB0aGF0IGhhdmUgYSBkYW5nZXJvdXMgZGVmYXVsdCBlZmZlY3QsIGV2ZW4gaWYgdGhlIGNvbW1hbmRzIHRoZXkgYXJlXG4vLyBib3VuZCB0byByZXR1cm4gZmFsc2UsIGFuZCB0byBtYWtlIHN1cmUgdGhhdCBjdXJzb3ItbW90aW9uIGtleXNcbi8vIGZpbmQgYSBjdXJzb3IgKGFzIG9wcG9zZWQgdG8gYSBub2RlIHNlbGVjdGlvbikgd2hlbiBwcmVzc2VkLiBGb3Jcbi8vIGN1cnNvci1tb3Rpb24ga2V5cywgdGhlIGNvZGUgaW4gdGhlIGhhbmRsZXJzIGFsc28gdGFrZXMgY2FyZSBvZlxuLy8gYmxvY2sgc2VsZWN0aW9ucy5cblxuZnVuY3Rpb24gZ2V0TW9kcyhldmVudCkge1xuICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgaWYgKGV2ZW50LmN0cmxLZXkpIHsgcmVzdWx0ICs9IFwiY1wiOyB9XG4gIGlmIChldmVudC5tZXRhS2V5KSB7IHJlc3VsdCArPSBcIm1cIjsgfVxuICBpZiAoZXZlbnQuYWx0S2V5KSB7IHJlc3VsdCArPSBcImFcIjsgfVxuICBpZiAoZXZlbnQuc2hpZnRLZXkpIHsgcmVzdWx0ICs9IFwic1wiOyB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgdmFyIGNvZGUgPSBldmVudC5rZXlDb2RlLCBtb2RzID0gZ2V0TW9kcyhldmVudCk7XG4gIGlmIChjb2RlID09IDggfHwgKHJlc3VsdC5tYWMgJiYgY29kZSA9PSA3MiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBCYWNrc3BhY2UsIEN0cmwtaCBvbiBNYWNcbiAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgLTEpIHx8IHNraXBJZ25vcmVkTm9kZXNMZWZ0KHZpZXcpXG4gIH0gZWxzZSBpZiAoY29kZSA9PSA0NiB8fCAocmVzdWx0Lm1hYyAmJiBjb2RlID09IDY4ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIERlbGV0ZSwgQ3RybC1kIG9uIE1hY1xuICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAxKSB8fCBza2lwSWdub3JlZE5vZGVzUmlnaHQodmlldylcbiAgfSBlbHNlIGlmIChjb2RlID09IDEzIHx8IGNvZGUgPT0gMjcpIHsgLy8gRW50ZXIsIEVzY1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoY29kZSA9PSAzNykgeyAvLyBMZWZ0IGFycm93XG4gICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCAtMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlc0xlZnQodmlldylcbiAgfSBlbHNlIGlmIChjb2RlID09IDM5KSB7IC8vIFJpZ2h0IGFycm93XG4gICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCAxLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzUmlnaHQodmlldylcbiAgfSBlbHNlIGlmIChjb2RlID09IDM4KSB7IC8vIFVwIGFycm93XG4gICAgcmV0dXJuIHNlbGVjdFZlcnRpY2FsbHkodmlldywgLTEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXNMZWZ0KHZpZXcpXG4gIH0gZWxzZSBpZiAoY29kZSA9PSA0MCkgeyAvLyBEb3duIGFycm93XG4gICAgcmV0dXJuIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB8fCBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIDEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXNSaWdodCh2aWV3KVxuICB9IGVsc2UgaWYgKG1vZHMgPT0gKHJlc3VsdC5tYWMgPyBcIm1cIiA6IFwiY1wiKSAmJlxuICAgICAgICAgICAgIChjb2RlID09IDY2IHx8IGNvZGUgPT0gNzMgfHwgY29kZSA9PSA4OSB8fCBjb2RlID09IDkwKSkgeyAvLyBNb2QtW2JpeXpdXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gTm90ZSB0aGF0IGFsbCByZWZlcmVuY2luZyBhbmQgcGFyc2luZyBpcyBkb25lIHdpdGggdGhlXG4vLyBzdGFydC1vZi1vcGVyYXRpb24gc2VsZWN0aW9uIGFuZCBkb2N1bWVudCwgc2luY2UgdGhhdCdzIHRoZSBvbmVcbi8vIHRoYXQgdGhlIERPTSByZXByZXNlbnRzLiBJZiBhbnkgY2hhbmdlcyBjYW1lIGluIGluIHRoZSBtZWFudGltZSxcbi8vIHRoZSBtb2RpZmljYXRpb24gaXMgbWFwcGVkIG92ZXIgdGhvc2UgYmVmb3JlIGl0IGlzIGFwcGxpZWQsIGluXG4vLyByZWFkRE9NQ2hhbmdlLlxuXG5mdW5jdGlvbiBwYXJzZUJldHdlZW4odmlldywgZnJvbV8sIHRvXykge1xuICB2YXIgcmVmID0gdmlldy5kb2NWaWV3LnBhcnNlUmFuZ2UoZnJvbV8sIHRvXyk7XG4gIHZhciBwYXJlbnQgPSByZWYubm9kZTtcbiAgdmFyIGZyb21PZmZzZXQgPSByZWYuZnJvbU9mZnNldDtcbiAgdmFyIHRvT2Zmc2V0ID0gcmVmLnRvT2Zmc2V0O1xuICB2YXIgZnJvbSA9IHJlZi5mcm9tO1xuICB2YXIgdG8gPSByZWYudG87XG5cbiAgdmFyIGRvbVNlbCA9IHZpZXcucm9vdC5nZXRTZWxlY3Rpb24oKSwgZmluZCA9IG51bGwsIGFuY2hvciA9IGRvbVNlbC5hbmNob3JOb2RlO1xuICBpZiAoYW5jaG9yICYmIHZpZXcuZG9tLmNvbnRhaW5zKGFuY2hvci5ub2RlVHlwZSA9PSAxID8gYW5jaG9yIDogYW5jaG9yLnBhcmVudE5vZGUpKSB7XG4gICAgZmluZCA9IFt7bm9kZTogYW5jaG9yLCBvZmZzZXQ6IGRvbVNlbC5hbmNob3JPZmZzZXR9XTtcbiAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKVxuICAgICAgeyBmaW5kLnB1c2goe25vZGU6IGRvbVNlbC5mb2N1c05vZGUsIG9mZnNldDogZG9tU2VsLmZvY3VzT2Zmc2V0fSk7IH1cbiAgfVxuICAvLyBXb3JrIGFyb3VuZCBpc3N1ZSBpbiBDaHJvbWUgd2hlcmUgYmFja3NwYWNpbmcgc29tZXRpbWVzIHJlcGxhY2VzXG4gIC8vIHRoZSBkZWxldGVkIGNvbnRlbnQgd2l0aCBhIHJhbmRvbSBCUiBub2RlIChpc3N1ZXMgIzc5OSwgIzgzMSlcbiAgaWYgKHJlc3VsdC5jaHJvbWUgJiYgdmlldy5sYXN0S2V5Q29kZSA9PT0gOCkge1xuICAgIGZvciAodmFyIG9mZiA9IHRvT2Zmc2V0OyBvZmYgPiBmcm9tT2Zmc2V0OyBvZmYtLSkge1xuICAgICAgdmFyIG5vZGUgPSBwYXJlbnQuY2hpbGROb2Rlc1tvZmYgLSAxXSwgZGVzYyA9IG5vZGUucG1WaWV3RGVzYztcbiAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZGVzYykgeyB0b09mZnNldCA9IG9mZjsgYnJlYWsgfVxuICAgICAgaWYgKCFkZXNjIHx8IGRlc2Muc2l6ZSkgeyBicmVhayB9XG4gICAgfVxuICB9XG4gIHZhciBzdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICB2YXIgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImRvbVBhcnNlclwiKSB8fCBET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gIHZhciAkZnJvbSA9IHN0YXJ0RG9jLnJlc29sdmUoZnJvbSk7XG5cbiAgdmFyIHNlbCA9IG51bGwsIGRvYyA9IHBhcnNlci5wYXJzZShwYXJlbnQsIHtcbiAgICB0b3BOb2RlOiAkZnJvbS5wYXJlbnQsXG4gICAgdG9wTWF0Y2g6ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKSxcbiAgICB0b3BPcGVuOiB0cnVlLFxuICAgIGZyb206IGZyb21PZmZzZXQsXG4gICAgdG86IHRvT2Zmc2V0LFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlID8gXCJmdWxsXCIgOiB0cnVlLFxuICAgIGVkaXRhYmxlQ29udGVudDogdHJ1ZSxcbiAgICBmaW5kUG9zaXRpb25zOiBmaW5kLFxuICAgIHJ1bGVGcm9tTm9kZTogcnVsZUZyb21Ob2RlLFxuICAgIGNvbnRleHQ6ICRmcm9tXG4gIH0pO1xuICBpZiAoZmluZCAmJiBmaW5kWzBdLnBvcyAhPSBudWxsKSB7XG4gICAgdmFyIGFuY2hvciQxID0gZmluZFswXS5wb3MsIGhlYWQgPSBmaW5kWzFdICYmIGZpbmRbMV0ucG9zO1xuICAgIGlmIChoZWFkID09IG51bGwpIHsgaGVhZCA9IGFuY2hvciQxOyB9XG4gICAgc2VsID0ge2FuY2hvcjogYW5jaG9yJDEgKyBmcm9tLCBoZWFkOiBoZWFkICsgZnJvbX07XG4gIH1cbiAgcmV0dXJuIHtkb2M6IGRvYywgc2VsOiBzZWwsIGZyb206IGZyb20sIHRvOiB0b31cbn1cblxuZnVuY3Rpb24gcnVsZUZyb21Ob2RlKGRvbSkge1xuICB2YXIgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICBpZiAoZGVzYykge1xuICAgIHJldHVybiBkZXNjLnBhcnNlUnVsZSgpXG4gIH0gZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiBkb20ucGFyZW50Tm9kZSkge1xuICAgIC8vIFNhZmFyaSByZXBsYWNlcyB0aGUgbGlzdCBpdGVtIG9yIHRhYmxlIGNlbGwgd2l0aCBhIEJSXG4gICAgLy8gZGlyZWN0bHkgaW4gdGhlIGxpc3Qgbm9kZSAoPyEpIGlmIHlvdSBkZWxldGUgdGhlIGxhc3RcbiAgICAvLyBjaGFyYWN0ZXIgaW4gYSBsaXN0IGl0ZW0gb3IgdGFibGUgY2VsbCAoIzcwOCwgIzg2MilcbiAgICBpZiAocmVzdWx0LnNhZmFyaSAmJiAvXih1bHxvbCkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgIHZhciBza2lwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHNraXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgIHJldHVybiB7c2tpcDogc2tpcH1cbiAgICB9IGVsc2UgaWYgKGRvbS5wYXJlbnROb2RlLmxhc3RDaGlsZCA9PSBkb20gfHwgcmVzdWx0LnNhZmFyaSAmJiAvXih0cnx0YWJsZSkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgIHJldHVybiB7aWdub3JlOiB0cnVlfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkb20ubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiBkb20uZ2V0QXR0cmlidXRlKFwibWFyay1wbGFjZWhvbGRlclwiKSkge1xuICAgIHJldHVybiB7aWdub3JlOiB0cnVlfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRET01DaGFuZ2UodmlldywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZE5vZGVzKSB7XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIHZhciBvcmlnaW4gPSB2aWV3Lmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwID8gdmlldy5sYXN0U2VsZWN0aW9uT3JpZ2luIDogbnVsbDtcbiAgICB2YXIgbmV3U2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4pO1xuICAgIGlmIChuZXdTZWwgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLmVxKG5ld1NlbCkpIHtcbiAgICAgIHZhciB0ciQxID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3U2VsKTtcbiAgICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpIHsgdHIkMS5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTsgfVxuICAgICAgZWxzZSBpZiAob3JpZ2luID09IFwia2V5XCIpIHsgdHIkMS5zY3JvbGxJbnRvVmlldygpOyB9XG4gICAgICB2aWV3LmRpc3BhdGNoKHRyJDEpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciAkYmVmb3JlID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShmcm9tKTtcbiAgdmFyIHNoYXJlZCA9ICRiZWZvcmUuc2hhcmVkRGVwdGgodG8pO1xuICBmcm9tID0gJGJlZm9yZS5iZWZvcmUoc2hhcmVkICsgMSk7XG4gIHRvID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSh0bykuYWZ0ZXIoc2hhcmVkICsgMSk7XG5cbiAgdmFyIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgcGFyc2UgPSBwYXJzZUJldHdlZW4odmlldywgZnJvbSwgdG8pO1xuICAvLyBDaHJvbWUgc29tZXRpbWVzIGxlYXZlcyB0aGUgY3Vyc29yIGJlZm9yZSB0aGUgaW5zZXJ0ZWQgdGV4dCB3aGVuXG4gIC8vIGNvbXBvc2luZyBhZnRlciBhIGN1cnNvciB3cmFwcGVyLiBUaGlzIG1vdmVzIGl0IGZvcndhcmQuXG4gIGlmIChyZXN1bHQuY2hyb21lICYmIHZpZXcuY3Vyc29yV3JhcHBlciAmJiBwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciA9PSB2aWV3LmN1cnNvcldyYXBwZXIuZGVjby5mcm9tKSB7XG4gICAgdmFyIHRleHQgPSB2aWV3LmN1cnNvcldyYXBwZXIuZGVjby50eXBlLnRvRE9NLm5leHRTaWJsaW5nO1xuICAgIHZhciBzaXplID0gdGV4dCAmJiB0ZXh0Lm5vZGVWYWx1ZSA/IHRleHQubm9kZVZhbHVlLmxlbmd0aCA6IDE7XG4gICAgcGFyc2Uuc2VsID0ge2FuY2hvcjogcGFyc2Uuc2VsLmFuY2hvciArIHNpemUsIGhlYWQ6IHBhcnNlLnNlbC5hbmNob3IgKyBzaXplfTtcbiAgfVxuXG4gIHZhciBkb2MgPSB2aWV3LnN0YXRlLmRvYywgY29tcGFyZSA9IGRvYy5zbGljZShwYXJzZS5mcm9tLCBwYXJzZS50byk7XG4gIHZhciBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGU7XG4gIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWRcbiAgaWYgKHZpZXcubGFzdEtleUNvZGUgPT09IDggJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcubGFzdEtleUNvZGVUaW1lKSB7XG4gICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgcHJlZmVycmVkU2lkZSA9IFwiZW5kXCI7XG4gIH0gZWxzZSB7XG4gICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbTtcbiAgICBwcmVmZXJyZWRTaWRlID0gXCJzdGFydFwiO1xuICB9XG4gIHZpZXcubGFzdEtleUNvZGUgPSBudWxsO1xuXG4gIHZhciBjaGFuZ2UgPSBmaW5kRGlmZihjb21wYXJlLmNvbnRlbnQsIHBhcnNlLmRvYy5jb250ZW50LCBwYXJzZS5mcm9tLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpO1xuICBpZiAoIWNoYW5nZSkge1xuICAgIGlmICh0eXBlT3ZlciAmJiBzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgJiYgc2VsLiRoZWFkLnNhbWVQYXJlbnQoc2VsLiRhbmNob3IpICYmXG4gICAgICAgICF2aWV3LmNvbXBvc2luZyAmJiAhKHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yICE9IHBhcnNlLnNlbC5oZWFkKSkge1xuICAgICAgY2hhbmdlID0ge3N0YXJ0OiBzZWwuZnJvbSwgZW5kQTogc2VsLnRvLCBlbmRCOiBzZWwudG99O1xuICAgIH0gZWxzZSBpZiAoKHJlc3VsdC5pb3MgJiYgdmlldy5sYXN0SU9TRW50ZXIgPiBEYXRlLm5vdygpIC0gMjI1IHx8IHJlc3VsdC5hbmRyb2lkKSAmJlxuICAgICAgICAgICAgICAgYWRkZWROb2Rlcy5zb21lKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLm5vZGVOYW1lID09IFwiRElWXCIgfHwgbi5ub2RlTmFtZSA9PSBcIlBcIjsgfSkgJiZcbiAgICAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKTsgfSkpIHtcbiAgICAgIHZpZXcubGFzdElPU0VudGVyID0gMDtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgIHZhciBzZWwkMSA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdmlldy5zdGF0ZS5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgIGlmIChzZWwkMSAmJiAhc2VsJDEuZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKSB7IHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsJDEpKTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIHZpZXcuZG9tQ2hhbmdlQ291bnQrKztcbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIG92ZXJ3cml0aW5nIGEgc2VsZWN0aW9uIGJ5IHR5cGluZyBtYXRjaGVzXG4gIC8vIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIHNlbGVjdGVkIGNvbnRlbnQsIGNyZWF0aW5nIGEgY2hhbmdlXG4gIC8vIHRoYXQncyBzbWFsbGVyIHRoYW4gd2hhdCB3YXMgYWN0dWFsbHkgb3ZlcndyaXR0ZW4uXG4gIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiZcbiAgICAgIGNoYW5nZS5zdGFydCA9PSBjaGFuZ2UuZW5kQiAmJlxuICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgaWYgKGNoYW5nZS5zdGFydCA+IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gJiYgY2hhbmdlLnN0YXJ0IDw9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gKyAyKSB7XG4gICAgICBjaGFuZ2Uuc3RhcnQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLmVuZEEgPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJiBjaGFuZ2UuZW5kQSA+PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIDIpIHtcbiAgICAgIGNoYW5nZS5lbmRCICs9ICh2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIGNoYW5nZS5lbmRBKTtcbiAgICAgIGNoYW5nZS5lbmRBID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgfVxuICB9XG5cbiAgLy8gSUUxMSB3aWxsIGluc2VydCBhIG5vbi1icmVha2luZyBzcGFjZSBfYWhlYWRfIG9mIHRoZSBzcGFjZSBhZnRlclxuICAvLyB0aGUgY3Vyc29yIHNwYWNlIHdoZW4gYWRkaW5nIGEgc3BhY2UgYmVmb3JlIGFub3RoZXIgc3BhY2UuIFdoZW5cbiAgLy8gdGhhdCBoYXBwZW5lZCwgYWRqdXN0IHRoZSBjaGFuZ2UgdG8gY292ZXIgdGhlIHNwYWNlIGluc3RlYWQuXG4gIGlmIChyZXN1bHQuaWUgJiYgcmVzdWx0LmllX3ZlcnNpb24gPD0gMTEgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0ICsgMSAmJlxuICAgICAgY2hhbmdlLmVuZEEgPT0gY2hhbmdlLnN0YXJ0ICYmIGNoYW5nZS5zdGFydCA+IHBhcnNlLmZyb20gJiZcbiAgICAgIHBhcnNlLmRvYy50ZXh0QmV0d2VlbihjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tIC0gMSwgY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSArIDEpID09IFwiIFxcdTAwYTBcIikge1xuICAgIGNoYW5nZS5zdGFydC0tO1xuICAgIGNoYW5nZS5lbmRBLS07XG4gICAgY2hhbmdlLmVuZEItLTtcbiAgfVxuXG4gIHZhciAkZnJvbSA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tKTtcbiAgdmFyICR0byA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pO1xuICB2YXIgaW5saW5lQ2hhbmdlID0gJGZyb20uc2FtZVBhcmVudCgkdG8pICYmICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50O1xuICB2YXIgbmV4dFNlbDtcbiAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIHRoZSBlZmZlY3Qgb2YgcHJlc3NpbmcgRW50ZXIgKG9yIHdhcyByZWNvcmRlZFxuICAvLyBhcyBiZWluZyBhbiBpT1MgZW50ZXIgcHJlc3MpLCBqdXN0IGRpc3BhdGNoIGFuIEVudGVyIGtleSBpbnN0ZWFkLlxuICBpZiAoKChyZXN1bHQuaW9zICYmIHZpZXcubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSAmJlxuICAgICAgICAoIWlubGluZUNoYW5nZSB8fCBhZGRlZE5vZGVzLnNvbWUoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ubm9kZU5hbWUgPT0gXCJESVZcIiB8fCBuLm5vZGVOYW1lID09IFwiUFwiOyB9KSkpIHx8XG4gICAgICAgKCFpbmxpbmVDaGFuZ2UgJiYgJGZyb20ucG9zIDwgcGFyc2UuZG9jLmNvbnRlbnQuc2l6ZSAmJlxuICAgICAgICAobmV4dFNlbCA9IFNlbGVjdGlvbi5maW5kRnJvbShwYXJzZS5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSwgMSwgdHJ1ZSkpICYmXG4gICAgICAgIG5leHRTZWwuaGVhZCA9PSAkdG8ucG9zKSkgJiZcbiAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKTsgfSkpIHtcbiAgICB2aWV3Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gU2FtZSBmb3IgYmFja3NwYWNlXG4gIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPiBjaGFuZ2Uuc3RhcnQgJiZcbiAgICAgIGxvb2tzTGlrZUpvaW4oZG9jLCBjaGFuZ2Uuc3RhcnQsIGNoYW5nZS5lbmRBLCAkZnJvbSwgJHRvKSAmJlxuICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywga2V5RXZlbnQoOCwgXCJCYWNrc3BhY2VcIikpOyB9KSkge1xuICAgIGlmIChyZXN1bHQuYW5kcm9pZCAmJiByZXN1bHQuY2hyb21lKSB7IHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7IH0gLy8gIzgyMFxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBvY2Nhc2lvbmFsbHksIGR1cmluZyBjb21wb3NpdGlvbiwgZGVsZXRlIHRoZVxuICAvLyBlbnRpcmUgY29tcG9zaXRpb24gYW5kIHRoZW4gaW1tZWRpYXRlbHkgaW5zZXJ0IGl0IGFnYWluLiBUaGlzIGlzXG4gIC8vIHVzZWQgdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICBpZiAocmVzdWx0LmNocm9tZSAmJiByZXN1bHQuYW5kcm9pZCAmJiBjaGFuZ2UudG9CID09IGNoYW5nZS5mcm9tKVxuICAgIHsgdmlldy5sYXN0QW5kcm9pZERlbGV0ZSA9IERhdGUubm93KCk7IH1cblxuICAvLyBUaGlzIHRyaWVzIHRvIGRldGVjdCBBbmRyb2lkIHZpcnR1YWwga2V5Ym9hcmRcbiAgLy8gZW50ZXItYW5kLXBpY2stc3VnZ2VzdGlvbiBhY3Rpb24uIFRoYXQgc29tZXRpbWVzIChzZWUgaXNzdWVcbiAgLy8gIzEwNTkpIGZpcnN0IGZpcmVzIGEgRE9NIG11dGF0aW9uLCBiZWZvcmUgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG9cbiAgLy8gdGhlIG5ld2x5IGNyZWF0ZWQgYmxvY2suIEFuZCB0aGVuLCBiZWNhdXNlIFByb3NlTWlycm9yIGNsZWFucyB1cFxuICAvLyB0aGUgRE9NIHNlbGVjdGlvbiwgaXQgZ2l2ZXMgdXAgbW92aW5nIHRoZSBzZWxlY3Rpb24gZW50aXJlbHksXG4gIC8vIGxlYXZpbmcgdGhlIGN1cnNvciBpbiB0aGUgd3JvbmcgcGxhY2UuIFdoZW4gdGhhdCBoYXBwZW5zLCB3ZSBkcm9wXG4gIC8vIHRoZSBuZXcgcGFyYWdyYXBoIGZyb20gdGhlIGluaXRpYWwgY2hhbmdlLCBhbmQgZmlyZSBhIHNpbXVsYXRlZFxuICAvLyBlbnRlciBrZXkgYWZ0ZXJ3YXJkcy5cbiAgaWYgKHJlc3VsdC5hbmRyb2lkICYmICFpbmxpbmVDaGFuZ2UgJiYgJGZyb20uc3RhcnQoKSAhPSAkdG8uc3RhcnQoKSAmJiAkdG8ucGFyZW50T2Zmc2V0ID09IDAgJiYgJGZyb20uZGVwdGggPT0gJHRvLmRlcHRoICYmXG4gICAgICBwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciA9PSBwYXJzZS5zZWwuaGVhZCAmJiBwYXJzZS5zZWwuaGVhZCA9PSBjaGFuZ2UuZW5kQSkge1xuICAgIGNoYW5nZS5lbmRCIC09IDI7XG4gICAgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSk7IH0pO1xuICAgIH0sIDIwKTtcbiAgfVxuXG4gIHZhciBjaEZyb20gPSBjaGFuZ2Uuc3RhcnQsIGNoVG8gPSBjaGFuZ2UuZW5kQTtcblxuICB2YXIgdHIsIHN0b3JlZE1hcmtzLCBtYXJrQ2hhbmdlLCAkZnJvbTE7XG4gIGlmIChpbmxpbmVDaGFuZ2UpIHtcbiAgICBpZiAoJGZyb20ucG9zID09ICR0by5wb3MpIHsgLy8gRGVsZXRpb25cbiAgICAgIC8vIElFMTEgc29tZXRpbWVzIHdlaXJkbHkgbW92ZXMgdGhlIERPTSBzZWxlY3Rpb24gYXJvdW5kIGFmdGVyXG4gICAgICAvLyBiYWNrc3BhY2luZyBvdXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSB0ZXh0YmxvY2tcbiAgICAgIGlmIChyZXN1bHQuaWUgJiYgcmVzdWx0LmllX3ZlcnNpb24gPD0gMTEgJiYgJGZyb20ucGFyZW50T2Zmc2V0ID09IDApIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxlY3Rpb25Ub0RPTSh2aWV3KTsgfSwgMjApO1xuICAgICAgfVxuICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLmRlbGV0ZShjaEZyb20sIGNoVG8pO1xuICAgICAgc3RvcmVkTWFya3MgPSBkb2MucmVzb2x2ZShjaGFuZ2Uuc3RhcnQpLm1hcmtzQWNyb3NzKGRvYy5yZXNvbHZlKGNoYW5nZS5lbmRBKSk7XG4gICAgfSBlbHNlIGlmICggLy8gQWRkaW5nIG9yIHJlbW92aW5nIGEgbWFya1xuICAgICAgY2hhbmdlLmVuZEEgPT0gY2hhbmdlLmVuZEIgJiYgKCRmcm9tMSA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCkpICYmXG4gICAgICAobWFya0NoYW5nZSA9IGlzTWFya0NoYW5nZSgkZnJvbS5wYXJlbnQuY29udGVudC5jdXQoJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRmcm9tMS5wYXJlbnQuY29udGVudC5jdXQoJGZyb20xLnBhcmVudE9mZnNldCwgY2hhbmdlLmVuZEEgLSAkZnJvbTEuc3RhcnQoKSkpKVxuICAgICkge1xuICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgICAgaWYgKG1hcmtDaGFuZ2UudHlwZSA9PSBcImFkZFwiKSB7IHRyLmFkZE1hcmsoY2hGcm9tLCBjaFRvLCBtYXJrQ2hhbmdlLm1hcmspOyB9XG4gICAgICBlbHNlIHsgdHIucmVtb3ZlTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7IH1cbiAgICB9IGVsc2UgaWYgKCRmcm9tLnBhcmVudC5jaGlsZCgkZnJvbS5pbmRleCgpKS5pc1RleHQgJiYgJGZyb20uaW5kZXgoKSA9PSAkdG8uaW5kZXgoKSAtICgkdG8udGV4dE9mZnNldCA/IDAgOiAxKSkge1xuICAgICAgLy8gQm90aCBwb3NpdGlvbnMgaW4gdGhlIHNhbWUgdGV4dCBub2RlIC0tIHNpbXBseSBpbnNlcnQgdGV4dFxuICAgICAgdmFyIHRleHQkMSA9ICRmcm9tLnBhcmVudC50ZXh0QmV0d2VlbigkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpO1xuICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywgY2hGcm9tLCBjaFRvLCB0ZXh0JDEpOyB9KSkgeyByZXR1cm4gfVxuICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLmluc2VydFRleHQodGV4dCQxLCBjaEZyb20sIGNoVG8pO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdHIpXG4gICAgeyB0ciA9IHZpZXcuc3RhdGUudHIucmVwbGFjZShjaEZyb20sIGNoVG8sIHBhcnNlLmRvYy5zbGljZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tLCBjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pKTsgfVxuICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgdmFyIHNlbCQyID0gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCB0ci5kb2MsIHBhcnNlLnNlbCk7XG4gICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBzb21ldGltZXMsIGR1cmluZyBjb21wb3NpdGlvbiwgcmVwb3J0IHRoZVxuICAgIC8vIHNlbGVjdGlvbiBpbiB0aGUgd3JvbmcgcGxhY2UuIElmIGl0IGxvb2tzIGxpa2UgdGhhdCBpc1xuICAgIC8vIGhhcHBlbmluZywgZG9uJ3QgdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgLy8gRWRnZSBqdXN0IGRvZXNuJ3QgbW92ZSB0aGUgY3Vyc29yIGZvcndhcmQgd2hlbiB5b3Ugc3RhcnQgdHlwaW5nXG4gICAgLy8gaW4gYW4gZW1wdHkgYmxvY2sgb3IgYmV0d2VlbiBiciBub2Rlcy5cbiAgICBpZiAoc2VsJDIgJiYgIShyZXN1bHQuY2hyb21lICYmIHJlc3VsdC5hbmRyb2lkICYmIHZpZXcuY29tcG9zaW5nICYmIHNlbCQyLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIChjaGFuZ2Uuc3RhcnQgIT0gY2hhbmdlLmVuZEIgfHwgdmlldy5sYXN0QW5kcm9pZERlbGV0ZSA8IERhdGUubm93KCkgLSAxMDApICYmXG4gICAgICAgICAgICAgICAgIChzZWwkMi5oZWFkID09IGNoRnJvbSB8fCBzZWwkMi5oZWFkID09IHRyLm1hcHBpbmcubWFwKGNoVG8pIC0gMSkgfHxcbiAgICAgICAgICAgICAgICAgcmVzdWx0LmllICYmIHNlbCQyLmVtcHR5ICYmIHNlbCQyLmhlYWQgPT0gY2hGcm9tKSlcbiAgICAgIHsgdHIuc2V0U2VsZWN0aW9uKHNlbCQyKTsgfVxuICB9XG4gIGlmIChzdG9yZWRNYXJrcykgeyB0ci5lbnN1cmVNYXJrcyhzdG9yZWRNYXJrcyk7IH1cbiAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCBkb2MsIHBhcnNlZFNlbCkge1xuICBpZiAoTWF0aC5tYXgocGFyc2VkU2VsLmFuY2hvciwgcGFyc2VkU2VsLmhlYWQpID4gZG9jLmNvbnRlbnQuc2l6ZSkgeyByZXR1cm4gbnVsbCB9XG4gIHJldHVybiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5hbmNob3IpLCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuaGVhZCkpXG59XG5cbi8vIDogKEZyYWdtZW50LCBGcmFnbWVudCkg4oaSID97bWFyazogTWFyaywgdHlwZTogc3RyaW5nfVxuLy8gR2l2ZW4gdHdvIHNhbWUtbGVuZ3RoLCBub24tZW1wdHkgZnJhZ21lbnRzIG9mIGlubGluZSBjb250ZW50LFxuLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGZpcnN0IGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgc2Vjb25kIGJ5XG4vLyByZW1vdmluZyBvciBhZGRpbmcgYSBzaW5nbGUgbWFyayB0eXBlLlxuZnVuY3Rpb24gaXNNYXJrQ2hhbmdlKGN1ciwgcHJldikge1xuICB2YXIgY3VyTWFya3MgPSBjdXIuZmlyc3RDaGlsZC5tYXJrcywgcHJldk1hcmtzID0gcHJldi5maXJzdENoaWxkLm1hcmtzO1xuICB2YXIgYWRkZWQgPSBjdXJNYXJrcywgcmVtb3ZlZCA9IHByZXZNYXJrcywgdHlwZSwgbWFyaywgdXBkYXRlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZNYXJrcy5sZW5ndGg7IGkrKykgeyBhZGRlZCA9IHByZXZNYXJrc1tpXS5yZW1vdmVGcm9tU2V0KGFkZGVkKTsgfVxuICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjdXJNYXJrcy5sZW5ndGg7IGkkMSsrKSB7IHJlbW92ZWQgPSBjdXJNYXJrc1tpJDFdLnJlbW92ZUZyb21TZXQocmVtb3ZlZCk7IH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA9PSAxICYmIHJlbW92ZWQubGVuZ3RoID09IDApIHtcbiAgICBtYXJrID0gYWRkZWRbMF07XG4gICAgdHlwZSA9IFwiYWRkXCI7XG4gICAgdXBkYXRlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubWFyayhtYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTsgfTtcbiAgfSBlbHNlIGlmIChhZGRlZC5sZW5ndGggPT0gMCAmJiByZW1vdmVkLmxlbmd0aCA9PSAxKSB7XG4gICAgbWFyayA9IHJlbW92ZWRbMF07XG4gICAgdHlwZSA9IFwicmVtb3ZlXCI7XG4gICAgdXBkYXRlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubWFyayhtYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpOyB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmFyIHVwZGF0ZWQgPSBbXTtcbiAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcHJldi5jaGlsZENvdW50OyBpJDIrKykgeyB1cGRhdGVkLnB1c2godXBkYXRlKHByZXYuY2hpbGQoaSQyKSkpOyB9XG4gIGlmIChGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLmVxKGN1cikpIHsgcmV0dXJuIHttYXJrOiBtYXJrLCB0eXBlOiB0eXBlfSB9XG59XG5cbmZ1bmN0aW9uIGxvb2tzTGlrZUpvaW4ob2xkLCBzdGFydCwgZW5kLCAkbmV3U3RhcnQsICRuZXdFbmQpIHtcbiAgaWYgKCEkbmV3U3RhcnQucGFyZW50LmlzVGV4dGJsb2NrIHx8XG4gICAgICAvLyBUaGUgY29udGVudCBtdXN0IGhhdmUgc2hydW5rXG4gICAgICBlbmQgLSBzdGFydCA8PSAkbmV3RW5kLnBvcyAtICRuZXdTdGFydC5wb3MgfHxcbiAgICAgIC8vIG5ld0VuZCBtdXN0IHBvaW50IGRpcmVjdGx5IGF0IG9yIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGJsb2NrIHRoYXQgbmV3U3RhcnQgcG9pbnRzIGludG9cbiAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV3U3RhcnQsIHRydWUsIGZhbHNlKSA8ICRuZXdFbmQucG9zKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICB2YXIgJHN0YXJ0ID0gb2xkLnJlc29sdmUoc3RhcnQpO1xuICAvLyBTdGFydCBtdXN0IGJlIGF0IHRoZSBlbmQgb2YgYSBibG9ja1xuICBpZiAoJHN0YXJ0LnBhcmVudE9mZnNldCA8ICRzdGFydC5wYXJlbnQuY29udGVudC5zaXplIHx8ICEkc3RhcnQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyICRuZXh0ID0gb2xkLnJlc29sdmUoc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRzdGFydCwgdHJ1ZSwgdHJ1ZSkpO1xuICAvLyBUaGUgbmV4dCB0ZXh0YmxvY2sgbXVzdCBzdGFydCBiZWZvcmUgZW5kIGFuZCBlbmQgbmVhciBpdFxuICBpZiAoISRuZXh0LnBhcmVudC5pc1RleHRibG9jayB8fCAkbmV4dC5wb3MgPiBlbmQgfHxcbiAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV4dCwgdHJ1ZSwgZmFsc2UpIDwgZW5kKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICAvLyBUaGUgZnJhZ21lbnRzIGFmdGVyIHRoZSBqb2luIHBvaW50IG11c3QgbWF0Y2hcbiAgcmV0dXJuICRuZXdTdGFydC5wYXJlbnQuY29udGVudC5jdXQoJG5ld1N0YXJ0LnBhcmVudE9mZnNldCkuZXEoJG5leHQucGFyZW50LmNvbnRlbnQpXG59XG5cbmZ1bmN0aW9uIHNraXBDbG9zaW5nQW5kT3BlbmluZygkcG9zLCBmcm9tRW5kLCBtYXlPcGVuKSB7XG4gIHZhciBkZXB0aCA9ICRwb3MuZGVwdGgsIGVuZCA9IGZyb21FbmQgPyAkcG9zLmVuZCgpIDogJHBvcy5wb3M7XG4gIHdoaWxlIChkZXB0aCA+IDAgJiYgKGZyb21FbmQgfHwgJHBvcy5pbmRleEFmdGVyKGRlcHRoKSA9PSAkcG9zLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpKSB7XG4gICAgZGVwdGgtLTtcbiAgICBlbmQrKztcbiAgICBmcm9tRW5kID0gZmFsc2U7XG4gIH1cbiAgaWYgKG1heU9wZW4pIHtcbiAgICB2YXIgbmV4dCA9ICRwb3Mubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkcG9zLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5pc0xlYWYpIHtcbiAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICBlbmQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZFxufVxuXG5mdW5jdGlvbiBmaW5kRGlmZihhLCBiLCBwb3MsIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSkge1xuICB2YXIgc3RhcnQgPSBhLmZpbmREaWZmU3RhcnQoYiwgcG9zKTtcbiAgaWYgKHN0YXJ0ID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgcmVmID0gYS5maW5kRGlmZkVuZChiLCBwb3MgKyBhLnNpemUsIHBvcyArIGIuc2l6ZSk7XG4gIHZhciBlbmRBID0gcmVmLmE7XG4gIHZhciBlbmRCID0gcmVmLmI7XG4gIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcbiAgICB2YXIgYWRqdXN0ID0gTWF0aC5tYXgoMCwgc3RhcnQgLSBNYXRoLm1pbihlbmRBLCBlbmRCKSk7XG4gICAgcHJlZmVycmVkUG9zIC09IGVuZEEgKyBhZGp1c3QgLSBzdGFydDtcbiAgfVxuICBpZiAoZW5kQSA8IHN0YXJ0ICYmIGEuc2l6ZSA8IGIuc2l6ZSkge1xuICAgIHZhciBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRBID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgIHN0YXJ0IC09IG1vdmU7XG4gICAgZW5kQiA9IHN0YXJ0ICsgKGVuZEIgLSBlbmRBKTtcbiAgICBlbmRBID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAoZW5kQiA8IHN0YXJ0KSB7XG4gICAgdmFyIG1vdmUkMSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQiA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICBzdGFydCAtPSBtb3ZlJDE7XG4gICAgZW5kQSA9IHN0YXJ0ICsgKGVuZEEgLSBlbmRCKTtcbiAgICBlbmRCID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydDogc3RhcnQsIGVuZEE6IGVuZEEsIGVuZEI6IGVuZEJ9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSkge1xuICB2YXIgY29udGV4dCA9IFtdO1xuICB2YXIgY29udGVudCA9IHNsaWNlLmNvbnRlbnQ7XG4gIHZhciBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQ7XG4gIHZhciBvcGVuRW5kID0gc2xpY2Uub3BlbkVuZDtcbiAgd2hpbGUgKG9wZW5TdGFydCA+IDEgJiYgb3BlbkVuZCA+IDEgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEgJiYgY29udGVudC5maXJzdENoaWxkLmNoaWxkQ291bnQgPT0gMSkge1xuICAgIG9wZW5TdGFydC0tO1xuICAgIG9wZW5FbmQtLTtcbiAgICB2YXIgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICBjb250ZXh0LnB1c2gobm9kZS50eXBlLm5hbWUsIG5vZGUuYXR0cnMgIT0gbm9kZS50eXBlLmRlZmF1bHRBdHRycyA/IG5vZGUuYXR0cnMgOiBudWxsKTtcbiAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkU2VyaWFsaXplclwiKSB8fCBET01TZXJpYWxpemVyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICB2YXIgZG9jID0gZGV0YWNoZWREb2MoKSwgd3JhcCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB3cmFwLmFwcGVuZENoaWxkKHNlcmlhbGl6ZXIuc2VyaWFsaXplRnJhZ21lbnQoY29udGVudCwge2RvY3VtZW50OiBkb2N9KSk7XG5cbiAgdmFyIGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQsIG5lZWRzV3JhcDtcbiAgd2hpbGUgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxICYmIChuZWVkc1dyYXAgPSB3cmFwTWFwW2ZpcnN0Q2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pKSB7XG4gICAgZm9yICh2YXIgaSA9IG5lZWRzV3JhcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHdyYXBwZXIgPSBkb2MuY3JlYXRlRWxlbWVudChuZWVkc1dyYXBbaV0pO1xuICAgICAgd2hpbGUgKHdyYXAuZmlyc3RDaGlsZCkgeyB3cmFwcGVyLmFwcGVuZENoaWxkKHdyYXAuZmlyc3RDaGlsZCk7IH1cbiAgICAgIHdyYXAuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICBpZiAobmVlZHNXcmFwW2ldICE9IFwidGJvZHlcIikge1xuICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgb3BlbkVuZCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBmaXJzdENoaWxkID0gd3JhcC5maXJzdENoaWxkO1xuICB9XG5cbiAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgIHsgZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIsIChvcGVuU3RhcnQgKyBcIiBcIiArIG9wZW5FbmQgKyBcIiBcIiArIChKU09OLnN0cmluZ2lmeShjb250ZXh0KSkpKTsgfVxuXG4gIHZhciB0ZXh0ID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHNsaWNlKTsgfSkgfHxcbiAgICAgIHNsaWNlLmNvbnRlbnQudGV4dEJldHdlZW4oMCwgc2xpY2UuY29udGVudC5zaXplLCBcIlxcblxcblwiKTtcblxuICByZXR1cm4ge2RvbTogd3JhcCwgdGV4dDogdGV4dH1cbn1cblxuLy8gOiAoRWRpdG9yVmlldywgc3RyaW5nLCBzdHJpbmcsID9ib29sLCBSZXNvbHZlZFBvcykg4oaSID9TbGljZVxuLy8gUmVhZCBhIHNsaWNlIG9mIGNvbnRlbnQgZnJvbSB0aGUgY2xpcGJvYXJkIChvciBkcm9wIGRhdGEpLlxuZnVuY3Rpb24gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHBsYWluVGV4dCwgJGNvbnRleHQpIHtcbiAgdmFyIGRvbSwgaW5Db2RlID0gJGNvbnRleHQucGFyZW50LnR5cGUuc3BlYy5jb2RlLCBzbGljZTtcbiAgaWYgKCFodG1sICYmICF0ZXh0KSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGFzVGV4dCA9IHRleHQgJiYgKHBsYWluVGV4dCB8fCBpbkNvZGUgfHwgIWh0bWwpO1xuICBpZiAoYXNUZXh0KSB7XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFRleHRcIiwgZnVuY3Rpb24gKGYpIHsgdGV4dCA9IGYodGV4dCwgaW5Db2RlIHx8IHBsYWluVGV4dCk7IH0pO1xuICAgIGlmIChpbkNvZGUpIHsgcmV0dXJuIHRleHQgPyBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh2aWV3LnN0YXRlLnNjaGVtYS50ZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSkpLCAwLCAwKSA6IFNsaWNlLmVtcHR5IH1cbiAgICB2YXIgcGFyc2VkID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRQYXJzZXJcIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodGV4dCwgJGNvbnRleHQsIHBsYWluVGV4dCk7IH0pO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHNsaWNlID0gcGFyc2VkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFya3MgPSAkY29udGV4dC5tYXJrcygpO1xuICAgICAgdmFyIHJlZiA9IHZpZXcuc3RhdGU7XG4gICAgICB2YXIgc2NoZW1hID0gcmVmLnNjaGVtYTtcbiAgICAgIHZhciBzZXJpYWxpemVyID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGV4dC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pKy8pLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBwID0gZG9tLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpKTtcbiAgICAgICAgaWYgKGJsb2NrKSB7IHAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVOb2RlKHNjaGVtYS50ZXh0KGJsb2NrLCBtYXJrcykpKTsgfVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRIVE1MXCIsIGZ1bmN0aW9uIChmKSB7IGh0bWwgPSBmKGh0bWwpOyB9KTtcbiAgICBkb20gPSByZWFkSFRNTChodG1sKTtcbiAgICBpZiAocmVzdWx0LndlYmtpdCkgeyByZXN0b3JlUmVwbGFjZWRTcGFjZXMoZG9tKTsgfVxuICB9XG5cbiAgdmFyIGNvbnRleHROb2RlID0gZG9tICYmIGRvbS5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtcG0tc2xpY2VdXCIpO1xuICB2YXIgc2xpY2VEYXRhID0gY29udGV4dE5vZGUgJiYgL14oXFxkKykgKFxcZCspICguKikvLmV4ZWMoY29udGV4dE5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wbS1zbGljZVwiKSk7XG4gIGlmICghc2xpY2UpIHtcbiAgICB2YXIgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFBhcnNlclwiKSB8fCB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICBzbGljZSA9IHBhcnNlci5wYXJzZVNsaWNlKGRvbSwge3ByZXNlcnZlV2hpdGVzcGFjZTogISEoYXNUZXh0IHx8IHNsaWNlRGF0YSksIGNvbnRleHQ6ICRjb250ZXh0fSk7XG4gIH1cbiAgaWYgKHNsaWNlRGF0YSkge1xuICAgIHNsaWNlID0gYWRkQ29udGV4dChjbG9zZVNsaWNlKHNsaWNlLCArc2xpY2VEYXRhWzFdLCArc2xpY2VEYXRhWzJdKSwgc2xpY2VEYXRhWzNdKTtcbiAgfSBlbHNlIHsgLy8gSFRNTCB3YXNuJ3QgY3JlYXRlZCBieSBQcm9zZU1pcnJvci4gTWFrZSBzdXJlIHRvcC1sZXZlbCBzaWJsaW5ncyBhcmUgY29oZXJlbnRcbiAgICBzbGljZSA9IFNsaWNlLm1heE9wZW4obm9ybWFsaXplU2libGluZ3Moc2xpY2UuY29udGVudCwgJGNvbnRleHQpLCB0cnVlKTtcbiAgICBpZiAoc2xpY2Uub3BlblN0YXJ0IHx8IHNsaWNlLm9wZW5FbmQpIHtcbiAgICAgIHZhciBvcGVuU3RhcnQgPSAwLCBvcGVuRW5kID0gMDtcbiAgICAgIGZvciAodmFyIG5vZGUgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQ7IG9wZW5TdGFydCA8IHNsaWNlLm9wZW5TdGFydCAmJiAhbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nO1xuICAgICAgICAgICBvcGVuU3RhcnQrKywgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZCkge31cbiAgICAgIGZvciAodmFyIG5vZGUkMSA9IHNsaWNlLmNvbnRlbnQubGFzdENoaWxkOyBvcGVuRW5kIDwgc2xpY2Uub3BlbkVuZCAmJiAhbm9kZSQxLnR5cGUuc3BlYy5pc29sYXRpbmc7XG4gICAgICAgICAgIG9wZW5FbmQrKywgbm9kZSQxID0gbm9kZSQxLmxhc3RDaGlsZCkge31cbiAgICAgIHNsaWNlID0gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG4gIH1cblxuICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGZ1bmN0aW9uIChmKSB7IHNsaWNlID0gZihzbGljZSk7IH0pO1xuICByZXR1cm4gc2xpY2Vcbn1cblxuLy8gVGFrZXMgYSBzbGljZSBwYXJzZWQgd2l0aCBwYXJzZVNsaWNlLCB3aGljaCBtZWFucyB0aGVyZSBoYXNuJ3QgYmVlblxuLy8gYW55IGNvbnRlbnQtZXhwcmVzc2lvbiBjaGVja2luZyBkb25lIG9uIHRoZSB0b3Agbm9kZXMsIHRyaWVzIHRvXG4vLyBmaW5kIGEgcGFyZW50IG5vZGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dCB0aGF0IG1pZ2h0IGZpdCB0aGUgbm9kZXMsXG4vLyBhbmQgaWYgc3VjY2Vzc2Z1bCwgcmVidWlsZHMgdGhlIHNsaWNlIHNvIHRoYXQgaXQgZml0cyBpbnRvIHRoYXQgcGFyZW50LlxuLy9cbi8vIFRoaXMgYWRkcmVzc2VzIHRoZSBwcm9ibGVtIHRoYXQgVHJhbnNmb3JtLnJlcGxhY2UgZXhwZWN0cyBhXG4vLyBjb2hlcmVudCBzbGljZSwgYW5kIHdpbGwgZmFpbCB0byBwbGFjZSBhIHNldCBvZiBzaWJsaW5ncyB0aGF0IGRvbid0XG4vLyBmaXQgYW55d2hlcmUgaW4gdGhlIHNjaGVtYS5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpYmxpbmdzKGZyYWdtZW50LCAkY29udGV4dCkge1xuICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA8IDIpIHsgcmV0dXJuIGZyYWdtZW50IH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGQgKSB7XG4gICAgdmFyIHBhcmVudCA9ICRjb250ZXh0Lm5vZGUoZCk7XG4gICAgdmFyIG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4KGQpKTtcbiAgICB2YXIgbGFzdFdyYXAgPSAodm9pZCAwKSwgcmVzdWx0ID0gW107XG4gICAgZnJhZ21lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKCFyZXN1bHQpIHsgcmV0dXJuIH1cbiAgICAgIHZhciB3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSksIGluTGFzdDtcbiAgICAgIGlmICghd3JhcCkgeyByZXR1cm4gcmVzdWx0ID0gbnVsbCB9XG4gICAgICBpZiAoaW5MYXN0ID0gcmVzdWx0Lmxlbmd0aCAmJiBsYXN0V3JhcC5sZW5ndGggJiYgYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCAwKSkge1xuICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gaW5MYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHsgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IGNsb3NlUmlnaHQocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgbGFzdFdyYXAubGVuZ3RoKTsgfVxuICAgICAgICB2YXIgd3JhcHBlZCA9IHdpdGhXcmFwcGVycyhub2RlLCB3cmFwKTtcbiAgICAgICAgcmVzdWx0LnB1c2god3JhcHBlZCk7XG4gICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hUeXBlKHdyYXBwZWQudHlwZSwgd3JhcHBlZC5hdHRycyk7XG4gICAgICAgIGxhc3RXcmFwID0gd3JhcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVzdWx0KSB7IHJldHVybiB7IHY6IEZyYWdtZW50LmZyb20ocmVzdWx0KSB9IH1cbiAgfTtcblxuICBmb3IgKHZhciBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgdmFyIHJldHVybmVkID0gbG9vcCggZCApO1xuXG4gICAgaWYgKCByZXR1cm5lZCApIHJldHVybiByZXR1cm5lZC52O1xuICB9XG4gIHJldHVybiBmcmFnbWVudFxufVxuXG5mdW5jdGlvbiB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCwgZnJvbSkge1xuICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuXG4gIGZvciAodmFyIGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gZnJvbTsgaS0tKVxuICAgIHsgbm9kZSA9IHdyYXBbaV0uY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20obm9kZSkpOyB9XG4gIHJldHVybiBub2RlXG59XG5cbi8vIFVzZWQgdG8gZ3JvdXAgYWRqYWNlbnQgbm9kZXMgd3JhcHBlZCBpbiBzaW1pbGFyIHBhcmVudHMgYnlcbi8vIG5vcm1hbGl6ZVNpYmxpbmdzIGludG8gdGhlIHNhbWUgcGFyZW50IG5vZGVcbmZ1bmN0aW9uIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZywgZGVwdGgpIHtcbiAgaWYgKGRlcHRoIDwgd3JhcC5sZW5ndGggJiYgZGVwdGggPCBsYXN0V3JhcC5sZW5ndGggJiYgd3JhcFtkZXB0aF0gPT0gbGFzdFdyYXBbZGVwdGhdKSB7XG4gICAgdmFyIGlubmVyID0gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLmxhc3RDaGlsZCwgZGVwdGggKyAxKTtcbiAgICBpZiAoaW5uZXIpIHsgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQucmVwbGFjZUNoaWxkKHNpYmxpbmcuY2hpbGRDb3VudCAtIDEsIGlubmVyKSkgfVxuICAgIHZhciBtYXRjaCA9IHNpYmxpbmcuY29udGVudE1hdGNoQXQoc2libGluZy5jaGlsZENvdW50KTtcbiAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKGRlcHRoID09IHdyYXAubGVuZ3RoIC0gMSA/IG5vZGUudHlwZSA6IHdyYXBbZGVwdGggKyAxXSkpXG4gICAgICB7IHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LmFwcGVuZChGcmFnbWVudC5mcm9tKHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBkZXB0aCArIDEpKSkpIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9zZVJpZ2h0KG5vZGUsIGRlcHRoKSB7XG4gIGlmIChkZXB0aCA9PSAwKSB7IHJldHVybiBub2RlIH1cbiAgdmFyIGZyYWdtZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChub2RlLmNoaWxkQ291bnQgLSAxLCBjbG9zZVJpZ2h0KG5vZGUubGFzdENoaWxkLCBkZXB0aCAtIDEpKTtcbiAgdmFyIGZpbGwgPSBub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gIHJldHVybiBub2RlLmNvcHkoZnJhZ21lbnQuYXBwZW5kKGZpbGwpKVxufVxuXG5mdW5jdGlvbiBjbG9zZVJhbmdlKGZyYWdtZW50LCBzaWRlLCBmcm9tLCB0bywgZGVwdGgsIG9wZW5FbmQpIHtcbiAgdmFyIG5vZGUgPSBzaWRlIDwgMCA/IGZyYWdtZW50LmZpcnN0Q2hpbGQgOiBmcmFnbWVudC5sYXN0Q2hpbGQsIGlubmVyID0gbm9kZS5jb250ZW50O1xuICBpZiAoZGVwdGggPCB0byAtIDEpIHsgaW5uZXIgPSBjbG9zZVJhbmdlKGlubmVyLCBzaWRlLCBmcm9tLCB0bywgZGVwdGggKyAxLCBvcGVuRW5kKTsgfVxuICBpZiAoZGVwdGggPj0gZnJvbSlcbiAgICB7IGlubmVyID0gc2lkZSA8IDAgPyBub2RlLmNvbnRlbnRNYXRjaEF0KDApLmZpbGxCZWZvcmUoaW5uZXIsIGZyYWdtZW50LmNoaWxkQ291bnQgPiAxIHx8IG9wZW5FbmQgPD0gZGVwdGgpLmFwcGVuZChpbm5lcilcbiAgICAgIDogaW5uZXIuYXBwZW5kKG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7IH1cbiAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZChzaWRlIDwgMCA/IDAgOiBmcmFnbWVudC5jaGlsZENvdW50IC0gMSwgbm9kZS5jb3B5KGlubmVyKSlcbn1cblxuZnVuY3Rpb24gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gIGlmIChvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQpXG4gICAgeyBzbGljZSA9IG5ldyBTbGljZShjbG9zZVJhbmdlKHNsaWNlLmNvbnRlbnQsIC0xLCBvcGVuU3RhcnQsIHNsaWNlLm9wZW5TdGFydCwgMCwgc2xpY2Uub3BlbkVuZCksIG9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZCk7IH1cbiAgaWYgKG9wZW5FbmQgPCBzbGljZS5vcGVuRW5kKVxuICAgIHsgc2xpY2UgPSBuZXcgU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAxLCBvcGVuRW5kLCBzbGljZS5vcGVuRW5kLCAwLCAwKSwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRW5kKTsgfVxuICByZXR1cm4gc2xpY2Vcbn1cblxuLy8gVHJpY2sgZnJvbSBqUXVlcnkgLS0gc29tZSBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gb3RoZXJcbi8vIGVsZW1lbnRzIGZvciBpbm5lckhUTUwgdG8gd29yay4gSS5lLiBpZiB5b3UgZG8gYGRpdi5pbm5lckhUTUwgPVxuLy8gXCI8dGQ+Li48L3RkPlwiYCB0aGUgdGFibGUgY2VsbHMgYXJlIGlnbm9yZWQuXG52YXIgd3JhcE1hcCA9IHtcbiAgdGhlYWQ6IFtcInRhYmxlXCJdLFxuICB0Ym9keTogW1widGFibGVcIl0sXG4gIHRmb290OiBbXCJ0YWJsZVwiXSxcbiAgY2FwdGlvbjogW1widGFibGVcIl0sXG4gIGNvbGdyb3VwOiBbXCJ0YWJsZVwiXSxcbiAgY29sOiBbXCJ0YWJsZVwiLCBcImNvbGdyb3VwXCJdLFxuICB0cjogW1widGFibGVcIiwgXCJ0Ym9keVwiXSxcbiAgdGQ6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXSxcbiAgdGg6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXVxufTtcblxudmFyIF9kZXRhY2hlZERvYyA9IG51bGw7XG5mdW5jdGlvbiBkZXRhY2hlZERvYygpIHtcbiAgcmV0dXJuIF9kZXRhY2hlZERvYyB8fCAoX2RldGFjaGVkRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwidGl0bGVcIikpXG59XG5cbmZ1bmN0aW9uIHJlYWRIVE1MKGh0bWwpIHtcbiAgdmFyIG1ldGFzID0gL14oXFxzKjxtZXRhIFtePl0qPikqLy5leGVjKGh0bWwpO1xuICBpZiAobWV0YXMpIHsgaHRtbCA9IGh0bWwuc2xpY2UobWV0YXNbMF0ubGVuZ3RoKTsgfVxuICB2YXIgZWx0ID0gZGV0YWNoZWREb2MoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB2YXIgZmlyc3RUYWcgPSAvPChbYS16XVtePlxcc10rKS9pLmV4ZWMoaHRtbCksIHdyYXA7XG4gIGlmICh3cmFwID0gZmlyc3RUYWcgJiYgd3JhcE1hcFtmaXJzdFRhZ1sxXS50b0xvd2VyQ2FzZSgpXSlcbiAgICB7IGh0bWwgPSB3cmFwLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gXCI8XCIgKyBuICsgXCI+XCI7IH0pLmpvaW4oXCJcIikgKyBodG1sICsgd3JhcC5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFwiPC9cIiArIG4gKyBcIj5cIjsgfSkucmV2ZXJzZSgpLmpvaW4oXCJcIik7IH1cbiAgZWx0LmlubmVySFRNTCA9IGh0bWw7XG4gIGlmICh3cmFwKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKykgeyBlbHQgPSBlbHQucXVlcnlTZWxlY3Rvcih3cmFwW2ldKSB8fCBlbHQ7IH0gfVxuICByZXR1cm4gZWx0XG59XG5cbi8vIFdlYmtpdCBicm93c2VycyBkbyBzb21lIGhhcmQtdG8tcHJlZGljdCByZXBsYWNlbWVudCBvZiByZWd1bGFyXG4vLyBzcGFjZXMgd2l0aCBub24tYnJlYWtpbmcgc3BhY2VzIHdoZW4gcHV0dGluZyBjb250ZW50IG9uIHRoZVxuLy8gY2xpcGJvYXJkLiBUaGlzIHRyaWVzIHRvIGNvbnZlcnQgc3VjaCBub24tYnJlYWtpbmcgc3BhY2VzICh3aGljaFxuLy8gd2lsbCBiZSB3cmFwcGVkIGluIGEgcGxhaW4gc3BhbiBvbiBDaHJvbWUsIGEgc3BhbiB3aXRoIGNsYXNzXG4vLyBBcHBsZS1jb252ZXJ0ZWQtc3BhY2Ugb24gU2FmYXJpKSBiYWNrIHRvIHJlZ3VsYXIgc3BhY2VzLlxuZnVuY3Rpb24gcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSkge1xuICB2YXIgbm9kZXMgPSBkb20ucXVlcnlTZWxlY3RvckFsbChyZXN1bHQuY2hyb21lID8gXCJzcGFuOm5vdChbY2xhc3NdKTpub3QoW3N0eWxlXSlcIiA6IFwic3Bhbi5BcHBsZS1jb252ZXJ0ZWQtc3BhY2VcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS50ZXh0Q29udGVudCA9PSBcIlxcdTAwYTBcIiAmJiBub2RlLnBhcmVudE5vZGUpXG4gICAgICB7IG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgXCIpLCBub2RlKTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZENvbnRleHQoc2xpY2UsIGNvbnRleHQpIHtcbiAgaWYgKCFzbGljZS5zaXplKSB7IHJldHVybiBzbGljZSB9XG4gIHZhciBzY2hlbWEgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQudHlwZS5zY2hlbWEsIGFycmF5O1xuICB0cnkgeyBhcnJheSA9IEpTT04ucGFyc2UoY29udGV4dCk7IH1cbiAgY2F0Y2goZSkgeyByZXR1cm4gc2xpY2UgfVxuICB2YXIgY29udGVudCA9IHNsaWNlLmNvbnRlbnQ7XG4gIHZhciBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQ7XG4gIHZhciBvcGVuRW5kID0gc2xpY2Uub3BlbkVuZDtcbiAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgdmFyIHR5cGUgPSBzY2hlbWEubm9kZXNbYXJyYXlbaV1dO1xuICAgIGlmICghdHlwZSB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgeyBicmVhayB9XG4gICAgY29udGVudCA9IEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXJyYXlbaSArIDFdLCBjb250ZW50KSk7XG4gICAgb3BlblN0YXJ0Kys7IG9wZW5FbmQrKztcbiAgfVxuICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZClcbn1cblxudmFyIG9ic2VydmVPcHRpb25zID0ge1xuICBjaGlsZExpc3Q6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgYXR0cmlidXRlczogdHJ1ZSxcbiAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gIHN1YnRyZWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZFxudmFyIHVzZUNoYXJEYXRhID0gcmVzdWx0LmllICYmIHJlc3VsdC5pZV92ZXJzaW9uIDw9IDExO1xuXG52YXIgU2VsZWN0aW9uU3RhdGUgPSBmdW5jdGlvbiBTZWxlY3Rpb25TdGF0ZSgpIHtcbiAgdGhpcy5hbmNob3JOb2RlID0gdGhpcy5hbmNob3JPZmZzZXQgPSB0aGlzLmZvY3VzTm9kZSA9IHRoaXMuZm9jdXNPZmZzZXQgPSBudWxsO1xufTtcblxuU2VsZWN0aW9uU3RhdGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoc2VsKSB7XG4gIHRoaXMuYW5jaG9yTm9kZSA9IHNlbC5hbmNob3JOb2RlOyB0aGlzLmFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gIHRoaXMuZm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTsgdGhpcy5mb2N1c09mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbn07XG5cblNlbGVjdGlvblN0YXRlLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChzZWwpIHtcbiAgcmV0dXJuIHNlbC5hbmNob3JOb2RlID09IHRoaXMuYW5jaG9yTm9kZSAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09IHRoaXMuYW5jaG9yT2Zmc2V0ICYmXG4gICAgc2VsLmZvY3VzTm9kZSA9PSB0aGlzLmZvY3VzTm9kZSAmJiBzZWwuZm9jdXNPZmZzZXQgPT0gdGhpcy5mb2N1c09mZnNldFxufTtcblxudmFyIERPTU9ic2VydmVyID0gZnVuY3Rpb24gRE9NT2JzZXJ2ZXIodmlldywgaGFuZGxlRE9NQ2hhbmdlKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMudmlldyA9IHZpZXc7XG4gIHRoaXMuaGFuZGxlRE9NQ2hhbmdlID0gaGFuZGxlRE9NQ2hhbmdlO1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gIHRoaXMub2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciAmJlxuICAgIG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykgeyB0aGlzJDEucXVldWUucHVzaChtdXRhdGlvbnNbaV0pOyB9XG4gICAgICAvLyBJRTExIHdpbGwgc29tZXRpbWVzIChvbiBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICAvLyB0ZXh0IG5vZGUgYWZ0ZXIgYSBCUiBub2RlKSBjYWxsIHRoZSBvYnNlcnZlciBjYWxsYmFja1xuICAgICAgLy8gYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00sIHdoaWNoIHdpbGwgY2F1c2VcbiAgICAgIC8vIFByb3NlTWlycm9yIHRvIG1pc3MgdGhlIGNoYW5nZSAoc2VlICM5MzApXG4gICAgICBpZiAocmVzdWx0LmllICYmIHJlc3VsdC5pZV92ZXJzaW9uIDw9IDExICYmIG11dGF0aW9ucy5zb21lKFxuICAgICAgICBmdW5jdGlvbiAobSkgeyByZXR1cm4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aDsgfSkpXG4gICAgICAgIHsgdGhpcyQxLmZsdXNoU29vbigpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcyQxLmZsdXNoKCk7IH1cbiAgICB9KTtcbiAgdGhpcy5jdXJyZW50U2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvblN0YXRlO1xuICBpZiAodXNlQ2hhckRhdGEpIHtcbiAgICB0aGlzLm9uQ2hhckRhdGEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcyQxLnF1ZXVlLnB1c2goe3RhcmdldDogZS50YXJnZXQsIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLCBvbGRWYWx1ZTogZS5wcmV2VmFsdWV9KTtcbiAgICAgIHRoaXMkMS5mbHVzaFNvb24oKTtcbiAgICB9O1xuICB9XG4gIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gZmFsc2U7XG59O1xuXG5ET01PYnNlcnZlci5wcm90b3R5cGUuZmx1c2hTb29uID0gZnVuY3Rpb24gZmx1c2hTb29uICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5mbHVzaGluZ1Nvb24gPCAwKVxuICAgIHsgdGhpcy5mbHVzaGluZ1Nvb24gPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRoaXMkMS5mbHVzaGluZ1Nvb24gPSAtMTsgdGhpcyQxLmZsdXNoKCk7IH0sIDIwKTsgfVxufTtcblxuRE9NT2JzZXJ2ZXIucHJvdG90eXBlLmZvcmNlRmx1c2ggPSBmdW5jdGlvbiBmb3JjZUZsdXNoICgpIHtcbiAgaWYgKHRoaXMuZmx1c2hpbmdTb29uID4gLTEpIHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZmx1c2hpbmdTb29uKTtcbiAgICB0aGlzLmZsdXNoaW5nU29vbiA9IC0xO1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuRE9NT2JzZXJ2ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQgKCkge1xuICBpZiAodGhpcy5vYnNlcnZlcilcbiAgICB7IHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnZpZXcuZG9tLCBvYnNlcnZlT3B0aW9ucyk7IH1cbiAgaWYgKHVzZUNoYXJEYXRhKVxuICAgIHsgdGhpcy52aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7IH1cbiAgdGhpcy5jb25uZWN0U2VsZWN0aW9uKCk7XG59O1xuXG5ET01PYnNlcnZlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgdmFyIHRha2UgPSB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgaWYgKHRha2UubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRha2UubGVuZ3RoOyBpKyspIHsgdGhpcy5xdWV1ZS5wdXNoKHRha2VbaV0pOyB9XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuZmx1c2goKTsgfSwgMjApO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodXNlQ2hhckRhdGEpIHsgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7IH1cbiAgdGhpcy5kaXNjb25uZWN0U2VsZWN0aW9uKCk7XG59O1xuXG5ET01PYnNlcnZlci5wcm90b3R5cGUuY29ubmVjdFNlbGVjdGlvbiA9IGZ1bmN0aW9uIGNvbm5lY3RTZWxlY3Rpb24gKCkge1xuICB0aGlzLnZpZXcuZG9tLm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbn07XG5cbkRPTU9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0U2VsZWN0aW9uID0gZnVuY3Rpb24gZGlzY29ubmVjdFNlbGVjdGlvbiAoKSB7XG4gIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xufTtcblxuRE9NT2JzZXJ2ZXIucHJvdG90eXBlLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcyA9IGZ1bmN0aW9uIHN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSB0cnVlO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZTsgfSwgNTApO1xufTtcblxuRE9NT2JzZXJ2ZXIucHJvdG90eXBlLm9uU2VsZWN0aW9uQ2hhbmdlID0gZnVuY3Rpb24gb25TZWxlY3Rpb25DaGFuZ2UgKCkge1xuICBpZiAoIWhhc0ZvY3VzQW5kU2VsZWN0aW9uKHRoaXMudmlldykpIHsgcmV0dXJuIH1cbiAgaWYgKHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzKSB7IHJldHVybiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpIH1cbiAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcbiAgLy8gdXMgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgRE9NIGNoYW5nZXMgYXJlXG4gIC8vIHJlcG9ydGVkLlxuICBpZiAocmVzdWx0LmllICYmIHJlc3VsdC5pZV92ZXJzaW9uIDw9IDExICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgdmFyIHNlbCA9IHRoaXMudmlldy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgIC8vIFNlbGVjdGlvbi5pc0NvbGxhcHNlZCBpc24ndCByZWxpYWJsZSBvbiBJRVxuICAgIGlmIChzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgeyByZXR1cm4gdGhpcy5mbHVzaFNvb24oKSB9XG4gIH1cbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuRE9NT2JzZXJ2ZXIucHJvdG90eXBlLnNldEN1clNlbGVjdGlvbiA9IGZ1bmN0aW9uIHNldEN1clNlbGVjdGlvbiAoKSB7XG4gIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQodGhpcy52aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCkpO1xufTtcblxuRE9NT2JzZXJ2ZXIucHJvdG90eXBlLmlnbm9yZVNlbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uIGlnbm9yZVNlbGVjdGlvbkNoYW5nZSAoc2VsKSB7XG4gIGlmIChzZWwucmFuZ2VDb3VudCA9PSAwKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGNvbnRhaW5lciA9IHNlbC5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICB2YXIgZGVzYyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGNvbnRhaW5lcik7XG4gIGlmIChkZXNjICYmIGRlc2MuaWdub3JlTXV0YXRpb24oe3R5cGU6IFwic2VsZWN0aW9uXCIsIHRhcmdldDogY29udGFpbmVyLm5vZGVUeXBlID09IDMgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lcn0pKSB7XG4gICAgdGhpcy5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59O1xuXG5ET01PYnNlcnZlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCAoKSB7XG4gIGlmICghdGhpcy52aWV3LmRvY1ZpZXcgfHwgdGhpcy5mbHVzaGluZ1Nvb24gPiAtMSkgeyByZXR1cm4gfVxuICB2YXIgbXV0YXRpb25zID0gdGhpcy5vYnNlcnZlciA/IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSA6IFtdO1xuICBpZiAodGhpcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICBtdXRhdGlvbnMgPSB0aGlzLnF1ZXVlLmNvbmNhdChtdXRhdGlvbnMpO1xuICAgIHRoaXMucXVldWUubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHZhciBzZWwgPSB0aGlzLnZpZXcucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIG5ld1NlbCA9ICF0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyAmJiAhdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkgJiYgaGFzU2VsZWN0aW9uKHRoaXMudmlldykgJiYgIXRoaXMuaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCk7XG5cbiAgdmFyIGZyb20gPSAtMSwgdG8gPSAtMSwgdHlwZU92ZXIgPSBmYWxzZSwgYWRkZWQgPSBbXTtcbiAgaWYgKHRoaXMudmlldy5lZGl0YWJsZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVzdWx0JDEgPSB0aGlzLnJlZ2lzdGVyTXV0YXRpb24obXV0YXRpb25zW2ldLCBhZGRlZCk7XG4gICAgICBpZiAocmVzdWx0JDEpIHtcbiAgICAgICAgZnJvbSA9IGZyb20gPCAwID8gcmVzdWx0JDEuZnJvbSA6IE1hdGgubWluKHJlc3VsdCQxLmZyb20sIGZyb20pO1xuICAgICAgICB0byA9IHRvIDwgMCA/IHJlc3VsdCQxLnRvIDogTWF0aC5tYXgocmVzdWx0JDEudG8sIHRvKTtcbiAgICAgICAgaWYgKHJlc3VsdCQxLnR5cGVPdmVyKSB7IHR5cGVPdmVyID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChyZXN1bHQuZ2Vja28gJiYgYWRkZWQubGVuZ3RoID4gMSkge1xuICAgIHZhciBicnMgPSBhZGRlZC5maWx0ZXIoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ubm9kZU5hbWUgPT0gXCJCUlwiOyB9KTtcbiAgICBpZiAoYnJzLmxlbmd0aCA9PSAyKSB7XG4gICAgICB2YXIgYSA9IGJyc1swXTtcbiAgICAgICAgdmFyIGIgPSBicnNbMV07XG4gICAgICBpZiAoYS5wYXJlbnROb2RlICYmIGEucGFyZW50Tm9kZS5wYXJlbnROb2RlID09IGIucGFyZW50Tm9kZSkgeyBiLnJlbW92ZSgpOyB9XG4gICAgICBlbHNlIHsgYS5yZW1vdmUoKTsgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmcm9tID4gLTEgfHwgbmV3U2VsKSB7XG4gICAgaWYgKGZyb20gPiAtMSkge1xuICAgICAgdGhpcy52aWV3LmRvY1ZpZXcubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgIGNoZWNrQ1NTKHRoaXMudmlldyk7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlRE9NQ2hhbmdlKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpO1xuICAgIGlmICh0aGlzLnZpZXcuZG9jVmlldy5kaXJ0eSkgeyB0aGlzLnZpZXcudXBkYXRlU3RhdGUodGhpcy52aWV3LnN0YXRlKTsgfVxuICAgIGVsc2UgaWYgKCF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSkgeyBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpOyB9XG4gICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldChzZWwpO1xuICB9XG59O1xuXG5ET01PYnNlcnZlci5wcm90b3R5cGUucmVnaXN0ZXJNdXRhdGlvbiA9IGZ1bmN0aW9uIHJlZ2lzdGVyTXV0YXRpb24gKG11dCwgYWRkZWQpIHtcbiAgLy8gSWdub3JlIG11dGF0aW9ucyBpbnNpZGUgbm9kZXMgdGhhdCB3ZXJlIGFscmVhZHkgbm90ZWQgYXMgaW5zZXJ0ZWRcbiAgaWYgKGFkZGVkLmluZGV4T2YobXV0LnRhcmdldCkgPiAtMSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBkZXNjID0gdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MobXV0LnRhcmdldCk7XG4gIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIiAmJlxuICAgICAgKGRlc2MgPT0gdGhpcy52aWV3LmRvY1ZpZXcgfHwgbXV0LmF0dHJpYnV0ZU5hbWUgPT0gXCJjb250ZW50ZWRpdGFibGVcIiB8fFxuICAgICAgIC8vIEZpcmVmb3ggc29tZXRpbWVzIGZpcmVzIHNwdXJpb3VzIGV2ZW50cyBmb3IgbnVsbC9lbXB0eSBzdHlsZXNcbiAgICAgICAobXV0LmF0dHJpYnV0ZU5hbWUgPT0gXCJzdHlsZVwiICYmICFtdXQub2xkVmFsdWUgJiYgIW11dC50YXJnZXQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikpKSlcbiAgICB7IHJldHVybiBudWxsIH1cbiAgaWYgKCFkZXNjIHx8IGRlc2MuaWdub3JlTXV0YXRpb24obXV0KSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgaWYgKG11dC50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dC5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7IGFkZGVkLnB1c2gobXV0LmFkZGVkTm9kZXNbaV0pOyB9XG4gICAgaWYgKGRlc2MuY29udGVudERPTSAmJiBkZXNjLmNvbnRlbnRET00gIT0gZGVzYy5kb20gJiYgIWRlc2MuY29udGVudERPTS5jb250YWlucyhtdXQudGFyZ2V0KSlcbiAgICAgIHsgcmV0dXJuIHtmcm9tOiBkZXNjLnBvc0JlZm9yZSwgdG86IGRlc2MucG9zQWZ0ZXJ9IH1cbiAgICB2YXIgcHJldiA9IG11dC5wcmV2aW91c1NpYmxpbmcsIG5leHQgPSBtdXQubmV4dFNpYmxpbmc7XG4gICAgaWYgKHJlc3VsdC5pZSAmJiByZXN1bHQuaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXQuYWRkZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIC8vIElFMTEgZ2l2ZXMgdXMgaW5jb3JyZWN0IG5leHQvcHJldiBzaWJsaW5ncyBmb3Igc29tZVxuICAgICAgLy8gaW5zZXJ0aW9ucywgc28gaWYgdGhlcmUgYXJlIGFkZGVkIG5vZGVzLCByZWNvbXB1dGUgdGhvc2VcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG11dC5hZGRlZE5vZGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIHJlZiA9IG11dC5hZGRlZE5vZGVzW2kkMV07XG4gICAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IHJlZi5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gcmVmLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoIXByZXZpb3VzU2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBwcmV2aW91c1NpYmxpbmcpIDwgMCkgeyBwcmV2ID0gcHJldmlvdXNTaWJsaW5nOyB9XG4gICAgICAgIGlmICghbmV4dFNpYmxpbmcgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChtdXQuYWRkZWROb2RlcywgbmV4dFNpYmxpbmcpIDwgMCkgeyBuZXh0ID0gbmV4dFNpYmxpbmc7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZyb21PZmZzZXQgPSBwcmV2ICYmIHByZXYucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0XG4gICAgICAgID8gZG9tSW5kZXgocHJldikgKyAxIDogMDtcbiAgICB2YXIgZnJvbSA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIGZyb21PZmZzZXQsIC0xKTtcbiAgICB2YXIgdG9PZmZzZXQgPSBuZXh0ICYmIG5leHQucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0XG4gICAgICAgID8gZG9tSW5kZXgobmV4dCkgOiBtdXQudGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIHZhciB0byA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIHRvT2Zmc2V0LCAxKTtcbiAgICByZXR1cm4ge2Zyb206IGZyb20sIHRvOiB0b31cbiAgfSBlbHNlIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIikge1xuICAgIHJldHVybiB7ZnJvbTogZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIsIHRvOiBkZXNjLnBvc0F0RW5kICsgZGVzYy5ib3JkZXJ9XG4gIH0gZWxzZSB7IC8vIFwiY2hhcmFjdGVyRGF0YVwiXG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IGRlc2MucG9zQXRTdGFydCxcbiAgICAgIHRvOiBkZXNjLnBvc0F0RW5kLFxuICAgICAgLy8gQW4gZXZlbnQgd2FzIGdlbmVyYXRlZCBmb3IgYSB0ZXh0IGNoYW5nZSB0aGF0IGRpZG4ndCBjaGFuZ2VcbiAgICAgIC8vIGFueSB0ZXh0LiBNYXJrIHRoZSBkb20gY2hhbmdlIHRvIGZhbGwgYmFjayB0byBhc3N1bWluZyB0aGVcbiAgICAgIC8vIHNlbGVjdGlvbiB3YXMgdHlwZWQgb3ZlciB3aXRoIGFuIGlkZW50aWNhbCB2YWx1ZSBpZiBpdCBjYW4ndFxuICAgICAgLy8gZmluZCBhbm90aGVyIGNoYW5nZS5cbiAgICAgIHR5cGVPdmVyOiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWVcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjc3NDaGVja2VkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNoZWNrQ1NTKHZpZXcpIHtcbiAgaWYgKGNzc0NoZWNrZWQpIHsgcmV0dXJuIH1cbiAgY3NzQ2hlY2tlZCA9IHRydWU7XG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS53aGl0ZVNwYWNlID09IFwibm9ybWFsXCIpXG4gICAgeyBjb25zb2xlW1wid2FyblwiXShcIlByb3NlTWlycm9yIGV4cGVjdHMgdGhlIENTUyB3aGl0ZS1zcGFjZSBwcm9wZXJ0eSB0byBiZSBzZXQsIHByZWZlcmFibHkgdG8gJ3ByZS13cmFwJy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gbG9hZCBzdHlsZS9wcm9zZW1pcnJvci5jc3MgZnJvbSB0aGUgcHJvc2VtaXJyb3ItdmlldyBwYWNrYWdlLlwiKTsgfVxufVxuXG4vLyBBIGNvbGxlY3Rpb24gb2YgRE9NIGV2ZW50cyB0aGF0IG9jY3VyIHdpdGhpbiB0aGUgZWRpdG9yLCBhbmQgY2FsbGJhY2sgZnVuY3Rpb25zXG4vLyB0byBpbnZva2Ugd2hlbiB0aGUgZXZlbnQgZmlyZXMuXG52YXIgaGFuZGxlcnMgPSB7fSwgZWRpdEhhbmRsZXJzID0ge307XG5cbmZ1bmN0aW9uIGluaXRJbnB1dCh2aWV3KSB7XG4gIHZpZXcuc2hpZnRLZXkgPSBmYWxzZTtcbiAgdmlldy5tb3VzZURvd24gPSBudWxsO1xuICB2aWV3Lmxhc3RLZXlDb2RlID0gbnVsbDtcbiAgdmlldy5sYXN0S2V5Q29kZVRpbWUgPSAwO1xuICB2aWV3Lmxhc3RDbGljayA9IHt0aW1lOiAwLCB4OiAwLCB5OiAwLCB0eXBlOiBcIlwifTtcbiAgdmlldy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgdmlldy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG5cbiAgdmlldy5sYXN0SU9TRW50ZXIgPSAwO1xuICB2aWV3Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IG51bGw7XG4gIHZpZXcubGFzdEFuZHJvaWREZWxldGUgPSAwO1xuXG4gIHZpZXcuY29tcG9zaW5nID0gZmFsc2U7XG4gIHZpZXcuY29tcG9zaW5nVGltZW91dCA9IG51bGw7XG4gIHZpZXcuY29tcG9zaXRpb25Ob2RlcyA9IFtdO1xuICB2aWV3LmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG5cbiAgdmlldy5kb21PYnNlcnZlciA9IG5ldyBET01PYnNlcnZlcih2aWV3LCBmdW5jdGlvbiAoZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZCkgeyByZXR1cm4gcmVhZERPTUNoYW5nZSh2aWV3LCBmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTsgfSk7XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgLy8gVXNlZCBieSBoYWNrcyBsaWtlIHRoZSBiZWZvcmVpbnB1dCBoYW5kbGVyIHRvIGNoZWNrIHdoZXRoZXIgYW55dGhpbmcgaGFwcGVuZWQgaW4gdGhlIERPTVxuICB2aWV3LmRvbUNoYW5nZUNvdW50ID0gMDtcblxuICB2aWV3LmV2ZW50SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudF07XG4gICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdmlldy5ldmVudEhhbmRsZXJzW2V2ZW50XSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50QmVsb25nc1RvVmlldyh2aWV3LCBldmVudCkgJiYgIXJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpICYmXG4gICAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgIShldmVudC50eXBlIGluIGVkaXRIYW5kbGVycykpKVxuICAgICAgICB7IGhhbmRsZXIodmlldywgZXZlbnQpOyB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZXZlbnQgaW4gaGFuZGxlcnMpIGxvb3AoIGV2ZW50ICk7XG4gIC8vIE9uIFNhZmFyaSwgZm9yIHJlYXNvbnMgYmV5b25kIG15IHVuZGVyc3RhbmRpbmcsIGFkZGluZyBhbiBpbnB1dFxuICAvLyBldmVudCBoYW5kbGVyIG1ha2VzIGFuIGlzc3VlIHdoZXJlIHRoZSBjb21wb3NpdGlvbiB2YW5pc2hlcyB3aGVuXG4gIC8vIHlvdSBwcmVzcyBlbnRlciBnbyBhd2F5LlxuICBpZiAocmVzdWx0LnNhZmFyaSkgeyB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSk7IH1cblxuICBlbnN1cmVMaXN0ZW5lcnModmlldyk7XG59XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBvcmlnaW4pIHtcbiAgdmlldy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICB2aWV3Lmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbn1cblxuZnVuY3Rpb24gZGVzdHJveUlucHV0KHZpZXcpIHtcbiAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gIGZvciAodmFyIHR5cGUgaW4gdmlldy5ldmVudEhhbmRsZXJzKVxuICAgIHsgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmV2ZW50SGFuZGxlcnNbdHlwZV0pOyB9XG4gIGNsZWFyVGltZW91dCh2aWV3LmNvbXBvc2luZ1RpbWVvdXQpO1xuICBjbGVhclRpbWVvdXQodmlldy5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQpO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5lcnModmlldykge1xuICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGZ1bmN0aW9uIChjdXJyZW50SGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciB0eXBlIGluIGN1cnJlbnRIYW5kbGVycykgeyBpZiAoIXZpZXcuZXZlbnRIYW5kbGVyc1t0eXBlXSlcbiAgICAgIHsgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmV2ZW50SGFuZGxlcnNbdHlwZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpOyB9KTsgfSB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSB7XG4gIHJldHVybiB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGZ1bmN0aW9uIChoYW5kbGVycykge1xuICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnQudHlwZV07XG4gICAgcmV0dXJuIGhhbmRsZXIgPyBoYW5kbGVyKHZpZXcsIGV2ZW50KSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkIDogZmFsc2VcbiAgfSlcbn1cblxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSB7XG4gIGlmICghZXZlbnQuYnViYmxlcykgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybiBmYWxzZSB9XG4gIGZvciAodmFyIG5vZGUgPSBldmVudC50YXJnZXQ7IG5vZGUgIT0gdmlldy5kb207IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgeyBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fFxuICAgICAgICAobm9kZS5wbVZpZXdEZXNjICYmIG5vZGUucG1WaWV3RGVzYy5zdG9wRXZlbnQoZXZlbnQpKSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH0gfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHZpZXcsIGV2ZW50KSB7XG4gIGlmICghcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiYgaGFuZGxlcnNbZXZlbnQudHlwZV0gJiZcbiAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICB7IGhhbmRsZXJzW2V2ZW50LnR5cGVdKHZpZXcsIGV2ZW50KTsgfVxufVxuXG5lZGl0SGFuZGxlcnMua2V5ZG93biA9IGZ1bmN0aW9uICh2aWV3LCBldmVudCkge1xuICB2aWV3LnNoaWZ0S2V5ID0gZXZlbnQua2V5Q29kZSA9PSAxNiB8fCBldmVudC5zaGlmdEtleTtcbiAgaWYgKGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpKSB7IHJldHVybiB9XG4gIGlmIChldmVudC5rZXlDb2RlICE9IDIyOSkgeyB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTsgfVxuICB2aWV3Lmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgdmlldy5sYXN0S2V5Q29kZVRpbWUgPSBEYXRlLm5vdygpO1xuICAvLyBPbiBpT1MsIGlmIHdlIHByZXZlbnREZWZhdWx0IGVudGVyIGtleSBwcmVzc2VzLCB0aGUgdmlydHVhbFxuICAvLyBrZXlib2FyZCBnZXRzIGNvbmZ1c2VkLiBTbyB0aGUgaGFjayBoZXJlIGlzIHRvIHNldCBhIGZsYWcgdGhhdFxuICAvLyBtYWtlcyB0aGUgRE9NIGNoYW5nZSBjb2RlIHJlY29nbml6ZSB0aGF0IHdoYXQganVzdCBoYXBwZW5zIHNob3VsZFxuICAvLyBiZSByZXBsYWNlZCBieSB3aGF0ZXZlciB0aGUgRW50ZXIga2V5IGhhbmRsZXJzIGRvLlxuICBpZiAocmVzdWx0LmlvcyAmJiBldmVudC5rZXlDb2RlID09IDEzICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3Lmxhc3RJT1NFbnRlciA9IG5vdztcbiAgICB2aWV3Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHZpZXcubGFzdElPU0VudGVyID09IG5vdykge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSk7IH0pO1xuICAgICAgICB2aWV3Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICB9XG4gICAgfSwgMjAwKTtcbiAgfSBlbHNlIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBldmVudCk7IH0pIHx8IGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwia2V5XCIpO1xuICB9XG59O1xuXG5lZGl0SGFuZGxlcnMua2V5dXAgPSBmdW5jdGlvbiAodmlldywgZSkge1xuICBpZiAoZS5rZXlDb2RlID09IDE2KSB7IHZpZXcuc2hpZnRLZXkgPSBmYWxzZTsgfVxufTtcblxuZWRpdEhhbmRsZXJzLmtleXByZXNzID0gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSB8fCAhZXZlbnQuY2hhckNvZGUgfHxcbiAgICAgIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSB8fCByZXN1bHQubWFjICYmIGV2ZW50Lm1ldGFLZXkpIHsgcmV0dXJuIH1cblxuICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleVByZXNzXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGV2ZW50KTsgfSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICBpZiAoIShzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB8fCAhc2VsLiRmcm9tLnNhbWVQYXJlbnQoc2VsLiR0bykpIHtcbiAgICB2YXIgdGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgIGlmICghdmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBzZWwuJGZyb20ucG9zLCBzZWwuJHRvLnBvcywgdGV4dCk7IH0pKVxuICAgICAgeyB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0KS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV2ZW50Q29vcmRzKGV2ZW50KSB7IHJldHVybiB7bGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZfSB9XG5cbmZ1bmN0aW9uIGlzTmVhcihldmVudCwgY2xpY2spIHtcbiAgdmFyIGR4ID0gY2xpY2sueCAtIGV2ZW50LmNsaWVudFgsIGR5ID0gY2xpY2sueSAtIGV2ZW50LmNsaWVudFk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8IDEwMFxufVxuXG5mdW5jdGlvbiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIHByb3BOYW1lLCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgaWYgKGluc2lkZSA9PSAtMSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgaWYgKHZpZXcuc29tZVByb3AocHJvcE5hbWUsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBpID4gJHBvcy5kZXB0aCA/IGYodmlldywgcG9zLCAkcG9zLm5vZGVBZnRlciwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZih2aWV3LCBwb3MsICRwb3Mubm9kZShpKSwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCBmYWxzZSk7IH0pKVxuICAgICAgeyByZXR1cm4geyB2OiB0cnVlIH0gfVxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgIHZhciByZXR1cm5lZCA9IGxvb3AoIGkgKTtcblxuICAgIGlmICggcmV0dXJuZWQgKSByZXR1cm4gcmV0dXJuZWQudjtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKHZpZXcsIHNlbGVjdGlvbiwgb3JpZ2luKSB7XG4gIGlmICghdmlldy5mb2N1c2VkKSB7IHZpZXcuZm9jdXMoKTsgfVxuICB2YXIgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICBpZiAob3JpZ2luID09IFwicG9pbnRlclwiKSB7IHRyLnNldE1ldGEoXCJwb2ludGVyXCIsIHRydWUpOyB9XG4gIHZpZXcuZGlzcGF0Y2godHIpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpIHtcbiAgaWYgKGluc2lkZSA9PSAtMSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKSwgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICBpZiAobm9kZSAmJiBub2RlLmlzQXRvbSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKSwgXCJwb2ludGVyXCIpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkge1xuICBpZiAoaW5zaWRlID09IC0xKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0ZWROb2RlLCBzZWxlY3RBdDtcbiAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHsgc2VsZWN0ZWROb2RlID0gc2VsLm5vZGU7IH1cblxuICB2YXIgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgZm9yICh2YXIgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBzZWwuJGZyb20uZGVwdGggPiAwICYmXG4gICAgICAgICAgaSA+PSBzZWwuJGZyb20uZGVwdGggJiYgJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoICsgMSkgPT0gc2VsLiRmcm9tLnBvcylcbiAgICAgICAgeyBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKHNlbC4kZnJvbS5kZXB0aCk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKGkpOyB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxlY3RBdCAhPSBudWxsKSB7XG4gICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBzZWxlY3RBdCksIFwicG9pbnRlclwiKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCwgc2VsZWN0Tm9kZSkge1xuICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVDbGlja1wiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBwb3MsIGV2ZW50KTsgfSkgfHxcbiAgICAoc2VsZWN0Tm9kZSA/IHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkgOiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpKVxufVxuXG5mdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVEb3VibGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRG91YmxlQ2xpY2tcIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywgcG9zLCBldmVudCk7IH0pXG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRyaXBsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZVRyaXBsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVUcmlwbGVDbGlja1wiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBwb3MsIGV2ZW50KTsgfSkgfHxcbiAgICBkZWZhdWx0VHJpcGxlQ2xpY2sodmlldywgaW5zaWRlLCBldmVudClcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmJ1dHRvbiAhPSAwKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBkb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgaWYgKGluc2lkZSA9PSAtMSkge1xuICAgIGlmIChkb2MuaW5saW5lQ29udGVudCkge1xuICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgMCwgZG9jLmNvbnRlbnQuc2l6ZSksIFwicG9pbnRlclwiKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShpbnNpZGUpO1xuICBmb3IgKHZhciBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgbm9kZSA9IGkgPiAkcG9zLmRlcHRoID8gJHBvcy5ub2RlQWZ0ZXIgOiAkcG9zLm5vZGUoaSk7XG4gICAgdmFyIG5vZGVQb3MgPSAkcG9zLmJlZm9yZShpKTtcbiAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50KVxuICAgICAgeyB1cGRhdGVTZWxlY3Rpb24odmlldywgVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBub2RlUG9zICsgMSwgbm9kZVBvcyArIDEgKyBub2RlLmNvbnRlbnQuc2l6ZSksIFwicG9pbnRlclwiKTsgfVxuICAgIGVsc2UgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgeyB1cGRhdGVTZWxlY3Rpb24odmlldywgTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBub2RlUG9zKSwgXCJwb2ludGVyXCIpOyB9XG4gICAgZWxzZVxuICAgICAgeyBjb250aW51ZSB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZURPTUZsdXNoKHZpZXcpIHtcbiAgcmV0dXJuIGVuZENvbXBvc2l0aW9uKHZpZXcpXG59XG5cbnZhciBzZWxlY3ROb2RlTW9kaWZpZXIgPSByZXN1bHQubWFjID8gXCJtZXRhS2V5XCIgOiBcImN0cmxLZXlcIjtcblxuaGFuZGxlcnMubW91c2Vkb3duID0gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gIHZpZXcuc2hpZnRLZXkgPSBldmVudC5zaGlmdEtleTtcbiAgdmFyIGZsdXNoZWQgPSBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICB2YXIgbm93ID0gRGF0ZS5ub3coKSwgdHlwZSA9IFwic2luZ2xlQ2xpY2tcIjtcbiAgaWYgKG5vdyAtIHZpZXcubGFzdENsaWNrLnRpbWUgPCA1MDAgJiYgaXNOZWFyKGV2ZW50LCB2aWV3Lmxhc3RDbGljaykgJiYgIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl0pIHtcbiAgICBpZiAodmlldy5sYXN0Q2xpY2sudHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpIHsgdHlwZSA9IFwiZG91YmxlQ2xpY2tcIjsgfVxuICAgIGVsc2UgaWYgKHZpZXcubGFzdENsaWNrLnR5cGUgPT0gXCJkb3VibGVDbGlja1wiKSB7IHR5cGUgPSBcInRyaXBsZUNsaWNrXCI7IH1cbiAgfVxuICB2aWV3Lmxhc3RDbGljayA9IHt0aW1lOiBub3csIHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHR5cGU6IHR5cGV9O1xuXG4gIHZhciBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gIGlmICghcG9zKSB7IHJldHVybiB9XG5cbiAgaWYgKHR5cGUgPT0gXCJzaW5nbGVDbGlja1wiKSB7XG4gICAgaWYgKHZpZXcubW91c2VEb3duKSB7IHZpZXcubW91c2VEb3duLmRvbmUoKTsgfVxuICAgIHZpZXcubW91c2VEb3duID0gbmV3IE1vdXNlRG93bih2aWV3LCBwb3MsIGV2ZW50LCBmbHVzaGVkKTtcbiAgfSBlbHNlIGlmICgodHlwZSA9PSBcImRvdWJsZUNsaWNrXCIgPyBoYW5kbGVEb3VibGVDbGljayA6IGhhbmRsZVRyaXBsZUNsaWNrKSh2aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IGVsc2Uge1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gIH1cbn07XG5cbnZhciBNb3VzZURvd24gPSBmdW5jdGlvbiBNb3VzZURvd24odmlldywgcG9zLCBldmVudCwgZmx1c2hlZCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLnZpZXcgPSB2aWV3O1xuICB0aGlzLnN0YXJ0RG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gIHRoaXMucG9zID0gcG9zO1xuICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gIHRoaXMuZmx1c2hlZCA9IGZsdXNoZWQ7XG4gIHRoaXMuc2VsZWN0Tm9kZSA9IGV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl07XG4gIHRoaXMuYWxsb3dEZWZhdWx0ID0gZXZlbnQuc2hpZnRLZXk7XG4gIHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMgPSBmYWxzZTtcblxuICB2YXIgdGFyZ2V0Tm9kZSwgdGFyZ2V0UG9zO1xuICBpZiAocG9zLmluc2lkZSA+IC0xKSB7XG4gICAgdGFyZ2V0Tm9kZSA9IHZpZXcuc3RhdGUuZG9jLm5vZGVBdChwb3MuaW5zaWRlKTtcbiAgICB0YXJnZXRQb3MgPSBwb3MuaW5zaWRlO1xuICB9IGVsc2Uge1xuICAgIHZhciAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKTtcbiAgICB0YXJnZXROb2RlID0gJHBvcy5wYXJlbnQ7XG4gICAgdGFyZ2V0UG9zID0gJHBvcy5kZXB0aCA/ICRwb3MuYmVmb3JlKCkgOiAwO1xuICB9XG5cbiAgdGhpcy5taWdodERyYWcgPSBudWxsO1xuXG4gIHZhciB0YXJnZXQgPSBmbHVzaGVkID8gbnVsbCA6IGV2ZW50LnRhcmdldDtcbiAgdmFyIHRhcmdldERlc2MgPSB0YXJnZXQgPyB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2ModGFyZ2V0LCB0cnVlKSA6IG51bGw7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0RGVzYyA/IHRhcmdldERlc2MuZG9tIDogbnVsbDtcblxuICB2YXIgcmVmID0gdmlldy5zdGF0ZTtcbiAgdmFyIHNlbGVjdGlvbiA9IHJlZi5zZWxlY3Rpb247XG4gIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIHRhcmdldE5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlIHx8XG4gICAgICBzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5mcm9tIDw9IHRhcmdldFBvcyAmJiBzZWxlY3Rpb24udG8gPiB0YXJnZXRQb3MpXG4gICAgeyB0aGlzLm1pZ2h0RHJhZyA9IHtub2RlOiB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIHBvczogdGFyZ2V0UG9zLFxuICAgICAgICAgICAgICAgICAgICAgIGFkZEF0dHI6IHRoaXMudGFyZ2V0ICYmICF0aGlzLnRhcmdldC5kcmFnZ2FibGUsXG4gICAgICAgICAgICAgICAgICAgICAgc2V0VW5lZGl0YWJsZTogdGhpcy50YXJnZXQgJiYgcmVzdWx0LmdlY2tvICYmICF0aGlzLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIil9OyB9XG5cbiAgaWYgKHRoaXMudGFyZ2V0ICYmIHRoaXMubWlnaHREcmFnICYmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyIHx8IHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpKSB7XG4gICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cikgeyB0aGlzLnRhcmdldC5kcmFnZ2FibGUgPSB0cnVlOyB9XG4gICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyQxLnZpZXcubW91c2VEb3duID09IHRoaXMkMSkgeyB0aGlzJDEudGFyZ2V0LnNldEF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiLCBcImZhbHNlXCIpOyB9XG4gICAgICB9LCAyMCk7IH1cbiAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgfVxuXG4gIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcykpO1xuICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcblxuTW91c2VEb3duLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCk7XG4gIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgaWYgKHRoaXMubWlnaHREcmFnICYmIHRoaXMudGFyZ2V0KSB7XG4gICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cikgeyB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7IH1cbiAgICBpZiAodGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSkgeyB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIik7IH1cbiAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgfVxuICBpZiAodGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYykgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGVjdGlvblRvRE9NKHRoaXMkMS52aWV3KTsgfSk7IH1cbiAgdGhpcy52aWV3Lm1vdXNlRG93biA9IG51bGw7XG59O1xuXG5Nb3VzZURvd24ucHJvdG90eXBlLnVwID0gZnVuY3Rpb24gdXAgKGV2ZW50KSB7XG4gIHRoaXMuZG9uZSgpO1xuXG4gIGlmICghdGhpcy52aWV3LmRvbS5jb250YWlucyhldmVudC50YXJnZXQubm9kZVR5cGUgPT0gMyA/IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlIDogZXZlbnQudGFyZ2V0KSlcbiAgICB7IHJldHVybiB9XG5cbiAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICBpZiAodGhpcy52aWV3LnN0YXRlLmRvYyAhPSB0aGlzLnN0YXJ0RG9jKSB7IHBvcyA9IHRoaXMudmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpOyB9XG5cbiAgaWYgKHRoaXMuYWxsb3dEZWZhdWx0IHx8ICFwb3MpIHtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlU2luZ2xlQ2xpY2sodGhpcy52aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCwgdGhpcy5zZWxlY3ROb2RlKSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgICAodGhpcy5mbHVzaGVkIHx8XG4gICAgICAgICAgICAgIC8vIFNhZmFyaSBpZ25vcmVzIGNsaWNrcyBvbiBkcmFnZ2FibGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgKHJlc3VsdC5zYWZhcmkgJiYgdGhpcy5taWdodERyYWcgJiYgIXRoaXMubWlnaHREcmFnLm5vZGUuaXNBdG9tKSB8fFxuICAgICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMgdHJlYXQgYSBub2RlIHNlbGVjdGlvbiBhcyBhXG4gICAgICAgICAgICAgIC8vIGN1cnNvciwgYnV0IHN0aWxsIHJlcG9ydCB0aGF0IHRoZSBub2RlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgIC8vIHdoZW4gYXNrZWQgdGhyb3VnaCBnZXRTZWxlY3Rpb24uIFlvdSdsbCB0aGVuIGdldCBhXG4gICAgICAgICAgICAgIC8vIHNpdHVhdGlvbiB3aGVyZSBjbGlja2luZyBhdCB0aGUgcG9pbnQgd2hlcmUgdGhhdFxuICAgICAgICAgICAgICAvLyAoaGlkZGVuKSBjdXJzb3IgaXMgZG9lc24ndCBjaGFuZ2UgdGhlIHNlbGVjdGlvbiwgYW5kXG4gICAgICAgICAgICAgIC8vIHRodXMgZG9lc24ndCBnZXQgYSByZWFjdGlvbiBmcm9tIFByb3NlTWlycm9yLiBUaGlzXG4gICAgICAgICAgICAgIC8vIHdvcmtzIGFyb3VuZCB0aGF0LlxuICAgICAgICAgICAgICAocmVzdWx0LmNocm9tZSAmJiAhKHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSAmJlxuICAgICAgICAgICAgICAgTWF0aC5taW4oTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSksXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhwb3MucG9zIC0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi50bykpIDw9IDIpKSkge1xuICAgIHVwZGF0ZVNlbGVjdGlvbih0aGlzLnZpZXcsIFNlbGVjdGlvbi5uZWFyKHRoaXMudmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKSksIFwicG9pbnRlclwiKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IGVsc2Uge1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgfVxufTtcblxuTW91c2VEb3duLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gbW92ZSAoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLmFsbG93RGVmYXVsdCAmJiAoTWF0aC5hYnModGhpcy5ldmVudC54IC0gZXZlbnQuY2xpZW50WCkgPiA0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuZXZlbnQueSAtIGV2ZW50LmNsaWVudFkpID4gNCkpXG4gICAgeyB0aGlzLmFsbG93RGVmYXVsdCA9IHRydWU7IH1cbiAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKSB7IHRoaXMuZG9uZSgpOyB9XG59O1xuXG5oYW5kbGVycy50b3VjaGRvd24gPSBmdW5jdGlvbiAodmlldykge1xuICBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcblxuaGFuZGxlcnMuY29udGV4dG1lbnUgPSBmdW5jdGlvbiAodmlldykgeyByZXR1cm4gZm9yY2VET01GbHVzaCh2aWV3KTsgfTtcblxuZnVuY3Rpb24gaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkge1xuICBpZiAodmlldy5jb21wb3NpbmcpIHsgcmV0dXJuIHRydWUgfVxuICAvLyBTZWUgaHR0cHM6Ly93d3cuc3R1bS5kZS8yMDE2LzA2LzI0L2hhbmRsaW5nLWltZS1ldmVudHMtaW4tamF2YXNjcmlwdC8uXG4gIC8vIE9uIEphcGFuZXNlIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvIGNvbmZpcm0gY2hhcmFjdGVyXG4gIC8vIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmVcbiAgLy8gZW1pdHRlZC4gVGhlIGtleWRvd24gZXZlbnQgdHJpZ2dlcnMgbmV3bGluZSBpbnNlcnRpb24sIHdoaWNoIHdlIGRvbid0IHdhbnQuXG4gIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgdHJ1ZSBpZiB0aGUga2V5ZG93biBldmVudCBzaG91bGQgYmUgaWdub3JlZC5cbiAgLy8gV2Ugb25seSBpZ25vcmUgaXQgb25jZSwgYXMgcHJlc3NpbmcgRW50ZXIgYSBzZWNvbmQgdGltZSAqc2hvdWxkKiBpbnNlcnQgYSBuZXdsaW5lLlxuICAvLyBGdXJ0aGVybW9yZSwgdGhlIGtleWRvd24gZXZlbnQgdGltZXN0YW1wIG11c3QgYmUgY2xvc2UgdG8gdGhlIGNvbXBvc2l0aW9uRW5kZWRBdCB0aW1lc3RhbXAuXG4gIC8vIFRoaXMgZ3VhcmRzIGFnYWluc3QgdGhlIGNhc2Ugd2hlcmUgY29tcG9zaXRpb25lbmQgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgdGhlIGtleWJvYXJkXG4gIC8vIChlLmcuIGNoYXJhY3RlciBjb25maXJtYXRpb24gbWF5IGJlIGRvbmUgd2l0aCB0aGUgbW91c2UpLCBhbmQga2V5ZG93biBpcyB0cmlnZ2VyZWRcbiAgLy8gYWZ0ZXJ3YXJkcy0gd2Ugd291bGRuJ3Qgd2FudCB0byBpZ25vcmUgdGhlIGtleWRvd24gZXZlbnQgaW4gdGhpcyBjYXNlLlxuICBpZiAocmVzdWx0LnNhZmFyaSAmJiBNYXRoLmFicyhldmVudC50aW1lU3RhbXAgLSB2aWV3LmNvbXBvc2l0aW9uRW5kZWRBdCkgPCA1MDApIHtcbiAgICB2aWV3LmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gRHJvcCBhY3RpdmUgY29tcG9zaXRpb24gYWZ0ZXIgNSBzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gQW5kcm9pZFxudmFyIHRpbWVvdXRDb21wb3NpdGlvbiA9IHJlc3VsdC5hbmRyb2lkID8gNTAwMCA6IC0xO1xuXG5lZGl0SGFuZGxlcnMuY29tcG9zaXRpb25zdGFydCA9IGVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnVwZGF0ZSA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gIGlmICghdmlldy5jb21wb3NpbmcpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCk7XG4gICAgdmFyIHN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICB2YXIgJHBvcyA9IHN0YXRlLnNlbGVjdGlvbi4kZnJvbTtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmXG4gICAgICAgIChzdGF0ZS5zdG9yZWRNYXJrcyB8fFxuICAgICAgICAgKCEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5wYXJlbnRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLnNvbWUoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2U7IH0pKSkpIHtcbiAgICAgIC8vIE5lZWQgdG8gd3JhcCB0aGUgY3Vyc29yIGluIG1hcmsgbm9kZXMgZGlmZmVyZW50IGZyb20gdGhlIG9uZXMgaW4gdGhlIERPTSBjb250ZXh0XG4gICAgICB2aWV3Lm1hcmtDdXJzb3IgPSB2aWV3LnN0YXRlLnN0b3JlZE1hcmtzIHx8ICRwb3MubWFya3MoKTtcbiAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsIHRydWUpO1xuICAgICAgdmlldy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kQ29tcG9zaXRpb24odmlldyk7XG4gICAgICAvLyBJbiBmaXJlZm94LCBpZiB0aGUgY3Vyc29yIGlzIGFmdGVyIGJ1dCBvdXRzaWRlIGEgbWFya2VkIG5vZGUsXG4gICAgICAvLyB0aGUgaW5zZXJ0ZWQgdGV4dCB3b24ndCBpbmhlcml0IHRoZSBtYXJrcy4gU28gdGhpcyBtb3ZlcyBpdFxuICAgICAgLy8gaW5zaWRlIGlmIG5lY2Vzc2FyeS5cbiAgICAgIGlmIChyZXN1bHQuZ2Vja28gJiYgc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICB2YXIgc2VsID0gdmlldy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBmb3IgKHZhciBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0OyBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgIT0gMDspIHtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gb2Zmc2V0IDwgMCA/IG5vZGUubGFzdENoaWxkIDogbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgIGlmICghYmVmb3JlKSB7IGJyZWFrIH1cbiAgICAgICAgICBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgIHNlbC5jb2xsYXBzZShiZWZvcmUsIGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmlldy5jb21wb3NpbmcgPSB0cnVlO1xuICB9XG4gIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCB0aW1lb3V0Q29tcG9zaXRpb24pO1xufTtcblxuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgIHZpZXcuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdmlldy5jb21wb3NpdGlvbkVuZGVkQXQgPSBldmVudC50aW1lU3RhbXA7XG4gICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIDIwKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIGRlbGF5KSB7XG4gIGNsZWFyVGltZW91dCh2aWV3LmNvbXBvc2luZ1RpbWVvdXQpO1xuICBpZiAoZGVsYXkgPiAtMSkgeyB2aWV3LmNvbXBvc2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuZENvbXBvc2l0aW9uKHZpZXcpOyB9LCBkZWxheSk7IH1cbn1cblxuZnVuY3Rpb24gY2xlYXJDb21wb3NpdGlvbih2aWV3KSB7XG4gIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgIHZpZXcuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdmlldy5jb21wb3NpdGlvbkVuZGVkQXQgPSB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKTtcbiAgfVxuICB3aGlsZSAodmlldy5jb21wb3NpdGlvbk5vZGVzLmxlbmd0aCA+IDApIHsgdmlldy5jb21wb3NpdGlvbk5vZGVzLnBvcCgpLm1hcmtQYXJlbnRzRGlydHkoKTsgfVxufVxuXG5mdW5jdGlvbiB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKSB7XG4gIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gIGV2ZW50LmluaXRFdmVudChcImV2ZW50XCIsIHRydWUsIHRydWUpO1xuICByZXR1cm4gZXZlbnQudGltZVN0YW1wXG59XG5cbmZ1bmN0aW9uIGVuZENvbXBvc2l0aW9uKHZpZXcsIGZvcmNlVXBkYXRlKSB7XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICBjbGVhckNvbXBvc2l0aW9uKHZpZXcpO1xuICBpZiAoZm9yY2VVcGRhdGUgfHwgdmlldy5kb2NWaWV3LmRpcnR5KSB7XG4gICAgdmFyIHNlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldyk7XG4gICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkgeyB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCkpOyB9XG4gICAgZWxzZSB7IHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29weSh2aWV3LCBkb20pIHtcbiAgLy8gVGhlIGV4dHJhIHdyYXBwZXIgaXMgc29tZWhvdyBuZWNlc3Nhcnkgb24gSUUvRWRnZSB0byBwcmV2ZW50IHRoZVxuICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgaWYgKCF2aWV3LmRvbS5wYXJlbnROb2RlKSB7IHJldHVybiB9XG4gIHZhciB3cmFwID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICB3cmFwLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICB2YXIgc2VsID0gZ2V0U2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGRvbSk7XG4gIC8vIERvbmUgYmVjYXVzZSBJRSB3aWxsIGZpcmUgYSBzZWxlY3Rpb25jaGFuZ2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cbiAgLy8gdG8gaXRzIHN0YXJ0IHdoZW4gcmVtb3ZlQWxsUmFuZ2VzIGlzIGNhbGxlZCBhbmQgdGhlIGVkaXRvciBzdGlsbFxuICAvLyBoYXMgZm9jdXMgKHdoaWNoIHdpbGwgbWVzcyB1cCB0aGUgZWRpdG9yJ3Mgc2VsZWN0aW9uIHN0YXRlKS5cbiAgdmlldy5kb20uYmx1cigpO1xuICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICh3cmFwLnBhcmVudE5vZGUpIHsgd3JhcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHdyYXApOyB9XG4gICAgdmlldy5mb2N1cygpO1xuICB9LCA1MCk7XG59XG5cbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSeKAlGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbnZhciBicm9rZW5DbGlwYm9hcmRBUEkgPSAocmVzdWx0LmllICYmIHJlc3VsdC5pZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgICAocmVzdWx0LmlvcyAmJiByZXN1bHQud2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuXG5oYW5kbGVycy5jb3B5ID0gZWRpdEhhbmRsZXJzLmN1dCA9IGZ1bmN0aW9uICh2aWV3LCBlKSB7XG4gIHZhciBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgY3V0ID0gZS50eXBlID09IFwiY3V0XCI7XG4gIGlmIChzZWwuZW1wdHkpIHsgcmV0dXJuIH1cblxuICAvLyBJRSBhbmQgRWRnZSdzIGNsaXBib2FyZCBpbnRlcmZhY2UgaXMgY29tcGxldGVseSBicm9rZW5cbiAgdmFyIGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZS5jbGlwYm9hcmREYXRhO1xuICB2YXIgc2xpY2UgPSBzZWwuY29udGVudCgpO1xuICB2YXIgcmVmID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKTtcbiAgdmFyIGRvbSA9IHJlZi5kb207XG4gIHZhciB0ZXh0ID0gcmVmLnRleHQ7XG4gIGlmIChkYXRhKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgZGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgIGRhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgY2FwdHVyZUNvcHkodmlldywgZG9tKTtcbiAgfVxuICBpZiAoY3V0KSB7IHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiY3V0XCIpKTsgfVxufTtcblxuZnVuY3Rpb24gc2xpY2VTaW5nbGVOb2RlKHNsaWNlKSB7XG4gIHJldHVybiBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDEgPyBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3LCBlKSB7XG4gIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSkgeyByZXR1cm4gfVxuICB2YXIgcGxhaW5UZXh0ID0gdmlldy5zaGlmdEtleSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGU7XG4gIHZhciB0YXJnZXQgPSB2aWV3LmRvbS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGxhaW5UZXh0ID8gXCJ0ZXh0YXJlYVwiIDogXCJkaXZcIikpO1xuICBpZiAoIXBsYWluVGV4dCkgeyB0YXJnZXQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7IH1cbiAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICB0YXJnZXQuZm9jdXMoKTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdmlldy5mb2N1cygpO1xuICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZSkgeyB0YXJnZXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXQpOyB9XG4gICAgaWYgKHBsYWluVGV4dCkgeyBkb1Bhc3RlKHZpZXcsIHRhcmdldC52YWx1ZSwgbnVsbCwgZSk7IH1cbiAgICBlbHNlIHsgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudGV4dENvbnRlbnQsIHRhcmdldC5pbm5lckhUTUwsIGUpOyB9XG4gIH0sIDUwKTtcbn1cblxuZnVuY3Rpb24gZG9QYXN0ZSh2aWV3LCB0ZXh0LCBodG1sLCBlKSB7XG4gIHZhciBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCB2aWV3LnNoaWZ0S2V5LCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbSk7XG4gIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlUGFzdGVcIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywgZSwgc2xpY2UgfHwgU2xpY2UuZW1wdHkpOyB9KSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmICghc2xpY2UpIHsgcmV0dXJuIGZhbHNlIH1cblxuICB2YXIgc2luZ2xlTm9kZSA9IHNsaWNlU2luZ2xlTm9kZShzbGljZSk7XG4gIHZhciB0ciA9IHNpbmdsZU5vZGUgPyB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNpbmdsZU5vZGUsIHZpZXcuc2hpZnRLZXkpIDogdmlldy5zdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uKHNsaWNlKTtcbiAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJwYXN0ZVwiLCB0cnVlKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcInBhc3RlXCIpKTtcbiAgcmV0dXJuIHRydWVcbn1cblxuZWRpdEhhbmRsZXJzLnBhc3RlID0gZnVuY3Rpb24gKHZpZXcsIGUpIHtcbiAgdmFyIGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZS5jbGlwYm9hcmREYXRhO1xuICBpZiAoZGF0YSAmJiBkb1Bhc3RlKHZpZXcsIGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIiksIGRhdGEuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgZSkpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gIGVsc2UgeyBjYXB0dXJlUGFzdGUodmlldywgZSk7IH1cbn07XG5cbnZhciBEcmFnZ2luZyA9IGZ1bmN0aW9uIERyYWdnaW5nKHNsaWNlLCBtb3ZlKSB7XG4gIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgdGhpcy5tb3ZlID0gbW92ZTtcbn07XG5cbnZhciBkcmFnQ29weU1vZGlmaWVyID0gcmVzdWx0Lm1hYyA/IFwiYWx0S2V5XCIgOiBcImN0cmxLZXlcIjtcblxuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gZnVuY3Rpb24gKHZpZXcsIGUpIHtcbiAgdmFyIG1vdXNlRG93biA9IHZpZXcubW91c2VEb3duO1xuICBpZiAobW91c2VEb3duKSB7IG1vdXNlRG93bi5kb25lKCk7IH1cbiAgaWYgKCFlLmRhdGFUcmFuc2ZlcikgeyByZXR1cm4gfVxuXG4gIHZhciBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyIHBvcyA9IHNlbC5lbXB0eSA/IG51bGwgOiB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGUpKTtcbiAgaWYgKHBvcyAmJiBwb3MucG9zID49IHNlbC5mcm9tICYmIHBvcy5wb3MgPD0gKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gPyBzZWwudG8gLSAxOiBzZWwudG8pKSA7IGVsc2UgaWYgKG1vdXNlRG93biAmJiBtb3VzZURvd24ubWlnaHREcmFnKSB7XG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgbW91c2VEb3duLm1pZ2h0RHJhZy5wb3MpKSk7XG4gIH0gZWxzZSBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQubm9kZVR5cGUgPT0gMSkge1xuICAgIHZhciBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGUudGFyZ2V0LCB0cnVlKTtcbiAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSAmJiBkZXNjICE9IHZpZXcuZG9jVmlldylcbiAgICAgIHsgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgZGVzYy5wb3NCZWZvcmUpKSk7IH1cbiAgfVxuICB2YXIgc2xpY2UgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5jb250ZW50KCk7XG4gIHZhciByZWYgPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpO1xuICB2YXIgZG9tID0gcmVmLmRvbTtcbiAgdmFyIHRleHQgPSByZWYudGV4dDtcbiAgZS5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG4gIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoYnJva2VuQ2xpcGJvYXJkQVBJID8gXCJUZXh0XCIgOiBcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci9pc3N1ZXMvMTE1NlxuICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuICBpZiAoIWJyb2tlbkNsaXBib2FyZEFQSSkgeyBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTsgfVxuICB2aWV3LmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKHNsaWNlLCAhZVtkcmFnQ29weU1vZGlmaWVyXSk7XG59O1xuXG5oYW5kbGVycy5kcmFnZW5kID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgdmFyIGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICh2aWV3LmRyYWdnaW5nID09IGRyYWdnaW5nKSAgeyB2aWV3LmRyYWdnaW5nID0gbnVsbDsgfVxuICB9LCA1MCk7XG59O1xuXG5lZGl0SGFuZGxlcnMuZHJhZ292ZXIgPSBlZGl0SGFuZGxlcnMuZHJhZ2VudGVyID0gZnVuY3Rpb24gKF8sIGUpIHsgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTsgfTtcblxuZWRpdEhhbmRsZXJzLmRyb3AgPSBmdW5jdGlvbiAodmlldywgZSkge1xuICB2YXIgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcblxuICBpZiAoIWUuZGF0YVRyYW5zZmVyKSB7IHJldHVybiB9XG5cbiAgdmFyIGV2ZW50UG9zID0gdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhlKSk7XG4gIGlmICghZXZlbnRQb3MpIHsgcmV0dXJuIH1cbiAgdmFyICRtb3VzZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZXZlbnRQb3MucG9zKTtcbiAgaWYgKCEkbW91c2UpIHsgcmV0dXJuIH1cbiAgdmFyIHNsaWNlID0gZHJhZ2dpbmcgJiYgZHJhZ2dpbmcuc2xpY2U7XG4gIGlmIChzbGljZSkge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZnVuY3Rpb24gKGYpIHsgc2xpY2UgPSBmKHNsaWNlKTsgfSk7XG4gIH0gZWxzZSB7XG4gICAgc2xpY2UgPSBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShicm9rZW5DbGlwYm9hcmRBUEkgPyBcIlRleHRcIiA6IFwidGV4dC9wbGFpblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgZmFsc2UsICRtb3VzZSk7XG4gIH1cbiAgdmFyIG1vdmUgPSBkcmFnZ2luZyAmJiAhZVtkcmFnQ29weU1vZGlmaWVyXTtcbiAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVEcm9wXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGUsIHNsaWNlIHx8IFNsaWNlLmVtcHR5LCBtb3ZlKTsgfSkpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFzbGljZSkgeyByZXR1cm4gfVxuXG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgdmFyIGluc2VydFBvcyA9IHNsaWNlID8gZHJvcFBvaW50KHZpZXcuc3RhdGUuZG9jLCAkbW91c2UucG9zLCBzbGljZSkgOiAkbW91c2UucG9zO1xuICBpZiAoaW5zZXJ0UG9zID09IG51bGwpIHsgaW5zZXJ0UG9zID0gJG1vdXNlLnBvczsgfVxuXG4gIHZhciB0ciA9IHZpZXcuc3RhdGUudHI7XG4gIGlmIChtb3ZlKSB7IHRyLmRlbGV0ZVNlbGVjdGlvbigpOyB9XG5cbiAgdmFyIHBvcyA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gIHZhciBpc05vZGUgPSBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDE7XG4gIHZhciBiZWZvcmVJbnNlcnQgPSB0ci5kb2M7XG4gIGlmIChpc05vZGUpXG4gICAgeyB0ci5yZXBsYWNlUmFuZ2VXaXRoKHBvcywgcG9zLCBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpOyB9XG4gIGVsc2VcbiAgICB7IHRyLnJlcGxhY2VSYW5nZShwb3MsIHBvcywgc2xpY2UpOyB9XG4gIGlmICh0ci5kb2MuZXEoYmVmb3JlSW5zZXJ0KSkgeyByZXR1cm4gfVxuXG4gIHZhciAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKTtcbiAgaWYgKGlzTm9kZSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpICYmXG4gICAgICAkcG9zLm5vZGVBZnRlciAmJiAkcG9zLm5vZGVBZnRlci5zYW1lTWFya3VwKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICB0ci5zZXRTZWxlY3Rpb24obmV3IE5vZGVTZWxlY3Rpb24oJHBvcykpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbmQgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgIHRyLm1hcHBpbmcubWFwc1t0ci5tYXBwaW5nLm1hcHMubGVuZ3RoIC0gMV0uZm9yRWFjaChmdW5jdGlvbiAoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSB7IHJldHVybiBlbmQgPSBuZXdUbzsgfSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbkJldHdlZW4odmlldywgJHBvcywgdHIuZG9jLnJlc29sdmUoZW5kKSkpO1xuICB9XG4gIHZpZXcuZm9jdXMoKTtcbiAgdmlldy5kaXNwYXRjaCh0ci5zZXRNZXRhKFwidWlFdmVudFwiLCBcImRyb3BcIikpO1xufTtcblxuaGFuZGxlcnMuZm9jdXMgPSBmdW5jdGlvbiAodmlldykge1xuICBpZiAoIXZpZXcuZm9jdXNlZCkge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB2aWV3LmZvY3VzZWQgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3Lmhhc0ZvY3VzKCkgJiYgIXZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCkpKVxuICAgICAgICB7IHNlbGVjdGlvblRvRE9NKHZpZXcpOyB9XG4gICAgfSwgMjApO1xuICB9XG59O1xuXG5oYW5kbGVycy5ibHVyID0gZnVuY3Rpb24gKHZpZXcsIGUpIHtcbiAgaWYgKHZpZXcuZm9jdXNlZCkge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ICYmIHZpZXcuZG9tLmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpXG4gICAgICB7IHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5zZXQoe30pOyB9XG4gICAgdmlldy5mb2N1c2VkID0gZmFsc2U7XG4gIH1cbn07XG5cbmhhbmRsZXJzLmJlZm9yZWlucHV0ID0gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gIC8vIFdlIHNob3VsZCBwcm9iYWJseSBkbyBtb3JlIHdpdGggYmVmb3JlaW5wdXQgZXZlbnRzLCBidXQgc3VwcG9ydFxuICAvLyBpcyBzbyBzcG90dHkgdGhhdCBJJ20gc3RpbGwgd2FpdGluZyB0byBzZWUgd2hlcmUgdGhleSBhcmUgZ29pbmcuXG5cbiAgLy8gVmVyeSBzcGVjaWZpYyBoYWNrIHRvIGRlYWwgd2l0aCBiYWNrc3BhY2Ugc29tZXRpbWVzIGZhaWxpbmcgb25cbiAgLy8gQ2hyb21lIEFuZHJvaWQgd2hlbiBhZnRlciBhbiB1bmVkaXRhYmxlIG5vZGUuXG4gIGlmIChyZXN1bHQuY2hyb21lICYmIHJlc3VsdC5hbmRyb2lkICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiKSB7XG4gICAgdmFyIGRvbUNoYW5nZUNvdW50ID0gdmlldy5kb21DaGFuZ2VDb3VudDtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh2aWV3LmRvbUNoYW5nZUNvdW50ICE9IGRvbUNoYW5nZUNvdW50KSB7IHJldHVybiB9IC8vIEV2ZW50IGFscmVhZHkgaGFkIHNvbWUgZWZmZWN0XG4gICAgICAvLyBUaGlzIGJ1ZyB0ZW5kcyB0byBjbG9zZSB0aGUgdmlydHVhbCBrZXlib2FyZCwgc28gd2UgcmVmb2N1c1xuICAgICAgdmlldy5kb20uYmx1cigpO1xuICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKTsgfSkpIHsgcmV0dXJuIH1cbiAgICAgIHZhciByZWYgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgIHZhciAkY3Vyc29yID0gcmVmLiRjdXJzb3I7XG4gICAgICAvLyBDcnVkZSBhcHByb3hpbWF0aW9uIG9mIGJhY2tzcGFjZSBiZWhhdmlvciB3aGVuIG5vIGNvbW1hbmQgaGFuZGxlZCBpdFxuICAgICAgaWYgKCRjdXJzb3IgJiYgJGN1cnNvci5wb3MgPiAwKSB7IHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGUoJGN1cnNvci5wb3MgLSAxLCAkY3Vyc29yLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgICB9LCA1MCk7XG4gIH1cbn07XG5cbi8vIE1ha2Ugc3VyZSBhbGwgaGFuZGxlcnMgZ2V0IHJlZ2lzdGVyZWRcbmZvciAodmFyIHByb3AgaW4gZWRpdEhhbmRsZXJzKSB7IGhhbmRsZXJzW3Byb3BdID0gZWRpdEhhbmRsZXJzW3Byb3BdOyB9XG5cbmZ1bmN0aW9uIGNvbXBhcmVPYmpzKGEsIGIpIHtcbiAgaWYgKGEgPT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIGZvciAodmFyIHAgaW4gYSkgeyBpZiAoYVtwXSAhPT0gYltwXSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIGZvciAodmFyIHAkMSBpbiBiKSB7IGlmICghKHAkMSBpbiBhKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIHJldHVybiB0cnVlXG59XG5cbnZhciBXaWRnZXRUeXBlID0gZnVuY3Rpb24gV2lkZ2V0VHlwZSh0b0RPTSwgc3BlYykge1xuICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgdGhpcy5zaWRlID0gdGhpcy5zcGVjLnNpZGUgfHwgMDtcbiAgdGhpcy50b0RPTSA9IHRvRE9NO1xufTtcblxuV2lkZ2V0VHlwZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICB2YXIgcmVmID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNpZGUgPCAwID8gLTEgOiAxKTtcbiAgICB2YXIgcG9zID0gcmVmLnBvcztcbiAgICB2YXIgZGVsZXRlZCA9IHJlZi5kZWxldGVkO1xuICByZXR1cm4gZGVsZXRlZCA/IG51bGwgOiBuZXcgRGVjb3JhdGlvbihwb3MgLSBvZmZzZXQsIHBvcyAtIG9mZnNldCwgdGhpcylcbn07XG5cbldpZGdldFR5cGUucHJvdG90eXBlLnZhbGlkID0gZnVuY3Rpb24gdmFsaWQgKCkgeyByZXR1cm4gdHJ1ZSB9O1xuXG5XaWRnZXRUeXBlLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFR5cGUgJiZcbiAgICAgKHRoaXMuc3BlYy5rZXkgJiYgdGhpcy5zcGVjLmtleSA9PSBvdGhlci5zcGVjLmtleSB8fFxuICAgICAgdGhpcy50b0RPTSA9PSBvdGhlci50b0RPTSAmJiBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKSlcbn07XG5cbnZhciBJbmxpbmVUeXBlID0gZnVuY3Rpb24gSW5saW5lVHlwZShhdHRycywgc3BlYykge1xuICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgdGhpcy5hdHRycyA9IGF0dHJzO1xufTtcblxuSW5saW5lVHlwZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICB2YXIgZnJvbSA9IG1hcHBpbmcubWFwKHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZVN0YXJ0ID8gLTEgOiAxKSAtIG9mZnNldDtcbiAgdmFyIHRvID0gbWFwcGluZy5tYXAoc3Bhbi50byArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZUVuZCA/IDEgOiAtMSkgLSBvZmZzZXQ7XG4gIHJldHVybiBmcm9tID49IHRvID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzKVxufTtcblxuSW5saW5lVHlwZS5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiB2YWxpZCAoXywgc3BhbikgeyByZXR1cm4gc3Bhbi5mcm9tIDwgc3Bhbi50byB9O1xuXG5JbmxpbmVUeXBlLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgIChvdGhlciBpbnN0YW5jZW9mIElubGluZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpXG59O1xuXG5JbmxpbmVUeXBlLmlzID0gZnVuY3Rpb24gaXMgKHNwYW4pIHsgcmV0dXJuIHNwYW4udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUgfTtcblxudmFyIE5vZGVUeXBlID0gZnVuY3Rpb24gTm9kZVR5cGUoYXR0cnMsIHNwZWMpIHtcbiAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gIHRoaXMuYXR0cnMgPSBhdHRycztcbn07XG5cbk5vZGVUeXBlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gIHZhciBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCAxKTtcbiAgaWYgKGZyb20uZGVsZXRlZCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4udG8gKyBvbGRPZmZzZXQsIC0xKTtcbiAgaWYgKHRvLmRlbGV0ZWQgfHwgdG8ucG9zIDw9IGZyb20ucG9zKSB7IHJldHVybiBudWxsIH1cbiAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20ucG9zIC0gb2Zmc2V0LCB0by5wb3MgLSBvZmZzZXQsIHRoaXMpXG59O1xuXG5Ob2RlVHlwZS5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiB2YWxpZCAobm9kZSwgc3Bhbikge1xuICB2YXIgcmVmID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChzcGFuLmZyb20pO1xuICAgIHZhciBpbmRleCA9IHJlZi5pbmRleDtcbiAgICB2YXIgb2Zmc2V0ID0gcmVmLm9mZnNldDtcbiAgICB2YXIgY2hpbGQ7XG4gIHJldHVybiBvZmZzZXQgPT0gc3Bhbi5mcm9tICYmICEoY2hpbGQgPSBub2RlLmNoaWxkKGluZGV4KSkuaXNUZXh0ICYmIG9mZnNldCArIGNoaWxkLm5vZGVTaXplID09IHNwYW4udG9cbn07XG5cbk5vZGVUeXBlLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgIChvdGhlciBpbnN0YW5jZW9mIE5vZGVUeXBlICYmIGNvbXBhcmVPYmpzKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSAmJlxuICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKVxufTtcblxuLy8gOjotIERlY29yYXRpb24gb2JqZWN0cyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIHZpZXcgdGhyb3VnaCB0aGVcbi8vIFtgZGVjb3JhdGlvbnNgIHByb3BdKCN2aWV3LkVkaXRvclByb3BzLmRlY29yYXRpb25zKS4gVGhleSBjb21lIGluXG4vLyBzZXZlcmFsIHZhcmlhbnRz4oCUc2VlIHRoZSBzdGF0aWMgbWVtYmVycyBvZiB0aGlzIGNsYXNzIGZvciBkZXRhaWxzLlxudmFyIERlY29yYXRpb24gPSBmdW5jdGlvbiBEZWNvcmF0aW9uKGZyb20sIHRvLCB0eXBlKSB7XG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGRlY29yYXRpb24uXG4gIHRoaXMuZnJvbSA9IGZyb207XG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgZW5kIHBvc2l0aW9uLiBXaWxsIGJlIHRoZSBzYW1lIGFzIGBmcm9tYCBmb3IgW3dpZGdldFxuICAvLyBkZWNvcmF0aW9uc10oI3ZpZXcuRGVjb3JhdGlvbl53aWRnZXQpLlxuICB0aGlzLnRvID0gdG87XG4gIHRoaXMudHlwZSA9IHR5cGU7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEgPSB7IHNwZWM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5saW5lOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkRlY29yYXRpb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChmcm9tLCB0bykge1xuICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMudHlwZSlcbn07XG5cbkRlY29yYXRpb24ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyLCBvZmZzZXQpIHtcbiAgICBpZiAoIG9mZnNldCA9PT0gdm9pZCAwICkgb2Zmc2V0ID0gMDtcblxuICByZXR1cm4gdGhpcy50eXBlLmVxKG90aGVyLnR5cGUpICYmIHRoaXMuZnJvbSArIG9mZnNldCA9PSBvdGhlci5mcm9tICYmIHRoaXMudG8gKyBvZmZzZXQgPT0gb3RoZXIudG9cbn07XG5cbkRlY29yYXRpb24ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMudHlwZS5tYXAobWFwcGluZywgdGhpcywgb2Zmc2V0LCBvbGRPZmZzZXQpXG59O1xuXG4vLyA6OiAobnVtYmVyLCB1bmlvbjwodmlldzogRWRpdG9yVmlldywgZ2V0UG9zOiAoKSDihpIgbnVtYmVyKSDihpIgZG9tLk5vZGUsIGRvbS5Ob2RlPiwgP09iamVjdCkg4oaSIERlY29yYXRpb25cbi8vIENyZWF0ZXMgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggaXMgYSBET00gbm9kZSB0aGF0J3Mgc2hvd24gaW5cbi8vIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91XG4vLyBkZWxheSByZW5kZXJpbmcgdGhlIHdpZGdldCBieSBwYXNzaW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4vLyBjYWxsZWQgd2hlbiB0aGUgd2lkZ2V0IGlzIGFjdHVhbGx5IGRyYXduIGluIGEgdmlldywgYnV0IHlvdSBjYW5cbi8vIGFsc28gZGlyZWN0bHkgcGFzcyBhIERPTSBub2RlLiBgZ2V0UG9zYCBjYW4gYmUgdXNlZCB0byBmaW5kIHRoZVxuLy8gd2lkZ2V0J3MgY3VycmVudCBkb2N1bWVudCBwb3NpdGlvbi5cbi8vXG4vLyBzcGVjOjotIFRoZXNlIG9wdGlvbnMgYXJlIHN1cHBvcnRlZDpcbi8vXG4vLyAgIHNpZGU6OiA/bnVtYmVyXG4vLyAgIENvbnRyb2xzIHdoaWNoIHNpZGUgb2YgdGhlIGRvY3VtZW50IHBvc2l0aW9uIHRoaXMgd2lkZ2V0IGlzXG4vLyAgIGFzc29jaWF0ZWQgd2l0aC4gV2hlbiBuZWdhdGl2ZSwgaXQgaXMgZHJhd24gYmVmb3JlIGEgY3Vyc29yXG4vLyAgIGF0IGl0cyBwb3NpdGlvbiwgYW5kIGNvbnRlbnQgaW5zZXJ0ZWQgYXQgdGhhdCBwb3NpdGlvbiBlbmRzXG4vLyAgIHVwIGFmdGVyIHRoZSB3aWRnZXQuIFdoZW4gemVybyAodGhlIGRlZmF1bHQpIG9yIHBvc2l0aXZlLCB0aGVcbi8vICAgd2lkZ2V0IGlzIGRyYXduIGFmdGVyIHRoZSBjdXJzb3IgYW5kIGNvbnRlbnQgaW5zZXJ0ZWQgdGhlcmVcbi8vICAgZW5kcyB1cCBiZWZvcmUgdGhlIHdpZGdldC5cbi8vXG4vLyAgIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHdpZGdldHMgYXQgYSBnaXZlbiBwb3NpdGlvbiwgdGhlaXJcbi8vICAgYHNpZGVgIHZhbHVlcyBkZXRlcm1pbmUgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyLiBUaG9zZVxuLy8gICB3aXRoIGxvd2VyIHZhbHVlcyBhcHBlYXIgZmlyc3QuIFRoZSBvcmRlcmluZyBvZiB3aWRnZXRzIHdpdGhcbi8vICAgdGhlIHNhbWUgYHNpZGVgIHZhbHVlIGlzIHVuc3BlY2lmaWVkLlxuLy9cbi8vICAgV2hlbiBgbWFya3NgIGlzIG51bGwsIGBzaWRlYCBhbHNvIGRldGVybWluZXMgdGhlIG1hcmtzIHRoYXRcbi8vICAgdGhlIHdpZGdldCBpcyB3cmFwcGVkIGlu4oCUdGhvc2Ugb2YgdGhlIG5vZGUgYmVmb3JlIHdoZW5cbi8vICAgbmVnYXRpdmUsIHRob3NlIG9mIHRoZSBub2RlIGFmdGVyIHdoZW4gcG9zaXRpdmUuXG4vL1xuLy8gICBtYXJrczo6ID9bTWFya11cbi8vICAgVGhlIHByZWNpc2Ugc2V0IG9mIG1hcmtzIHRvIGRyYXcgYXJvdW5kIHRoZSB3aWRnZXQuXG4vL1xuLy8gICBzdG9wRXZlbnQ6OiA/KGV2ZW50OiBkb20uRXZlbnQpIOKGkiBib29sXG4vLyAgIENhbiBiZSB1c2VkIHRvIGNvbnRyb2wgd2hpY2ggRE9NIGV2ZW50cywgd2hlbiB0aGV5IGJ1YmJsZSBvdXRcbi8vICAgb2YgdGhpcyB3aWRnZXQsIHRoZSBlZGl0b3IgdmlldyBzaG91bGQgaWdub3JlLlxuLy9cbi8vICAgaWdub3JlU2VsZWN0aW9uOjogP2Jvb2xcbi8vICAgV2hlbiBzZXQgKGRlZmF1bHRzIHRvIGZhbHNlKSwgc2VsZWN0aW9uIGNoYW5nZXMgaW5zaWRlIHRoZVxuLy8gICB3aWRnZXQgYXJlIGlnbm9yZWQsIGFuZCBkb24ndCBjYXVzZSBQcm9zZU1pcnJvciB0byB0cnkgYW5kXG4vLyAgIHJlLXN5bmMgdGhlIHNlbGVjdGlvbiB3aXRoIGl0cyBzZWxlY3Rpb24gc3RhdGUuXG4vL1xuLy8gICBrZXk6OiA/c3RyaW5nXG4vLyAgIFdoZW4gY29tcGFyaW5nIGRlY29yYXRpb25zIG9mIHRoaXMgdHlwZSAoaW4gb3JkZXIgdG8gZGVjaWRlXG4vLyAgIHdoZXRoZXIgaXQgbmVlZHMgdG8gYmUgcmVkcmF3biksIFByb3NlTWlycm9yIHdpbGwgYnkgZGVmYXVsdFxuLy8gICBjb21wYXJlIHRoZSB3aWRnZXQgRE9NIG5vZGUgYnkgaWRlbnRpdHkuIElmIHlvdSBwYXNzIGEga2V5LFxuLy8gICB0aGF0IGtleSB3aWxsIGJlIGNvbXBhcmVkIGluc3RlYWQsIHdoaWNoIGNhbiBiZSB1c2VmdWwgd2hlblxuLy8gICB5b3UgZ2VuZXJhdGUgZGVjb3JhdGlvbnMgb24gdGhlIGZseSBhbmQgZG9uJ3Qgd2FudCB0byBzdG9yZVxuLy8gICBhbmQgcmV1c2UgRE9NIG5vZGVzLiBNYWtlIHN1cmUgdGhhdCBhbnkgd2lkZ2V0cyB3aXRoIHRoZSBzYW1lXG4vLyAgIGtleSBhcmUgaW50ZXJjaGFuZ2VhYmxl4oCUaWYgd2lkZ2V0cyBkaWZmZXIgaW4sIGZvciBleGFtcGxlLFxuLy8gICB0aGUgYmVoYXZpb3Igb2Ygc29tZSBldmVudCBoYW5kbGVyLCB0aGV5IHNob3VsZCBnZXRcbi8vICAgZGlmZmVyZW50IGtleXMuXG5EZWNvcmF0aW9uLndpZGdldCA9IGZ1bmN0aW9uIHdpZGdldCAocG9zLCB0b0RPTSwgc3BlYykge1xuICByZXR1cm4gbmV3IERlY29yYXRpb24ocG9zLCBwb3MsIG5ldyBXaWRnZXRUeXBlKHRvRE9NLCBzcGVjKSlcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlciwgRGVjb3JhdGlvbkF0dHJzLCA/T2JqZWN0KSDihpIgRGVjb3JhdGlvblxuLy8gQ3JlYXRlcyBhbiBpbmxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggYWRkcyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyB0b1xuLy8gZWFjaCBpbmxpbmUgbm9kZSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cbi8vXG4vLyBzcGVjOjotIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQ6XG4vL1xuLy8gICBpbmNsdXNpdmVTdGFydDo6ID9ib29sXG4vLyAgIERldGVybWluZXMgaG93IHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGRlY29yYXRpb24gaXNcbi8vICAgW21hcHBlZF0oI3RyYW5zZm9ybS5Qb3NpdGlvbl9NYXBwaW5nKSB3aGVuIGNvbnRlbnQgaXNcbi8vICAgaW5zZXJ0ZWQgZGlyZWN0bHkgYXQgdGhhdCBwb3NpdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGRlY29yYXRpb25cbi8vICAgd29uJ3QgaW5jbHVkZSB0aGUgbmV3IGNvbnRlbnQsIGJ1dCB5b3UgY2FuIHNldCB0aGlzIHRvIGB0cnVlYFxuLy8gICB0byBtYWtlIGl0IGluY2x1c2l2ZS5cbi8vXG4vLyAgIGluY2x1c2l2ZUVuZDo6ID9ib29sXG4vLyAgIERldGVybWluZXMgaG93IHRoZSByaWdodCBzaWRlIG9mIHRoZSBkZWNvcmF0aW9uIGlzIG1hcHBlZC5cbi8vICAgU2VlXG4vLyAgIFtgaW5jbHVzaXZlU3RhcnRgXSgjdmlldy5EZWNvcmF0aW9uXmlubGluZV5zcGVjLmluY2x1c2l2ZVN0YXJ0KS5cbkRlY29yYXRpb24uaW5saW5lID0gZnVuY3Rpb24gaW5saW5lIChmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgSW5saW5lVHlwZShhdHRycywgc3BlYykpXG59O1xuXG4vLyA6OiAobnVtYmVyLCBudW1iZXIsIERlY29yYXRpb25BdHRycywgP09iamVjdCkg4oaSIERlY29yYXRpb25cbi8vIENyZWF0ZXMgYSBub2RlIGRlY29yYXRpb24uIGBmcm9tYCBhbmQgYHRvYCBzaG91bGQgcG9pbnQgcHJlY2lzZWx5XG4vLyBiZWZvcmUgYW5kIGFmdGVyIGEgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFRoYXQgbm9kZSwgYW5kIG9ubHkgdGhhdFxuLy8gbm9kZSwgd2lsbCByZWNlaXZlIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuLy9cbi8vIHNwZWM6Oi1cbi8vXG4vLyBPcHRpb25hbCBpbmZvcm1hdGlvbiB0byBzdG9yZSB3aXRoIHRoZSBkZWNvcmF0aW9uLiBJdFxuLy8gaXMgYWxzbyB1c2VkIHdoZW4gY29tcGFyaW5nIGRlY29yYXRvcnMgZm9yIGVxdWFsaXR5LlxuRGVjb3JhdGlvbi5ub2RlID0gZnVuY3Rpb24gbm9kZSAoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IE5vZGVUeXBlKGF0dHJzLCBzcGVjKSlcbn07XG5cbi8vIDo6IE9iamVjdFxuLy8gVGhlIHNwZWMgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyB0aGlzIGRlY29yYXRpb24uIENhbiBiZSB1c2VmdWxcbi8vIGlmIHlvdSd2ZSBzdG9yZWQgZXh0cmEgaW5mb3JtYXRpb24gaW4gdGhhdCBvYmplY3QuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5zcGVjLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZS5zcGVjIH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLmlubGluZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBEZWNvcmF0aW9uLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDEgKTtcblxuLy8gRGVjb3JhdGlvbkF0dHJzOjogaW50ZXJmYWNlXG4vLyBBIHNldCBvZiBhdHRyaWJ1dGVzIHRvIGFkZCB0byBhIGRlY29yYXRlZCBub2RlLiBNb3N0IHByb3BlcnRpZXNcbi8vIHNpbXBseSBkaXJlY3RseSBjb3JyZXNwb25kIHRvIERPTSBhdHRyaWJ1dGVzIG9mIHRoZSBzYW1lIG5hbWUsXG4vLyB3aGljaCB3aWxsIGJlIHNldCB0byB0aGUgcHJvcGVydHkncyB2YWx1ZS4gVGhlc2UgYXJlIGV4Y2VwdGlvbnM6XG4vL1xuLy8gICBjbGFzczo6ID9zdHJpbmdcbi8vICAgQSBDU1MgY2xhc3MgbmFtZSBvciBhIHNwYWNlLXNlcGFyYXRlZCBzZXQgb2YgY2xhc3MgbmFtZXMgdG8gYmVcbi8vICAgX2FkZGVkXyB0byB0aGUgY2xhc3NlcyB0aGF0IHRoZSBub2RlIGFscmVhZHkgaGFkLlxuLy9cbi8vICAgc3R5bGU6OiA/c3RyaW5nXG4vLyAgIEEgc3RyaW5nIG9mIENTUyB0byBiZSBfYWRkZWRfIHRvIHRoZSBub2RlJ3MgZXhpc3RpbmcgYHN0eWxlYCBwcm9wZXJ0eS5cbi8vXG4vLyAgIG5vZGVOYW1lOjogP3N0cmluZ1xuLy8gICBXaGVuIG5vbi1udWxsLCB0aGUgdGFyZ2V0IG5vZGUgaXMgd3JhcHBlZCBpbiBhIERPTSBlbGVtZW50IG9mXG4vLyAgIHRoaXMgdHlwZSAoYW5kIHRoZSBvdGhlciBhdHRyaWJ1dGVzIGFyZSBhcHBsaWVkIHRvIHRoaXMgZWxlbWVudCkuXG5cbnZhciBub25lID0gW10sIG5vU3BlYyA9IHt9O1xuXG4vLyA6OiBjbGFzcyBleHRlbmRzIERlY29yYXRpb25Tb3VyY2Vcbi8vIEEgY29sbGVjdGlvbiBvZiBbZGVjb3JhdGlvbnNdKCN2aWV3LkRlY29yYXRpb24pLCBvcmdhbml6ZWQgaW5cbi8vIHN1Y2ggYSB3YXkgdGhhdCB0aGUgZHJhd2luZyBhbGdvcml0aG0gY2FuIGVmZmljaWVudGx5IHVzZSBhbmRcbi8vIGNvbXBhcmUgdGhlbS4gVGhpcyBpcyBhIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmXigJRpdCBpcyBub3Rcbi8vIG1vZGlmaWVkLCB1cGRhdGVzIGNyZWF0ZSBhIG5ldyB2YWx1ZS5cbnZhciBEZWNvcmF0aW9uU2V0ID0gZnVuY3Rpb24gRGVjb3JhdGlvblNldChsb2NhbCwgY2hpbGRyZW4pIHtcbiAgdGhpcy5sb2NhbCA9IGxvY2FsICYmIGxvY2FsLmxlbmd0aCA/IGxvY2FsIDogbm9uZTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuIDogbm9uZTtcbn07XG5cbi8vIDo6IChOb2RlLCBbRGVjb3JhdGlvbl0pIOKGkiBEZWNvcmF0aW9uU2V0XG4vLyBDcmVhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMsIHVzaW5nIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuXG4vLyBkb2N1bWVudC5cbkRlY29yYXRpb25TZXQuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlIChkb2MsIGRlY29yYXRpb25zKSB7XG4gIHJldHVybiBkZWNvcmF0aW9ucy5sZW5ndGggPyBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIGRvYywgMCwgbm9TcGVjKSA6IGVtcHR5XG59O1xuXG4vLyA6OiAoP251bWJlciwgP251bWJlciwgPyhzcGVjOiBPYmplY3QpIOKGkiBib29sKSDihpIgW0RlY29yYXRpb25dXG4vLyBGaW5kIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCB3aGljaCB0b3VjaCB0aGUgZ2l2ZW4gcmFuZ2Vcbi8vIChpbmNsdWRpbmcgZGVjb3JhdGlvbnMgdGhhdCBzdGFydCBvciBlbmQgZGlyZWN0bHkgYXQgdGhlXG4vLyBib3VuZGFyaWVzKSBhbmQgbWF0Y2ggdGhlIGdpdmVuIHByZWRpY2F0ZSBvbiB0aGVpciBzcGVjLiBXaGVuXG4vLyBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgb21pdHRlZCwgYWxsIGRlY29yYXRpb25zIGluIHRoZSBzZXQgYXJlXG4vLyBjb25zaWRlcmVkLiBXaGVuIGBwcmVkaWNhdGVgIGlzbid0IGdpdmVuLCBhbGwgZGVjb3JhdGlvbnMgYXJlXG4vLyBhc3N1bWVkIHRvIG1hdGNoLlxuRGVjb3JhdGlvblNldC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQgKHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHRoaXMuZmluZElubmVyKHN0YXJ0ID09IG51bGwgPyAwIDogc3RhcnQsIGVuZCA9PSBudWxsID8gMWU5IDogZW5kLCByZXN1bHQsIDAsIHByZWRpY2F0ZSk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLmZpbmRJbm5lciA9IGZ1bmN0aW9uIGZpbmRJbm5lciAoc3RhcnQsIGVuZCwgcmVzdWx0LCBvZmZzZXQsIHByZWRpY2F0ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3BhbiA9IHRoaXMubG9jYWxbaV07XG4gICAgaWYgKHNwYW4uZnJvbSA8PSBlbmQgJiYgc3Bhbi50byA+PSBzdGFydCAmJiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoc3Bhbi5zcGVjKSkpXG4gICAgICB7IHJlc3VsdC5wdXNoKHNwYW4uY29weShzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQpKTsgfVxuICB9XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpJDEgKz0gMykge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuW2kkMV0gPCBlbmQgJiYgdGhpcy5jaGlsZHJlbltpJDEgKyAxXSA+IHN0YXJ0KSB7XG4gICAgICB2YXIgY2hpbGRPZmYgPSB0aGlzLmNoaWxkcmVuW2kkMV0gKyAxO1xuICAgICAgdGhpcy5jaGlsZHJlbltpJDEgKyAyXS5maW5kSW5uZXIoc3RhcnQgLSBjaGlsZE9mZiwgZW5kIC0gY2hpbGRPZmYsIHJlc3VsdCwgb2Zmc2V0ICsgY2hpbGRPZmYsIHByZWRpY2F0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyA6OiAoTWFwcGluZywgTm9kZSwgP09iamVjdCkg4oaSIERlY29yYXRpb25TZXRcbi8vIE1hcCB0aGUgc2V0IG9mIGRlY29yYXRpb25zIGluIHJlc3BvbnNlIHRvIGEgY2hhbmdlIGluIHRoZVxuLy8gZG9jdW1lbnQuXG4vL1xuLy8gb3B0aW9uczo6LSBBbiBvcHRpb25hbCBzZXQgb2Ygb3B0aW9ucy5cbi8vXG4vLyAgIG9uUmVtb3ZlOjogPyhkZWNvcmF0aW9uU3BlYzogT2JqZWN0KVxuLy8gICBXaGVuIGdpdmVuLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGRlY29yYXRpb25cbi8vICAgdGhhdCBnZXRzIGRyb3BwZWQgYXMgYSByZXN1bHQgb2YgdGhlIG1hcHBpbmcsIHBhc3NpbmcgdGhlXG4vLyAgIHNwZWMgb2YgdGhhdCBkZWNvcmF0aW9uLlxuRGVjb3JhdGlvblNldC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nLCBkb2MsIG9wdGlvbnMpIHtcbiAgaWYgKHRoaXMgPT0gZW1wdHkgfHwgbWFwcGluZy5tYXBzLmxlbmd0aCA9PSAwKSB7IHJldHVybiB0aGlzIH1cbiAgcmV0dXJuIHRoaXMubWFwSW5uZXIobWFwcGluZywgZG9jLCAwLCAwLCBvcHRpb25zIHx8IG5vU3BlYylcbn07XG5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLm1hcElubmVyID0gZnVuY3Rpb24gbWFwSW5uZXIgKG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gIHZhciBuZXdMb2NhbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hcHBlZCA9IHRoaXMubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICBpZiAobWFwcGVkICYmIG1hcHBlZC50eXBlLnZhbGlkKG5vZGUsIG1hcHBlZCkpIHsgKG5ld0xvY2FsIHx8IChuZXdMb2NhbCA9IFtdKSkucHVzaChtYXBwZWQpOyB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSkgeyBvcHRpb25zLm9uUmVtb3ZlKHRoaXMubG9jYWxbaV0uc3BlYyk7IH1cbiAgfVxuXG4gIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICB7IHJldHVybiBtYXBDaGlsZHJlbih0aGlzLmNoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIH1cbiAgZWxzZVxuICAgIHsgcmV0dXJuIG5ld0xvY2FsID8gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcykpIDogZW1wdHkgfVxufTtcblxuLy8gOjogKE5vZGUsIFtEZWNvcmF0aW9uXSkg4oaSIERlY29yYXRpb25TZXRcbi8vIEFkZCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbnMgdG8gdGhlIG9uZXMgaW4gdGhlIHNldCxcbi8vIHByb2R1Y2luZyBhIG5ldyBzZXQuIE5lZWRzIGFjY2VzcyB0byB0aGUgY3VycmVudCBkb2N1bWVudCB0b1xuLy8gY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB0cmVlIHN0cnVjdHVyZS5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZG9jLCBkZWNvcmF0aW9ucykge1xuICBpZiAoIWRlY29yYXRpb25zLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gIGlmICh0aGlzID09IGVtcHR5KSB7IHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKSB9XG4gIHJldHVybiB0aGlzLmFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIDApXG59O1xuXG5EZWNvcmF0aW9uU2V0LnByb3RvdHlwZS5hZGRJbm5lciA9IGZ1bmN0aW9uIGFkZElubmVyIChkb2MsIGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY2hpbGRyZW4sIGNoaWxkSW5kZXggPSAwO1xuICBkb2MuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlLCBjaGlsZE9mZnNldCkge1xuICAgIHZhciBiYXNlT2Zmc2V0ID0gY2hpbGRPZmZzZXQgKyBvZmZzZXQsIGZvdW5kO1xuICAgIGlmICghKGZvdW5kID0gdGFrZVNwYW5zRm9yTm9kZShkZWNvcmF0aW9ucywgY2hpbGROb2RlLCBiYXNlT2Zmc2V0KSkpIHsgcmV0dXJuIH1cblxuICAgIGlmICghY2hpbGRyZW4pIHsgY2hpbGRyZW4gPSB0aGlzJDEuY2hpbGRyZW4uc2xpY2UoKTsgfVxuICAgIHdoaWxlIChjaGlsZEluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2NoaWxkSW5kZXhdIDwgY2hpbGRPZmZzZXQpIHsgY2hpbGRJbmRleCArPSAzOyB9XG4gICAgaWYgKGNoaWxkcmVuW2NoaWxkSW5kZXhdID09IGNoaWxkT2Zmc2V0KVxuICAgICAgeyBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0gPSBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0uYWRkSW5uZXIoY2hpbGROb2RlLCBmb3VuZCwgYmFzZU9mZnNldCArIDEpOyB9XG4gICAgZWxzZVxuICAgICAgeyBjaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMCwgY2hpbGRPZmZzZXQsIGNoaWxkT2Zmc2V0ICsgY2hpbGROb2RlLm5vZGVTaXplLCBidWlsZFRyZWUoZm91bmQsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCArIDEsIG5vU3BlYykpOyB9XG4gICAgY2hpbGRJbmRleCArPSAzO1xuICB9KTtcblxuICB2YXIgbG9jYWwgPSBtb3ZlU3BhbnMoY2hpbGRJbmRleCA/IHdpdGhvdXROdWxscyhkZWNvcmF0aW9ucykgOiBkZWNvcmF0aW9ucywgLW9mZnNldCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHsgaWYgKCFsb2NhbFtpXS50eXBlLnZhbGlkKGRvYywgbG9jYWxbaV0pKSB7IGxvY2FsLnNwbGljZShpLS0sIDEpOyB9IH1cblxuICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobG9jYWwubGVuZ3RoID8gdGhpcy5sb2NhbC5jb25jYXQobG9jYWwpLnNvcnQoYnlQb3MpIDogdGhpcy5sb2NhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4pXG59O1xuXG4vLyA6OiAoW0RlY29yYXRpb25dKSDihpIgRGVjb3JhdGlvblNldFxuLy8gQ3JlYXRlIGEgbmV3IHNldCB0aGF0IGNvbnRhaW5zIHRoZSBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCwgbWludXNcbi8vIHRoZSBvbmVzIGluIHRoZSBnaXZlbiBhcnJheS5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoZGVjb3JhdGlvbnMpIHtcbiAgaWYgKGRlY29yYXRpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMgPT0gZW1wdHkpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gdGhpcy5yZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgMClcbn07XG5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLnJlbW92ZUlubmVyID0gZnVuY3Rpb24gcmVtb3ZlSW5uZXIgKGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiwgbG9jYWwgPSB0aGlzLmxvY2FsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgdmFyIGZvdW5kID0gKHZvaWQgMCksIGZyb20gPSBjaGlsZHJlbltpXSArIG9mZnNldCwgdG8gPSBjaGlsZHJlbltpICsgMV0gKyBvZmZzZXQ7XG4gICAgZm9yICh2YXIgaiA9IDAsIHNwYW4gPSAodm9pZCAwKTsgaiA8IGRlY29yYXRpb25zLmxlbmd0aDsgaisrKSB7IGlmIChzcGFuID0gZGVjb3JhdGlvbnNbal0pIHtcbiAgICAgIGlmIChzcGFuLmZyb20gPiBmcm9tICYmIHNwYW4udG8gPCB0bykge1xuICAgICAgICBkZWNvcmF0aW9uc1tqXSA9IG51bGxcbiAgICAgICAgOyhmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICB9XG4gICAgfSB9XG4gICAgaWYgKCFmb3VuZCkgeyBjb250aW51ZSB9XG4gICAgaWYgKGNoaWxkcmVuID09IHRoaXMuY2hpbGRyZW4pIHsgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7IH1cbiAgICB2YXIgcmVtb3ZlZCA9IGNoaWxkcmVuW2kgKyAyXS5yZW1vdmVJbm5lcihmb3VuZCwgZnJvbSArIDEpO1xuICAgIGlmIChyZW1vdmVkICE9IGVtcHR5KSB7XG4gICAgICBjaGlsZHJlbltpICsgMl0gPSByZW1vdmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMyk7XG4gICAgICBpIC09IDM7XG4gICAgfVxuICB9XG4gIGlmIChsb2NhbC5sZW5ndGgpIHsgZm9yICh2YXIgaSQxID0gMCwgc3BhbiQxID0gKHZvaWQgMCk7IGkkMSA8IGRlY29yYXRpb25zLmxlbmd0aDsgaSQxKyspIHsgaWYgKHNwYW4kMSA9IGRlY29yYXRpb25zW2kkMV0pIHtcbiAgICBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBsb2NhbC5sZW5ndGg7IGokMSsrKSB7IGlmIChsb2NhbFtqJDFdLmVxKHNwYW4kMSwgb2Zmc2V0KSkge1xuICAgICAgaWYgKGxvY2FsID09IHRoaXMubG9jYWwpIHsgbG9jYWwgPSB0aGlzLmxvY2FsLnNsaWNlKCk7IH1cbiAgICAgIGxvY2FsLnNwbGljZShqJDEtLSwgMSk7XG4gICAgfSB9XG4gIH0gfSB9XG4gIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuICYmIGxvY2FsID09IHRoaXMubG9jYWwpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gbG9jYWwubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLCBjaGlsZHJlbikgOiBlbXB0eVxufTtcblxuRGVjb3JhdGlvblNldC5wcm90b3R5cGUuZm9yQ2hpbGQgPSBmdW5jdGlvbiBmb3JDaGlsZCAob2Zmc2V0LCBub2RlKSB7XG4gIGlmICh0aGlzID09IGVtcHR5KSB7IHJldHVybiB0aGlzIH1cbiAgaWYgKG5vZGUuaXNMZWFmKSB7IHJldHVybiBEZWNvcmF0aW9uU2V0LmVtcHR5IH1cblxuICB2YXIgY2hpbGQsIGxvY2FsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHsgaWYgKHRoaXMuY2hpbGRyZW5baV0gPj0gb2Zmc2V0KSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPT0gb2Zmc2V0KSB7IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpICsgMl07IH1cbiAgICBicmVha1xuICB9IH1cbiAgdmFyIHN0YXJ0ID0gb2Zmc2V0ICsgMSwgZW5kID0gc3RhcnQgKyBub2RlLmNvbnRlbnQuc2l6ZTtcbiAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkkMSsrKSB7XG4gICAgdmFyIGRlYyA9IHRoaXMubG9jYWxbaSQxXTtcbiAgICBpZiAoZGVjLmZyb20gPCBlbmQgJiYgZGVjLnRvID4gc3RhcnQgJiYgKGRlYy50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZSkpIHtcbiAgICAgIHZhciBmcm9tID0gTWF0aC5tYXgoc3RhcnQsIGRlYy5mcm9tKSAtIHN0YXJ0LCB0byA9IE1hdGgubWluKGVuZCwgZGVjLnRvKSAtIHN0YXJ0O1xuICAgICAgaWYgKGZyb20gPCB0bykgeyAobG9jYWwgfHwgKGxvY2FsID0gW10pKS5wdXNoKGRlYy5jb3B5KGZyb20sIHRvKSk7IH1cbiAgICB9XG4gIH1cbiAgaWYgKGxvY2FsKSB7XG4gICAgdmFyIGxvY2FsU2V0ID0gbmV3IERlY29yYXRpb25TZXQobG9jYWwuc29ydChieVBvcykpO1xuICAgIHJldHVybiBjaGlsZCA/IG5ldyBEZWNvcmF0aW9uR3JvdXAoW2xvY2FsU2V0LCBjaGlsZF0pIDogbG9jYWxTZXRcbiAgfVxuICByZXR1cm4gY2hpbGQgfHwgZW1wdHlcbn07XG5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyKSB7XG4gIGlmICh0aGlzID09IG90aGVyKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0KSB8fFxuICAgICAgdGhpcy5sb2NhbC5sZW5ndGggIT0gb3RoZXIubG9jYWwubGVuZ3RoIHx8XG4gICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPSBvdGhlci5jaGlsZHJlbi5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKVxuICAgIHsgaWYgKCF0aGlzLmxvY2FsW2ldLmVxKG90aGVyLmxvY2FsW2ldKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpJDEgKz0gMylcbiAgICB7IGlmICh0aGlzLmNoaWxkcmVuW2kkMV0gIT0gb3RoZXIuY2hpbGRyZW5baSQxXSB8fFxuICAgICAgICB0aGlzLmNoaWxkcmVuW2kkMSArIDFdICE9IG90aGVyLmNoaWxkcmVuW2kkMSArIDFdIHx8XG4gICAgICAgICF0aGlzLmNoaWxkcmVuW2kkMSArIDJdLmVxKG90aGVyLmNoaWxkcmVuW2kkMSArIDJdKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG5EZWNvcmF0aW9uU2V0LnByb3RvdHlwZS5sb2NhbHMgPSBmdW5jdGlvbiBsb2NhbHMgKG5vZGUpIHtcbiAgcmV0dXJuIHJlbW92ZU92ZXJsYXAodGhpcy5sb2NhbHNJbm5lcihub2RlKSlcbn07XG5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLmxvY2Fsc0lubmVyID0gZnVuY3Rpb24gbG9jYWxzSW5uZXIgKG5vZGUpIHtcbiAgaWYgKHRoaXMgPT0gZW1wdHkpIHsgcmV0dXJuIG5vbmUgfVxuICBpZiAobm9kZS5pbmxpbmVDb250ZW50IHx8ICF0aGlzLmxvY2FsLnNvbWUoSW5saW5lVHlwZS5pcykpIHsgcmV0dXJuIHRoaXMubG9jYWwgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghKHRoaXMubG9jYWxbaV0udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKVxuICAgICAgeyByZXN1bHQucHVzaCh0aGlzLmxvY2FsW2ldKTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIERlY29yYXRpb25Tb3VyY2U6OiBpbnRlcmZhY2Vcbi8vIEFuIG9iamVjdCB0aGF0IGNhbiBbcHJvdmlkZV0oI3ZpZXcuRWRpdG9yUHJvcHMuZGVjb3JhdGlvbnMpXG4vLyBkZWNvcmF0aW9ucy4gSW1wbGVtZW50ZWQgYnkgW2BEZWNvcmF0aW9uU2V0YF0oI3ZpZXcuRGVjb3JhdGlvblNldCksXG4vLyBhbmQgcGFzc2VkIHRvIFtub2RlIHZpZXdzXSgjdmlldy5FZGl0b3JQcm9wcy5ub2RlVmlld3MpLlxuLy9cbi8vICAgbWFwOjogKE1hcHBpbmcsIE5vZGUpIOKGkiBEZWNvcmF0aW9uU291cmNlXG4vLyAgIE1hcCB0aGUgc2V0IG9mIGRlY29yYXRpb25zIGluIHJlc3BvbnNlIHRvIGEgY2hhbmdlIGluIHRoZVxuLy8gICBkb2N1bWVudC5cblxudmFyIGVtcHR5ID0gbmV3IERlY29yYXRpb25TZXQoKTtcblxuLy8gOjogRGVjb3JhdGlvblNldFxuLy8gVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbkRlY29yYXRpb25TZXQuZW1wdHkgPSBlbXB0eTtcblxuRGVjb3JhdGlvblNldC5yZW1vdmVPdmVybGFwID0gcmVtb3ZlT3ZlcmxhcDtcblxuLy8gOi0gQW4gYWJzdHJhY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGNvZGUgZGVhbGluZyB3aXRoIGRlY29yYXRpb25zIHRvXG4vLyB0cmVhdCBtdWx0aXBsZSBEZWNvcmF0aW9uU2V0IG9iamVjdHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBvYmplY3Rcbi8vIHdpdGggKGEgc3Vic2V0IG9mKSB0aGUgc2FtZSBpbnRlcmZhY2UuXG52YXIgRGVjb3JhdGlvbkdyb3VwID0gZnVuY3Rpb24gRGVjb3JhdGlvbkdyb3VwKG1lbWJlcnMpIHtcbiAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbn07XG5cbkRlY29yYXRpb25Hcm91cC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nLCBkb2MpIHtcbiAgdmFyIG1hcHBlZERlY29zID0gdGhpcy5tZW1iZXJzLm1hcChcbiAgICBmdW5jdGlvbiAobWVtYmVyKSB7IHJldHVybiBtZW1iZXIubWFwKG1hcHBpbmcsIGRvYywgbm9TcGVjKTsgfVxuICApO1xuICByZXR1cm4gRGVjb3JhdGlvbkdyb3VwLmZyb20obWFwcGVkRGVjb3MpXG59O1xuXG5EZWNvcmF0aW9uR3JvdXAucHJvdG90eXBlLmZvckNoaWxkID0gZnVuY3Rpb24gZm9yQ2hpbGQgKG9mZnNldCwgY2hpbGQpIHtcbiAgaWYgKGNoaWxkLmlzTGVhZikgeyByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eSB9XG4gIHZhciBmb3VuZCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm1lbWJlcnNbaV0uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCk7XG4gICAgaWYgKHJlc3VsdCA9PSBlbXB0eSkgeyBjb250aW51ZSB9XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIERlY29yYXRpb25Hcm91cCkgeyBmb3VuZCA9IGZvdW5kLmNvbmNhdChyZXN1bHQubWVtYmVycyk7IH1cbiAgICBlbHNlIHsgZm91bmQucHVzaChyZXN1bHQpOyB9XG4gIH1cbiAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKVxufTtcblxuRGVjb3JhdGlvbkdyb3VwLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERlY29yYXRpb25Hcm91cCkgfHxcbiAgICAgIG90aGVyLm1lbWJlcnMubGVuZ3RoICE9IHRoaXMubWVtYmVycy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspXG4gICAgeyBpZiAoIXRoaXMubWVtYmVyc1tpXS5lcShvdGhlci5tZW1iZXJzW2ldKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG5EZWNvcmF0aW9uR3JvdXAucHJvdG90eXBlLmxvY2FscyA9IGZ1bmN0aW9uIGxvY2FscyAobm9kZSkge1xuICB2YXIgcmVzdWx0LCBzb3J0ZWQgPSB0cnVlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsb2NhbHMgPSB0aGlzLm1lbWJlcnNbaV0ubG9jYWxzSW5uZXIobm9kZSk7XG4gICAgaWYgKCFsb2NhbHMubGVuZ3RoKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gbG9jYWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgpO1xuICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbG9jYWxzLmxlbmd0aDsgaisrKSB7IHJlc3VsdC5wdXNoKGxvY2Fsc1tqXSk7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdCA/IHJlbW92ZU92ZXJsYXAoc29ydGVkID8gcmVzdWx0IDogcmVzdWx0LnNvcnQoYnlQb3MpKSA6IG5vbmVcbn07XG5cbi8vIDogKFtEZWNvcmF0aW9uU2V0XSkg4oaSIHVuaW9uPERlY29yYXRpb25TZXQsIERlY29yYXRpb25Hcm91cD5cbi8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbiBzZXRzLCBvciByZXR1cm5cbi8vIGEgc2luZ2xlIHNldCB3aGVuIHBvc3NpYmxlLlxuRGVjb3JhdGlvbkdyb3VwLmZyb20gPSBmdW5jdGlvbiBmcm9tIChtZW1iZXJzKSB7XG4gIHN3aXRjaCAobWVtYmVycy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBlbXB0eVxuICAgIGNhc2UgMTogcmV0dXJuIG1lbWJlcnNbMF1cbiAgICBkZWZhdWx0OiByZXR1cm4gbmV3IERlY29yYXRpb25Hcm91cChtZW1iZXJzKVxuICB9XG59O1xuXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gIHZhciBjaGlsZHJlbiA9IG9sZENoaWxkcmVuLnNsaWNlKCk7XG5cbiAgLy8gTWFyayB0aGUgY2hpbGRyZW4gdGhhdCBhcmUgZGlyZWN0bHkgdG91Y2hlZCBieSBjaGFuZ2VzLCBhbmRcbiAgLy8gbW92ZSB0aG9zZSB0aGF0IGFyZSBhZnRlciB0aGUgY2hhbmdlcy5cbiAgdmFyIHNoaWZ0ID0gZnVuY3Rpb24gKG9sZFN0YXJ0LCBvbGRFbmQsIG5ld1N0YXJ0LCBuZXdFbmQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICB2YXIgZW5kID0gY2hpbGRyZW5baSArIDFdLCBkU2l6ZSA9ICh2b2lkIDApO1xuICAgICAgaWYgKGVuZCA9PSAtMSB8fCBvbGRTdGFydCA+IGVuZCArIG9sZE9mZnNldCkgeyBjb250aW51ZSB9XG4gICAgICBpZiAob2xkRW5kID49IGNoaWxkcmVuW2ldICsgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChuZXdTdGFydCA+PSBvZmZzZXQgJiYgKGRTaXplID0gKG5ld0VuZCAtIG5ld1N0YXJ0KSAtIChvbGRFbmQgLSBvbGRTdGFydCkpKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldICs9IGRTaXplO1xuICAgICAgICBjaGlsZHJlbltpICsgMV0gKz0gZFNpemU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykgeyBtYXBwaW5nLm1hcHNbaV0uZm9yRWFjaChzaGlmdCk7IH1cblxuICAvLyBGaW5kIHRoZSBjaGlsZCBub2RlcyB0aGF0IHN0aWxsIGNvcnJlc3BvbmQgdG8gYSBzaW5nbGUgbm9kZSxcbiAgLy8gcmVjdXJzaXZlbHkgY2FsbCBtYXBJbm5lciBvbiB0aGVtIGFuZCB1cGRhdGUgdGhlaXIgcG9zaXRpb25zLlxuICB2YXIgbXVzdFJlYnVpbGQgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDEgKz0gMykgeyBpZiAoY2hpbGRyZW5baSQxICsgMV0gPT0gLTEpIHsgLy8gVG91Y2hlZCBub2Rlc1xuICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5baSQxXSArIG9sZE9mZnNldCksIGZyb21Mb2NhbCA9IGZyb20gLSBvZmZzZXQ7XG4gICAgaWYgKGZyb21Mb2NhbCA8IDAgfHwgZnJvbUxvY2FsID49IG5vZGUuY29udGVudC5zaXplKSB7XG4gICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICAvLyBNdXN0IHJlYWQgb2xkQ2hpbGRyZW4gYmVjYXVzZSBjaGlsZHJlbiB3YXMgdGFnZ2VkIHdpdGggLTFcbiAgICB2YXIgdG8gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpJDEgKyAxXSArIG9sZE9mZnNldCwgLTEpLCB0b0xvY2FsID0gdG8gLSBvZmZzZXQ7XG4gICAgdmFyIHJlZiA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoZnJvbUxvY2FsKTtcbiAgICB2YXIgaW5kZXggPSByZWYuaW5kZXg7XG4gICAgdmFyIGNoaWxkT2Zmc2V0ID0gcmVmLm9mZnNldDtcbiAgICB2YXIgY2hpbGROb2RlID0gbm9kZS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkT2Zmc2V0ID09IGZyb21Mb2NhbCAmJiBjaGlsZE9mZnNldCArIGNoaWxkTm9kZS5ub2RlU2l6ZSA9PSB0b0xvY2FsKSB7XG4gICAgICB2YXIgbWFwcGVkID0gY2hpbGRyZW5baSQxICsgMl0ubWFwSW5uZXIobWFwcGluZywgY2hpbGROb2RlLCBmcm9tICsgMSwgb2xkQ2hpbGRyZW5baSQxXSArIG9sZE9mZnNldCArIDEsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1hcHBlZCAhPSBlbXB0eSkge1xuICAgICAgICBjaGlsZHJlbltpJDFdID0gZnJvbUxvY2FsO1xuICAgICAgICBjaGlsZHJlbltpJDEgKyAxXSA9IHRvTG9jYWw7XG4gICAgICAgIGNoaWxkcmVuW2kkMSArIDJdID0gbWFwcGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW5baSQxICsgMV0gPSAtMjtcbiAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgfVxuICB9IH1cblxuICAvLyBSZW1haW5pbmcgY2hpbGRyZW4gbXVzdCBiZSBjb2xsZWN0ZWQgYW5kIHJlYnVpbHQgaW50byB0aGUgYXBwcm9wcmlhdGUgc3RydWN0dXJlXG4gIGlmIChtdXN0UmVidWlsZCkge1xuICAgIHZhciBkZWNvcmF0aW9ucyA9IG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgbmV3TG9jYWwgfHwgW10sIG1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgIHZhciBidWlsdCA9IGJ1aWxkVHJlZShkZWNvcmF0aW9ucywgbm9kZSwgMCwgb3B0aW9ucyk7XG4gICAgbmV3TG9jYWwgPSBidWlsdC5sb2NhbDtcbiAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMiArPSAzKSB7IGlmIChjaGlsZHJlbltpJDIgKyAxXSA8IDApIHtcbiAgICAgIGNoaWxkcmVuLnNwbGljZShpJDIsIDMpO1xuICAgICAgaSQyIC09IDM7XG4gICAgfSB9XG4gICAgZm9yICh2YXIgaSQzID0gMCwgaiA9IDA7IGkkMyA8IGJ1aWx0LmNoaWxkcmVuLmxlbmd0aDsgaSQzICs9IDMpIHtcbiAgICAgIHZhciBmcm9tJDEgPSBidWlsdC5jaGlsZHJlbltpJDNdO1xuICAgICAgd2hpbGUgKGogPCBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bal0gPCBmcm9tJDEpIHsgaiArPSAzOyB9XG4gICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMCwgYnVpbHQuY2hpbGRyZW5baSQzXSwgYnVpbHQuY2hpbGRyZW5baSQzICsgMV0sIGJ1aWx0LmNoaWxkcmVuW2kkMyArIDJdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwgJiYgbmV3TG9jYWwuc29ydChieVBvcyksIGNoaWxkcmVuKVxufVxuXG5mdW5jdGlvbiBtb3ZlU3BhbnMoc3BhbnMsIG9mZnNldCkge1xuICBpZiAoIW9mZnNldCB8fCAhc3BhbnMubGVuZ3RoKSB7IHJldHVybiBzcGFucyB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgcmVzdWx0LnB1c2gobmV3IERlY29yYXRpb24oc3Bhbi5mcm9tICsgb2Zmc2V0LCBzcGFuLnRvICsgb2Zmc2V0LCBzcGFuLnR5cGUpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgZGVjb3JhdGlvbnMsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gIC8vIEdhdGhlciBhbGwgZGVjb3JhdGlvbnMgZnJvbSB0aGUgcmVtYWluaW5nIG1hcmtlZCBjaGlsZHJlblxuICBmdW5jdGlvbiBnYXRoZXIoc2V0LCBvbGRPZmZzZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1hcHBlZCA9IHNldC5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgaWYgKG1hcHBlZCkgeyBkZWNvcmF0aW9ucy5wdXNoKG1hcHBlZCk7IH1cbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpIHsgb3B0aW9ucy5vblJlbW92ZShzZXQubG9jYWxbaV0uc3BlYyk7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc2V0LmNoaWxkcmVuLmxlbmd0aDsgaSQxICs9IDMpXG4gICAgICB7IGdhdGhlcihzZXQuY2hpbGRyZW5baSQxICsgMl0sIHNldC5jaGlsZHJlbltpJDFdICsgb2xkT2Zmc2V0ICsgMSk7IH1cbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7IGlmIChjaGlsZHJlbltpICsgMV0gPT0gLTEpXG4gICAgeyBnYXRoZXIoY2hpbGRyZW5baSArIDJdLCBvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEpOyB9IH1cblxuICByZXR1cm4gZGVjb3JhdGlvbnNcbn1cblxuZnVuY3Rpb24gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgbm9kZSwgb2Zmc2V0KSB7XG4gIGlmIChub2RlLmlzTGVhZikgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBlbmQgPSBvZmZzZXQgKyBub2RlLm5vZGVTaXplLCBmb3VuZCA9IG51bGw7XG4gIGZvciAodmFyIGkgPSAwLCBzcGFuID0gKHZvaWQgMCk7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICgoc3BhbiA9IHNwYW5zW2ldKSAmJiBzcGFuLmZyb20gPiBvZmZzZXQgJiYgc3Bhbi50byA8IGVuZCkge1xuKGZvdW5kIHx8IChmb3VuZCA9IFtdKSkucHVzaChzcGFuKTtcbiAgICAgIHNwYW5zW2ldID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvdW5kXG59XG5cbmZ1bmN0aW9uIHdpdGhvdXROdWxscyhhcnJheSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgeyBpZiAoYXJyYXlbaV0gIT0gbnVsbCkgeyByZXN1bHQucHVzaChhcnJheVtpXSk7IH0gfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIDogKFtEZWNvcmF0aW9uXSwgTm9kZSwgbnVtYmVyKSDihpIgRGVjb3JhdGlvblNldFxuLy8gQnVpbGQgdXAgYSB0cmVlIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBzZXQgb2YgZGVjb3JhdGlvbnMuIGBvZmZzZXRgXG4vLyBpcyBhIGJhc2Ugb2Zmc2V0IHRoYXQgc2hvdWxkIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgYGZyb21gIGFuZCBgdG9gXG4vLyBwb3NpdGlvbnMgaW4gdGhlIHNwYW5zIChzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gYWxsb2NhdGUgbmV3IHNwYW5zXG4vLyBmb3IgcmVjdXJzaXZlIGNhbGxzKS5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShzcGFucywgbm9kZSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gIHZhciBjaGlsZHJlbiA9IFtdLCBoYXNOdWxscyA9IGZhbHNlO1xuICBub2RlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSwgbG9jYWxTdGFydCkge1xuICAgIHZhciBmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoc3BhbnMsIGNoaWxkTm9kZSwgbG9jYWxTdGFydCArIG9mZnNldCk7XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICBoYXNOdWxscyA9IHRydWU7XG4gICAgICB2YXIgc3VidHJlZSA9IGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBvZmZzZXQgKyBsb2NhbFN0YXJ0ICsgMSwgb3B0aW9ucyk7XG4gICAgICBpZiAoc3VidHJlZSAhPSBlbXB0eSlcbiAgICAgICAgeyBjaGlsZHJlbi5wdXNoKGxvY2FsU3RhcnQsIGxvY2FsU3RhcnQgKyBjaGlsZE5vZGUubm9kZVNpemUsIHN1YnRyZWUpOyB9XG4gICAgfVxuICB9KTtcbiAgdmFyIGxvY2FscyA9IG1vdmVTcGFucyhoYXNOdWxscyA/IHdpdGhvdXROdWxscyhzcGFucykgOiBzcGFucywgLW9mZnNldCkuc29ydChieVBvcyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYWxzLmxlbmd0aDsgaSsrKSB7IGlmICghbG9jYWxzW2ldLnR5cGUudmFsaWQobm9kZSwgbG9jYWxzW2ldKSkge1xuICAgIGlmIChvcHRpb25zLm9uUmVtb3ZlKSB7IG9wdGlvbnMub25SZW1vdmUobG9jYWxzW2ldLnNwZWMpOyB9XG4gICAgbG9jYWxzLnNwbGljZShpLS0sIDEpO1xuICB9IH1cbiAgcmV0dXJuIGxvY2Fscy5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWxzLCBjaGlsZHJlbikgOiBlbXB0eVxufVxuXG4vLyA6IChEZWNvcmF0aW9uLCBEZWNvcmF0aW9uKSDihpIgbnVtYmVyXG4vLyBVc2VkIHRvIHNvcnQgZGVjb3JhdGlvbnMgc28gdGhhdCBvbmVzIHdpdGggYSBsb3cgc3RhcnQgcG9zaXRpb25cbi8vIGNvbWUgZmlyc3QsIGFuZCB3aXRoaW4gYSBzZXQgd2l0aCB0aGUgc2FtZSBzdGFydCBwb3NpdGlvbiwgdGhvc2Vcbi8vIHdpdGggYW4gc21hbGxlciBlbmQgcG9zaXRpb24gY29tZSBmaXJzdC5cbmZ1bmN0aW9uIGJ5UG9zKGEsIGIpIHtcbiAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnRvIC0gYi50b1xufVxuXG4vLyA6IChbRGVjb3JhdGlvbl0pIOKGkiBbRGVjb3JhdGlvbl1cbi8vIFNjYW4gYSBzb3J0ZWQgYXJyYXkgb2YgZGVjb3JhdGlvbnMgZm9yIHBhcnRpYWxseSBvdmVybGFwcGluZyBzcGFucyxcbi8vIGFuZCBzcGxpdCB0aG9zZSBzbyB0aGF0IG9ubHkgZnVsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGxlZnQgKHRvXG4vLyBtYWtlIHN1YnNlcXVlbnQgcmVuZGVyaW5nIGVhc2llcikuIFdpbGwgcmV0dXJuIHRoZSBpbnB1dCBhcnJheSBpZlxuLy8gbm8gcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zIGFyZSBmb3VuZCAodGhlIGNvbW1vbiBjYXNlKS5cbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXAoc3BhbnMpIHtcbiAgdmFyIHdvcmtpbmcgPSBzcGFucztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JraW5nLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHZhciBzcGFuID0gd29ya2luZ1tpXTtcbiAgICBpZiAoc3Bhbi5mcm9tICE9IHNwYW4udG8pIHsgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgd29ya2luZy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG5leHQgPSB3b3JraW5nW2pdO1xuICAgICAgaWYgKG5leHQuZnJvbSA9PSBzcGFuLmZyb20pIHtcbiAgICAgICAgaWYgKG5leHQudG8gIT0gc3Bhbi50bykge1xuICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKSB7IHdvcmtpbmcgPSBzcGFucy5zbGljZSgpOyB9XG4gICAgICAgICAgLy8gRm9sbG93ZWQgYnkgYSBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgbGFyZ2VyIHNwYW4uIFNwbGl0IHRoYXRcbiAgICAgICAgICAvLyBzcGFuLlxuICAgICAgICAgIHdvcmtpbmdbal0gPSBuZXh0LmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKTtcbiAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqICsgMSwgbmV4dC5jb3B5KHNwYW4udG8sIG5leHQudG8pKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5leHQuZnJvbSA8IHNwYW4udG8pIHtcbiAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucykgeyB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTsgfVxuICAgICAgICAgIC8vIFRoZSBlbmQgb2YgdGhpcyBvbmUgb3ZlcmxhcHMgd2l0aCBhIHN1YnNlcXVlbnQgc3Bhbi4gU3BsaXRcbiAgICAgICAgICAvLyB0aGlzIG9uZS5cbiAgICAgICAgICB3b3JraW5nW2ldID0gc3Bhbi5jb3B5KHNwYW4uZnJvbSwgbmV4dC5mcm9tKTtcbiAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqLCBzcGFuLmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9IH1cbiAgfVxuICByZXR1cm4gd29ya2luZ1xufVxuXG5mdW5jdGlvbiBpbnNlcnRBaGVhZChhcnJheSwgaSwgZGVjbykge1xuICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCAmJiBieVBvcyhkZWNvLCBhcnJheVtpXSkgPiAwKSB7IGkrKzsgfVxuICBhcnJheS5zcGxpY2UoaSwgMCwgZGVjbyk7XG59XG5cbi8vIDogKEVkaXRvclZpZXcpIOKGkiB1bmlvbjxEZWNvcmF0aW9uU2V0LCBEZWNvcmF0aW9uR3JvdXA+XG4vLyBHZXQgdGhlIGRlY29yYXRpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBwcm9wcyBvZiBhIHZpZXcuXG5mdW5jdGlvbiB2aWV3RGVjb3JhdGlvbnModmlldykge1xuICB2YXIgZm91bmQgPSBbXTtcbiAgdmlldy5zb21lUHJvcChcImRlY29yYXRpb25zXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIHJlc3VsdCA9IGYodmlldy5zdGF0ZSk7XG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgIT0gZW1wdHkpIHsgZm91bmQucHVzaChyZXN1bHQpOyB9XG4gIH0pO1xuICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKVxuICAgIHsgZm91bmQucHVzaChEZWNvcmF0aW9uU2V0LmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgW3ZpZXcuY3Vyc29yV3JhcHBlci5kZWNvXSkpOyB9XG4gIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZClcbn1cblxuLy8gOjotIEFuIGVkaXRvciB2aWV3IG1hbmFnZXMgdGhlIERPTSBzdHJ1Y3R1cmUgdGhhdCByZXByZXNlbnRzIGFuXG4vLyBlZGl0YWJsZSBkb2N1bWVudC4gSXRzIHN0YXRlIGFuZCBiZWhhdmlvciBhcmUgZGV0ZXJtaW5lZCBieSBpdHNcbi8vIFtwcm9wc10oI3ZpZXcuRGlyZWN0RWRpdG9yUHJvcHMpLlxudmFyIEVkaXRvclZpZXcgPSBmdW5jdGlvbiBFZGl0b3JWaWV3KHBsYWNlLCBwcm9wcykge1xuICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuICAvLyA6OiBFZGl0b3JTdGF0ZVxuICAvLyBUaGUgdmlldydzIGN1cnJlbnQgW3N0YXRlXSgjc3RhdGUuRWRpdG9yU3RhdGUpLlxuICB0aGlzLnN0YXRlID0gcHJvcHMuc3RhdGU7XG5cbiAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgdGhpcy5kaXJlY3RQbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG5cbiAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcblxuICB0aGlzLl9yb290ID0gbnVsbDtcbiAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gIC8vIEtsdWRnZSB1c2VkIHRvIHdvcmsgYXJvdW5kIGEgQ2hyb21lIGJ1Z1xuICB0aGlzLnRyYWNrV3JpdGVzID0gbnVsbDtcblxuICAvLyA6OiBkb20uRWxlbWVudFxuICAvLyBBbiBlZGl0YWJsZSBET00gbm9kZSBjb250YWluaW5nIHRoZSBkb2N1bWVudC4gKFlvdSBwcm9iYWJseVxuICAvLyBzaG91bGQgbm90IGRpcmVjdGx5IGludGVyZmVyZSB3aXRoIGl0cyBjb250ZW50LilcbiAgdGhpcy5kb20gPSAocGxhY2UgJiYgcGxhY2UubW91bnQpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGlmIChwbGFjZSkge1xuICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZCkgeyBwbGFjZS5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7IH1cbiAgICBlbHNlIGlmIChwbGFjZS5hcHBseSkgeyBwbGFjZSh0aGlzLmRvbSk7IH1cbiAgICBlbHNlIGlmIChwbGFjZS5tb3VudCkgeyB0aGlzLm1vdW50ZWQgPSB0cnVlOyB9XG4gIH1cblxuICAvLyA6OiBib29sXG4gIC8vIEluZGljYXRlcyB3aGV0aGVyIHRoZSBlZGl0b3IgaXMgY3VycmVudGx5IFtlZGl0YWJsZV0oI3ZpZXcuRWRpdG9yUHJvcHMuZWRpdGFibGUpLlxuICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gIHRoaXMubWFya0N1cnNvciA9IG51bGw7XG4gIHRoaXMuY3Vyc29yV3JhcHBlciA9IG51bGw7XG4gIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gIHRoaXMubm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHRoaXMuc3RhdGUuZG9jLCBjb21wdXRlRG9jRGVjbyh0aGlzKSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzLmRvbSwgdGhpcyk7XG5cbiAgdGhpcy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IG51bGw7XG4gIC8vIDo6ID97c2xpY2U6IFNsaWNlLCBtb3ZlOiBib29sfVxuICAvLyBXaGVuIGVkaXRvciBjb250ZW50IGlzIGJlaW5nIGRyYWdnZWQsIHRoaXMgb2JqZWN0IGNvbnRhaW5zXG4gIC8vIGluZm9ybWF0aW9uIGFib3V0IHRoZSBkcmFnZ2VkIHNsaWNlIGFuZCB3aGV0aGVyIGl0IGlzIGJlaW5nXG4gIC8vIGNvcGllZCBvciBtb3ZlZC4gQXQgYW55IG90aGVyIHRpbWUsIGl0IGlzIG51bGwuXG4gIHRoaXMuZHJhZ2dpbmcgPSBudWxsO1xuXG4gIGluaXRJbnB1dCh0aGlzKTtcblxuICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gW107XG4gIHRoaXMucGx1Z2luVmlld3MgPSBbXTtcbiAgdGhpcy51cGRhdGVQbHVnaW5WaWV3cygpO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQyID0geyBwcm9wczogeyBjb25maWd1cmFibGU6IHRydWUgfSxyb290OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIGNvbXBvc2luZzo6IGJvb2xlYW5cbi8vIEhvbGRzIGB0cnVlYCB3aGVuIGFcbi8vIFtjb21wb3NpdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Nb3ppbGxhL0lNRV9oYW5kbGluZ19ndWlkZSlcbi8vIGlzIGFjdGl2ZS5cblxuLy8gOjogRGlyZWN0RWRpdG9yUHJvcHNcbi8vIFRoZSB2aWV3J3MgY3VycmVudCBbcHJvcHNdKCN2aWV3LkVkaXRvclByb3BzKS5cbnByb3RvdHlwZUFjY2Vzc29ycyQyLnByb3BzLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3Byb3BzLnN0YXRlICE9IHRoaXMuc3RhdGUpIHtcbiAgICB2YXIgcHJldiA9IHRoaXMuX3Byb3BzO1xuICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2KSB7IHRoaXMuX3Byb3BzW25hbWVdID0gcHJldltuYW1lXTsgfVxuICAgIHRoaXMuX3Byb3BzLnN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fcHJvcHNcbn07XG5cbi8vIDo6IChEaXJlY3RFZGl0b3JQcm9wcylcbi8vIFVwZGF0ZSB0aGUgdmlldydzIHByb3BzLiBXaWxsIGltbWVkaWF0ZWx5IGNhdXNlIGFuIHVwZGF0ZSB0b1xuLy8gdGhlIERPTS5cbkVkaXRvclZpZXcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAocHJvcHMpIHtcbiAgaWYgKHByb3BzLmhhbmRsZURPTUV2ZW50cyAhPSB0aGlzLl9wcm9wcy5oYW5kbGVET01FdmVudHMpIHsgZW5zdXJlTGlzdGVuZXJzKHRoaXMpOyB9XG4gIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gIGlmIChwcm9wcy5wbHVnaW5zKSB7XG4gICAgcHJvcHMucGx1Z2lucy5mb3JFYWNoKGNoZWNrU3RhdGVDb21wb25lbnQpO1xuICAgIHRoaXMuZGlyZWN0UGx1Z2lucyA9IHByb3BzLnBsdWdpbnM7XG4gIH1cbiAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHByb3BzLnN0YXRlLCB0cnVlKTtcbn07XG5cbi8vIDo6IChEaXJlY3RFZGl0b3JQcm9wcylcbi8vIFVwZGF0ZSB0aGUgdmlldyBieSB1cGRhdGluZyBleGlzdGluZyBwcm9wcyBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0XG4vLyBnaXZlbiBhcyBhcmd1bWVudC4gRXF1aXZhbGVudCB0byBgdmlldy51cGRhdGUoT2JqZWN0LmFzc2lnbih7fSxcbi8vIHZpZXcucHJvcHMsIHByb3BzKSlgLlxuRWRpdG9yVmlldy5wcm90b3R5cGUuc2V0UHJvcHMgPSBmdW5jdGlvbiBzZXRQcm9wcyAocHJvcHMpIHtcbiAgdmFyIHVwZGF0ZWQgPSB7fTtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLl9wcm9wcykgeyB1cGRhdGVkW25hbWVdID0gdGhpcy5fcHJvcHNbbmFtZV07IH1cbiAgdXBkYXRlZC5zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gIGZvciAodmFyIG5hbWUkMSBpbiBwcm9wcykgeyB1cGRhdGVkW25hbWUkMV0gPSBwcm9wc1tuYW1lJDFdOyB9XG4gIHRoaXMudXBkYXRlKHVwZGF0ZWQpO1xufTtcblxuLy8gOjogKEVkaXRvclN0YXRlKVxuLy8gVXBkYXRlIHRoZSBlZGl0b3IncyBgc3RhdGVgIHByb3AsIHdpdGhvdXQgdG91Y2hpbmcgYW55IG9mIHRoZVxuLy8gb3RoZXIgcHJvcHMuXG5FZGl0b3JWaWV3LnByb3RvdHlwZS51cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlIChzdGF0ZSkge1xuICB0aGlzLnVwZGF0ZVN0YXRlSW5uZXIoc3RhdGUsIHRoaXMuc3RhdGUucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zKTtcbn07XG5cbkVkaXRvclZpZXcucHJvdG90eXBlLnVwZGF0ZVN0YXRlSW5uZXIgPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZUlubmVyIChzdGF0ZSwgcmVjb25maWd1cmVkKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHByZXYgPSB0aGlzLnN0YXRlLCByZWRyYXcgPSBmYWxzZSwgdXBkYXRlU2VsID0gZmFsc2U7XG4gIC8vIFdoZW4gc3RvcmVkIG1hcmtzIGFyZSBhZGRlZCwgc3RvcCBjb21wb3NpdGlvbiwgc28gdGhhdCB0aGV5IGNhblxuICAvLyBiZSBkaXNwbGF5ZWQuXG4gIGlmIChzdGF0ZS5zdG9yZWRNYXJrcyAmJiB0aGlzLmNvbXBvc2luZykge1xuICAgIGNsZWFyQ29tcG9zaXRpb24odGhpcyk7XG4gICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgfVxuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIGlmIChyZWNvbmZpZ3VyZWQpIHtcbiAgICB2YXIgbm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgaWYgKGNoYW5nZWROb2RlVmlld3Mobm9kZVZpZXdzLCB0aGlzLm5vZGVWaWV3cykpIHtcbiAgICAgIHRoaXMubm9kZVZpZXdzID0gbm9kZVZpZXdzO1xuICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICB9XG4gICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICB9XG5cbiAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICB2YXIgaW5uZXJEZWNvID0gdmlld0RlY29yYXRpb25zKHRoaXMpLCBvdXRlckRlY28gPSBjb21wdXRlRG9jRGVjbyh0aGlzKTtcblxuICB2YXIgc2Nyb2xsID0gcmVjb25maWd1cmVkID8gXCJyZXNldFwiXG4gICAgICA6IHN0YXRlLnNjcm9sbFRvU2VsZWN0aW9uID4gcHJldi5zY3JvbGxUb1NlbGVjdGlvbiA/IFwidG8gc2VsZWN0aW9uXCIgOiBcInByZXNlcnZlXCI7XG4gIHZhciB1cGRhdGVEb2MgPSByZWRyYXcgfHwgIXRoaXMuZG9jVmlldy5tYXRjaGVzTm9kZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgaWYgKHVwZGF0ZURvYyB8fCAhc3RhdGUuc2VsZWN0aW9uLmVxKHByZXYuc2VsZWN0aW9uKSkgeyB1cGRhdGVTZWwgPSB0cnVlOyB9XG4gIHZhciBvbGRTY3JvbGxQb3MgPSBzY3JvbGwgPT0gXCJwcmVzZXJ2ZVwiICYmIHVwZGF0ZVNlbCAmJiB0aGlzLmRvbS5zdHlsZS5vdmVyZmxvd0FuY2hvciA9PSBudWxsICYmIHN0b3JlU2Nyb2xsUG9zKHRoaXMpO1xuXG4gIGlmICh1cGRhdGVTZWwpIHtcbiAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAvLyBXb3JrIGFyb3VuZCBhbiBpc3N1ZSBpbiBDaHJvbWUsIElFLCBhbmQgRWRnZSB3aGVyZSBjaGFuZ2luZ1xuICAgIC8vIHRoZSBET00gYXJvdW5kIGFuIGFjdGl2ZSBzZWxlY3Rpb24gcHV0cyBpdCBpbnRvIGEgYnJva2VuXG4gICAgLy8gc3RhdGUgd2hlcmUgdGhlIHRoaW5nIHRoZSB1c2VyIHNlZXMgZGlmZmVycyBmcm9tIHRoZVxuICAgIC8vIHNlbGVjdGlvbiByZXBvcnRlZCBieSB0aGUgU2VsZWN0aW9uIG9iamVjdCAoIzcxMCwgIzk3MyxcbiAgICAvLyAjMTAxMSwgIzEwMTMsICMxMDM1KS5cbiAgICB2YXIgZm9yY2VTZWxVcGRhdGUgPSB1cGRhdGVEb2MgJiYgKHJlc3VsdC5pZSB8fCByZXN1bHQuY2hyb21lKSAmJiAhdGhpcy5jb21wb3NpbmcgJiZcbiAgICAgICAgIXByZXYuc2VsZWN0aW9uLmVtcHR5ICYmICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgc2VsZWN0aW9uQ29udGV4dENoYW5nZWQocHJldi5zZWxlY3Rpb24sIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgaWYgKHVwZGF0ZURvYykge1xuICAgICAgLy8gSWYgdGhlIG5vZGUgdGhhdCB0aGUgc2VsZWN0aW9uIHBvaW50cyBpbnRvIGlzIHdyaXR0ZW4gdG8sXG4gICAgICAvLyBDaHJvbWUgc29tZXRpbWVzIHN0YXJ0cyBtaXNyZXBvcnRpbmcgdGhlIHNlbGVjdGlvbiwgc28gdGhpc1xuICAgICAgLy8gdHJhY2tzIHRoYXQgYW5kIGZvcmNlcyBhIHNlbGVjdGlvbiByZXNldCB3aGVuIG91ciB1cGRhdGVcbiAgICAgIC8vIGRpZCB3cml0ZSB0byB0aGUgbm9kZS5cbiAgICAgIHZhciBjaHJvbWVLbHVkZ2UgPSByZXN1bHQuY2hyb21lID8gKHRoaXMudHJhY2tXcml0ZXMgPSB0aGlzLnJvb3QuZ2V0U2VsZWN0aW9uKCkuZm9jdXNOb2RlKSA6IG51bGw7XG4gICAgICBpZiAocmVkcmF3IHx8ICF0aGlzLmRvY1ZpZXcudXBkYXRlKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMpKSB7XG4gICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVPdXRlckRlY28oW10pO1xuICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyhzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzLmRvbSwgdGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoY2hyb21lS2x1ZGdlICYmICF0aGlzLnRyYWNrV3JpdGVzKSB7IGZvcmNlU2VsVXBkYXRlID0gdHJ1ZTsgfVxuICAgIH1cbiAgICAvLyBXb3JrIGFyb3VuZCBmb3IgYW4gaXNzdWUgd2hlcmUgYW4gdXBkYXRlIGFycml2aW5nIHJpZ2h0IGJldHdlZW5cbiAgICAvLyBhIERPTSBzZWxlY3Rpb24gY2hhbmdlIGFuZCB0aGUgXCJzZWxlY3Rpb25jaGFuZ2VcIiBldmVudCBmb3IgaXRcbiAgICAvLyBjYW4gY2F1c2UgYSBzcHVyaW91cyBET00gc2VsZWN0aW9uIHVwZGF0ZSwgZGlzcnVwdGluZyBtb3VzZVxuICAgIC8vIGRyYWcgc2VsZWN0aW9uLlxuICAgIGlmIChmb3JjZVNlbFVwZGF0ZSB8fFxuICAgICAgICAhKHRoaXMubW91c2VEb3duICYmIHRoaXMuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh0aGlzLnJvb3QuZ2V0U2VsZWN0aW9uKCkpICYmIGFuY2hvckluUmlnaHRQbGFjZSh0aGlzKSkpIHtcbiAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMsIGZvcmNlU2VsVXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3luY05vZGVTZWxlY3Rpb24odGhpcywgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgfVxuXG4gIHRoaXMudXBkYXRlUGx1Z2luVmlld3MocHJldik7XG5cbiAgaWYgKHNjcm9sbCA9PSBcInJlc2V0XCIpIHtcbiAgICB0aGlzLmRvbS5zY3JvbGxUb3AgPSAwO1xuICB9IGVsc2UgaWYgKHNjcm9sbCA9PSBcInRvIHNlbGVjdGlvblwiKSB7XG4gICAgdmFyIHN0YXJ0RE9NID0gdGhpcy5yb290LmdldFNlbGVjdGlvbigpLmZvY3VzTm9kZTtcbiAgICBpZiAodGhpcy5zb21lUHJvcChcImhhbmRsZVNjcm9sbFRvU2VsZWN0aW9uXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHRoaXMkMSk7IH0pKVxuICAgICAgOyAvLyBIYW5kbGVkXG4gICAgZWxzZSBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbilcbiAgICAgIHsgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRoaXMuZG9jVmlldy5kb21BZnRlclBvcyhzdGF0ZS5zZWxlY3Rpb24uZnJvbSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHN0YXJ0RE9NKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRoaXMuY29vcmRzQXRQb3Moc3RhdGUuc2VsZWN0aW9uLmhlYWQsIDEpLCBzdGFydERPTSk7IH1cbiAgfSBlbHNlIGlmIChvbGRTY3JvbGxQb3MpIHtcbiAgICByZXNldFNjcm9sbFBvcyhvbGRTY3JvbGxQb3MpO1xuICB9XG59O1xuXG5FZGl0b3JWaWV3LnByb3RvdHlwZS5kZXN0cm95UGx1Z2luVmlld3MgPSBmdW5jdGlvbiBkZXN0cm95UGx1Z2luVmlld3MgKCkge1xuICB2YXIgdmlldztcbiAgd2hpbGUgKHZpZXcgPSB0aGlzLnBsdWdpblZpZXdzLnBvcCgpKSB7IGlmICh2aWV3LmRlc3Ryb3kpIHsgdmlldy5kZXN0cm95KCk7IH0gfVxufTtcblxuRWRpdG9yVmlldy5wcm90b3R5cGUudXBkYXRlUGx1Z2luVmlld3MgPSBmdW5jdGlvbiB1cGRhdGVQbHVnaW5WaWV3cyAocHJldlN0YXRlKSB7XG4gIGlmICghcHJldlN0YXRlIHx8IHByZXZTdGF0ZS5wbHVnaW5zICE9IHRoaXMuc3RhdGUucGx1Z2lucyB8fCB0aGlzLmRpcmVjdFBsdWdpbnMgIT0gdGhpcy5wcmV2RGlyZWN0UGx1Z2lucykge1xuICAgIHRoaXMucHJldkRpcmVjdFBsdWdpbnMgPSB0aGlzLmRpcmVjdFBsdWdpbnM7XG4gICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBsdWdpbiA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXTtcbiAgICAgIGlmIChwbHVnaW4uc3BlYy52aWV3KSB7IHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTsgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLnN0YXRlLnBsdWdpbnMubGVuZ3RoOyBpJDErKykge1xuICAgICAgdmFyIHBsdWdpbiQxID0gdGhpcy5zdGF0ZS5wbHVnaW5zW2kkMV07XG4gICAgICBpZiAocGx1Z2luJDEuc3BlYy52aWV3KSB7IHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4kMS5zcGVjLnZpZXcodGhpcykpOyB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHRoaXMucGx1Z2luVmlld3MubGVuZ3RoOyBpJDIrKykge1xuICAgICAgdmFyIHBsdWdpblZpZXcgPSB0aGlzLnBsdWdpblZpZXdzW2kkMl07XG4gICAgICBpZiAocGx1Z2luVmlldy51cGRhdGUpIHsgcGx1Z2luVmlldy51cGRhdGUodGhpcywgcHJldlN0YXRlKTsgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gOjogKHN0cmluZywgPyhwcm9wOiAqKSDihpIgKikg4oaSICpcbi8vIEdvZXMgb3ZlciB0aGUgdmFsdWVzIG9mIGEgcHJvcCwgZmlyc3QgdGhvc2UgcHJvdmlkZWQgZGlyZWN0bHksXG4vLyB0aGVuIHRob3NlIGZyb20gcGx1Z2lucyBnaXZlbiB0byB0aGUgdmlldywgdGhlbiBmcm9tIHBsdWdpbnMgaW5cbi8vIHRoZSBzdGF0ZSAoaW4gb3JkZXIpLCBhbmQgY2FsbHMgYGZgIGV2ZXJ5IHRpbWUgYSBub24tdW5kZWZpbmVkXG4vLyB2YWx1ZSBpcyBmb3VuZC4gV2hlbiBgZmAgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSwgdGhhdCBpc1xuLy8gaW1tZWRpYXRlbHkgcmV0dXJuZWQuIFdoZW4gYGZgIGlzbid0IHByb3ZpZGVkLCBpdCBpcyB0cmVhdGVkIGFzXG4vLyB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gKHRoZSBwcm9wIHZhbHVlIGlzIHJldHVybmVkIGRpcmVjdGx5KS5cbkVkaXRvclZpZXcucHJvdG90eXBlLnNvbWVQcm9wID0gZnVuY3Rpb24gc29tZVByb3AgKHByb3BOYW1lLCBmKSB7XG4gIHZhciBwcm9wID0gdGhpcy5fcHJvcHMgJiYgdGhpcy5fcHJvcHNbcHJvcE5hbWVdLCB2YWx1ZTtcbiAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKSB7IHJldHVybiB2YWx1ZSB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AkMSA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKHByb3AkMSAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3AkMSkgOiBwcm9wJDEpKSB7IHJldHVybiB2YWx1ZSB9XG4gIH1cbiAgdmFyIHBsdWdpbnMgPSB0aGlzLnN0YXRlLnBsdWdpbnM7XG4gIGlmIChwbHVnaW5zKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBsdWdpbnMubGVuZ3RoOyBpJDErKykge1xuICAgIHZhciBwcm9wJDIgPSBwbHVnaW5zW2kkMV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmIChwcm9wJDIgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wJDIpIDogcHJvcCQyKSkgeyByZXR1cm4gdmFsdWUgfVxuICB9IH1cbn07XG5cbi8vIDo6ICgpIOKGkiBib29sXG4vLyBRdWVyeSB3aGV0aGVyIHRoZSB2aWV3IGhhcyBmb2N1cy5cbkVkaXRvclZpZXcucHJvdG90eXBlLmhhc0ZvY3VzID0gZnVuY3Rpb24gaGFzRm9jdXMgKCkge1xuICByZXR1cm4gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb21cbn07XG5cbi8vIDo6ICgpXG4vLyBGb2N1cyB0aGUgZWRpdG9yLlxuRWRpdG9yVmlldy5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiBmb2N1cyAoKSB7XG4gIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICBpZiAodGhpcy5lZGl0YWJsZSkgeyBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5kb20pOyB9XG4gIHNlbGVjdGlvblRvRE9NKHRoaXMpO1xuICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG59O1xuXG4vLyA6OiB1bmlvbjxkb20uRG9jdW1lbnQsIGRvbS5Eb2N1bWVudEZyYWdtZW50PlxuLy8gR2V0IHRoZSBkb2N1bWVudCByb290IGluIHdoaWNoIHRoZSBlZGl0b3IgZXhpc3RzLiBUaGlzIHdpbGxcbi8vIHVzdWFsbHkgYmUgdGhlIHRvcC1sZXZlbCBgZG9jdW1lbnRgLCBidXQgbWlnaHQgYmUgYSBbc2hhZG93XG4vLyBET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1dlYl9Db21wb25lbnRzL1NoYWRvd19ET00pXG4vLyByb290IGlmIHRoZSBlZGl0b3IgaXMgaW5zaWRlIG9uZS5cbnByb3RvdHlwZUFjY2Vzc29ycyQyLnJvb3QuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fcm9vdDtcbiAgaWYgKGNhY2hlZCA9PSBudWxsKSB7IGZvciAodmFyIHNlYXJjaCA9IHRoaXMuZG9tLnBhcmVudE5vZGU7IHNlYXJjaDsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICBpZiAoc2VhcmNoLm5vZGVUeXBlID09IDkgfHwgKHNlYXJjaC5ub2RlVHlwZSA9PSAxMSAmJiBzZWFyY2guaG9zdCkpIHtcbiAgICAgIGlmICghc2VhcmNoLmdldFNlbGVjdGlvbikgeyBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VhcmNoKS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTsgfTsgfVxuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QgPSBzZWFyY2hcbiAgICB9XG4gIH0gfVxuICByZXR1cm4gY2FjaGVkIHx8IGRvY3VtZW50XG59O1xuXG4vLyA6OiAoe2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9KSDihpIgP3twb3M6IG51bWJlciwgaW5zaWRlOiBudW1iZXJ9XG4vLyBHaXZlbiBhIHBhaXIgb2Ygdmlld3BvcnQgY29vcmRpbmF0ZXMsIHJldHVybiB0aGUgZG9jdW1lbnRcbi8vIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlbS4gTWF5IHJldHVybiBudWxsIGlmIHRoZSBnaXZlblxuLy8gY29vcmRpbmF0ZXMgYXJlbid0IGluc2lkZSBvZiB0aGUgZWRpdG9yLiBXaGVuIGFuIG9iamVjdCBpc1xuLy8gcmV0dXJuZWQsIGl0cyBgcG9zYCBwcm9wZXJ0eSBpcyB0aGUgcG9zaXRpb24gbmVhcmVzdCB0byB0aGVcbi8vIGNvb3JkaW5hdGVzLCBhbmQgaXRzIGBpbnNpZGVgIHByb3BlcnR5IGhvbGRzIHRoZSBwb3NpdGlvbiBvZiB0aGVcbi8vIGlubmVyIG5vZGUgdGhhdCB0aGUgcG9zaXRpb24gZmFsbHMgaW5zaWRlIG9mLCBvciAtMSBpZiBpdCBpcyBhdFxuLy8gdGhlIHRvcCBsZXZlbCwgbm90IGluIGFueSBub2RlLlxuRWRpdG9yVmlldy5wcm90b3R5cGUucG9zQXRDb29yZHMgPSBmdW5jdGlvbiBwb3NBdENvb3JkcyQxIChjb29yZHMpIHtcbiAgcmV0dXJuIHBvc0F0Q29vcmRzKHRoaXMsIGNvb3Jkcylcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlcikg4oaSIHtsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBib3R0b206IG51bWJlcn1cbi8vIFJldHVybnMgdGhlIHZpZXdwb3J0IHJlY3RhbmdsZSBhdCBhIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuLy8gYGxlZnRgIGFuZCBgcmlnaHRgIHdpbGwgYmUgdGhlIHNhbWUgbnVtYmVyLCBhcyB0aGlzIHJldHVybnMgYVxuLy8gZmxhdCBjdXJzb3ItaXNoIHJlY3RhbmdsZS4gSWYgdGhlIHBvc2l0aW9uIGlzIGJldHdlZW4gdHdvIHRoaW5nc1xuLy8gdGhhdCBhcmVuJ3QgZGlyZWN0bHkgYWRqYWNlbnQsIGBzaWRlYCBkZXRlcm1pbmVzIHdoaWNoIGVsZW1lbnQgaXNcbi8vIHVzZWQuIFdoZW4gPCAwLCB0aGUgZWxlbWVudCBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHVzZWQsXG4vLyBvdGhlcndpc2UgdGhlIGVsZW1lbnQgYWZ0ZXIuXG5FZGl0b3JWaWV3LnByb3RvdHlwZS5jb29yZHNBdFBvcyA9IGZ1bmN0aW9uIGNvb3Jkc0F0UG9zJDEgKHBvcywgc2lkZSkge1xuICAgIGlmICggc2lkZSA9PT0gdm9pZCAwICkgc2lkZSA9IDE7XG5cbiAgcmV0dXJuIGNvb3Jkc0F0UG9zKHRoaXMsIHBvcywgc2lkZSlcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlcikg4oaSIHtub2RlOiBkb20uTm9kZSwgb2Zmc2V0OiBudW1iZXJ9XG4vLyBGaW5kIHRoZSBET00gcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gZG9jdW1lbnRcbi8vIHBvc2l0aW9uLiBXaGVuIGBzaWRlYCBpcyBuZWdhdGl2ZSwgZmluZCB0aGUgcG9zaXRpb24gYXMgY2xvc2UgYXNcbi8vIHBvc3NpYmxlIHRvIHRoZSBjb250ZW50IGJlZm9yZSB0aGUgcG9zaXRpb24uIFdoZW4gcG9zaXRpdmUsXG4vLyBwcmVmZXIgcG9zaXRpb25zIGNsb3NlIHRvIHRoZSBjb250ZW50IGFmdGVyIHRoZSBwb3NpdGlvbi4gV2hlblxuLy8gemVybywgcHJlZmVyIGFzIHNoYWxsb3cgYSBwb3NpdGlvbiBhcyBwb3NzaWJsZS5cbi8vXG4vLyBOb3RlIHRoYXQgeW91IHNob3VsZCAqKm5vdCoqIG11dGF0ZSB0aGUgZWRpdG9yJ3MgaW50ZXJuYWwgRE9NLFxuLy8gb25seSBpbnNwZWN0IGl0IChhbmQgZXZlbiB0aGF0IGlzIHVzdWFsbHkgbm90IG5lY2Vzc2FyeSkuXG5FZGl0b3JWaWV3LnByb3RvdHlwZS5kb21BdFBvcyA9IGZ1bmN0aW9uIGRvbUF0UG9zIChwb3MsIHNpZGUpIHtcbiAgICBpZiAoIHNpZGUgPT09IHZvaWQgMCApIHNpZGUgPSAwO1xuXG4gIHJldHVybiB0aGlzLmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIHNpZGUpXG59O1xuXG4vLyA6OiAobnVtYmVyKSDihpIgP2RvbS5Ob2RlXG4vLyBGaW5kIHRoZSBET00gbm9kZSB0aGF0IHJlcHJlc2VudHMgdGhlIGRvY3VtZW50IG5vZGUgYWZ0ZXIgdGhlXG4vLyBnaXZlbiBwb3NpdGlvbi4gTWF5IHJldHVybiBgbnVsbGAgd2hlbiB0aGUgcG9zaXRpb24gZG9lc24ndCBwb2ludFxuLy8gaW4gZnJvbnQgb2YgYSBub2RlIG9yIGlmIHRoZSBub2RlIGlzIGluc2lkZSBhbiBvcGFxdWUgbm9kZSB2aWV3LlxuLy9cbi8vIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYWJsZSB0byBjYWxsIHRoaW5ncyBsaWtlXG4vLyBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBvbiB0aGF0IERPTSBub2RlLiBEbyAqKm5vdCoqIG11dGF0ZSB0aGVcbi8vIGVkaXRvciBET00gZGlyZWN0bHksIG9yIGFkZCBzdHlsaW5nIHRoaXMgd2F5LCBzaW5jZSB0aGF0IHdpbGwgYmVcbi8vIGltbWVkaWF0ZWx5IG92ZXJyaWRlbiBieSB0aGUgZWRpdG9yIGFzIGl0IHJlZHJhd3MgdGhlIG5vZGUuXG5FZGl0b3JWaWV3LnByb3RvdHlwZS5ub2RlRE9NID0gZnVuY3Rpb24gbm9kZURPTSAocG9zKSB7XG4gIHZhciBkZXNjID0gdGhpcy5kb2NWaWV3LmRlc2NBdChwb3MpO1xuICByZXR1cm4gZGVzYyA/IGRlc2Mubm9kZURPTSA6IG51bGxcbn07XG5cbi8vIDo6IChkb20uTm9kZSwgbnVtYmVyLCA/bnVtYmVyKSDihpIgbnVtYmVyXG4vLyBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgZ2l2ZW4gRE9NXG4vLyBwb3NpdGlvbi4gKFdoZW5ldmVyIHBvc3NpYmxlLCBpdCBpcyBwcmVmZXJhYmxlIHRvIGluc3BlY3QgdGhlXG4vLyBkb2N1bWVudCBzdHJ1Y3R1cmUgZGlyZWN0bHksIHJhdGhlciB0aGFuIHBva2luZyBhcm91bmQgaW4gdGhlXG4vLyBET00sIGJ1dCBzb21ldGltZXPigJRmb3IgZXhhbXBsZSB3aGVuIGludGVycHJldGluZyBhbiBldmVudFxuLy8gdGFyZ2V04oCUeW91IGRvbid0IGhhdmUgYSBjaG9pY2UuKVxuLy9cbi8vIFRoZSBgYmlhc2AgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIGluZmx1ZW5jZSB3aGljaCBzaWRlIG9mIGEgRE9NXG4vLyBub2RlIHRvIHVzZSB3aGVuIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgYSBsZWFmIG5vZGUuXG5FZGl0b3JWaWV3LnByb3RvdHlwZS5wb3NBdERPTSA9IGZ1bmN0aW9uIHBvc0F0RE9NIChub2RlLCBvZmZzZXQsIGJpYXMpIHtcbiAgICBpZiAoIGJpYXMgPT09IHZvaWQgMCApIGJpYXMgPSAtMTtcblxuICB2YXIgcG9zID0gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCBiaWFzKTtcbiAgaWYgKHBvcyA9PSBudWxsKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiRE9NIHBvc2l0aW9uIG5vdCBpbnNpZGUgdGhlIGVkaXRvclwiKSB9XG4gIHJldHVybiBwb3Ncbn07XG5cbi8vIDo6ICh1bmlvbjxcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImZvcndhcmRcIiwgXCJiYWNrd2FyZFwiPiwgP0VkaXRvclN0YXRlKSDihpIgYm9vbFxuLy8gRmluZCBvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2sgd2hlblxuLy8gbW92aW5nIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLiBXaGVuLCBmb3IgZXhhbXBsZSwgZ2l2ZW4gYFwibGVmdFwiYCxcbi8vIGl0IHdpbGwgcmV0dXJuIHRydWUgaWYgbW92aW5nIGxlZnQgZnJvbSB0aGUgY3VycmVudCBjdXJzb3Jcbi8vIHBvc2l0aW9uIHdvdWxkIGxlYXZlIHRoYXQgcG9zaXRpb24ncyBwYXJlbnQgdGV4dGJsb2NrLiBXaWxsIGFwcGx5XG4vLyB0byB0aGUgdmlldydzIGN1cnJlbnQgc3RhdGUgYnkgZGVmYXVsdCwgYnV0IGl0IGlzIHBvc3NpYmxlIHRvXG4vLyBwYXNzIGEgZGlmZmVyZW50IHN0YXRlLlxuRWRpdG9yVmlldy5wcm90b3R5cGUuZW5kT2ZUZXh0YmxvY2sgPSBmdW5jdGlvbiBlbmRPZlRleHRibG9jayQxIChkaXIsIHN0YXRlKSB7XG4gIHJldHVybiBlbmRPZlRleHRibG9jayh0aGlzLCBzdGF0ZSB8fCB0aGlzLnN0YXRlLCBkaXIpXG59O1xuXG4vLyA6OiAoKVxuLy8gUmVtb3ZlcyB0aGUgZWRpdG9yIGZyb20gdGhlIERPTSBhbmQgZGVzdHJveXMgYWxsIFtub2RlXG4vLyB2aWV3c10oI3ZpZXcuTm9kZVZpZXcpLlxuRWRpdG9yVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICBpZiAoIXRoaXMuZG9jVmlldykgeyByZXR1cm4gfVxuICBkZXN0cm95SW5wdXQodGhpcyk7XG4gIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICB0aGlzLmRvY1ZpZXcudXBkYXRlKHRoaXMuc3RhdGUuZG9jLCBbXSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzKTtcbiAgICB0aGlzLmRvbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gIH0gZWxzZSBpZiAodGhpcy5kb20ucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20pO1xuICB9XG4gIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gIHRoaXMuZG9jVmlldyA9IG51bGw7XG59O1xuXG4vLyBVc2VkIGZvciB0ZXN0aW5nLlxuRWRpdG9yVmlldy5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQkMSAoZXZlbnQpIHtcbiAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgZXZlbnQpXG59O1xuXG4vLyA6OiAoVHJhbnNhY3Rpb24pXG4vLyBEaXNwYXRjaCBhIHRyYW5zYWN0aW9uLiBXaWxsIGNhbGxcbi8vIFtgZGlzcGF0Y2hUcmFuc2FjdGlvbmBdKCN2aWV3LkRpcmVjdEVkaXRvclByb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb24pXG4vLyB3aGVuIGdpdmVuLCBhbmQgb3RoZXJ3aXNlIGRlZmF1bHRzIHRvIGFwcGx5aW5nIHRoZSB0cmFuc2FjdGlvbiB0b1xuLy8gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGNhbGxpbmdcbi8vIFtgdXBkYXRlU3RhdGVgXSgjdmlldy5FZGl0b3JWaWV3LnVwZGF0ZVN0YXRlKSB3aXRoIHRoZSByZXN1bHQuXG4vLyBUaGlzIG1ldGhvZCBpcyBib3VuZCB0byB0aGUgdmlldyBpbnN0YW5jZSwgc28gdGhhdCBpdCBjYW4gYmVcbi8vIGVhc2lseSBwYXNzZWQgYXJvdW5kLlxuRWRpdG9yVmlldy5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAodHIpIHtcbiAgdmFyIGRpc3BhdGNoVHJhbnNhY3Rpb24gPSB0aGlzLl9wcm9wcy5kaXNwYXRjaFRyYW5zYWN0aW9uO1xuICBpZiAoZGlzcGF0Y2hUcmFuc2FjdGlvbikgeyBkaXNwYXRjaFRyYW5zYWN0aW9uLmNhbGwodGhpcywgdHIpOyB9XG4gIGVsc2UgeyB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUuYXBwbHkodHIpKTsgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEVkaXRvclZpZXcucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMiApO1xuXG5mdW5jdGlvbiBjb21wdXRlRG9jRGVjbyh2aWV3KSB7XG4gIHZhciBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGF0dHJzLmNsYXNzID0gXCJQcm9zZU1pcnJvclwiO1xuICBhdHRycy5jb250ZW50ZWRpdGFibGUgPSBTdHJpbmcodmlldy5lZGl0YWJsZSk7XG4gIGF0dHJzLnRyYW5zbGF0ZSA9IFwibm9cIjtcblxuICB2aWV3LnNvbWVQcm9wKFwiYXR0cmlidXRlc1wiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIikgeyB2YWx1ZSA9IHZhbHVlKHZpZXcuc3RhdGUpOyB9XG4gICAgaWYgKHZhbHVlKSB7IGZvciAodmFyIGF0dHIgaW4gdmFsdWUpIHtcbiAgICAgIGlmIChhdHRyID09IFwiY2xhc3NcIilcbiAgICAgICAgeyBhdHRycy5jbGFzcyArPSBcIiBcIiArIHZhbHVlW2F0dHJdOyB9XG4gICAgICBpZiAoYXR0ciA9PSBcInN0eWxlXCIpIHtcbiAgICAgICAgYXR0cnMuc3R5bGUgPSAoYXR0cnMuc3R5bGUgPyBhdHRycy5zdHlsZSArIFwiO1wiIDogXCJcIikgKyB2YWx1ZVthdHRyXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFhdHRyc1thdHRyXSAmJiBhdHRyICE9IFwiY29udGVudGVkaXRhYmxlXCIgJiYgYXR0ciAhPSBcIm5vZGVOYW1lXCIpXG4gICAgICAgIHsgYXR0cnNbYXR0cl0gPSBTdHJpbmcodmFsdWVbYXR0cl0pOyB9XG4gICAgfSB9XG4gIH0pO1xuXG4gIHJldHVybiBbRGVjb3JhdGlvbi5ub2RlKDAsIHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSwgYXR0cnMpXVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgaWYgKHZpZXcubWFya0N1cnNvcikge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXNlcGFyYXRvclwiO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJtYXJrLXBsYWNlaG9sZGVyXCIsIFwidHJ1ZVwiKTtcbiAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSB7ZG9tOiBkb20sIGRlY286IERlY29yYXRpb24ud2lkZ2V0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQsIGRvbSwge3JhdzogdHJ1ZSwgbWFya3M6IHZpZXcubWFya0N1cnNvcn0pfTtcbiAgfSBlbHNlIHtcbiAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEVkaXRhYmxlKHZpZXcpIHtcbiAgcmV0dXJuICF2aWV3LnNvbWVQcm9wKFwiZWRpdGFibGVcIiwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSh2aWV3LnN0YXRlKSA9PT0gZmFsc2U7IH0pXG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHNlbDEsIHNlbDIpIHtcbiAgdmFyIGRlcHRoID0gTWF0aC5taW4oc2VsMS4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDEuaGVhZCksIHNlbDIuJGFuY2hvci5zaGFyZWREZXB0aChzZWwyLmhlYWQpKTtcbiAgcmV0dXJuIHNlbDEuJGFuY2hvci5zdGFydChkZXB0aCkgIT0gc2VsMi4kYW5jaG9yLnN0YXJ0KGRlcHRoKVxufVxuXG5mdW5jdGlvbiBidWlsZE5vZGVWaWV3cyh2aWV3KSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmlldy5zb21lUHJvcChcIm5vZGVWaWV3c1wiLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBwcm9wKSlcbiAgICAgIHsgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdOyB9IH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY2hhbmdlZE5vZGVWaWV3cyhhLCBiKSB7XG4gIHZhciBuQSA9IDAsIG5CID0gMDtcbiAgZm9yICh2YXIgcHJvcCBpbiBhKSB7XG4gICAgaWYgKGFbcHJvcF0gIT0gYltwcm9wXSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgbkErKztcbiAgfVxuICBmb3IgKHZhciBfIGluIGIpIHsgbkIrKzsgfVxuICByZXR1cm4gbkEgIT0gbkJcbn1cblxuZnVuY3Rpb24gY2hlY2tTdGF0ZUNvbXBvbmVudChwbHVnaW4pIHtcbiAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlIHx8IHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uIHx8IHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKVxuICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQbHVnaW5zIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgdmlldyBtdXN0IG5vdCBoYXZlIGEgc3RhdGUgY29tcG9uZW50XCIpIH1cbn1cblxuLy8gRWRpdG9yUHJvcHM6OiBpbnRlcmZhY2Vcbi8vXG4vLyBQcm9wcyBhcmUgY29uZmlndXJhdGlvbiB2YWx1ZXMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGFuIGVkaXRvciB2aWV3XG4vLyBvciBpbmNsdWRlZCBpbiBhIHBsdWdpbi4gVGhpcyBpbnRlcmZhY2UgbGlzdHMgdGhlIHN1cHBvcnRlZCBwcm9wcy5cbi8vXG4vLyBUaGUgdmFyaW91cyBldmVudC1oYW5kbGluZyBmdW5jdGlvbnMgbWF5IGFsbCByZXR1cm4gYHRydWVgIHRvXG4vLyBpbmRpY2F0ZSB0aGF0IHRoZXkgaGFuZGxlZCB0aGUgZ2l2ZW4gZXZlbnQuIFRoZSB2aWV3IHdpbGwgdGhlbiB0YWtlXG4vLyBjYXJlIHRvIGNhbGwgYHByZXZlbnREZWZhdWx0YCBvbiB0aGUgZXZlbnQsIGV4Y2VwdCB3aXRoXG4vLyBgaGFuZGxlRE9NRXZlbnRzYCwgd2hlcmUgdGhlIGhhbmRsZXIgaXRzZWxmIGlzIHJlc3BvbnNpYmxlIGZvciB0aGF0LlxuLy9cbi8vIEhvdyBhIHByb3AgaXMgcmVzb2x2ZWQgZGVwZW5kcyBvbiB0aGUgcHJvcC4gSGFuZGxlciBmdW5jdGlvbnMgYXJlXG4vLyBjYWxsZWQgb25lIGF0IGEgdGltZSwgc3RhcnRpbmcgd2l0aCB0aGUgYmFzZSBwcm9wcyBhbmQgdGhlblxuLy8gc2VhcmNoaW5nIHRocm91Z2ggdGhlIHBsdWdpbnMgKGluIG9yZGVyIG9mIGFwcGVhcmFuY2UpIHVudGlsIG9uZSBvZlxuLy8gdGhlbSByZXR1cm5zIHRydWUuIEZvciBzb21lIHByb3BzLCB0aGUgZmlyc3QgcGx1Z2luIHRoYXQgeWllbGRzIGFcbi8vIHZhbHVlIGdldHMgcHJlY2VkZW5jZS5cbi8vXG4vLyAgIGhhbmRsZURPTUV2ZW50czo6ID9PYmplY3Q8KHZpZXc6IEVkaXRvclZpZXcsIGV2ZW50OiBkb20uRXZlbnQpIOKGkiBib29sPlxuLy8gICBDYW4gYmUgYW4gb2JqZWN0IG1hcHBpbmcgRE9NIGV2ZW50IHR5cGUgbmFtZXMgdG8gZnVuY3Rpb25zIHRoYXRcbi8vICAgaGFuZGxlIHRoZW0uIFN1Y2ggZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBhbnkgaGFuZGxpbmdcbi8vICAgUHJvc2VNaXJyb3IgZG9lcyBvZiBldmVudHMgZmlyZWQgb24gdGhlIGVkaXRhYmxlIERPTSBlbGVtZW50LlxuLy8gICBDb250cmFyeSB0byB0aGUgb3RoZXIgZXZlbnQgaGFuZGxpbmcgcHJvcHMsIHdoZW4gcmV0dXJuaW5nIHRydWVcbi8vICAgZnJvbSBzdWNoIGEgZnVuY3Rpb24sIHlvdSBhcmUgcmVzcG9uc2libGUgZm9yIGNhbGxpbmdcbi8vICAgYHByZXZlbnREZWZhdWx0YCB5b3Vyc2VsZiAob3Igbm90LCBpZiB5b3Ugd2FudCB0byBhbGxvdyB0aGVcbi8vICAgZGVmYXVsdCBiZWhhdmlvcikuXG4vL1xuLy8gICBoYW5kbGVLZXlEb3duOjogPyh2aWV3OiBFZGl0b3JWaWV3LCBldmVudDogZG9tLktleWJvYXJkRXZlbnQpIOKGkiBib29sXG4vLyAgIENhbGxlZCB3aGVuIHRoZSBlZGl0b3IgcmVjZWl2ZXMgYSBga2V5ZG93bmAgZXZlbnQuXG4vL1xuLy8gICBoYW5kbGVLZXlQcmVzczo6ID8odmlldzogRWRpdG9yVmlldywgZXZlbnQ6IGRvbS5LZXlib2FyZEV2ZW50KSDihpIgYm9vbFxuLy8gICBIYW5kbGVyIGZvciBga2V5cHJlc3NgIGV2ZW50cy5cbi8vXG4vLyAgIGhhbmRsZVRleHRJbnB1dDo6ID8odmlldzogRWRpdG9yVmlldywgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCB0ZXh0OiBzdHJpbmcpIOKGkiBib29sXG4vLyAgIFdoZW5ldmVyIHRoZSB1c2VyIGRpcmVjdGx5IGlucHV0IHRleHQsIHRoaXMgaGFuZGxlciBpcyBjYWxsZWRcbi8vICAgYmVmb3JlIHRoZSBpbnB1dCBpcyBhcHBsaWVkLiBJZiBpdCByZXR1cm5zIGB0cnVlYCwgdGhlIGRlZmF1bHRcbi8vICAgYmVoYXZpb3Igb2YgYWN0dWFsbHkgaW5zZXJ0aW5nIHRoZSB0ZXh0IGlzIHN1cHByZXNzZWQuXG4vL1xuLy8gICBoYW5kbGVDbGlja09uOjogPyh2aWV3OiBFZGl0b3JWaWV3LCBwb3M6IG51bWJlciwgbm9kZTogTm9kZSwgbm9kZVBvczogbnVtYmVyLCBldmVudDogZG9tLk1vdXNlRXZlbnQsIGRpcmVjdDogYm9vbCkg4oaSIGJvb2xcbi8vICAgQ2FsbGVkIGZvciBlYWNoIG5vZGUgYXJvdW5kIGEgY2xpY2ssIGZyb20gdGhlIGluc2lkZSBvdXQuIFRoZVxuLy8gICBgZGlyZWN0YCBmbGFnIHdpbGwgYmUgdHJ1ZSBmb3IgdGhlIGlubmVyIG5vZGUuXG4vL1xuLy8gICBoYW5kbGVDbGljazo6ID8odmlldzogRWRpdG9yVmlldywgcG9zOiBudW1iZXIsIGV2ZW50OiBkb20uTW91c2VFdmVudCkg4oaSIGJvb2xcbi8vICAgQ2FsbGVkIHdoZW4gdGhlIGVkaXRvciBpcyBjbGlja2VkLCBhZnRlciBgaGFuZGxlQ2xpY2tPbmAgaGFuZGxlcnNcbi8vICAgaGF2ZSBiZWVuIGNhbGxlZC5cbi8vXG4vLyAgIGhhbmRsZURvdWJsZUNsaWNrT246OiA/KHZpZXc6IEVkaXRvclZpZXcsIHBvczogbnVtYmVyLCBub2RlOiBOb2RlLCBub2RlUG9zOiBudW1iZXIsIGV2ZW50OiBkb20uTW91c2VFdmVudCwgZGlyZWN0OiBib29sKSDihpIgYm9vbFxuLy8gICBDYWxsZWQgZm9yIGVhY2ggbm9kZSBhcm91bmQgYSBkb3VibGUgY2xpY2suXG4vL1xuLy8gICBoYW5kbGVEb3VibGVDbGljazo6ID8odmlldzogRWRpdG9yVmlldywgcG9zOiBudW1iZXIsIGV2ZW50OiBkb20uTW91c2VFdmVudCkg4oaSIGJvb2xcbi8vICAgQ2FsbGVkIHdoZW4gdGhlIGVkaXRvciBpcyBkb3VibGUtY2xpY2tlZCwgYWZ0ZXIgYGhhbmRsZURvdWJsZUNsaWNrT25gLlxuLy9cbi8vICAgaGFuZGxlVHJpcGxlQ2xpY2tPbjo6ID8odmlldzogRWRpdG9yVmlldywgcG9zOiBudW1iZXIsIG5vZGU6IE5vZGUsIG5vZGVQb3M6IG51bWJlciwgZXZlbnQ6IGRvbS5Nb3VzZUV2ZW50LCBkaXJlY3Q6IGJvb2wpIOKGkiBib29sXG4vLyAgIENhbGxlZCBmb3IgZWFjaCBub2RlIGFyb3VuZCBhIHRyaXBsZSBjbGljay5cbi8vXG4vLyAgIGhhbmRsZVRyaXBsZUNsaWNrOjogPyh2aWV3OiBFZGl0b3JWaWV3LCBwb3M6IG51bWJlciwgZXZlbnQ6IGRvbS5Nb3VzZUV2ZW50KSDihpIgYm9vbFxuLy8gICBDYWxsZWQgd2hlbiB0aGUgZWRpdG9yIGlzIHRyaXBsZS1jbGlja2VkLCBhZnRlciBgaGFuZGxlVHJpcGxlQ2xpY2tPbmAuXG4vL1xuLy8gICBoYW5kbGVQYXN0ZTo6ID8odmlldzogRWRpdG9yVmlldywgZXZlbnQ6IGRvbS5DbGlwYm9hcmRFdmVudCwgc2xpY2U6IFNsaWNlKSDihpIgYm9vbFxuLy8gICBDYW4gYmUgdXNlZCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3Igb2YgcGFzdGluZy4gYHNsaWNlYCBpcyB0aGVcbi8vICAgcGFzdGVkIGNvbnRlbnQgcGFyc2VkIGJ5IHRoZSBlZGl0b3IsIGJ1dCB5b3UgY2FuIGRpcmVjdGx5IGFjY2Vzc1xuLy8gICB0aGUgZXZlbnQgdG8gZ2V0IGF0IHRoZSByYXcgY29udGVudC5cbi8vXG4vLyAgIGhhbmRsZURyb3A6OiA/KHZpZXc6IEVkaXRvclZpZXcsIGV2ZW50OiBkb20uRXZlbnQsIHNsaWNlOiBTbGljZSwgbW92ZWQ6IGJvb2wpIOKGkiBib29sXG4vLyAgIENhbGxlZCB3aGVuIHNvbWV0aGluZyBpcyBkcm9wcGVkIG9uIHRoZSBlZGl0b3IuIGBtb3ZlZGAgd2lsbCBiZVxuLy8gICB0cnVlIGlmIHRoaXMgZHJvcCBtb3ZlcyBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbiAod2hpY2ggc2hvdWxkXG4vLyAgIHRodXMgYmUgZGVsZXRlZCkuXG4vL1xuLy8gICBoYW5kbGVTY3JvbGxUb1NlbGVjdGlvbjo6ID8odmlldzogRWRpdG9yVmlldykg4oaSIGJvb2xcbi8vICAgQ2FsbGVkIHdoZW4gdGhlIHZpZXcsIGFmdGVyIHVwZGF0aW5nIGl0cyBzdGF0ZSwgdHJpZXMgdG8gc2Nyb2xsXG4vLyAgIHRoZSBzZWxlY3Rpb24gaW50byB2aWV3LiBBIGhhbmRsZXIgZnVuY3Rpb24gbWF5IHJldHVybiBmYWxzZSB0b1xuLy8gICBpbmRpY2F0ZSB0aGF0IGl0IGRpZCBub3QgaGFuZGxlIHRoZSBzY3JvbGxpbmcgYW5kIGZ1cnRoZXJcbi8vICAgaGFuZGxlcnMgb3IgdGhlIGRlZmF1bHQgYmVoYXZpb3Igc2hvdWxkIGJlIHRyaWVkLlxuLy9cbi8vICAgY3JlYXRlU2VsZWN0aW9uQmV0d2Vlbjo6ID8odmlldzogRWRpdG9yVmlldywgYW5jaG9yOiBSZXNvbHZlZFBvcywgaGVhZDogUmVzb2x2ZWRQb3MpIOKGkiA/U2VsZWN0aW9uXG4vLyAgIENhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIHRoZSB3YXkgYSBzZWxlY3Rpb24gaXMgY3JlYXRlZCB3aGVuXG4vLyAgIHJlYWRpbmcgYSBET00gc2VsZWN0aW9uIGJldHdlZW4gdGhlIGdpdmVuIGFuY2hvciBhbmQgaGVhZC5cbi8vXG4vLyAgIGRvbVBhcnNlcjo6ID9ET01QYXJzZXJcbi8vICAgVGhlIFtwYXJzZXJdKCNtb2RlbC5ET01QYXJzZXIpIHRvIHVzZSB3aGVuIHJlYWRpbmcgZWRpdG9yIGNoYW5nZXNcbi8vICAgZnJvbSB0aGUgRE9NLiBEZWZhdWx0cyB0byBjYWxsaW5nXG4vLyAgIFtgRE9NUGFyc2VyLmZyb21TY2hlbWFgXSgjbW9kZWwuRE9NUGFyc2VyXmZyb21TY2hlbWEpIG9uIHRoZVxuLy8gICBlZGl0b3IncyBzY2hlbWEuXG4vL1xuLy8gICB0cmFuc2Zvcm1QYXN0ZWRIVE1MOjogPyhodG1sOiBzdHJpbmcpIOKGkiBzdHJpbmdcbi8vICAgQ2FuIGJlIHVzZWQgdG8gdHJhbnNmb3JtIHBhc3RlZCBIVE1MIHRleHQsIF9iZWZvcmVfIGl0IGlzIHBhcnNlZCxcbi8vICAgZm9yIGV4YW1wbGUgdG8gY2xlYW4gaXQgdXAuXG4vL1xuLy8gICBjbGlwYm9hcmRQYXJzZXI6OiA/RE9NUGFyc2VyXG4vLyAgIFRoZSBbcGFyc2VyXSgjbW9kZWwuRE9NUGFyc2VyKSB0byB1c2Ugd2hlbiByZWFkaW5nIGNvbnRlbnQgZnJvbVxuLy8gICB0aGUgY2xpcGJvYXJkLiBXaGVuIG5vdCBnaXZlbiwgdGhlIHZhbHVlIG9mIHRoZVxuLy8gICBbYGRvbVBhcnNlcmBdKCN2aWV3LkVkaXRvclByb3BzLmRvbVBhcnNlcikgcHJvcCBpcyB1c2VkLlxuLy9cbi8vICAgdHJhbnNmb3JtUGFzdGVkVGV4dDo6ID8odGV4dDogc3RyaW5nLCBwbGFpbjogYm9vbCkg4oaSIHN0cmluZ1xuLy8gICBUcmFuc2Zvcm0gcGFzdGVkIHBsYWluIHRleHQuIFRoZSBgcGxhaW5gIGZsYWcgd2lsbCBiZSB0cnVlIHdoZW5cbi8vICAgdGhlIHRleHQgaXMgcGFzdGVkIGFzIHBsYWluIHRleHQuXG4vL1xuLy8gICBjbGlwYm9hcmRUZXh0UGFyc2VyOjogPyh0ZXh0OiBzdHJpbmcsICRjb250ZXh0OiBSZXNvbHZlZFBvcywgcGxhaW46IGJvb2wpIOKGkiBTbGljZVxuLy8gICBBIGZ1bmN0aW9uIHRvIHBhcnNlIHRleHQgZnJvbSB0aGUgY2xpcGJvYXJkIGludG8gYSBkb2N1bWVudFxuLy8gICBzbGljZS4gQ2FsbGVkIGFmdGVyXG4vLyAgIFtgdHJhbnNmb3JtUGFzdGVkVGV4dGBdKCN2aWV3LkVkaXRvclByb3BzLnRyYW5zZm9ybVBhc3RlZFRleHQpLlxuLy8gICBUaGUgZGVmYXVsdCBiZWhhdmlvciBpcyB0byBzcGxpdCB0aGUgdGV4dCBpbnRvIGxpbmVzLCB3cmFwIHRoZW1cbi8vICAgaW4gYDxwPmAgdGFncywgYW5kIGNhbGxcbi8vICAgW2BjbGlwYm9hcmRQYXJzZXJgXSgjdmlldy5FZGl0b3JQcm9wcy5jbGlwYm9hcmRQYXJzZXIpIG9uIGl0LlxuLy8gICBUaGUgYHBsYWluYCBmbGFnIHdpbGwgYmUgdHJ1ZSB3aGVuIHRoZSB0ZXh0IGlzIHBhc3RlZCBhcyBwbGFpbiB0ZXh0LlxuLy9cbi8vICAgdHJhbnNmb3JtUGFzdGVkOjogPyhTbGljZSkg4oaSIFNsaWNlXG4vLyAgIENhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBwYXN0ZWQgY29udGVudCBiZWZvcmUgaXQgaXMgYXBwbGllZCB0b1xuLy8gICB0aGUgZG9jdW1lbnQuXG4vL1xuLy8gICBub2RlVmlld3M6OiA/T2JqZWN0PChub2RlOiBOb2RlLCB2aWV3OiBFZGl0b3JWaWV3LCBnZXRQb3M6ICgpIOKGkiBudW1iZXIsIGRlY29yYXRpb25zOiBbRGVjb3JhdGlvbl0sIGlubmVyRGVjb3JhdGlvbnM6IERlY29yYXRpb25Tb3VyY2UpIOKGkiBOb2RlVmlldz5cbi8vICAgQWxsb3dzIHlvdSB0byBwYXNzIGN1c3RvbSByZW5kZXJpbmcgYW5kIGJlaGF2aW9yIGxvZ2ljIGZvciBub2Rlc1xuLy8gICBhbmQgbWFya3MuIFNob3VsZCBtYXAgbm9kZSBhbmQgbWFyayBuYW1lcyB0byBjb25zdHJ1Y3RvclxuLy8gICBmdW5jdGlvbnMgdGhhdCBwcm9kdWNlIGEgW2BOb2RlVmlld2BdKCN2aWV3Lk5vZGVWaWV3KSBvYmplY3Rcbi8vICAgaW1wbGVtZW50aW5nIHRoZSBub2RlJ3MgZGlzcGxheSBiZWhhdmlvci4gRm9yIG5vZGVzLCB0aGUgdGhpcmRcbi8vICAgYXJndW1lbnQgYGdldFBvc2AgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgdG8gZ2V0IHRoZVxuLy8gICBub2RlJ3MgY3VycmVudCBwb3NpdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWZ1bCB3aGVuIGNyZWF0aW5nXG4vLyAgIHRyYW5zYWN0aW9ucyB0byB1cGRhdGUgaXQuIEZvciBtYXJrcywgdGhlIHRoaXJkIGFyZ3VtZW50IGlzIGFcbi8vICAgYm9vbGVhbiB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBtYXJrJ3MgY29udGVudCBpcyBpbmxpbmUuXG4vL1xuLy8gICBgZGVjb3JhdGlvbnNgIGlzIGFuIGFycmF5IG9mIG5vZGUgb3IgaW5saW5lIGRlY29yYXRpb25zIHRoYXQgYXJlXG4vLyAgIGFjdGl2ZSBhcm91bmQgdGhlIG5vZGUuIFRoZXkgYXJlIGF1dG9tYXRpY2FsbHkgZHJhd24gaW4gdGhlXG4vLyAgIG5vcm1hbCB3YXksIGFuZCB5b3Ugd2lsbCB1c3VhbGx5IGp1c3Qgd2FudCB0byBpZ25vcmUgdGhpcywgYnV0XG4vLyAgIHRoZXkgY2FuIGFsc28gYmUgdXNlZCBhcyBhIHdheSB0byBwcm92aWRlIGNvbnRleHQgaW5mb3JtYXRpb24gdG9cbi8vICAgdGhlIG5vZGUgdmlldyB3aXRob3V0IGFkZGluZyBpdCB0byB0aGUgZG9jdW1lbnQgaXRzZWxmLlxuLy9cbi8vICAgYGlubmVyRGVjb3JhdGlvbnNgIGhvbGRzIHRoZSBkZWNvcmF0aW9ucyBmb3IgdGhlIG5vZGUncyBjb250ZW50LlxuLy8gICBZb3UgY2FuIHNhZmVseSBpZ25vcmUgdGhpcyBpZiB5b3VyIHZpZXcgaGFzIG5vIGNvbnRlbnQgb3IgYVxuLy8gICBgY29udGVudERPTWAgcHJvcGVydHksIHNpbmNlIHRoZSBlZGl0b3Igd2lsbCBkcmF3IHRoZSBkZWNvcmF0aW9uc1xuLy8gICBvbiB0aGUgY29udGVudC4gQnV0IGlmIHlvdSwgZm9yIGV4YW1wbGUsIHdhbnQgdG8gY3JlYXRlIGEgbmVzdGVkXG4vLyAgIGVkaXRvciB3aXRoIHRoZSBjb250ZW50LCBpdCBtYXkgbWFrZSBzZW5zZSB0byBwcm92aWRlIGl0IHdpdGggdGhlXG4vLyAgIGlubmVyIGRlY29yYXRpb25zLlxuLy9cbi8vICAgY2xpcGJvYXJkU2VyaWFsaXplcjo6ID9ET01TZXJpYWxpemVyXG4vLyAgIFRoZSBET00gc2VyaWFsaXplciB0byB1c2Ugd2hlbiBwdXR0aW5nIGNvbnRlbnQgb250byB0aGVcbi8vICAgY2xpcGJvYXJkLiBJZiBub3QgZ2l2ZW4sIHRoZSByZXN1bHQgb2Zcbi8vICAgW2BET01TZXJpYWxpemVyLmZyb21TY2hlbWFgXSgjbW9kZWwuRE9NU2VyaWFsaXplcl5mcm9tU2NoZW1hKVxuLy8gICB3aWxsIGJlIHVzZWQuXG4vL1xuLy8gICBjbGlwYm9hcmRUZXh0U2VyaWFsaXplcjo6ID8oU2xpY2UpIOKGkiBzdHJpbmdcbi8vICAgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIGdldCB0aGUgdGV4dCBmb3IgdGhlIGN1cnJlbnRcbi8vICAgc2VsZWN0aW9uIHdoZW4gY29weWluZyB0ZXh0IHRvIHRoZSBjbGlwYm9hcmQuIEJ5IGRlZmF1bHQsIHRoZVxuLy8gICBlZGl0b3Igd2lsbCB1c2UgW2B0ZXh0QmV0d2VlbmBdKCNtb2RlbC5Ob2RlLnRleHRCZXR3ZWVuKSBvbiB0aGVcbi8vICAgc2VsZWN0ZWQgcmFuZ2UuXG4vL1xuLy8gICBkZWNvcmF0aW9uczo6ID8oc3RhdGU6IEVkaXRvclN0YXRlKSDihpIgP0RlY29yYXRpb25Tb3VyY2Vcbi8vICAgQSBzZXQgb2YgW2RvY3VtZW50IGRlY29yYXRpb25zXSgjdmlldy5EZWNvcmF0aW9uKSB0byBzaG93IGluIHRoZVxuLy8gICB2aWV3LlxuLy9cbi8vICAgZWRpdGFibGU6OiA/KHN0YXRlOiBFZGl0b3JTdGF0ZSkg4oaSIGJvb2xcbi8vICAgV2hlbiB0aGlzIHJldHVybnMgZmFsc2UsIHRoZSBjb250ZW50IG9mIHRoZSB2aWV3IGlzIG5vdCBkaXJlY3RseVxuLy8gICBlZGl0YWJsZS5cbi8vXG4vLyAgIGF0dHJpYnV0ZXM6OiA/dW5pb248T2JqZWN0PHN0cmluZz4sIChFZGl0b3JTdGF0ZSkg4oaSID9PYmplY3Q8c3RyaW5nPj5cbi8vICAgQ29udHJvbCB0aGUgRE9NIGF0dHJpYnV0ZXMgb2YgdGhlIGVkaXRhYmxlIGVsZW1lbnQuIE1heSBiZSBlaXRoZXJcbi8vICAgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24gZ29pbmcgZnJvbSBhbiBlZGl0b3Igc3RhdGUgdG8gYW4gb2JqZWN0LlxuLy8gICBCeSBkZWZhdWx0LCB0aGUgZWxlbWVudCB3aWxsIGdldCBhIGNsYXNzIGBcIlByb3NlTWlycm9yXCJgLCBhbmRcbi8vICAgd2lsbCBoYXZlIGl0cyBgY29udGVudEVkaXRhYmxlYCBhdHRyaWJ1dGUgZGV0ZXJtaW5lZCBieSB0aGVcbi8vICAgW2BlZGl0YWJsZWAgcHJvcF0oI3ZpZXcuRWRpdG9yUHJvcHMuZWRpdGFibGUpLiBBZGRpdGlvbmFsIGNsYXNzZXNcbi8vICAgcHJvdmlkZWQgaGVyZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjbGFzcy4gRm9yIG90aGVyIGF0dHJpYnV0ZXMsXG4vLyAgIHRoZSB2YWx1ZSBwcm92aWRlZCBmaXJzdCAoYXMgaW5cbi8vICAgW2Bzb21lUHJvcGBdKCN2aWV3LkVkaXRvclZpZXcuc29tZVByb3ApKSB3aWxsIGJlIHVzZWQuXG4vL1xuLy8gICBzY3JvbGxUaHJlc2hvbGQ6OiA/dW5pb248bnVtYmVyLCB7dG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9PlxuLy8gICBEZXRlcm1pbmVzIHRoZSBkaXN0YW5jZSAoaW4gcGl4ZWxzKSBiZXR3ZWVuIHRoZSBjdXJzb3IgYW5kIHRoZVxuLy8gICBlbmQgb2YgdGhlIHZpc2libGUgdmlld3BvcnQgYXQgd2hpY2ggcG9pbnQsIHdoZW4gc2Nyb2xsaW5nIHRoZVxuLy8gICBjdXJzb3IgaW50byB2aWV3LCBzY3JvbGxpbmcgdGFrZXMgcGxhY2UuIERlZmF1bHRzIHRvIDAuXG4vL1xuLy8gICBzY3JvbGxNYXJnaW46OiA/dW5pb248bnVtYmVyLCB7dG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9PlxuLy8gICBEZXRlcm1pbmVzIHRoZSBleHRyYSBzcGFjZSAoaW4gcGl4ZWxzKSB0aGF0IGlzIGxlZnQgYWJvdmUgb3Jcbi8vICAgYmVsb3cgdGhlIGN1cnNvciB3aGVuIGl0IGlzIHNjcm9sbGVkIGludG8gdmlldy4gRGVmYXVsdHMgdG8gNS5cblxuLy8gRGlyZWN0RWRpdG9yUHJvcHM6OiBpbnRlcmZhY2UgZXh0ZW5kcyBFZGl0b3JQcm9wc1xuLy9cbi8vIFRoZSBwcm9wcyBvYmplY3QgZ2l2ZW4gZGlyZWN0bHkgdG8gdGhlIGVkaXRvciB2aWV3IHN1cHBvcnRzIHR3b1xuLy8gZmllbGRzIHRoYXQgY2FuJ3QgYmUgdXNlZCBpbiBwbHVnaW5zOlxuLy9cbi8vICAgc3RhdGU6OiBFZGl0b3JTdGF0ZVxuLy8gICBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxuLy9cbi8vICAgcGx1Z2luczo6IFtQbHVnaW5dXG4vLyAgIEEgc2V0IG9mIHBsdWdpbnMgdG8gdXNlIGluIHRoZSB2aWV3LCBhcHBseWluZyB0aGVpciBbcGx1Z2luXG4vLyAgIHZpZXddKCNzdGF0ZS5QbHVnaW5TcGVjLnZpZXcpIGFuZFxuLy8gICBbcHJvcHNdKCNzdGF0ZS5QbHVnaW5TcGVjLnByb3BzKS4gUGFzc2luZyBwbHVnaW5zIHdpdGggYSBzdGF0ZVxuLy8gICBjb21wb25lbnQgKGEgW3N0YXRlIGZpZWxkXSgjc3RhdGUuUGx1Z2luU3BlYy5zdGF0ZSkgZmllbGQgb3IgYVxuLy8gICBbdHJhbnNhY3Rpb24pWyNzdGF0ZS5QbHVnaW5TcGVjLmZpbHRlclRyYW5zYWN0aW9uXSBmaWx0ZXIgb3Jcbi8vICAgYXBwZW5kZXIpIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yLCBzaW5jZSBzdWNoIHBsdWdpbnMgbXVzdCBiZVxuLy8gICBwcmVzZW50IGluIHRoZSBzdGF0ZSB0byB3b3JrLlxuLy9cbi8vICAgZGlzcGF0Y2hUcmFuc2FjdGlvbjo6ID8odHI6IFRyYW5zYWN0aW9uKVxuLy8gICBUaGUgY2FsbGJhY2sgb3ZlciB3aGljaCB0byBzZW5kIHRyYW5zYWN0aW9ucyAoc3RhdGUgdXBkYXRlcylcbi8vICAgcHJvZHVjZWQgYnkgdGhlIHZpZXcuIElmIHlvdSBzcGVjaWZ5IHRoaXMsIHlvdSBwcm9iYWJseSB3YW50IHRvXG4vLyAgIG1ha2Ugc3VyZSB0aGlzIGVuZHMgdXAgY2FsbGluZyB0aGUgdmlldydzXG4vLyAgIFtgdXBkYXRlU3RhdGVgXSgjdmlldy5FZGl0b3JWaWV3LnVwZGF0ZVN0YXRlKSBtZXRob2Qgd2l0aCBhIG5ld1xuLy8gICBzdGF0ZSB0aGF0IGhhcyB0aGUgdHJhbnNhY3Rpb25cbi8vICAgW2FwcGxpZWRdKCNzdGF0ZS5FZGl0b3JTdGF0ZS5hcHBseSkuIFRoZSBjYWxsYmFjayB3aWxsIGJlIGJvdW5kIHRvIGhhdmVcbi8vICAgdGhlIHZpZXcgaW5zdGFuY2UgYXMgaXRzIGB0aGlzYCBiaW5kaW5nLlxuXG5leHBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0LCBFZGl0b3JWaWV3LCBlbmRDb21wb3NpdGlvbiBhcyBfX2VuZENvbXBvc2l0aW9uLCBwYXJzZUZyb21DbGlwYm9hcmQgYXMgX19wYXJzZUZyb21DbGlwYm9hcmQsIHNlcmlhbGl6ZUZvckNsaXBib2FyZCBhcyBfX3NlcmlhbGl6ZUZvckNsaXBib2FyZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJ2YXIgR09PRF9MRUFGX1NJWkUgPSAyMDA7XG5cbi8vIDo6IGNsYXNzPFQ+IEEgcm9wZSBzZXF1ZW5jZSBpcyBhIHBlcnNpc3RlbnQgc2VxdWVuY2UgZGF0YSBzdHJ1Y3R1cmVcbi8vIHRoYXQgc3VwcG9ydHMgYXBwZW5kaW5nLCBwcmVwZW5kaW5nLCBhbmQgc2xpY2luZyB3aXRob3V0IGRvaW5nIGFcbi8vIGZ1bGwgY29weS4gSXQgaXMgcmVwcmVzZW50ZWQgYXMgYSBtb3N0bHktYmFsYW5jZWQgdHJlZS5cbnZhciBSb3BlU2VxdWVuY2UgPSBmdW5jdGlvbiBSb3BlU2VxdWVuY2UgKCkge307XG5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kIChvdGhlcikge1xuICBpZiAoIW90aGVyLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gIG90aGVyID0gUm9wZVNlcXVlbmNlLmZyb20ob3RoZXIpO1xuXG4gIHJldHVybiAoIXRoaXMubGVuZ3RoICYmIG90aGVyKSB8fFxuICAgIChvdGhlci5sZW5ndGggPCBHT09EX0xFQUZfU0laRSAmJiB0aGlzLmxlYWZBcHBlbmQob3RoZXIpKSB8fFxuICAgICh0aGlzLmxlbmd0aCA8IEdPT0RfTEVBRl9TSVpFICYmIG90aGVyLmxlYWZQcmVwZW5kKHRoaXMpKSB8fFxuICAgIHRoaXMuYXBwZW5kSW5uZXIob3RoZXIpXG59O1xuXG4vLyA6OiAodW5pb248W1RdLCBSb3BlU2VxdWVuY2U8VD4+KSDihpIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBQcmVwZW5kIGFuIGFycmF5IG9yIG90aGVyIHJvcGUgdG8gdGhpcyBvbmUsIHJldHVybmluZyBhIG5ldyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCAob3RoZXIpIHtcbiAgaWYgKCFvdGhlci5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gUm9wZVNlcXVlbmNlLmZyb20ob3RoZXIpLmFwcGVuZCh0aGlzKVxufTtcblxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5hcHBlbmRJbm5lciA9IGZ1bmN0aW9uIGFwcGVuZElubmVyIChvdGhlcikge1xuICByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLCBvdGhlcilcbn07XG5cbi8vIDo6ICg/bnVtYmVyLCA/bnVtYmVyKSDihpIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBDcmVhdGUgYSByb3BlIHJlcGVzZW50aW5nIGEgc3ViLXNlcXVlbmNlIG9mIHRoaXMgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGZyb20gPj0gdG8pIHsgcmV0dXJuIFJvcGVTZXF1ZW5jZS5lbXB0eSB9XG4gIHJldHVybiB0aGlzLnNsaWNlSW5uZXIoTWF0aC5tYXgoMCwgZnJvbSksIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykpXG59O1xuXG4vLyA6OiAobnVtYmVyKSDihpIgVFxuLy8gUmV0cmlldmUgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhpcyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHVuZGVmaW5lZCB9XG4gIHJldHVybiB0aGlzLmdldElubmVyKGkpXG59O1xuXG4vLyA6OiAoKGVsZW1lbnQ6IFQsIGluZGV4OiBudW1iZXIpIOKGkiA/Ym9vbCwgP251bWJlciwgP251bWJlcilcbi8vIENhbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgYmV0d2VlbiB0aGUgZ2l2ZW5cbi8vIGluZGljZXMuIFRoaXMgdGVuZHMgdG8gYmUgbW9yZSBlZmZpY2llbnQgdGhhbiBsb29waW5nIG92ZXIgdGhlXG4vLyBpbmRpY2VzIGFuZCBjYWxsaW5nIGBnZXRgLCBiZWNhdXNlIGl0IGRvZXNuJ3QgaGF2ZSB0byBkZXNjZW5kIHRoZVxuLy8gdHJlZSBmb3IgZXZlcnkgZWxlbWVudC5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2ggKGYsIGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChmcm9tIDw9IHRvKVxuICAgIHsgdGhpcy5mb3JFYWNoSW5uZXIoZiwgZnJvbSwgdG8sIDApOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgZnJvbSwgdG8sIDApOyB9XG59O1xuXG4vLyA6OiAoKGVsZW1lbnQ6IFQsIGluZGV4OiBudW1iZXIpIOKGkiBVLCA/bnVtYmVyLCA/bnVtYmVyKSDihpIgW1VdXG4vLyBNYXAgdGhlIGdpdmVuIGZ1bmN0aW9ucyBvdmVyIHRoZSBlbGVtZW50cyBvZiB0aGUgcm9wZSwgcHJvZHVjaW5nXG4vLyBhIGZsYXQgYXJyYXkuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAoZiwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsdCwgaSkgeyByZXR1cm4gcmVzdWx0LnB1c2goZihlbHQsIGkpKTsgfSwgZnJvbSwgdG8pO1xuICByZXR1cm4gcmVzdWx0XG59O1xuXG4vLyA6OiAoP3VuaW9uPFtUXSwgUm9wZVNlcXVlbmNlPFQ+Pikg4oaSIFJvcGVTZXF1ZW5jZTxUPlxuLy8gQ3JlYXRlIGEgcm9wZSByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGFycmF5LCBvciByZXR1cm4gdGhlIHJvcGVcbi8vIGl0c2VsZiBpZiBhIHJvcGUgd2FzIGdpdmVuLlxuUm9wZVNlcXVlbmNlLmZyb20gPSBmdW5jdGlvbiBmcm9tICh2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFJvcGVTZXF1ZW5jZSkgeyByZXR1cm4gdmFsdWVzIH1cbiAgcmV0dXJuIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoID8gbmV3IExlYWYodmFsdWVzKSA6IFJvcGVTZXF1ZW5jZS5lbXB0eVxufTtcblxudmFyIExlYWYgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChSb3BlU2VxdWVuY2UpIHtcbiAgZnVuY3Rpb24gTGVhZih2YWx1ZXMpIHtcbiAgICBSb3BlU2VxdWVuY2UuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgfVxuXG4gIGlmICggUm9wZVNlcXVlbmNlICkgTGVhZi5fX3Byb3RvX18gPSBSb3BlU2VxdWVuY2U7XG4gIExlYWYucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUm9wZVNlcXVlbmNlICYmIFJvcGVTZXF1ZW5jZS5wcm90b3R5cGUgKTtcbiAgTGVhZi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZWFmO1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGxlbmd0aDogeyBjb25maWd1cmFibGU6IHRydWUgfSxkZXB0aDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNcbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5zbGljZUlubmVyID0gZnVuY3Rpb24gc2xpY2VJbm5lciAoZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgICByZXR1cm4gbmV3IExlYWYodGhpcy52YWx1ZXMuc2xpY2UoZnJvbSwgdG8pKVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmdldElubmVyID0gZnVuY3Rpb24gZ2V0SW5uZXIgKGkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbaV1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5mb3JFYWNoSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgIHsgaWYgKGYodGhpcy52YWx1ZXNbaV0sIHN0YXJ0ICsgaSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5mb3JFYWNoSW52ZXJ0ZWRJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbnZlcnRlZElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICBmb3IgKHZhciBpID0gZnJvbSAtIDE7IGkgPj0gdG87IGktLSlcbiAgICAgIHsgaWYgKGYodGhpcy52YWx1ZXNbaV0sIHN0YXJ0ICsgaSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5sZWFmQXBwZW5kID0gZnVuY3Rpb24gbGVhZkFwcGVuZCAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGggPD0gR09PRF9MRUFGX1NJWkUpXG4gICAgICB7IHJldHVybiBuZXcgTGVhZih0aGlzLnZhbHVlcy5jb25jYXQob3RoZXIuZmxhdHRlbigpKSkgfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmxlYWZQcmVwZW5kID0gZnVuY3Rpb24gbGVhZlByZXBlbmQgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoIDw9IEdPT0RfTEVBRl9TSVpFKVxuICAgICAgeyByZXR1cm4gbmV3IExlYWYob3RoZXIuZmxhdHRlbigpLmNvbmNhdCh0aGlzLnZhbHVlcykpIH1cbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMubGVuZ3RoLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aCB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5kZXB0aC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExlYWYucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gTGVhZjtcbn0oUm9wZVNlcXVlbmNlKSk7XG5cbi8vIDo6IFJvcGVTZXF1ZW5jZVxuLy8gVGhlIGVtcHR5IHJvcGUgc2VxdWVuY2UuXG5Sb3BlU2VxdWVuY2UuZW1wdHkgPSBuZXcgTGVhZihbXSk7XG5cbnZhciBBcHBlbmQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChSb3BlU2VxdWVuY2UpIHtcbiAgZnVuY3Rpb24gQXBwZW5kKGxlZnQsIHJpZ2h0KSB7XG4gICAgUm9wZVNlcXVlbmNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aDtcbiAgICB0aGlzLmRlcHRoID0gTWF0aC5tYXgobGVmdC5kZXB0aCwgcmlnaHQuZGVwdGgpICsgMTtcbiAgfVxuXG4gIGlmICggUm9wZVNlcXVlbmNlICkgQXBwZW5kLl9fcHJvdG9fXyA9IFJvcGVTZXF1ZW5jZTtcbiAgQXBwZW5kLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJvcGVTZXF1ZW5jZSAmJiBSb3BlU2VxdWVuY2UucHJvdG90eXBlICk7XG4gIEFwcGVuZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcHBlbmQ7XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVmdC5mbGF0dGVuKCkuY29uY2F0KHRoaXMucmlnaHQuZmxhdHRlbigpKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZ2V0SW5uZXIgPSBmdW5jdGlvbiBnZXRJbm5lciAoaSkge1xuICAgIHJldHVybiBpIDwgdGhpcy5sZWZ0Lmxlbmd0aCA/IHRoaXMubGVmdC5nZXQoaSkgOiB0aGlzLnJpZ2h0LmdldChpIC0gdGhpcy5sZWZ0Lmxlbmd0aClcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmZvckVhY2hJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmIChmcm9tIDwgbGVmdExlbiAmJlxuICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaElubmVyKGYsIGZyb20sIE1hdGgubWluKHRvLCBsZWZ0TGVuKSwgc3RhcnQpID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodG8gPiBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaElubmVyKGYsIE1hdGgubWF4KGZyb20gLSBsZWZ0TGVuLCAwKSwgTWF0aC5taW4odGhpcy5sZW5ndGgsIHRvKSAtIGxlZnRMZW4sIHN0YXJ0ICsgbGVmdExlbikgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZm9yRWFjaEludmVydGVkSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW52ZXJ0ZWRJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmIChmcm9tID4gbGVmdExlbiAmJlxuICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hJbnZlcnRlZElubmVyKGYsIGZyb20gLSBsZWZ0TGVuLCBNYXRoLm1heCh0bywgbGVmdExlbikgLSBsZWZ0TGVuLCBzdGFydCArIGxlZnRMZW4pID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodG8gPCBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMubGVmdC5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBNYXRoLm1pbihmcm9tLCBsZWZ0TGVuKSwgdG8sIHN0YXJ0KSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5zbGljZUlubmVyID0gZnVuY3Rpb24gc2xpY2VJbm5lciAoZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKHRvIDw9IGxlZnRMZW4pIHsgcmV0dXJuIHRoaXMubGVmdC5zbGljZShmcm9tLCB0bykgfVxuICAgIGlmIChmcm9tID49IGxlZnRMZW4pIHsgcmV0dXJuIHRoaXMucmlnaHQuc2xpY2UoZnJvbSAtIGxlZnRMZW4sIHRvIC0gbGVmdExlbikgfVxuICAgIHJldHVybiB0aGlzLmxlZnQuc2xpY2UoZnJvbSwgbGVmdExlbikuYXBwZW5kKHRoaXMucmlnaHQuc2xpY2UoMCwgdG8gLSBsZWZ0TGVuKSlcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmxlYWZBcHBlbmQgPSBmdW5jdGlvbiBsZWFmQXBwZW5kIChvdGhlcikge1xuICAgIHZhciBpbm5lciA9IHRoaXMucmlnaHQubGVhZkFwcGVuZChvdGhlcik7XG4gICAgaWYgKGlubmVyKSB7IHJldHVybiBuZXcgQXBwZW5kKHRoaXMubGVmdCwgaW5uZXIpIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmxlYWZQcmVwZW5kID0gZnVuY3Rpb24gbGVhZlByZXBlbmQgKG90aGVyKSB7XG4gICAgdmFyIGlubmVyID0gdGhpcy5sZWZ0LmxlYWZQcmVwZW5kKG90aGVyKTtcbiAgICBpZiAoaW5uZXIpIHsgcmV0dXJuIG5ldyBBcHBlbmQoaW5uZXIsIHRoaXMucmlnaHQpIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmFwcGVuZElubmVyID0gZnVuY3Rpb24gYXBwZW5kSW5uZXIgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVmdC5kZXB0aCA+PSBNYXRoLm1heCh0aGlzLnJpZ2h0LmRlcHRoLCBvdGhlci5kZXB0aCkgKyAxKVxuICAgICAgeyByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLmxlZnQsIG5ldyBBcHBlbmQodGhpcy5yaWdodCwgb3RoZXIpKSB9XG4gICAgcmV0dXJuIG5ldyBBcHBlbmQodGhpcywgb3RoZXIpXG4gIH07XG5cbiAgcmV0dXJuIEFwcGVuZDtcbn0oUm9wZVNlcXVlbmNlKSk7XG5cbnZhciByb3BlU2VxdWVuY2UgPSBSb3BlU2VxdWVuY2U7XG5cbmV4cG9ydCBkZWZhdWx0IHJvcGVTZXF1ZW5jZTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcyAqL1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5pbXBvcnQgeyBET01QYXJzZXIgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBzY2hlbWEgfSBmcm9tICdwcm9zZW1pcnJvci1zY2hlbWEtYmFzaWMnO1xuaW1wb3J0IHsgZXhhbXBsZVNldHVwIH0gZnJvbSAncHJvc2VtaXJyb3ItZXhhbXBsZS1zZXR1cCc7XG5pbXBvcnQgY29kZW1hcmsgZnJvbSAnLi4vc3JjJztcblxuY29uc3QgZWRpdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2VkaXRvcicpIGFzIEhUTUxEaXZFbGVtZW50O1xuY29uc3QgY29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjb250ZW50JykgYXMgSFRNTERpdkVsZW1lbnQ7XG5cbih3aW5kb3cgYXMgYW55KS52aWV3ID0gbmV3IEVkaXRvclZpZXcoZWRpdG9yLCB7XG4gIHN0YXRlOiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgIGRvYzogRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShjb250ZW50KSxcbiAgICBwbHVnaW5zOiBbXG4gICAgICAuLi5jb2RlbWFyayh7IG1hcmtUeXBlOiBzY2hlbWEubWFya3MuY29kZSB9KSxcbiAgICAgIC4uLmV4YW1wbGVTZXR1cCh7IHNjaGVtYSwgbWVudUJhcjogZmFsc2UgfSksXG4gICAgXSxcbiAgfSksXG59KTtcbiIsImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgUGx1Z2luLCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuaW1wb3J0IHsgQ29kZW1hcmtTdGF0ZSwgQ3Vyc29yTWV0YVRyIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBNQVhfTUFUQ0ggfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBPdXRzaWRlTmV4dFRyQW5kUGFzcyh2aWV3OiBFZGl0b3JWaWV3LCBwbHVnaW46IFBsdWdpbik6IGJvb2xlYW4ge1xuICBjb25zdCBtZXRhOiBDdXJzb3JNZXRhVHIgPSB7IGFjdGlvbjogJ25leHQnIH07XG4gIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRNZXRhKHBsdWdpbiwgbWV0YSkpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkJhY2t0aWNrKFxuICB2aWV3OiBFZGl0b3JWaWV3LFxuICBwbHVnaW46IFBsdWdpbixcbiAgZXZlbnQ6IEtleWJvYXJkRXZlbnQsXG4gIG1hcmtUeXBlOiBNYXJrVHlwZSxcbik6IGJvb2xlYW4ge1xuICBpZiAodmlldy5zdGF0ZS5zZWxlY3Rpb24uZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkpIHJldHVybiBmYWxzZTtcbiAgLy8gQ3JlYXRlIGEgY29kZSBtYXJrIVxuICBjb25zdCB7IGZyb20sIHRvIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKHRvIC0gZnJvbSA+PSBNQVhfTUFUQ0ggfHwgdmlldy5zdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKGZyb20sIHRvLCBtYXJrVHlwZSkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyLmFkZE1hcmsoZnJvbSwgdG8sIG1hcmtUeXBlLmNyZWF0ZSgpKTtcbiAgY29uc3QgbWV0YTogQ3Vyc29yTWV0YVRyID0geyBhY3Rpb246ICdhZGQnLCBwb3M6IHRvIH07XG4gIGNvbnN0IHNlbGVjdGVkID0gdHJcbiAgICAuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgdG8pKVxuICAgIC5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKVxuICAgIC5zZXRNZXRhKHBsdWdpbiwgbWV0YSk7XG4gIHZpZXcuZGlzcGF0Y2goc2VsZWN0ZWQpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25BcnJvd1JpZ2h0SW5zaWRlKFxuICB2aWV3OiBFZGl0b3JWaWV3LFxuICBwbHVnaW46IFBsdWdpbixcbiAgZXZlbnQ6IEtleWJvYXJkRXZlbnQsXG4gIG1hcmtUeXBlOiBNYXJrVHlwZSxcbik6IGJvb2xlYW4ge1xuICBpZiAoZXZlbnQubWV0YUtleSkgcmV0dXJuIHN0ZXBPdXRzaWRlTmV4dFRyQW5kUGFzcyh2aWV3LCBwbHVnaW4pO1xuICBpZiAoZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdmlldy5zdGF0ZTtcbiAgaWYgKCFzZWxlY3Rpb24uZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcGx1Z2luU3RhdGUgPSBwbHVnaW4uZ2V0U3RhdGUodmlldy5zdGF0ZSkgYXMgQ29kZW1hcmtTdGF0ZTtcbiAgY29uc3QgcG9zID0gc2VsZWN0aW9uLiRmcm9tO1xuICBjb25zdCBpbkNvZGUgPSAhIW1hcmtUeXBlLmlzSW5TZXQocG9zLm1hcmtzKCkpO1xuICBjb25zdCBuZXh0Q29kZSA9ICEhbWFya1R5cGUuaXNJblNldChwb3MubWFya3NBY3Jvc3MoZG9jLnJlc29sdmUoc2VsZWN0aW9uLmZyb20gKyAxKSkgPz8gW10pO1xuICBpZiAoaW5Db2RlID09PSBuZXh0Q29kZSAmJiBwb3MucGFyZW50T2Zmc2V0ICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmIChpbkNvZGUgJiYgIXBsdWdpblN0YXRlPy5kZWNvcmF0aW9ucyAmJiBwb3MucGFyZW50T2Zmc2V0ICE9PSAwKSB7XG4gICAgLy8gYGNvZGV8YCAtLT4gYGNvZGVgfFxuICAgIGNvbnN0IG1ldGE6IEN1cnNvck1ldGFUciA9IHsgYWN0aW9uOiAnYWRkJywgcG9zOiBzZWxlY3Rpb24uZnJvbSB9O1xuICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKS5zZXRNZXRhKHBsdWdpbiwgbWV0YSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChcbiAgICAobmV4dENvZGUgJiYgIXBsdWdpblN0YXRlPy5kZWNvcmF0aW9ucyAmJiBwb3MucGFyZW50T2Zmc2V0ICE9PSAwKSB8fFxuICAgIChwb3MucGFyZW50T2Zmc2V0ID09PSAwICYmIHBsdWdpblN0YXRlPy5zaWRlID09PSAtMSlcbiAgKSB7XG4gICAgLy8gfGBjb2RlYCAtLT4gYHxjb2RlYFxuICAgIGNvbnN0IG1ldGE6IEN1cnNvck1ldGFUciA9IHsgYWN0aW9uOiAnYWRkJywgcG9zOiBzZWxlY3Rpb24uZnJvbSB9O1xuICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5hZGRTdG9yZWRNYXJrKG1hcmtUeXBlLmNyZWF0ZSgpKS5zZXRNZXRhKHBsdWdpbiwgbWV0YSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uQXJyb3dSaWdodChcbiAgdmlldzogRWRpdG9yVmlldyxcbiAgcGx1Z2luOiBQbHVnaW4sXG4gIGV2ZW50OiBLZXlib2FyZEV2ZW50LFxuICBtYXJrVHlwZTogTWFya1R5cGUsXG4pOiBib29sZWFuIHtcbiAgY29uc3QgaGFuZGxlZCA9IG9uQXJyb3dSaWdodEluc2lkZSh2aWV3LCBwbHVnaW4sIGV2ZW50LCBtYXJrVHlwZSk7XG4gIGlmIChoYW5kbGVkKSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHZpZXcuc3RhdGU7XG4gIGNvbnN0IHBvcyA9IHNlbGVjdGlvbi4kZnJvbTtcbiAgaWYgKHNlbGVjdGlvbi5lbXB0eSAmJiBwb3MucGFyZW50T2Zmc2V0ID09PSBwb3MucGFyZW50Lm5vZGVTaXplIC0gMikge1xuICAgIHJldHVybiBzdGVwT3V0c2lkZU5leHRUckFuZFBhc3ModmlldywgcGx1Z2luKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQXJyb3dMZWZ0SW5zaWRlKFxuICB2aWV3OiBFZGl0b3JWaWV3LFxuICBwbHVnaW46IFBsdWdpbixcbiAgZXZlbnQ6IEtleWJvYXJkRXZlbnQsXG4gIG1hcmtUeXBlOiBNYXJrVHlwZSxcbik6IGJvb2xlYW4ge1xuICBpZiAoZXZlbnQubWV0YUtleSkgcmV0dXJuIHN0ZXBPdXRzaWRlTmV4dFRyQW5kUGFzcyh2aWV3LCBwbHVnaW4pO1xuICBpZiAoZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdmlldy5zdGF0ZTtcbiAgY29uc3QgcGx1Z2luU3RhdGUgPSBwbHVnaW4uZ2V0U3RhdGUodmlldy5zdGF0ZSkgYXMgQ29kZW1hcmtTdGF0ZTtcbiAgY29uc3QgaW5Db2RlID0gISFtYXJrVHlwZS5pc0luU2V0KHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgY29uc3QgbmV4dENvZGUgPSAhIW1hcmtUeXBlLmlzSW5TZXQoXG4gICAgZG9jLnJlc29sdmUoc2VsZWN0aW9uLmVtcHR5ID8gc2VsZWN0aW9uLmZyb20gLSAxIDogc2VsZWN0aW9uLmZyb20gKyAxKS5tYXJrcygpID8/IFtdLFxuICApO1xuICBpZiAoaW5Db2RlICYmIHBsdWdpblN0YXRlPy5zaWRlID09PSAtMSkge1xuICAgIC8vIE5ldyBsaW5lIVxuICAgIC8vIF58YGNvZGVgIC0tPiB8XmBjb2RlYFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaW5Db2RlICYmIHBsdWdpblN0YXRlPy5kZWNvcmF0aW9ucykge1xuICAgIC8vIGBjb2RlYHwgLS0+IGBjb2RlfGBcbiAgICBjb25zdCBtZXRhOiBDdXJzb3JNZXRhVHIgPSB7IGFjdGlvbjogJ3JlbW92ZScgfTtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoKSkuc2V0TWV0YShwbHVnaW4sIG1ldGEpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWluQ29kZSAmJiBwbHVnaW5TdGF0ZT8uZGVjb3JhdGlvbnMpIHtcbiAgICAvLyBgfGNvZGVgIC0tPiB8YGNvZGVgXG4gICAgY29uc3QgbWV0YTogQ3Vyc29yTWV0YVRyID0geyBhY3Rpb246ICdyZW1vdmUnIH07XG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnJlbW92ZVN0b3JlZE1hcmsobWFya1R5cGUpLnNldE1ldGEocGx1Z2luLCBtZXRhKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGluQ29kZSA9PT0gbmV4dENvZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKChuZXh0Q29kZSB8fCAoIXNlbGVjdGlvbi5lbXB0eSAmJiBpbkNvZGUpKSAmJiAhcGx1Z2luU3RhdGU/LmRlY29yYXRpb25zKSB7XG4gICAgLy8gYGNvZGVgX3xfIC0tPiBgY29kZWB8ICAgbmV4dENvZGVcbiAgICAvLyBgY29kZWDilojilojiloggLS0+IGBjb2RlYHwgICAhc2VsZWN0aW9uLmVtcHR5ICYmIGluQ29kZVxuICAgIC8vIGDilojilohkZWBfX18gLS0+IGB8Y29kZWAgICAhc2VsZWN0aW9uLmVtcHR5ICYmIG5leHRDb2RlXG4gICAgY29uc3QgZnJvbSA9IHNlbGVjdGlvbi5lbXB0eSA/IHNlbGVjdGlvbi5mcm9tIC0gMSA6IHNlbGVjdGlvbi5mcm9tO1xuICAgIGNvbnN0IG1ldGE6IEN1cnNvck1ldGFUciA9IHsgYWN0aW9uOiAnYWRkJywgcG9zOiBmcm9tIH07XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB2aWV3LnN0YXRlLnRyXG4gICAgICAuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgZnJvbSkpXG4gICAgICAuc2V0TWV0YShwbHVnaW4sIG1ldGEpO1xuICAgIGlmICghc2VsZWN0aW9uLmVtcHR5ICYmIG5leHRDb2RlKSB7XG4gICAgICB2aWV3LmRpc3BhdGNoKHNlbGVjdGVkLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKCkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5kaXNwYXRjaChzZWxlY3RlZC5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgobmV4dENvZGUgfHwgKCFzZWxlY3Rpb24uZW1wdHkgJiYgaW5Db2RlKSkgJiYgIXBsdWdpblN0YXRlPy5kZWNvcmF0aW9ucykge1xuICAgIC8vIGBjb2RlYF98XyAtLT4gYGNvZGVgfFxuICAgIC8vIGBjb2RlYOKWiOKWiOKWiCAtLT4gYGNvZGVgfFxuICAgIGNvbnN0IGZyb20gPSBzZWxlY3Rpb24uZW1wdHkgPyBzZWxlY3Rpb24uZnJvbSAtIDEgOiBzZWxlY3Rpb24uZnJvbTtcbiAgICBjb25zdCBtZXRhOiBDdXJzb3JNZXRhVHIgPSB7IGFjdGlvbjogJ2FkZCcsIHBvczogZnJvbSB9O1xuICAgIHZpZXcuZGlzcGF0Y2goXG4gICAgICB2aWV3LnN0YXRlLnRyXG4gICAgICAgIC5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBmcm9tKSlcbiAgICAgICAgLnJlbW92ZVN0b3JlZE1hcmsobWFya1R5cGUpXG4gICAgICAgIC5zZXRNZXRhKHBsdWdpbiwgbWV0YSksXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaW5Db2RlICYmICFwbHVnaW5TdGF0ZT8uZGVjb3JhdGlvbnMgJiYgc2VsZWN0aW9uLiRmcm9tLnBhcmVudE9mZnNldCA+IDApIHtcbiAgICAvLyBgY3xvZGVgIC0tPiBgfGNvZGVgXG4gICAgY29uc3QgbWV0YTogQ3Vyc29yTWV0YVRyID0geyBhY3Rpb246ICdhZGQnLCBwb3M6IHNlbGVjdGlvbi5mcm9tIC0gMSB9O1xuICAgIHZpZXcuZGlzcGF0Y2goXG4gICAgICB2aWV3LnN0YXRlLnRyXG4gICAgICAgIC5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBzZWxlY3Rpb24uZnJvbSAtIDEpKVxuICAgICAgICAuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoKSlcbiAgICAgICAgLnNldE1ldGEocGx1Z2luLCBtZXRhKSxcbiAgICApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbkNvZGUgJiYgIXBsdWdpblN0YXRlPy5kZWNvcmF0aW9ucyAmJiBzZWxlY3Rpb24uJGZyb20ucGFyZW50T2Zmc2V0ID09PSAwKSB7XG4gICAgLy8gU3RhcnQgb2YgbGluZVxuICAgIC8vIF5gfGNvZGVgIC0tPiBefGBjb2RlYFxuICAgIGNvbnN0IG1ldGE6IEN1cnNvck1ldGFUciA9IHsgYWN0aW9uOiAnYWRkJywgcG9zOiBzZWxlY3Rpb24uZnJvbSwgc2lkZTogLTEgfTtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSkuc2V0TWV0YShwbHVnaW4sIG1ldGEpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkFycm93TGVmdChcbiAgdmlldzogRWRpdG9yVmlldyxcbiAgcGx1Z2luOiBQbHVnaW4sXG4gIGV2ZW50OiBLZXlib2FyZEV2ZW50LFxuICBtYXJrVHlwZTogTWFya1R5cGUsXG4pOiBib29sZWFuIHtcbiAgY29uc3QgaGFuZGxlZCA9IG9uQXJyb3dMZWZ0SW5zaWRlKHZpZXcsIHBsdWdpbiwgZXZlbnQsIG1hcmtUeXBlKTtcbiAgaWYgKGhhbmRsZWQpIHJldHVybiB0cnVlO1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdmlldy5zdGF0ZTtcbiAgY29uc3QgcG9zID0gc2VsZWN0aW9uLiRmcm9tO1xuICBpZiAoc2VsZWN0aW9uLmVtcHR5ICYmIHBvcy5wYXJlbnRPZmZzZXQgPT09IDApIHtcbiAgICByZXR1cm4gc3RlcE91dHNpZGVOZXh0VHJBbmRQYXNzKHZpZXcsIHBsdWdpbik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25CYWNrc3BhY2UoXG4gIHZpZXc6IEVkaXRvclZpZXcsXG4gIHBsdWdpbjogUGx1Z2luLFxuICBldmVudDogS2V5Ym9hcmRFdmVudCxcbiAgbWFya1R5cGU6IE1hcmtUeXBlLFxuKTogYm9vbGVhbiB7XG4gIGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5KSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHZpZXcuc3RhdGU7XG4gIGlmIChzZWxlY3Rpb24uZW1wdHkgJiYgc2VsZWN0aW9uLiRmcm9tLnBhcmVudE9mZnNldCA9PT0gMCkge1xuICAgIC8vIE5vIG92ZXJyaWRlIGF0IHRoZSBzdGFydCBvZiB0aGUgbGluZSFcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaW5Db2RlID0gISFtYXJrVHlwZS5pc0luU2V0KHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgY29uc3QgbmV4dENvZGUgPSAhIW1hcmtUeXBlLmlzSW5TZXQoXG4gICAgZG9jLnJlc29sdmUoc2VsZWN0aW9uLmVtcHR5ID8gc2VsZWN0aW9uLmZyb20gLSAxIDogc2VsZWN0aW9uLmZyb20gKyAxKS5tYXJrcygpID8/IFtdLFxuICApO1xuICBjb25zdCBwbHVzQ29kZSA9ICEhbWFya1R5cGUuaXNJblNldChcbiAgICBkb2MucmVzb2x2ZShzZWxlY3Rpb24uZW1wdHkgPyBzZWxlY3Rpb24uZnJvbSArIDEgOiBzZWxlY3Rpb24udG8gKyAxKS5tYXJrcygpID8/IFtdLFxuICApO1xuICBpZiAoaW5Db2RlID09PSBuZXh0Q29kZSAmJiAoaW5Db2RlID09PSBwbHVzQ29kZSB8fCAhcGx1c0NvZGUpKSByZXR1cm4gZmFsc2U7XG4gIGxldCB7IHRyIH0gPSB2aWV3LnN0YXRlO1xuICBpZiAoc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgdHIgPSB0ci5kZWxldGUoc2VsZWN0aW9uLmZyb20gLSAxLCBzZWxlY3Rpb24uZnJvbSk7XG4gIH0gZWxzZSB7XG4gICAgdHIgPSB0ci5kZWxldGUoc2VsZWN0aW9uLmZyb20sIHNlbGVjdGlvbi50byk7XG4gIH1cbiAgaWYgKChuZXh0Q29kZSAmJiBzZWxlY3Rpb24uZW1wdHkpIHx8IChpbkNvZGUgJiYgIXNlbGVjdGlvbi5lbXB0eSkpIHtcbiAgICAvLyBgY29kZWBffF8gLS0+IGBjb2RlYHwgICAgIG5leHRDb2RlICYmIHNlbGVjdGlvbi5lbXB0eVxuICAgIC8vIGBjb2RlYOKWiOKWiOKWiCAtLT4gYGNvZGVgfCAgICAgaW5Db2RlICYmICFzZWxlY3Rpb24uZW1wdHlcbiAgICBjb25zdCBtZXRhOiBDdXJzb3JNZXRhVHIgPSB7IGFjdGlvbjogJ2FkZCcsIHBvczogdHIuc2VsZWN0aW9uLmZyb20gfTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnJlbW92ZVN0b3JlZE1hcmsobWFya1R5cGUpLnNldE1ldGEocGx1Z2luLCBtZXRhKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHRyLnNlbGVjdGlvbi4kZnJvbS5wYXJlbnRPZmZzZXQgPT09IDApIHtcbiAgICAvLyBe4paI4paI4paIYGNvZGVgIC0tPiBgfG9kZWBcbiAgICBjb25zdCBtZXRhOiBDdXJzb3JNZXRhVHIgPSB7IGFjdGlvbjogJ2FkZCcsIHBvczogdHIuc2VsZWN0aW9uLmZyb20sIHNpZGU6IC0xIH07XG4gICAgdmlldy5kaXNwYXRjaCh0ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKS5zZXRNZXRhKHBsdWdpbiwgbWV0YSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbkNvZGUgfHwgbmV4dENvZGUpIHtcbiAgICAvLyBgY3xvZGVgIC0tPiBgfG9kZWBcbiAgICAvLyBg4paI4paIZGVgIC0tPiBgfGRlYFxuICAgIGNvbnN0IG1ldGE6IEN1cnNvck1ldGFUciA9IHsgYWN0aW9uOiAnYWRkJywgcG9zOiB0ci5zZWxlY3Rpb24uZnJvbSB9O1xuICAgIHZpZXcuZGlzcGF0Y2godHIuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoKSkuc2V0TWV0YShwbHVnaW4sIG1ldGEpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVwT3V0c2lkZSh2aWV3OiBFZGl0b3JWaWV3LCBwbHVnaW46IFBsdWdpbiwgbWFya1R5cGU6IE1hcmtUeXBlKTogdm9pZCB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHZpZXcuc3RhdGU7XG4gIGlmICghc2VsZWN0aW9uLmVtcHR5KSByZXR1cm47XG4gIGNvbnN0IGluQ29kZSA9ICEhbWFya1R5cGUuaXNJblNldChzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gIGlmICghaW5Db2RlKSByZXR1cm47XG4gIGNvbnN0IG5leHRDb2RlID0gISFtYXJrVHlwZS5pc0luU2V0KGRvYy5yZXNvbHZlKHNlbGVjdGlvbi5mcm9tICsgMSkubWFya3MoKSA/PyBbXSk7XG4gIGNvbnN0IHByZXZDb2RlID0gISFtYXJrVHlwZS5pc0luU2V0KGRvYy5yZXNvbHZlKHNlbGVjdGlvbi5mcm9tIC0gMSkubWFya3MoKSA/PyBbXSk7XG4gIGxldCBtZXRhOiBDdXJzb3JNZXRhVHIgfCBudWxsID0gbnVsbDtcbiAgaWYgKCFuZXh0Q29kZSkge1xuICAgIC8vIGBjb2RlfGAgLS0+IGBjb2RlYHxcbiAgICBtZXRhID0geyBhY3Rpb246ICdhZGQnLCBwb3M6IHNlbGVjdGlvbi5mcm9tIH07XG4gIH0gZWxzZSBpZiAoIXByZXZDb2RlKSB7XG4gICAgLy8gYHxjb2RlYCAtLT4gfGBjb2RlYFxuICAgIG1ldGEgPSB7IGFjdGlvbjogJ2FkZCcsIHBvczogc2VsZWN0aW9uLmZyb20sIHNpZGU6IC0xIH07XG4gIH1cbiAgaWYgKG1ldGEpIHtcbiAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSkuc2V0TWV0YShwbHVnaW4sIG1ldGEpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjb2RlbWFyayB9IGZyb20gJy4vcGx1Z2luJztcblxuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNvZGVtYXJrO1xuIiwiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpblNwZWMsIFRleHRTZWxlY3Rpb24sIFRyYW5zYWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuaW1wb3J0IHsgTUFYX01BVENIIH0gZnJvbSAnLi91dGlscyc7XG5cbnR5cGUgSW5wdXRSdWxlU3RhdGUgPSB7XG4gIHRyYW5zZm9ybTogVHJhbnNhY3Rpb247XG4gIGZyb206IG51bWJlcjtcbiAgdG86IG51bWJlcjtcbiAgdGV4dDogc3RyaW5nO1xufSB8IG51bGw7XG5cbnR5cGUgUGx1Z2lucyA9IHsgaW5wdXQ6IFBsdWdpbjsgY3Vyc29yOiBQbHVnaW4gfTtcblxudHlwZSBIYW5kbGVyID0gKFxuICBzdGF0ZTogRWRpdG9yVmlldyxcbiAgdGV4dDogc3RyaW5nLFxuICBtYXRjaDogUmVnRXhwRXhlY0FycmF5LFxuICBmcm9tOiBudW1iZXIsXG4gIHRvOiBudW1iZXIsXG4gIHBsdWdpbjogUGx1Z2lucyxcbikgPT4gYm9vbGVhbjtcblxudHlwZSBSdWxlID0ge1xuICBtYXRjaDogUmVnRXhwO1xuICBoYW5kbGVyOiBIYW5kbGVyO1xufTtcblxuY29uc3QgbWFya0JlZm9yZTogUnVsZSA9IHtcbiAgbWF0Y2g6IC9gKCg/OlteYFxcd118W1xcd10pKylgJC8sXG4gIGhhbmRsZXI6ICh2aWV3LCB0ZXh0LCBtYXRjaCwgZnJvbSwgdG8sIHBsdWdpbnMpID0+IHtcbiAgICBjb25zdCBtYXJrVHlwZSA9IHZpZXcuc3RhdGUuc2NoZW1hLm1hcmtzLmNvZGUgYXMgTWFya1R5cGU7XG4gICAgLy8gRG9uJ3QgY3JlYXRlIGl0IGlmIHRoZXJlIGlzIGNvZGUgaW4gYmV0d2VlbiFcbiAgICBpZiAodmlldy5zdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKGZyb20sIHRvLCBtYXJrVHlwZSkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBjb2RlID0gbWF0Y2hbMV07XG4gICAgY29uc3QgbWFyayA9IG1hcmtUeXBlLmNyZWF0ZSgpO1xuICAgIGNvbnN0IHBvcyA9IGZyb20gKyBjb2RlLmxlbmd0aDtcbiAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHIuZGVsZXRlKGZyb20sIHRvKS5pbnNlcnRUZXh0KGNvZGUpLmFkZE1hcmsoZnJvbSwgcG9zLCBtYXJrKTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRyXG4gICAgICAuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9zKSlcbiAgICAgIC5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKVxuICAgICAgLnNldE1ldGEocGx1Z2lucy5jdXJzb3IsIHtcbiAgICAgICAgYWN0aW9uOiAnYWRkJyxcbiAgICAgICAgcG9zLFxuICAgICAgfSk7XG4gICAgY29uc3Qgd2l0aE1ldGEgPSBzZWxlY3RlZC5zZXRNZXRhKHBsdWdpbnMuaW5wdXQsIHtcbiAgICAgIHRyYW5zZm9ybTogc2VsZWN0ZWQsXG4gICAgICBmcm9tLFxuICAgICAgdG8sXG4gICAgICB0ZXh0OiBgXFxgJHtjb2RlfSR7dGV4dH1gLFxuICAgIH0pO1xuICAgIHZpZXcuZGlzcGF0Y2god2l0aE1ldGEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxufTtcblxuY29uc3QgbWFya0FmdGVyOiBSdWxlID0ge1xuICBtYXRjaDogL15gKCg/OlteYFxcd118W1xcd10pKylgLyxcbiAgaGFuZGxlcjogKHZpZXcsIHRleHQsIG1hdGNoLCBmcm9tLCB0bywgcGx1Z2lucykgPT4ge1xuICAgIGNvbnN0IG1hcmtUeXBlID0gdmlldy5zdGF0ZS5zY2hlbWEubWFya3MuY29kZSBhcyBNYXJrVHlwZTtcbiAgICAvLyBEb24ndCBjcmVhdGUgaXQgaWYgdGhlcmUgaXMgY29kZSBpbiBiZXR3ZWVuIVxuICAgIGlmICh2aWV3LnN0YXRlLmRvYy5yYW5nZUhhc01hcmsoZnJvbSwgdG8sIG1hcmtUeXBlKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IG1hcmsgPSBtYXJrVHlwZS5jcmVhdGUoKTtcbiAgICBjb25zdCBjb2RlID0gbWF0Y2hbMV07XG4gICAgY29uc3QgcG9zID0gZnJvbTtcbiAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHIuZGVsZXRlKGZyb20sIHRvKS5pbnNlcnRUZXh0KGNvZGUpLmFkZE1hcmsoZnJvbSwgdG8sIG1hcmspO1xuICAgIGNvbnN0IHNlbGVjdGVkID0gdHJcbiAgICAgIC5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb3MpKVxuICAgICAgLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKCkpXG4gICAgICAuc2V0TWV0YShwbHVnaW5zLmN1cnNvciwge1xuICAgICAgICBhY3Rpb246ICdhZGQnLFxuICAgICAgICBwb3MsXG4gICAgICB9KTtcbiAgICBjb25zdCB3aXRoTWV0YSA9IHNlbGVjdGVkLnNldE1ldGEocGx1Z2lucy5pbnB1dCwge1xuICAgICAgdHJhbnNmb3JtOiBzZWxlY3RlZCxcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIHRleHQ6IGBcXGAke2NvZGV9JHt0ZXh0fWAsXG4gICAgfSk7XG4gICAgdmlldy5kaXNwYXRjaCh3aXRoTWV0YSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBydW4odmlldzogRWRpdG9yVmlldywgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCB0ZXh0OiBzdHJpbmcsIHBsdWdpbnM6IFBsdWdpbnMpIHtcbiAgaWYgKHZpZXcuY29tcG9zaW5nKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXc7XG4gIGNvbnN0ICRmcm9tID0gc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gIGlmICgkZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGUpIHJldHVybiBmYWxzZTtcblxuICBjb25zdCBsZWFmVGV4dCA9ICdcXHVmZmZjJztcbiAgY29uc3QgdGV4dEJlZm9yZSA9XG4gICAgJGZyb20ucGFyZW50LnRleHRCZXR3ZWVuKFxuICAgICAgTWF0aC5tYXgoMCwgJGZyb20ucGFyZW50T2Zmc2V0IC0gTUFYX01BVENIKSxcbiAgICAgICRmcm9tLnBhcmVudE9mZnNldCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGxlYWZUZXh0LFxuICAgICkgKyB0ZXh0O1xuICBjb25zdCB0ZXh0QWZ0ZXIgPVxuICAgIHRleHQgK1xuICAgICRmcm9tLnBhcmVudC50ZXh0QmV0d2VlbihcbiAgICAgICRmcm9tLnBhcmVudE9mZnNldCxcbiAgICAgIE1hdGgubWluKCRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDIsICRmcm9tLnBhcmVudE9mZnNldCArIE1BWF9NQVRDSCksXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBsZWFmVGV4dCxcbiAgICApO1xuICBjb25zdCBtYXRjaEIgPSBtYXJrQmVmb3JlLm1hdGNoLmV4ZWModGV4dEJlZm9yZSk7XG4gIGNvbnN0IG1hdGNoQSA9IG1hcmtBZnRlci5tYXRjaC5leGVjKHRleHRBZnRlcik7XG4gIGlmIChtYXRjaEIpIHtcbiAgICBjb25zdCBoYW5kbGVkID0gbWFya0JlZm9yZS5oYW5kbGVyKFxuICAgICAgdmlldyxcbiAgICAgIHRleHQsXG4gICAgICBtYXRjaEIsXG4gICAgICBmcm9tIC0gbWF0Y2hCWzBdLmxlbmd0aCArIHRleHQubGVuZ3RoLFxuICAgICAgdG8sXG4gICAgICBwbHVnaW5zLFxuICAgICk7XG4gICAgaWYgKGhhbmRsZWQpIHJldHVybiBoYW5kbGVkO1xuICB9XG4gIGlmIChtYXRjaEEpXG4gICAgcmV0dXJuIG1hcmtBZnRlci5oYW5kbGVyKFxuICAgICAgdmlldyxcbiAgICAgIHRleHQsXG4gICAgICBtYXRjaEEsXG4gICAgICBmcm9tLFxuICAgICAgdG8gKyBtYXRjaEFbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgsXG4gICAgICBwbHVnaW5zLFxuICAgICk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUlucHV0UnVsZShjdXJzb3JQbHVnaW46IFBsdWdpbikge1xuICBjb25zdCBwbHVnaW46IFBsdWdpbjxJbnB1dFJ1bGVTdGF0ZT4gPSBuZXcgUGx1Z2luKHtcbiAgICBpc0lucHV0UnVsZXM6IHRydWUsXG4gICAgc3RhdGU6IHtcbiAgICAgIGluaXQ6ICgpID0+IG51bGwsXG4gICAgICBhcHBseSh0ciwgcHJldikge1xuICAgICAgICBjb25zdCBtZXRhID0gdHIuZ2V0TWV0YShwbHVnaW4pO1xuICAgICAgICBpZiAobWV0YSkgcmV0dXJuIG1ldGE7XG4gICAgICAgIHJldHVybiB0ci5zZWxlY3Rpb25TZXQgfHwgdHIuZG9jQ2hhbmdlZCA/IG51bGwgOiBwcmV2O1xuICAgICAgfSxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVUZXh0SW5wdXQodmlldywgZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJ1bih2aWV3LCBmcm9tLCB0bywgdGV4dCwgeyBpbnB1dDogcGx1Z2luLCBjdXJzb3I6IGN1cnNvclBsdWdpbiB9KTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfSBhcyBQbHVnaW5TcGVjKTtcbiAgcmV0dXJuIHBsdWdpbjtcbn1cbiIsImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luU3BlYyB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuaW1wb3J0IHsgQ29kZW1hcmtTdGF0ZSwgQ3Vyc29yTWV0YVRyLCBPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBwbHVnaW5LZXkgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUlucHV0UnVsZSB9IGZyb20gJy4vaW5wdXRSdWxlcyc7XG5pbXBvcnQge1xuICBvbkFycm93TGVmdCxcbiAgb25BcnJvd1JpZ2h0LFxuICBvbkJhY2tzcGFjZSxcbiAgb25CYWNrdGljayxcbiAgc3RlcE91dHNpZGUsXG4gIHN0ZXBPdXRzaWRlTmV4dFRyQW5kUGFzcyxcbn0gZnJvbSAnLi9hY3Rpb25zJztcblxuZnVuY3Rpb24gdG9Eb20oKTogTm9kZSB7XG4gIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIHNwYW4uY2xhc3NMaXN0LmFkZCgnZmFrZS1jdXJzb3InKTtcbiAgcmV0dXJuIHNwYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWNvcmF0aW9uUGx1Z2luKG1hcmtUeXBlOiBNYXJrVHlwZSkge1xuICBjb25zdCBwbHVnaW46IFBsdWdpbjxDb2RlbWFya1N0YXRlPiA9IG5ldyBQbHVnaW4oe1xuICAgIGtleTogcGx1Z2luS2V5LFxuICAgIHZpZXcoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGU6ICh2aWV3KSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBwbHVnaW4uZ2V0U3RhdGUodmlldy5zdGF0ZSkgYXMgQ29kZW1hcmtTdGF0ZTtcbiAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3Rbc3RhdGU/LmRlY29yYXRpb25zID8gJ2FkZCcgOiAncmVtb3ZlJ10oJ25vLWN1cnNvcicpO1xuICAgICAgICAgIGlmIChzdGF0ZT8uY2hlY2spIHN0ZXBPdXRzaWRlKHZpZXcsIHBsdWdpbiwgbWFya1R5cGUpO1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICBpbml0OiAoKSA9PiBudWxsLFxuICAgICAgYXBwbHkodHIsIHZhbHVlLCBvbGRTdGF0ZSk6IENvZGVtYXJrU3RhdGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRyLmdldE1ldGEocGx1Z2luKSBhcyBDdXJzb3JNZXRhVHIgfCBudWxsO1xuICAgICAgICBjb25zdCBwcmV2ID0gcGx1Z2luLmdldFN0YXRlKG9sZFN0YXRlKSBhcyBDb2RlbWFya1N0YXRlO1xuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgYWN0aW9uIHRvbGQgdXMgdG8gY2hlY2ssIHRyaWdnZXIgdGhlIHZpZXcgdG8gcmVuZGVyXG4gICAgICAgIGlmIChwcmV2Py5uZXh0KSByZXR1cm4geyBjaGVjazogdHJ1ZSB9O1xuICAgICAgICBzd2l0Y2ggKG1ldGE/LmFjdGlvbikge1xuICAgICAgICAgIGNhc2UgJ2FkZCc6IHtcbiAgICAgICAgICAgIGNvbnN0IGRlY28gPSBEZWNvcmF0aW9uLndpZGdldChtZXRhLnBvcywgdG9Eb20sIHsgc2lkZTogbWV0YS5zaWRlID8/IDAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkZWNvcmF0aW9uczogRGVjb3JhdGlvblNldC5jcmVhdGUodHIuZG9jLCBbZGVjb10pLFxuICAgICAgICAgICAgICBzaWRlOiBtZXRhLnNpZGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgIC8vIFRoZSB0cmFuc2FjdGlvbiBwdXRzIGEgZmxhZyB0aGF0IHdlIHdpbGwgY2hlY2sgbmV4dFxuICAgICAgICAgICAgLy8gT24gdGhlIG5leHQgdHJhbnNhY3Rpb24gdGhpcyB0dXJucyBpbnRvIHsgY2hlY2s6IHRydWUgfVxuICAgICAgICAgICAgLy8gVXNlZCBvbiBjb21wbGV4IGN1cnNvciBtb3ZlbWVudHMgdGhhdCBhcmUgbm90IG92ZXJyaWRkZW5cbiAgICAgICAgICAgIHJldHVybiB7IG5leHQ6IHRydWUgfTtcbiAgICAgICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBkZWNvcmF0aW9uczogKHN0YXRlKSA9PiBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpPy5kZWNvcmF0aW9ucyA/PyBEZWNvcmF0aW9uU2V0LmVtcHR5LFxuICAgICAgaGFuZGxlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICAgIGNhc2UgJ2AnOlxuICAgICAgICAgICAgcmV0dXJuIG9uQmFja3RpY2sodmlldywgcGx1Z2luLCBldmVudCwgbWFya1R5cGUpO1xuICAgICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgICAgcmV0dXJuIG9uQXJyb3dSaWdodCh2aWV3LCBwbHVnaW4sIGV2ZW50LCBtYXJrVHlwZSk7XG4gICAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICAgIHJldHVybiBvbkFycm93TGVmdCh2aWV3LCBwbHVnaW4sIGV2ZW50LCBtYXJrVHlwZSk7XG4gICAgICAgICAgY2FzZSAnQmFja3NwYWNlJzpcbiAgICAgICAgICAgIHJldHVybiBvbkJhY2tzcGFjZSh2aWV3LCBwbHVnaW4sIGV2ZW50LCBtYXJrVHlwZSk7XG4gICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICBjYXNlICdIb21lJzpcbiAgICAgICAgICBjYXNlICdFbmQnOlxuICAgICAgICAgICAgcmV0dXJuIHN0ZXBPdXRzaWRlTmV4dFRyQW5kUGFzcyh2aWV3LCBwbHVnaW4pO1xuICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgaWYgKCFldmVudC5jdHJsS2V5KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gc3RlcE91dHNpZGVOZXh0VHJBbmRQYXNzKHZpZXcsIHBsdWdpbik7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LFxuICB9IGFzIFBsdWdpblNwZWMpO1xuICByZXR1cm4gcGx1Z2luO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29kZW1hcmsob3B0czogT3B0aW9ucykge1xuICBjb25zdCB7IG1hcmtUeXBlIH0gPSBvcHRzO1xuICBjb25zdCBjdXJzb3JQbHVnaW4gPSBnZXREZWNvcmF0aW9uUGx1Z2luKG1hcmtUeXBlKTtcbiAgY29uc3QgaW5wdXRSdWxlID0gY3JlYXRlSW5wdXRSdWxlKGN1cnNvclBsdWdpbik7XG4gIGNvbnN0IHJ1bGVzOiBQbHVnaW5bXSA9IFtjdXJzb3JQbHVnaW4sIGlucHV0UnVsZV07XG4gIHJldHVybiBydWxlcztcbn1cbiIsImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgRGVjb3JhdGlvblNldCB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBtYXJrVHlwZTogTWFya1R5cGU7XG59O1xuXG5leHBvcnQgdHlwZSBDb2RlbWFya1N0YXRlID0ge1xuICBkZWNvcmF0aW9ucz86IERlY29yYXRpb25TZXQ7XG4gIHNpZGU/OiAtMTtcbiAgbmV4dD86IHRydWU7IC8vIFRyaWdnZXIgYSBsb29rIHVwIG9uIHRoZSBuZXh0IHJlbmRlclxuICBjaGVjaz86IHRydWU7IC8vIENoZWNrIGlmIHRoZSBjdXJzb3Igc2hvdWxkIGJlIG1vdmVkXG59IHwgbnVsbDtcblxuZXhwb3J0IHR5cGUgQ3Vyc29yTWV0YVRyID1cbiAgfCB7XG4gICAgICBhY3Rpb246ICdhZGQnO1xuICAgICAgcG9zOiBudW1iZXI7XG4gICAgICBzaWRlPzogLTE7XG4gICAgfVxuICB8IHsgYWN0aW9uOiAncmVtb3ZlJyB9XG4gIHwgeyBhY3Rpb246ICduZXh0JyB9O1xuIiwiaW1wb3J0IHsgUGx1Z2luS2V5IH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9JRCA9ICdjb2RlbWFyayc7XG5leHBvcnQgY29uc3QgTUFYX01BVENIID0gMTAwO1xuZXhwb3J0IGNvbnN0IHBsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoREVGQVVMVF9JRCk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVsdCgpIHtcbiAgdmFyIGVsdCA9IGFyZ3VtZW50c1swXVxuICBpZiAodHlwZW9mIGVsdCA9PSBcInN0cmluZ1wiKSBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsdClcbiAgdmFyIGkgPSAxLCBuZXh0ID0gYXJndW1lbnRzWzFdXG4gIGlmIChuZXh0ICYmIHR5cGVvZiBuZXh0ID09IFwib2JqZWN0XCIgJiYgbmV4dC5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBuZXh0KSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHQsIG5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXh0W25hbWVdXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIGVsdC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSBlbHRbbmFtZV0gPSB2YWx1ZVxuICAgIH1cbiAgICBpKytcbiAgfVxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYWRkKGVsdCwgYXJndW1lbnRzW2ldKVxuICByZXR1cm4gZWx0XG59XG5cbmZ1bmN0aW9uIGFkZChlbHQsIGNoaWxkKSB7XG4gIGlmICh0eXBlb2YgY2hpbGQgPT0gXCJzdHJpbmdcIikge1xuICAgIGVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZCkpXG4gIH0gZWxzZSBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlICE9IG51bGwpIHtcbiAgICBlbHQuYXBwZW5kQ2hpbGQoY2hpbGQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmxlbmd0aDsgaSsrKSBhZGQoZWx0LCBjaGlsZFtpXSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVuc3VwcG9ydGVkIGNoaWxkIG5vZGU6IFwiICsgY2hpbGQpXG4gIH1cbn1cbiIsImV4cG9ydCB2YXIgYmFzZSA9IHtcbiAgODogXCJCYWNrc3BhY2VcIixcbiAgOTogXCJUYWJcIixcbiAgMTA6IFwiRW50ZXJcIixcbiAgMTI6IFwiTnVtTG9ja1wiLFxuICAxMzogXCJFbnRlclwiLFxuICAxNjogXCJTaGlmdFwiLFxuICAxNzogXCJDb250cm9sXCIsXG4gIDE4OiBcIkFsdFwiLFxuICAyMDogXCJDYXBzTG9ja1wiLFxuICAyNzogXCJFc2NhcGVcIixcbiAgMzI6IFwiIFwiLFxuICAzMzogXCJQYWdlVXBcIixcbiAgMzQ6IFwiUGFnZURvd25cIixcbiAgMzU6IFwiRW5kXCIsXG4gIDM2OiBcIkhvbWVcIixcbiAgMzc6IFwiQXJyb3dMZWZ0XCIsXG4gIDM4OiBcIkFycm93VXBcIixcbiAgMzk6IFwiQXJyb3dSaWdodFwiLFxuICA0MDogXCJBcnJvd0Rvd25cIixcbiAgNDQ6IFwiUHJpbnRTY3JlZW5cIixcbiAgNDU6IFwiSW5zZXJ0XCIsXG4gIDQ2OiBcIkRlbGV0ZVwiLFxuICA1OTogXCI7XCIsXG4gIDYxOiBcIj1cIixcbiAgOTE6IFwiTWV0YVwiLFxuICA5MjogXCJNZXRhXCIsXG4gIDEwNjogXCIqXCIsXG4gIDEwNzogXCIrXCIsXG4gIDEwODogXCIsXCIsXG4gIDEwOTogXCItXCIsXG4gIDExMDogXCIuXCIsXG4gIDExMTogXCIvXCIsXG4gIDE0NDogXCJOdW1Mb2NrXCIsXG4gIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gIDE2MDogXCJTaGlmdFwiLFxuICAxNjE6IFwiU2hpZnRcIixcbiAgMTYyOiBcIkNvbnRyb2xcIixcbiAgMTYzOiBcIkNvbnRyb2xcIixcbiAgMTY0OiBcIkFsdFwiLFxuICAxNjU6IFwiQWx0XCIsXG4gIDE3MzogXCItXCIsXG4gIDE4NjogXCI7XCIsXG4gIDE4NzogXCI9XCIsXG4gIDE4ODogXCIsXCIsXG4gIDE4OTogXCItXCIsXG4gIDE5MDogXCIuXCIsXG4gIDE5MTogXCIvXCIsXG4gIDE5MjogXCJgXCIsXG4gIDIxOTogXCJbXCIsXG4gIDIyMDogXCJcXFxcXCIsXG4gIDIyMTogXCJdXCIsXG4gIDIyMjogXCInXCIsXG4gIDIyOTogXCJxXCJcbn1cblxuZXhwb3J0IHZhciBzaGlmdCA9IHtcbiAgNDg6IFwiKVwiLFxuICA0OTogXCIhXCIsXG4gIDUwOiBcIkBcIixcbiAgNTE6IFwiI1wiLFxuICA1MjogXCIkXCIsXG4gIDUzOiBcIiVcIixcbiAgNTQ6IFwiXlwiLFxuICA1NTogXCImXCIsXG4gIDU2OiBcIipcIixcbiAgNTc6IFwiKFwiLFxuICA1OTogXCI6XCIsXG4gIDYxOiBcIitcIixcbiAgMTczOiBcIl9cIixcbiAgMTg2OiBcIjpcIixcbiAgMTg3OiBcIitcIixcbiAgMTg4OiBcIjxcIixcbiAgMTg5OiBcIl9cIixcbiAgMTkwOiBcIj5cIixcbiAgMTkxOiBcIj9cIixcbiAgMTkyOiBcIn5cIixcbiAgMjE5OiBcIntcIixcbiAgMjIwOiBcInxcIixcbiAgMjIxOiBcIn1cIixcbiAgMjIyOiBcIlxcXCJcIixcbiAgMjI5OiBcIlFcIlxufVxuXG52YXIgY2hyb21lID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClcbnZhciBzYWZhcmkgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpXG52YXIgZ2Vja28gPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0dlY2tvXFwvXFxkKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxudmFyIG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbnZhciBpZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBcXGR8VHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClcbnZhciBicm9rZW5Nb2RpZmllck5hbWVzID0gY2hyb21lICYmIChtYWMgfHwgK2Nocm9tZVsxXSA8IDU3KSB8fCBnZWNrbyAmJiBtYWNcblxuLy8gRmlsbCBpbiB0aGUgZGlnaXQga2V5c1xuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSBiYXNlWzQ4ICsgaV0gPSBiYXNlWzk2ICsgaV0gPSBTdHJpbmcoaSlcblxuLy8gVGhlIGZ1bmN0aW9uIGtleXNcbmZvciAodmFyIGkgPSAxOyBpIDw9IDI0OyBpKyspIGJhc2VbaSArIDExMV0gPSBcIkZcIiArIGlcblxuLy8gQW5kIHRoZSBhbHBoYWJldGljIGtleXNcbmZvciAodmFyIGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7XG4gIGJhc2VbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAzMilcbiAgc2hpZnRbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXG59XG5cbi8vIEZvciBlYWNoIGNvZGUgdGhhdCBkb2Vzbid0IGhhdmUgYSBzaGlmdC1lcXVpdmFsZW50LCBjb3B5IHRoZSBiYXNlIG5hbWVcbmZvciAodmFyIGNvZGUgaW4gYmFzZSkgaWYgKCFzaGlmdC5oYXNPd25Qcm9wZXJ0eShjb2RlKSkgc2hpZnRbY29kZV0gPSBiYXNlW2NvZGVdXG5cbmV4cG9ydCBmdW5jdGlvbiBrZXlOYW1lKGV2ZW50KSB7XG4gIC8vIERvbid0IHRydXN0IGV2ZW50LmtleSBpbiBDaHJvbWUgd2hlbiB0aGVyZSBhcmUgbW9kaWZpZXJzIHVudGlsXG4gIC8vIHRoZXkgZml4IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYzMzgzOFxuICB2YXIgaWdub3JlS2V5ID0gYnJva2VuTW9kaWZpZXJOYW1lcyAmJiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSkgfHxcbiAgICAoc2FmYXJpIHx8IGllKSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgJiYgZXZlbnQua2V5Lmxlbmd0aCA9PSAxXG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIlxuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXG4gIGlmIChuYW1lID09IFwiRGVsXCIpIG5hbWUgPSBcIkRlbGV0ZVwiXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIlxuICBpZiAobmFtZSA9PSBcIlJpZ2h0XCIpIG5hbWUgPSBcIkFycm93UmlnaHRcIlxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcbiAgcmV0dXJuIG5hbWVcbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9kZW1vL2luZGV4LnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9