/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/codemark.css":
/*!****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/codemark.css ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "@keyframes blink {\n  49% {\n    border-color: unset;\n  }\n  50% {\n    border-color: #fff;\n  }\n  99% {\n    border-color: #fff;\n  }\n}\n.no-cursor {\n  caret-color: transparent;\n}\ndiv:focus .fake-cursor,\nspan:focus .fake-cursor {\n  margin-right: -1px;\n  border-left-width: 1px;\n  border-left-style: solid;\n  animation: blink 1s;\n  animation-iteration-count: infinite;\n  position: relative;\n  z-index: 1;\n}\n", "",{"version":3,"sources":["webpack://./src/codemark.css"],"names":[],"mappings":"AAAA;EACE;IACE,mBAAmB;EACrB;EACA;IACE,kBAAkB;EACpB;EACA;IACE,kBAAkB;EACpB;AACF;AACA;EACE,wBAAwB;AAC1B;AACA;;EAEE,kBAAkB;EAClB,sBAAsB;EACtB,wBAAwB;EACxB,mBAAmB;EACnB,mCAAmC;EACnC,kBAAkB;EAClB,UAAU;AACZ","sourcesContent":["@keyframes blink {\n  49% {\n    border-color: unset;\n  }\n  50% {\n    border-color: #fff;\n  }\n  99% {\n    border-color: #fff;\n  }\n}\n.no-cursor {\n  caret-color: transparent;\n}\ndiv:focus .fake-cursor,\nspan:focus .fake-cursor {\n  margin-right: -1px;\n  border-left-width: 1px;\n  border-left-style: solid;\n  animation: blink 1s;\n  animation-iteration-count: infinite;\n  position: relative;\n  z-index: 1;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/rope-sequence/dist/index.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/rope-sequence/dist/index.es.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var GOOD_LEAF_SIZE = 200;

// :: class<T> A rope sequence is a persistent sequence data structure
// that supports appending, prepending, and slicing without doing a
// full copy. It is represented as a mostly-balanced tree.
var RopeSequence = function RopeSequence () {};

RopeSequence.prototype.append = function append (other) {
  if (!other.length) { return this }
  other = RopeSequence.from(other);

  return (!this.length && other) ||
    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||
    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||
    this.appendInner(other)
};

// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>
// Prepend an array or other rope to this one, returning a new rope.
RopeSequence.prototype.prepend = function prepend (other) {
  if (!other.length) { return this }
  return RopeSequence.from(other).append(this)
};

RopeSequence.prototype.appendInner = function appendInner (other) {
  return new Append(this, other)
};

// :: (?number, ?number) → RopeSequence<T>
// Create a rope repesenting a sub-sequence of this rope.
RopeSequence.prototype.slice = function slice (from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  if (from >= to) { return RopeSequence.empty }
  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))
};

// :: (number) → T
// Retrieve the element at the given position from this rope.
RopeSequence.prototype.get = function get (i) {
  if (i < 0 || i >= this.length) { return undefined }
  return this.getInner(i)
};

// :: ((element: T, index: number) → ?bool, ?number, ?number)
// Call the given function for each element between the given
// indices. This tends to be more efficient than looping over the
// indices and calling `get`, because it doesn't have to descend the
// tree for every element.
RopeSequence.prototype.forEach = function forEach (f, from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  if (from <= to)
    { this.forEachInner(f, from, to, 0); }
  else
    { this.forEachInvertedInner(f, from, to, 0); }
};

// :: ((element: T, index: number) → U, ?number, ?number) → [U]
// Map the given functions over the elements of the rope, producing
// a flat array.
RopeSequence.prototype.map = function map (f, from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  var result = [];
  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);
  return result
};

// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>
// Create a rope representing the given array, or return the rope
// itself if a rope was given.
RopeSequence.from = function from (values) {
  if (values instanceof RopeSequence) { return values }
  return values && values.length ? new Leaf(values) : RopeSequence.empty
};

var Leaf = /*@__PURE__*/(function (RopeSequence) {
  function Leaf(values) {
    RopeSequence.call(this);
    this.values = values;
  }

  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;
  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );
  Leaf.prototype.constructor = Leaf;

  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };

  Leaf.prototype.flatten = function flatten () {
    return this.values
  };

  Leaf.prototype.sliceInner = function sliceInner (from, to) {
    if (from == 0 && to == this.length) { return this }
    return new Leaf(this.values.slice(from, to))
  };

  Leaf.prototype.getInner = function getInner (i) {
    return this.values[i]
  };

  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {
    for (var i = from; i < to; i++)
      { if (f(this.values[i], start + i) === false) { return false } }
  };

  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
    for (var i = from - 1; i >= to; i--)
      { if (f(this.values[i], start + i) === false) { return false } }
  };

  Leaf.prototype.leafAppend = function leafAppend (other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE)
      { return new Leaf(this.values.concat(other.flatten())) }
  };

  Leaf.prototype.leafPrepend = function leafPrepend (other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE)
      { return new Leaf(other.flatten().concat(this.values)) }
  };

  prototypeAccessors.length.get = function () { return this.values.length };

  prototypeAccessors.depth.get = function () { return 0 };

  Object.defineProperties( Leaf.prototype, prototypeAccessors );

  return Leaf;
}(RopeSequence));

// :: RopeSequence
// The empty rope sequence.
RopeSequence.empty = new Leaf([]);

var Append = /*@__PURE__*/(function (RopeSequence) {
  function Append(left, right) {
    RopeSequence.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }

  if ( RopeSequence ) Append.__proto__ = RopeSequence;
  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );
  Append.prototype.constructor = Append;

  Append.prototype.flatten = function flatten () {
    return this.left.flatten().concat(this.right.flatten())
  };

  Append.prototype.getInner = function getInner (i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)
  };

  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {
    var leftLen = this.left.length;
    if (from < leftLen &&
        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)
      { return false }
    if (to > leftLen &&
        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)
      { return false }
  };

  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
    var leftLen = this.left.length;
    if (from > leftLen &&
        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)
      { return false }
    if (to < leftLen &&
        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)
      { return false }
  };

  Append.prototype.sliceInner = function sliceInner (from, to) {
    if (from == 0 && to == this.length) { return this }
    var leftLen = this.left.length;
    if (to <= leftLen) { return this.left.slice(from, to) }
    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }
    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))
  };

  Append.prototype.leafAppend = function leafAppend (other) {
    var inner = this.right.leafAppend(other);
    if (inner) { return new Append(this.left, inner) }
  };

  Append.prototype.leafPrepend = function leafPrepend (other) {
    var inner = this.left.leafPrepend(other);
    if (inner) { return new Append(inner, this.right) }
  };

  Append.prototype.appendInner = function appendInner (other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)
      { return new Append(this.left, new Append(this.right, other)) }
    return new Append(this, other)
  };

  return Append;
}(RopeSequence));

var ropeSequence = RopeSequence;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ropeSequence);


/***/ }),

/***/ "./src/codemark.css":
/*!**************************!*\
  !*** ./src/codemark.css ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_codemark_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./codemark.css */ "./node_modules/css-loader/dist/cjs.js!./src/codemark.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_codemark_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_codemark_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_codemark_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_codemark_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./demo/compare.ts":
/*!*************************!*\
  !*** ./demo/compare.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.basicPlugin = void 0;
const prosemirror_inputrules_1 = __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.cjs");
// https://discuss.prosemirror.net/t/input-rules-for-wrapping-marks/537/11
function markInputRule(regexp, markType) {
    return new prosemirror_inputrules_1.InputRule(regexp, (state, match, start, end) => {
        const { tr } = state;
        if (state.doc.rangeHasMark(start, end, markType)) {
            return null;
        }
        const mark = markType.create();
        tr.delete(start, end);
        const text = match[1];
        tr.insertText(text);
        tr.addMark(start, start + text.length, mark);
        tr.removeStoredMark(markType);
        return tr;
    });
}
const codeInline = (schema) => [markInputRule(/`([\W\w]+)`$/, schema.marks.code)];
function basicPlugin(schema) {
    return [(0, prosemirror_inputrules_1.inputRules)({ rules: codeInline(schema) })];
}
exports.basicPlugin = basicPlugin;


/***/ }),

/***/ "./demo/index.ts":
/*!***********************!*\
  !*** ./demo/index.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");
const prosemirror_view_1 = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.cjs");
const prosemirror_model_1 = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");
const prosemirror_schema_basic_1 = __webpack_require__(/*! prosemirror-schema-basic */ "./node_modules/prosemirror-schema-basic/dist/index.cjs");
const prosemirror_example_setup_1 = __webpack_require__(/*! prosemirror-example-setup */ "./node_modules/prosemirror-example-setup/dist/index.cjs");
const src_1 = __importDefault(__webpack_require__(/*! ../src */ "./src/index.ts"));
__webpack_require__(/*! ../src/codemark.css */ "./src/codemark.css");
const compare_1 = __webpack_require__(/*! ./compare */ "./demo/compare.ts");
const editor = document.querySelector('#editor');
const content = document.querySelector('#content');
window.view = new prosemirror_view_1.EditorView(editor, {
    state: prosemirror_state_1.EditorState.create({
        doc: prosemirror_model_1.DOMParser.fromSchema(prosemirror_schema_basic_1.schema).parse(content),
        plugins: [
            ...(0, src_1.default)({ markType: prosemirror_schema_basic_1.schema.marks.code }),
            ...(0, prosemirror_example_setup_1.exampleSetup)({ schema: prosemirror_schema_basic_1.schema, menuBar: false }),
        ],
    }),
});
// This is showing what not to do!!
const editor1 = document.querySelector('#editor1');
const content1 = document.querySelector('#content1');
window.view1 = new prosemirror_view_1.EditorView(editor1, {
    state: prosemirror_state_1.EditorState.create({
        doc: prosemirror_model_1.DOMParser.fromSchema(prosemirror_schema_basic_1.schema).parse(content1),
        plugins: [...(0, compare_1.basicPlugin)(prosemirror_schema_basic_1.schema), ...(0, prosemirror_example_setup_1.exampleSetup)({ schema: prosemirror_schema_basic_1.schema, menuBar: false })],
    }),
});


/***/ }),

/***/ "./src/actions.ts":
/*!************************!*\
  !*** ./src/actions.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stepOutside = exports.onDelete = exports.onBackspace = exports.onArrowLeft = exports.onArrowRight = exports.onBacktick = exports.stepOutsideNextTrAndPass = void 0;
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
function stepOutsideNextTrAndPass(view, plugin, action = 'next') {
    const meta = { action };
    view.dispatch(view.state.tr.setMeta(plugin, meta));
    return false;
}
exports.stepOutsideNextTrAndPass = stepOutsideNextTrAndPass;
function onBacktick(view, plugin, event, markType) {
    if (view.state.selection.empty)
        return false;
    if (event.metaKey || event.shiftKey || event.altKey || event.ctrlKey)
        return false;
    // Create a code mark!
    const { from, to } = view.state.selection;
    if (to - from >= utils_1.MAX_MATCH || view.state.doc.rangeHasMark(from, to, markType))
        return false;
    const tr = view.state.tr.addMark(from, to, markType.create());
    const selected = tr.setSelection(prosemirror_state_1.TextSelection.create(tr.doc, to)).removeStoredMark(markType);
    view.dispatch(selected);
    return true;
}
exports.onBacktick = onBacktick;
function onArrowRightInside(view, plugin, event, markType) {
    var _a;
    if (event.metaKey)
        return stepOutsideNextTrAndPass(view, plugin);
    if (event.shiftKey || event.altKey || event.ctrlKey)
        return false;
    const { selection, doc } = view.state;
    if (!selection.empty)
        return false;
    const pluginState = plugin.getState(view.state);
    const pos = selection.$from;
    const inCode = !!markType.isInSet(pos.marks());
    const nextCode = !!markType.isInSet((_a = pos.marksAcross((0, utils_1.safeResolve)(doc, selection.from + 1))) !== null && _a !== void 0 ? _a : []);
    if (pos.pos === view.state.doc.nodeSize - 3 &&
        pos.parentOffset === pos.parent.nodeSize - 2 &&
        (pluginState === null || pluginState === void 0 ? void 0 : pluginState.active)) {
        // Behaviour stops: `code`| at the end of the document
        view.dispatch(view.state.tr.removeStoredMark(markType));
        return true;
    }
    if (inCode === nextCode && pos.parentOffset !== 0)
        return false;
    if (inCode && (!(pluginState === null || pluginState === void 0 ? void 0 : pluginState.active) || pluginState.side === -1) && pos.parentOffset !== 0) {
        // `code|` --> `code`|
        view.dispatch(view.state.tr.removeStoredMark(markType));
        return true;
    }
    if (nextCode && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.side) === -1) {
        // |`code` --> `|code`
        view.dispatch(view.state.tr.addStoredMark(markType.create()));
        return true;
    }
    return false;
}
function onArrowRight(view, plugin, event, markType) {
    const handled = onArrowRightInside(view, plugin, event, markType);
    if (handled)
        return true;
    const { selection } = view.state;
    const pos = selection.$from;
    if (selection.empty && pos.parentOffset === pos.parent.nodeSize - 2) {
        return stepOutsideNextTrAndPass(view, plugin);
    }
    return false;
}
exports.onArrowRight = onArrowRight;
function onArrowLeftInside(view, plugin, event, markType) {
    var _a;
    if (event.metaKey)
        return stepOutsideNextTrAndPass(view, plugin);
    if (event.shiftKey || event.altKey || event.ctrlKey)
        return false;
    const { selection, doc } = view.state;
    const pluginState = plugin.getState(view.state);
    const inCode = !!markType.isInSet(selection.$from.marks());
    const nextCode = !!markType.isInSet((_a = (0, utils_1.safeResolve)(doc, selection.empty ? selection.from - 1 : selection.from + 1).marks()) !== null && _a !== void 0 ? _a : []);
    if (inCode && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.side) === -1 && selection.$from.parentOffset === 0) {
        // New line!
        // ^|`code` --> |^`code`
        return false;
    }
    if ((pluginState === null || pluginState === void 0 ? void 0 : pluginState.side) === 0 && selection.$from.parentOffset === 0) {
        // New line!
        // ^`|code` --> ^|`code`
        view.dispatch(view.state.tr.removeStoredMark(markType));
        return true;
    }
    if (inCode && nextCode && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.side) === 0) {
        // `code`| --> `code|`
        view.dispatch(view.state.tr.addStoredMark(markType.create()));
        return true;
    }
    if (inCode && !nextCode && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.active) && selection.$from.parentOffset === 0) {
        // ^`|code` --> ^|`code`
        view.dispatch(view.state.tr.removeStoredMark(markType));
        return true;
    }
    if (!inCode && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.active) && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.side) === 0) {
        // `|code` --> |`code`
        view.dispatch(view.state.tr.removeStoredMark(markType));
        return true;
    }
    if (inCode === nextCode)
        return false;
    if (nextCode || (!selection.empty && inCode)) {
        // `code`_|_ --> `code`|   nextCode
        // `code`███ --> `code`|   !selection.empty && inCode
        // `██de`___ --> `|code`   !selection.empty && nextCode
        const from = selection.empty ? selection.from - 1 : selection.from;
        const selected = view.state.tr.setSelection(prosemirror_state_1.TextSelection.create(doc, from));
        if (!selection.empty && nextCode) {
            view.dispatch(selected.addStoredMark(markType.create()));
        }
        else {
            view.dispatch(selected.removeStoredMark(markType));
        }
        return true;
    }
    if ((nextCode || (!selection.empty && inCode)) && !(pluginState === null || pluginState === void 0 ? void 0 : pluginState.active)) {
        // `code`_|_ --> `code`|
        // `code`███ --> `code`|
        const from = selection.empty ? selection.from - 1 : selection.from;
        view.dispatch(view.state.tr.setSelection(prosemirror_state_1.TextSelection.create(doc, from)).removeStoredMark(markType));
        return true;
    }
    if (inCode && !(pluginState === null || pluginState === void 0 ? void 0 : pluginState.active) && selection.$from.parentOffset > 0) {
        // `c|ode` --> `|code`
        view.dispatch(view.state.tr
            .setSelection(prosemirror_state_1.TextSelection.create(doc, selection.from - 1))
            .addStoredMark(markType.create()));
        return true;
    }
    if (inCode && !nextCode && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.active) && pluginState.side !== -1) {
        // `x`| --> `x|` - Single character
        view.dispatch(view.state.tr.addStoredMark(markType.create()));
        return true;
    }
    if (inCode && !nextCode && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.active)) {
        // `x|` --> `|x` - Single character inside
        const pos = selection.from - 1;
        view.dispatch(view.state.tr.setSelection(prosemirror_state_1.TextSelection.create(doc, pos)).addStoredMark(markType.create()));
        return true;
    }
    return false;
}
function onArrowLeft(view, plugin, event, markType) {
    const handled = onArrowLeftInside(view, plugin, event, markType);
    if (handled)
        return true;
    const { selection } = view.state;
    const pos = selection.$from;
    const pluginState = plugin.getState(view.state);
    if (pos.pos === 1 && pos.parentOffset === 0 && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.side) === -1) {
        return true;
    }
    if (selection.empty && pos.parentOffset === 0) {
        return stepOutsideNextTrAndPass(view, plugin);
    }
    return false;
}
exports.onArrowLeft = onArrowLeft;
function onBackspace(view, plugin, event, markType) {
    if (event.metaKey || event.shiftKey || event.altKey || event.ctrlKey)
        return false;
    const { selection, doc } = view.state;
    const from = (0, utils_1.safeResolve)(doc, selection.from - 1);
    const fromCode = !!markType.isInSet(from.marks());
    const startOfLine = from.parentOffset === 0;
    const toCode = !!markType.isInSet((0, utils_1.safeResolve)(doc, selection.to + 1).marks());
    if ((!fromCode || startOfLine) && !toCode) {
        // `x|`    → |
        // `|████` → |
        // `|███`█ → |
        return stepOutsideNextTrAndPass(view, plugin);
    }
    // Firefox has difficulty with the decorations on -1.
    const pluginState = plugin.getState(view.state);
    if (selection.empty && (pluginState === null || pluginState === void 0 ? void 0 : pluginState.side) === -1) {
        const tr = view.state.tr.delete(selection.from - 1, selection.from);
        view.dispatch(tr);
        return true;
    }
    return false;
}
exports.onBackspace = onBackspace;
function onDelete(view, plugin, event, markType) {
    if (event.metaKey || event.shiftKey || event.altKey || event.ctrlKey)
        return false;
    const { selection, doc } = view.state;
    const fromCode = !!markType.isInSet(selection.$from.marks());
    const startOfLine = selection.$from.parentOffset === 0;
    const toCode = !!markType.isInSet((0, utils_1.safeResolve)(doc, selection.to + 2).marks());
    if ((!fromCode || startOfLine) && !toCode) {
        return stepOutsideNextTrAndPass(view, plugin);
    }
    return false;
}
exports.onDelete = onDelete;
function stepOutside(state, markType) {
    var _a, _b;
    if (!state)
        return null;
    const { selection, doc } = state;
    if (!selection.empty)
        return null;
    const stored = !!markType.isInSet((_a = state.storedMarks) !== null && _a !== void 0 ? _a : []);
    const inCode = !!markType.isInSet(selection.$from.marks());
    const nextCode = !!markType.isInSet((_b = (0, utils_1.safeResolve)(doc, selection.from + 1).marks()) !== null && _b !== void 0 ? _b : []);
    const startOfLine = selection.$from.parentOffset === 0;
    // `code|` --> `code`|
    // `|code` --> |`code`
    // ^`|code` --> ^|`code`
    if (inCode !== nextCode || (!inCode && stored !== inCode) || (inCode && startOfLine))
        return state.tr.removeStoredMark(markType);
    return null;
}
exports.stepOutside = stepOutside;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const plugin_1 = __webpack_require__(/*! ./plugin */ "./src/plugin.ts");
__exportStar(__webpack_require__(/*! ./types */ "./src/types.ts"), exports);
exports["default"] = plugin_1.codemark;


/***/ }),

/***/ "./src/inputRules.ts":
/*!***************************!*\
  !*** ./src/inputRules.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createInputRule = void 0;
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
function stopMatch(markType, view, from, to) {
    var _a;
    const stored = markType.isInSet((_a = view.state.storedMarks) !== null && _a !== void 0 ? _a : view.state.doc.resolve(from).marks());
    const range = view.state.doc.rangeHasMark(from, to, markType);
    // Don't create it if there is code in between!
    if (stored || range)
        return true;
    return false;
}
const markBefore = {
    match: /`((?:[^`\w]|[\w])+)`$/,
    handler: (markType, view, text, match, from, to, plugins) => {
        if (stopMatch(markType, view, from, to))
            return false;
        const code = match[1];
        const mark = markType.create();
        const pos = from + code.length;
        const tr = view.state.tr.delete(from, to).insertText(code).addMark(from, pos, mark);
        const selected = tr.setSelection(prosemirror_state_1.TextSelection.create(tr.doc, pos)).removeStoredMark(markType);
        const withMeta = selected.setMeta(plugins.input, {
            transform: selected,
            from,
            to,
            text: `\`${code}${text}`,
        });
        view.dispatch(withMeta);
        return true;
    },
};
const markAfter = {
    match: /^`((?:[^`\w]|[\w])+)`/,
    handler: (markType, view, text, match, from, to, plugins) => {
        if (stopMatch(markType, view, from, to))
            return false;
        const mark = markType.create();
        const code = match[1];
        const pos = from;
        const tr = view.state.tr
            .delete(from, to)
            .insertText(code)
            .addMark(from, from + code.length, mark);
        const selected = tr
            .setSelection(prosemirror_state_1.TextSelection.create(tr.doc, pos))
            .addStoredMark(markType.create());
        const withMeta = selected.setMeta(plugins.input, {
            transform: selected,
            from,
            to,
            text: `\`${code}${text}`,
        });
        view.dispatch(withMeta);
        return true;
    },
};
function run(markType, view, from, to, text, plugins) {
    if (view.composing)
        return false;
    const { state } = view;
    const $from = state.doc.resolve(from);
    if ($from.parent.type.spec.code)
        return false;
    const leafText = '\ufffc';
    const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - utils_1.MAX_MATCH), $from.parentOffset, undefined, leafText) + text;
    const textAfter = text +
        $from.parent.textBetween($from.parentOffset, Math.min($from.parent.nodeSize - 2, $from.parentOffset + utils_1.MAX_MATCH), undefined, leafText);
    const matchB = markBefore.match.exec(textBefore);
    const matchA = markAfter.match.exec(textAfter);
    if (matchB) {
        const handled = markBefore.handler(markType, view, text, matchB, from - matchB[0].length + text.length, to, plugins);
        if (handled)
            return handled;
    }
    if (matchA)
        return markAfter.handler(markType, view, text, matchA, from, to + matchA[0].length - text.length, plugins);
    return false;
}
function createInputRule(cursorPlugin, opts) {
    const plugin = new prosemirror_state_1.Plugin({
        isInputRules: true,
        state: {
            init: () => null,
            apply(tr, prev) {
                const meta = tr.getMeta(plugin);
                if (meta)
                    return meta;
                return tr.selectionSet || tr.docChanged ? null : prev;
            },
        },
        props: {
            handleTextInput(view, from, to, text) {
                const markType = (0, utils_1.getMarkType)(view, opts);
                return run(markType, view, from, to, text, { input: plugin, cursor: cursorPlugin });
            },
        },
    });
    return plugin;
}
exports.createInputRule = createInputRule;


/***/ }),

/***/ "./src/plugin.ts":
/*!***********************!*\
  !*** ./src/plugin.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.codemark = exports.getDecorationPlugin = void 0;
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");
const prosemirror_view_1 = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.cjs");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
const inputRules_1 = __webpack_require__(/*! ./inputRules */ "./src/inputRules.ts");
const actions_1 = __webpack_require__(/*! ./actions */ "./src/actions.ts");
function toDom() {
    const span = document.createElement('span');
    span.classList.add('fake-cursor');
    return span;
}
function getDecorationPlugin(opts) {
    const plugin = new prosemirror_state_1.Plugin({
        key: utils_1.pluginKey,
        appendTransaction: (trs, oldState, newState) => {
            var _a;
            const prev = plugin.getState(oldState);
            const meta = (_a = trs[0]) === null || _a === void 0 ? void 0 : _a.getMeta(plugin);
            if ((prev === null || prev === void 0 ? void 0 : prev.next) || (meta === null || meta === void 0 ? void 0 : meta.action) === 'click') {
                return (0, actions_1.stepOutside)(newState, (0, utils_1.getMarkType)(newState, opts));
            }
            return null;
        },
        state: {
            init: () => null,
            apply(tr, value, oldState, state) {
                var _a;
                const meta = tr.getMeta(plugin);
                if ((meta === null || meta === void 0 ? void 0 : meta.action) === 'next')
                    return { next: true };
                const markType = (0, utils_1.getMarkType)(state, opts);
                const nextMark = markType.isInSet((_a = state.storedMarks) !== null && _a !== void 0 ? _a : state.doc.resolve(tr.selection.from).marks());
                const inCode = markType.isInSet(state.doc.resolve(tr.selection.from).marks());
                const nextCode = markType.isInSet((0, utils_1.safeResolve)(state.doc, tr.selection.from + 1).marks());
                const startOfLine = tr.selection.$from.parentOffset === 0;
                if (!tr.selection.empty)
                    return null;
                if (!nextMark && nextCode && (!inCode || startOfLine)) {
                    // |`code`
                    return { active: true, side: -1 };
                }
                if (nextMark && (!inCode || startOfLine)) {
                    // `|code`
                    return { active: true, side: 0 };
                }
                if (!nextMark && inCode && !nextCode) {
                    // `code`|
                    return { active: true, side: 0 };
                }
                if (nextMark && inCode && !nextCode) {
                    // `code|`
                    return { active: true, side: -1 };
                }
                return null;
            },
        },
        props: {
            attributes: (state) => {
                var _a;
                const { active = false } = (_a = plugin.getState(state)) !== null && _a !== void 0 ? _a : {};
                return Object.assign({}, (active ? { class: 'no-cursor' } : {}));
            },
            decorations: (state) => {
                var _a;
                const { active, side } = (_a = plugin.getState(state)) !== null && _a !== void 0 ? _a : {};
                if (!active)
                    return prosemirror_view_1.DecorationSet.empty;
                const deco = prosemirror_view_1.Decoration.widget(state.selection.from, toDom, { side });
                return prosemirror_view_1.DecorationSet.create(state.doc, [deco]);
            },
            handleKeyDown(view, event) {
                switch (event.key) {
                    case '`':
                        return (0, actions_1.onBacktick)(view, plugin, event, (0, utils_1.getMarkType)(view, opts));
                    case 'ArrowRight':
                        return (0, actions_1.onArrowRight)(view, plugin, event, (0, utils_1.getMarkType)(view, opts));
                    case 'ArrowLeft':
                        return (0, actions_1.onArrowLeft)(view, plugin, event, (0, utils_1.getMarkType)(view, opts));
                    case 'Backspace':
                        return (0, actions_1.onBackspace)(view, plugin, event, (0, utils_1.getMarkType)(view, opts));
                    case 'Delete':
                        return (0, actions_1.onDelete)(view, plugin, event, (0, utils_1.getMarkType)(view, opts));
                    case 'ArrowUp':
                    case 'ArrowDown':
                    case 'Home':
                    case 'End':
                        return (0, actions_1.stepOutsideNextTrAndPass)(view, plugin);
                    case 'e':
                    case 'a':
                        if (!event.ctrlKey)
                            return false;
                        return (0, actions_1.stepOutsideNextTrAndPass)(view, plugin);
                    default:
                        return false;
                }
            },
            handleClick(view) {
                return (0, actions_1.stepOutsideNextTrAndPass)(view, plugin, 'click');
            },
        },
    });
    return plugin;
}
exports.getDecorationPlugin = getDecorationPlugin;
function codemark(opts) {
    const cursorPlugin = getDecorationPlugin(opts);
    const inputRule = (0, inputRules_1.createInputRule)(cursorPlugin, opts);
    const rules = [cursorPlugin, inputRule];
    return rules;
}
exports.codemark = codemark;


/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.safeResolve = exports.getMarkType = exports.pluginKey = exports.MAX_MATCH = exports.DEFAULT_ID = void 0;
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");
exports.DEFAULT_ID = 'codemark';
exports.MAX_MATCH = 100;
exports.pluginKey = new prosemirror_state_1.PluginKey(exports.DEFAULT_ID);
function getMarkType(view, opts) {
    var _a, _b;
    if ('schema' in view)
        return (_a = opts === null || opts === void 0 ? void 0 : opts.markType) !== null && _a !== void 0 ? _a : view.schema.marks.code;
    return (_b = opts === null || opts === void 0 ? void 0 : opts.markType) !== null && _b !== void 0 ? _b : view.state.schema.marks.code;
}
exports.getMarkType = getMarkType;
function safeResolve(doc, pos) {
    return doc.resolve(Math.min(Math.max(1, pos), doc.nodeSize - 2));
}
exports.safeResolve = safeResolve;


/***/ }),

/***/ "./node_modules/crelt/dist/index.cjs":
/*!*******************************************!*\
  !*** ./node_modules/crelt/dist/index.cjs ***!
  \*******************************************/
/***/ ((module) => {



function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string") elt = document.createElement(elt);
  var i = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
      var value = next[name];
      if (typeof value == "string") elt.setAttribute(name, value);
      else if (value != null) elt[name] = value;
    }
    i++;
  }
  for (; i < arguments.length; i++) add(elt, arguments[i]);
  return elt
}

function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) ; else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add(elt, child[i]);
  } else {
    throw new RangeError("Unsupported child node: " + child)
  }
}

module.exports = crelt;


/***/ }),

/***/ "./node_modules/orderedmap/dist/index.cjs":
/*!************************************************!*\
  !*** ./node_modules/orderedmap/dist/index.cjs ***!
  \************************************************/
/***/ ((module) => {



// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap(content) {
  this.content = content;
}

OrderedMap.prototype = {
  constructor: OrderedMap,

  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i
    return -1
  },

  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found = this.find(key);
    return found == -1 ? undefined : this.content[found + 1]
  },

  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found = self.find(key), content = self.content.slice();
    if (found == -1) {
      content.push(newKey || key, value);
    } else {
      content[found + 1] = value;
      if (newKey) content[found] = newKey;
    }
    return new OrderedMap(content)
  },

  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found = this.find(key);
    if (found == -1) return this
    var content = this.content.slice();
    content.splice(found, 2);
    return new OrderedMap(content)
  },

  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content))
  },

  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content)
  },

  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found = without.find(place);
    content.splice(found == -1 ? content.length : found, 0, key, value);
    return new OrderedMap(content)
  },

  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(map.content.concat(this.subtract(map).content))
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(this.subtract(map).content.concat(map.content))
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i = 0; i < map.content.length; i += 2)
      result = result.remove(map.content[i]);
    return result
  },

  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1
  }
};

// :: (?union<Object, OrderedMap>) → OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content)
};

module.exports = OrderedMap;


/***/ }),

/***/ "./node_modules/prosemirror-commands/dist/index.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var deleteSelection = function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false;
  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};

var joinBackward = function joinBackward(state, dispatch, view) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) return false;
  var $cut = findCutBefore($cursor);

  if (!$cut) {
    var range = $cursor.blockRange(),
        target = range && prosemirrorTransform.liftTarget(range);
    if (target == null) return false;
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }

  var before = $cut.nodeBefore;
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) return true;

  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || prosemirrorState.NodeSelection.isSelectable(before))) {
    var delStep = prosemirrorTransform.replaceStep(state.doc, $cursor.before(), $cursor.after(), prosemirrorModel.Slice.empty);

    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(before, "end") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirrorState.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
        dispatch(tr.scrollIntoView());
      }

      return true;
    }
  }

  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) dispatch(state.tr["delete"]($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }

  return false;
};

function textblockAt(node, side) {
  var only = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  for (var scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock) return true;
    if (only && scan.childCount != 1) return false;
  }

  return false;
}

var selectNodeBackward = function selectNodeBackward(state, dispatch, view) {
  var _state$selection = state.selection,
      $head = _state$selection.$head,
      empty = _state$selection.empty,
      $cut = $head;
  if (!empty) return false;

  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) return false;
    $cut = findCutBefore($head);
  }

  var node = $cut && $cut.nodeBefore;
  if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) return false;
  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};

function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {
    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));
    if ($pos.node(i).type.spec.isolating) break;
  }
  return null;
}

var joinForward = function joinForward(state, dispatch, view) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) return false;
  var $cut = findCutAfter($cursor);
  if (!$cut) return false;
  var after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch)) return true;

  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || prosemirrorState.NodeSelection.isSelectable(after))) {
    var delStep = prosemirrorTransform.replaceStep(state.doc, $cursor.before(), $cursor.after(), prosemirrorModel.Slice.empty);

    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirrorState.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }

      return true;
    }
  }

  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) dispatch(state.tr["delete"]($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }

  return false;
};

var selectNodeForward = function selectNodeForward(state, dispatch, view) {
  var _state$selection2 = state.selection,
      $head = _state$selection2.$head,
      empty = _state$selection2.empty,
      $cut = $head;
  if (!empty) return false;

  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size) return false;
    $cut = findCutAfter($head);
  }

  var node = $cut && $cut.nodeAfter;
  if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) return false;
  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};

function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {
    var parent = $pos.node(i);
    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1));
    if (parent.type.spec.isolating) break;
  }
  return null;
}

var joinUp = function joinUp(state, dispatch) {
  var sel = state.selection,
      nodeSel = sel instanceof prosemirrorState.NodeSelection,
      point;

  if (nodeSel) {
    if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.from)) return false;
    point = sel.from;
  } else {
    point = prosemirrorTransform.joinPoint(state.doc, sel.from, -1);
    if (point == null) return false;
  }

  if (dispatch) {
    var tr = state.tr.join(point);
    if (nodeSel) tr.setSelection(prosemirrorState.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr.scrollIntoView());
  }

  return true;
};

var joinDown = function joinDown(state, dispatch) {
  var sel = state.selection,
      point;

  if (sel instanceof prosemirrorState.NodeSelection) {
    if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.to)) return false;
    point = sel.to;
  } else {
    point = prosemirrorTransform.joinPoint(state.doc, sel.to, 1);
    if (point == null) return false;
  }

  if (dispatch) dispatch(state.tr.join(point).scrollIntoView());
  return true;
};

var lift = function lift(state, dispatch) {
  var _state$selection3 = state.selection,
      $from = _state$selection3.$from,
      $to = _state$selection3.$to;
  var range = $from.blockRange($to),
      target = range && prosemirrorTransform.liftTarget(range);
  if (target == null) return false;
  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};

var newlineInCode = function newlineInCode(state, dispatch) {
  var _state$selection4 = state.selection,
      $head = _state$selection4.$head,
      $anchor = _state$selection4.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;
  if (dispatch) dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};

function defaultBlockAt(match) {
  for (var i = 0; i < match.edgeCount; i++) {
    var _match$edge = match.edge(i),
        type = _match$edge.type;

    if (type.isTextblock && !type.hasRequiredAttrs()) return type;
  }

  return null;
}

var exitCode = function exitCode(state, dispatch) {
  var _state$selection5 = state.selection,
      $head = _state$selection5.$head,
      $anchor = _state$selection5.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;
  var above = $head.node(-1),
      after = $head.indexAfter(-1),
      type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type)) return false;

  if (dispatch) {
    var pos = $head.after(),
        tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(prosemirrorState.Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }

  return true;
};

var createParagraphNear = function createParagraphNear(state, dispatch) {
  var sel = state.selection,
      $from = sel.$from,
      $to = sel.$to;
  if (sel instanceof prosemirrorState.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;
  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock) return false;

  if (dispatch) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }

  return true;
};

var liftEmptyBlock = function liftEmptyBlock(state, dispatch) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || $cursor.parent.content.size) return false;

  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before = $cursor.before();

    if (prosemirrorTransform.canSplit(state.doc, before)) {
      if (dispatch) dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }

  var range = $cursor.blockRange(),
      target = range && prosemirrorTransform.liftTarget(range);
  if (target == null) return false;
  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};

var splitBlock = function splitBlock(state, dispatch) {
  var _state$selection6 = state.selection,
      $from = _state$selection6.$from,
      $to = _state$selection6.$to;

  if (state.selection instanceof prosemirrorState.NodeSelection && state.selection.node.isBlock) {
    if (!$from.parentOffset || !prosemirrorTransform.canSplit(state.doc, $from.pos)) return false;
    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());
    return true;
  }

  if (!$from.parent.isBlock) return false;

  if (dispatch) {
    var atEnd = $to.parentOffset == $to.parent.content.size;
    var tr = state.tr;
    if (state.selection instanceof prosemirrorState.TextSelection || state.selection instanceof prosemirrorState.AllSelection) tr.deleteSelection();
    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    var types = atEnd && deflt ? [{
      type: deflt
    }] : undefined;
    var can = prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);

    if (!types && !can && prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{
      type: deflt
    }] : undefined)) {
      if (deflt) types = [{
        type: deflt
      }];
      can = true;
    }

    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);

      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
        var first = tr.mapping.map($from.before()),
            $first = tr.doc.resolve(first);
        if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
      }
    }

    dispatch(tr.scrollIntoView());
  }

  return true;
};

var splitBlockKeepMarks = function splitBlockKeepMarks(state, dispatch) {
  return splitBlock(state, dispatch && function (tr) {
    var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks) tr.ensureMarks(marks);
    dispatch(tr);
  });
};

var selectParentNode = function selectParentNode(state, dispatch) {
  var _state$selection7 = state.selection,
      $from = _state$selection7.$from,
      to = _state$selection7.to,
      pos;
  var same = $from.sharedDepth(to);
  if (same == 0) return false;
  pos = $from.before(same);
  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, pos)));
  return true;
};

var selectAll = function selectAll(state, dispatch) {
  if (dispatch) dispatch(state.tr.setSelection(new prosemirrorState.AllSelection(state.doc)));
  return true;
};

function joinMaybeClear(state, $pos, dispatch) {
  var before = $pos.nodeBefore,
      after = $pos.nodeAfter,
      index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type)) return false;

  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch) dispatch(state.tr["delete"]($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }

  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || prosemirrorTransform.canJoin(state.doc, $pos.pos))) return false;
  if (dispatch) dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}

function deleteBarrier(state, $cut, dispatch) {
  var before = $cut.nodeBefore,
      after = $cut.nodeAfter,
      conn,
      match;
  if (before.type.spec.isolating || after.type.spec.isolating) return false;
  if (joinMaybeClear(state, $cut, dispatch)) return true;
  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);

  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      var end = $cut.pos + after.nodeSize,
          wrap = prosemirrorModel.Fragment.empty;

      for (var i = conn.length - 1; i >= 0; i--) {
        wrap = prosemirrorModel.Fragment.from(conn[i].create(null, wrap));
      }

      wrap = prosemirrorModel.Fragment.from(before.copy(wrap));
      var tr = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirrorModel.Slice(wrap, 1, 0), conn.length, true));
      var joinAt = end + 2 * conn.length;
      if (prosemirrorTransform.canJoin(tr.doc, joinAt)) tr.join(joinAt);
      dispatch(tr.scrollIntoView());
    }

    return true;
  }

  var selAfter = prosemirrorState.Selection.findFrom($cut, 1);
  var range = selAfter && selAfter.$from.blockRange(selAfter.$to),
      target = range && prosemirrorTransform.liftTarget(range);

  if (target != null && target >= $cut.depth) {
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }

  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    var at = before,
        _wrap = [];

    for (;;) {
      _wrap.push(at);

      if (at.isTextblock) break;
      at = at.lastChild;
    }

    var afterText = after,
        afterDepth = 1;

    for (; !afterText.isTextblock; afterText = afterText.firstChild) {
      afterDepth++;
    }

    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        var _end = prosemirrorModel.Fragment.empty;

        for (var _i = _wrap.length - 1; _i >= 0; _i--) {
          _end = prosemirrorModel.Fragment.from(_wrap[_i].copy(_end));
        }

        var _tr = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - _wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirrorModel.Slice(_end, _wrap.length, 0), 0, true));

        dispatch(_tr.scrollIntoView());
      }

      return true;
    }
  }

  return false;
}

function selectTextblockSide(side) {
  return function (state, dispatch) {
    var sel = state.selection,
        $pos = side < 0 ? sel.$from : sel.$to;
    var depth = $pos.depth;

    while ($pos.node(depth).isInline) {
      if (!depth) return false;
      depth--;
    }

    if (!$pos.node(depth).isTextblock) return false;
    if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}

var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);

function wrapIn(nodeType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection8 = state.selection,
        $from = _state$selection8.$from,
        $to = _state$selection8.$to;
    var range = $from.blockRange($to),
        wrapping = range && prosemirrorTransform.findWrapping(range, nodeType, attrs);
    if (!wrapping) return false;
    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}

function setBlockType(nodeType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection9 = state.selection,
        from = _state$selection9.from,
        to = _state$selection9.to;
    var applicable = false;
    state.doc.nodesBetween(from, to, function (node, pos) {
      if (applicable) return false;
      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;

      if (node.type == nodeType) {
        applicable = true;
      } else {
        var $pos = state.doc.resolve(pos),
            index = $pos.index();
        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
      }
    });
    if (!applicable) return false;
    if (dispatch) dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView());
    return true;
  };
}

function markApplies(doc, ranges, type) {
  var _loop = function _loop(i) {
    var _ranges$i = ranges[i],
        $from = _ranges$i.$from,
        $to = _ranges$i.$to;
    var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;
    doc.nodesBetween($from.pos, $to.pos, function (node) {
      if (can) return false;
      can = node.inlineContent && node.type.allowsMarkType(type);
    });
    if (can) return {
      v: true
    };
  };

  for (var i = 0; i < ranges.length; i++) {
    var _ret = _loop(i);

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return false;
}

function toggleMark(markType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection10 = state.selection,
        empty = _state$selection10.empty,
        $cursor = _state$selection10.$cursor,
        ranges = _state$selection10.ranges;
    if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) return false;

    if (dispatch) {
      if ($cursor) {
        if (markType.isInSet(state.storedMarks || $cursor.marks())) dispatch(state.tr.removeStoredMark(markType));else dispatch(state.tr.addStoredMark(markType.create(attrs)));
      } else {
        var has = false,
            tr = state.tr;

        for (var i = 0; !has && i < ranges.length; i++) {
          var _ranges$i2 = ranges[i],
              $from = _ranges$i2.$from,
              $to = _ranges$i2.$to;
          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
        }

        for (var _i2 = 0; _i2 < ranges.length; _i2++) {
          var _ranges$_i = ranges[_i2],
              _$from = _ranges$_i.$from,
              _$to = _ranges$_i.$to;

          if (has) {
            tr.removeMark(_$from.pos, _$to.pos, markType);
          } else {
            var from = _$from.pos,
                to = _$to.pos,
                start = _$from.nodeAfter,
                end = _$to.nodeBefore;
            var spaceStart = start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
            var spaceEnd = end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;

            if (from + spaceStart < to) {
              from += spaceStart;
              to -= spaceEnd;
            }

            tr.addMark(from, to, markType.create(attrs));
          }
        }

        dispatch(tr.scrollIntoView());
      }
    }

    return true;
  };
}

function wrapDispatchForJoin(dispatch, isJoinable) {
  return function (tr) {
    if (!tr.isGeneric) return dispatch(tr);
    var ranges = [];

    for (var i = 0; i < tr.mapping.maps.length; i++) {
      var map = tr.mapping.maps[i];

      for (var j = 0; j < ranges.length; j++) {
        ranges[j] = map.map(ranges[j]);
      }

      map.forEach(function (_s, _e, from, to) {
        return ranges.push(from, to);
      });
    }

    var joinable = [];

    for (var _i3 = 0; _i3 < ranges.length; _i3 += 2) {
      var from = ranges[_i3],
          to = ranges[_i3 + 1];
      var $from = tr.doc.resolve(from),
          depth = $from.sharedDepth(to),
          parent = $from.node(depth);

      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {
        var after = parent.maybeChild(index);
        if (!after) break;

        if (index && joinable.indexOf(pos) == -1) {
          var before = parent.child(index - 1);
          if (before.type == after.type && isJoinable(before, after)) joinable.push(pos);
        }

        pos += after.nodeSize;
      }
    }

    joinable.sort(function (a, b) {
      return a - b;
    });

    for (var _i4 = joinable.length - 1; _i4 >= 0; _i4--) {
      if (prosemirrorTransform.canJoin(tr.doc, joinable[_i4])) tr.join(joinable[_i4]);
    }

    dispatch(tr);
  };
}

function autoJoin(command, isJoinable) {
  var canJoin = Array.isArray(isJoinable) ? function (node) {
    return isJoinable.indexOf(node.type.name) > -1;
  } : isJoinable;
  return function (state, dispatch, view) {
    return command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);
  };
}

function chainCommands() {
  for (var _len = arguments.length, commands = new Array(_len), _key = 0; _key < _len; _key++) {
    commands[_key] = arguments[_key];
  }

  return function (state, dispatch, view) {
    for (var i = 0; i < commands.length; i++) {
      if (commands[i](state, dispatch, view)) return true;
    }

    return false;
  };
}

var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};

for (var key in pcBaseKeymap) {
  macBaseKeymap[key] = pcBaseKeymap[key];
}

var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
var baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;
exports.autoJoin = autoJoin;
exports.baseKeymap = baseKeymap;
exports.chainCommands = chainCommands;
exports.createParagraphNear = createParagraphNear;
exports.deleteSelection = deleteSelection;
exports.exitCode = exitCode;
exports.joinBackward = joinBackward;
exports.joinDown = joinDown;
exports.joinForward = joinForward;
exports.joinUp = joinUp;
exports.lift = lift;
exports.liftEmptyBlock = liftEmptyBlock;
exports.macBaseKeymap = macBaseKeymap;
exports.newlineInCode = newlineInCode;
exports.pcBaseKeymap = pcBaseKeymap;
exports.selectAll = selectAll;
exports.selectNodeBackward = selectNodeBackward;
exports.selectNodeForward = selectNodeForward;
exports.selectParentNode = selectParentNode;
exports.selectTextblockEnd = selectTextblockEnd;
exports.selectTextblockStart = selectTextblockStart;
exports.setBlockType = setBlockType;
exports.splitBlock = splitBlock;
exports.splitBlockKeepMarks = splitBlockKeepMarks;
exports.toggleMark = toggleMark;
exports.wrapIn = wrapIn;


/***/ }),

/***/ "./node_modules/prosemirror-dropcursor/dist/index.cjs":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-dropcursor/dist/index.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

function dropCursor() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new prosemirrorState.Plugin({
    view: function view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}

var DropCursorView = function () {
  function DropCursorView(editorView, options) {
    var _this = this;

    _classCallCheck(this, DropCursorView);

    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = options.width || 1;
    this.color = options.color || "black";
    this["class"] = options["class"];
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(function (name) {
      var handler = function handler(e) {
        _this[name](e);
      };

      editorView.dom.addEventListener(name, handler);
      return {
        name: name,
        handler: handler
      };
    });
  }

  _createClass(DropCursorView, [{
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      this.handlers.forEach(function (_ref) {
        var name = _ref.name,
            handler = _ref.handler;
        return _this2.editorView.dom.removeEventListener(name, handler);
      });
    }
  }, {
    key: "update",
    value: function update(editorView, prevState) {
      if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
        if (this.cursorPos > editorView.state.doc.content.size) this.setCursor(null);else this.updateOverlay();
      }
    }
  }, {
    key: "setCursor",
    value: function setCursor(pos) {
      if (pos == this.cursorPos) return;
      this.cursorPos = pos;

      if (pos == null) {
        this.element.parentNode.removeChild(this.element);
        this.element = null;
      } else {
        this.updateOverlay();
      }
    }
  }, {
    key: "updateOverlay",
    value: function updateOverlay() {
      var $pos = this.editorView.state.doc.resolve(this.cursorPos),
          rect;

      if (!$pos.parent.inlineContent) {
        var before = $pos.nodeBefore,
            after = $pos.nodeAfter;

        if (before || after) {
          var nodeRect = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0)).getBoundingClientRect();
          var top = before ? nodeRect.bottom : nodeRect.top;
          if (before && after) top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          rect = {
            left: nodeRect.left,
            right: nodeRect.right,
            top: top - this.width / 2,
            bottom: top + this.width / 2
          };
        }
      }

      if (!rect) {
        var coords = this.editorView.coordsAtPos(this.cursorPos);
        rect = {
          left: coords.left - this.width / 2,
          right: coords.left + this.width / 2,
          top: coords.top,
          bottom: coords.bottom
        };
      }

      var parent = this.editorView.dom.offsetParent;

      if (!this.element) {
        this.element = parent.appendChild(document.createElement("div"));
        if (this["class"]) this.element.className = this["class"];
        this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none; background-color: " + this.color;
      }

      var parentLeft, parentTop;

      if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
        parentLeft = -pageXOffset;
        parentTop = -pageYOffset;
      } else {
        var _rect = parent.getBoundingClientRect();

        parentLeft = _rect.left - parent.scrollLeft;
        parentTop = _rect.top - parent.scrollTop;
      }

      this.element.style.left = rect.left - parentLeft + "px";
      this.element.style.top = rect.top - parentTop + "px";
      this.element.style.width = rect.right - rect.left + "px";
      this.element.style.height = rect.bottom - rect.top + "px";
    }
  }, {
    key: "scheduleRemoval",
    value: function scheduleRemoval(timeout) {
      var _this3 = this;

      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        return _this3.setCursor(null);
      }, timeout);
    }
  }, {
    key: "dragover",
    value: function dragover(event) {
      if (!this.editorView.editable) return;
      var pos = this.editorView.posAtCoords({
        left: event.clientX,
        top: event.clientY
      });
      var node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
      var disableDropCursor = node && node.type.spec.disableDropCursor;
      var disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos) : disableDropCursor;

      if (pos && !disabled) {
        var target = pos.pos;

        if (this.editorView.dragging && this.editorView.dragging.slice) {
          target = prosemirrorTransform.dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
          if (target == null) return this.setCursor(null);
        }

        this.setCursor(target);
        this.scheduleRemoval(5000);
      }
    }
  }, {
    key: "dragend",
    value: function dragend() {
      this.scheduleRemoval(20);
    }
  }, {
    key: "drop",
    value: function drop() {
      this.scheduleRemoval(20);
    }
  }, {
    key: "dragleave",
    value: function dragleave(event) {
      if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget)) this.setCursor(null);
    }
  }]);

  return DropCursorView;
}();

exports.dropCursor = dropCursor;


/***/ }),

/***/ "./node_modules/prosemirror-example-setup/dist/index.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/prosemirror-example-setup/dist/index.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorKeymap = __webpack_require__(/*! prosemirror-keymap */ "./node_modules/prosemirror-keymap/dist/index.cjs");

var prosemirrorHistory = __webpack_require__(/*! prosemirror-history */ "./node_modules/prosemirror-history/dist/index.cjs");

var prosemirrorCommands = __webpack_require__(/*! prosemirror-commands */ "./node_modules/prosemirror-commands/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var prosemirrorDropcursor = __webpack_require__(/*! prosemirror-dropcursor */ "./node_modules/prosemirror-dropcursor/dist/index.cjs");

var prosemirrorGapcursor = __webpack_require__(/*! prosemirror-gapcursor */ "./node_modules/prosemirror-gapcursor/dist/index.cjs");

var prosemirrorMenu = __webpack_require__(/*! prosemirror-menu */ "./node_modules/prosemirror-menu/dist/index.cjs");

var prosemirrorSchemaList = __webpack_require__(/*! prosemirror-schema-list */ "./node_modules/prosemirror-schema-list/dist/index.cjs");

var prosemirrorInputrules = __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.cjs");

var prefix = "ProseMirror-prompt";

function openPrompt(options) {
  var wrapper = document.body.appendChild(document.createElement("div"));
  wrapper.className = prefix;

  var mouseOutside = function mouseOutside(e) {
    if (!wrapper.contains(e.target)) close();
  };

  setTimeout(function () {
    return window.addEventListener("mousedown", mouseOutside);
  }, 50);

  var close = function close() {
    window.removeEventListener("mousedown", mouseOutside);
    if (wrapper.parentNode) wrapper.parentNode.removeChild(wrapper);
  };

  var domFields = [];

  for (var name in options.fields) {
    domFields.push(options.fields[name].render());
  }

  var submitButton = document.createElement("button");
  submitButton.type = "submit";
  submitButton.className = prefix + "-submit";
  submitButton.textContent = "OK";
  var cancelButton = document.createElement("button");
  cancelButton.type = "button";
  cancelButton.className = prefix + "-cancel";
  cancelButton.textContent = "Cancel";
  cancelButton.addEventListener("click", close);
  var form = wrapper.appendChild(document.createElement("form"));
  if (options.title) form.appendChild(document.createElement("h5")).textContent = options.title;
  domFields.forEach(function (field) {
    form.appendChild(document.createElement("div")).appendChild(field);
  });
  var buttons = form.appendChild(document.createElement("div"));
  buttons.className = prefix + "-buttons";
  buttons.appendChild(submitButton);
  buttons.appendChild(document.createTextNode(" "));
  buttons.appendChild(cancelButton);
  var box = wrapper.getBoundingClientRect();
  wrapper.style.top = (window.innerHeight - box.height) / 2 + "px";
  wrapper.style.left = (window.innerWidth - box.width) / 2 + "px";

  var submit = function submit() {
    var params = getValues(options.fields, domFields);

    if (params) {
      close();
      options.callback(params);
    }
  };

  form.addEventListener("submit", function (e) {
    e.preventDefault();
    submit();
  });
  form.addEventListener("keydown", function (e) {
    if (e.keyCode == 27) {
      e.preventDefault();
      close();
    } else if (e.keyCode == 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) {
      e.preventDefault();
      submit();
    } else if (e.keyCode == 9) {
      window.setTimeout(function () {
        if (!wrapper.contains(document.activeElement)) close();
      }, 500);
    }
  });
  var input = form.elements[0];
  if (input) input.focus();
}

function getValues(fields, domFields) {
  var result = Object.create(null),
      i = 0;

  for (var name in fields) {
    var field = fields[name],
        dom = domFields[i++];
    var value = field.read(dom),
        bad = field.validate(value);

    if (bad) {
      reportInvalid(dom, bad);
      return null;
    }

    result[name] = field.clean(value);
  }

  return result;
}

function reportInvalid(dom, message) {
  var parent = dom.parentNode;
  var msg = parent.appendChild(document.createElement("div"));
  msg.style.left = dom.offsetLeft + dom.offsetWidth + 2 + "px";
  msg.style.top = dom.offsetTop - 5 + "px";
  msg.className = "ProseMirror-invalid";
  msg.textContent = message;
  setTimeout(function () {
    return parent.removeChild(msg);
  }, 1500);
}

var Field = function () {
  function Field(options) {
    _classCallCheck(this, Field);

    this.options = options;
  }

  _createClass(Field, [{
    key: "read",
    value: function read(dom) {
      return dom.value;
    }
  }, {
    key: "validateType",
    value: function validateType(value) {
      return null;
    }
  }, {
    key: "validate",
    value: function validate(value) {
      if (!value && this.options.required) return "Required field";
      return this.validateType(value) || (this.options.validate ? this.options.validate(value) : null);
    }
  }, {
    key: "clean",
    value: function clean(value) {
      return this.options.clean ? this.options.clean(value) : value;
    }
  }]);

  return Field;
}();

var TextField = function (_Field) {
  _inherits(TextField, _Field);

  var _super = _createSuper(TextField);

  function TextField() {
    _classCallCheck(this, TextField);

    return _super.apply(this, arguments);
  }

  _createClass(TextField, [{
    key: "render",
    value: function render() {
      var input = document.createElement("input");
      input.type = "text";
      input.placeholder = this.options.label;
      input.value = this.options.value || "";
      input.autocomplete = "off";
      return input;
    }
  }]);

  return TextField;
}(Field);

function canInsert(state, nodeType) {
  var $from = state.selection.$from;

  for (var d = $from.depth; d >= 0; d--) {
    var index = $from.index(d);
    if ($from.node(d).canReplaceWith(index, index, nodeType)) return true;
  }

  return false;
}

function insertImageItem(nodeType) {
  return new prosemirrorMenu.MenuItem({
    title: "Insert image",
    label: "Image",
    enable: function enable(state) {
      return canInsert(state, nodeType);
    },
    run: function run(state, _, view) {
      var _state$selection = state.selection,
          from = _state$selection.from,
          to = _state$selection.to,
          attrs = null;
      if (state.selection instanceof prosemirrorState.NodeSelection && state.selection.node.type == nodeType) attrs = state.selection.node.attrs;
      openPrompt({
        title: "Insert image",
        fields: {
          src: new TextField({
            label: "Location",
            required: true,
            value: attrs && attrs.src
          }),
          title: new TextField({
            label: "Title",
            value: attrs && attrs.title
          }),
          alt: new TextField({
            label: "Description",
            value: attrs ? attrs.alt : state.doc.textBetween(from, to, " ")
          })
        },
        callback: function callback(attrs) {
          view.dispatch(view.state.tr.replaceSelectionWith(nodeType.createAndFill(attrs)));
          view.focus();
        }
      });
    }
  });
}

function cmdItem(cmd, options) {
  var passedOptions = {
    label: options.title,
    run: cmd
  };

  for (var prop in options) {
    passedOptions[prop] = options[prop];
  }

  if (!options.enable && !options.select) passedOptions[options.enable ? "enable" : "select"] = function (state) {
    return cmd(state);
  };
  return new prosemirrorMenu.MenuItem(passedOptions);
}

function markActive(state, type) {
  var _state$selection2 = state.selection,
      from = _state$selection2.from,
      $from = _state$selection2.$from,
      to = _state$selection2.to,
      empty = _state$selection2.empty;
  if (empty) return !!type.isInSet(state.storedMarks || $from.marks());else return state.doc.rangeHasMark(from, to, type);
}

function markItem(markType, options) {
  var passedOptions = {
    active: function active(state) {
      return markActive(state, markType);
    }
  };

  for (var prop in options) {
    passedOptions[prop] = options[prop];
  }

  return cmdItem(prosemirrorCommands.toggleMark(markType), passedOptions);
}

function linkItem(markType) {
  return new prosemirrorMenu.MenuItem({
    title: "Add or remove link",
    icon: prosemirrorMenu.icons.link,
    active: function active(state) {
      return markActive(state, markType);
    },
    enable: function enable(state) {
      return !state.selection.empty;
    },
    run: function run(state, dispatch, view) {
      if (markActive(state, markType)) {
        prosemirrorCommands.toggleMark(markType)(state, dispatch);
        return true;
      }

      openPrompt({
        title: "Create a link",
        fields: {
          href: new TextField({
            label: "Link target",
            required: true
          }),
          title: new TextField({
            label: "Title"
          })
        },
        callback: function callback(attrs) {
          prosemirrorCommands.toggleMark(markType, attrs)(view.state, view.dispatch);
          view.focus();
        }
      });
    }
  });
}

function wrapListItem(nodeType, options) {
  return cmdItem(prosemirrorSchemaList.wrapInList(nodeType, options.attrs), options);
}

function buildMenuItems(schema) {
  var r = {};
  var mark;
  if (mark = schema.marks.strong) r.toggleStrong = markItem(mark, {
    title: "Toggle strong style",
    icon: prosemirrorMenu.icons.strong
  });
  if (mark = schema.marks.em) r.toggleEm = markItem(mark, {
    title: "Toggle emphasis",
    icon: prosemirrorMenu.icons.em
  });
  if (mark = schema.marks.code) r.toggleCode = markItem(mark, {
    title: "Toggle code font",
    icon: prosemirrorMenu.icons.code
  });
  if (mark = schema.marks.link) r.toggleLink = linkItem(mark);
  var node;
  if (node = schema.nodes.image) r.insertImage = insertImageItem(node);
  if (node = schema.nodes.bullet_list) r.wrapBulletList = wrapListItem(node, {
    title: "Wrap in bullet list",
    icon: prosemirrorMenu.icons.bulletList
  });
  if (node = schema.nodes.ordered_list) r.wrapOrderedList = wrapListItem(node, {
    title: "Wrap in ordered list",
    icon: prosemirrorMenu.icons.orderedList
  });
  if (node = schema.nodes.blockquote) r.wrapBlockQuote = prosemirrorMenu.wrapItem(node, {
    title: "Wrap in block quote",
    icon: prosemirrorMenu.icons.blockquote
  });
  if (node = schema.nodes.paragraph) r.makeParagraph = prosemirrorMenu.blockTypeItem(node, {
    title: "Change to paragraph",
    label: "Plain"
  });
  if (node = schema.nodes.code_block) r.makeCodeBlock = prosemirrorMenu.blockTypeItem(node, {
    title: "Change to code block",
    label: "Code"
  });
  if (node = schema.nodes.heading) for (var i = 1; i <= 10; i++) {
    r["makeHead" + i] = prosemirrorMenu.blockTypeItem(node, {
      title: "Change to heading " + i,
      label: "Level " + i,
      attrs: {
        level: i
      }
    });
  }

  if (node = schema.nodes.horizontal_rule) {
    var hr = node;
    r.insertHorizontalRule = new prosemirrorMenu.MenuItem({
      title: "Insert horizontal rule",
      label: "Horizontal rule",
      enable: function enable(state) {
        return canInsert(state, hr);
      },
      run: function run(state, dispatch) {
        dispatch(state.tr.replaceSelectionWith(hr.create()));
      }
    });
  }

  var cut = function cut(arr) {
    return arr.filter(function (x) {
      return x;
    });
  };

  r.insertMenu = new prosemirrorMenu.Dropdown(cut([r.insertImage, r.insertHorizontalRule]), {
    label: "Insert"
  });
  r.typeMenu = new prosemirrorMenu.Dropdown(cut([r.makeParagraph, r.makeCodeBlock, r.makeHead1 && new prosemirrorMenu.DropdownSubmenu(cut([r.makeHead1, r.makeHead2, r.makeHead3, r.makeHead4, r.makeHead5, r.makeHead6]), {
    label: "Heading"
  })]), {
    label: "Type..."
  });
  r.inlineMenu = [cut([r.toggleStrong, r.toggleEm, r.toggleCode, r.toggleLink])];
  r.blockMenu = [cut([r.wrapBulletList, r.wrapOrderedList, r.wrapBlockQuote, prosemirrorMenu.joinUpItem, prosemirrorMenu.liftItem, prosemirrorMenu.selectParentNodeItem])];
  r.fullMenu = r.inlineMenu.concat([[r.insertMenu, r.typeMenu]], [[prosemirrorMenu.undoItem, prosemirrorMenu.redoItem]], r.blockMenu);
  return r;
}

var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;

function buildKeymap(schema, mapKeys) {
  var keys = {},
      type;

  function bind(key, cmd) {
    if (mapKeys) {
      var mapped = mapKeys[key];
      if (mapped === false) return;
      if (mapped) key = mapped;
    }

    keys[key] = cmd;
  }

  bind("Mod-z", prosemirrorHistory.undo);
  bind("Shift-Mod-z", prosemirrorHistory.redo);
  bind("Backspace", prosemirrorInputrules.undoInputRule);
  if (!mac) bind("Mod-y", prosemirrorHistory.redo);
  bind("Alt-ArrowUp", prosemirrorCommands.joinUp);
  bind("Alt-ArrowDown", prosemirrorCommands.joinDown);
  bind("Mod-BracketLeft", prosemirrorCommands.lift);
  bind("Escape", prosemirrorCommands.selectParentNode);

  if (type = schema.marks.strong) {
    bind("Mod-b", prosemirrorCommands.toggleMark(type));
    bind("Mod-B", prosemirrorCommands.toggleMark(type));
  }

  if (type = schema.marks.em) {
    bind("Mod-i", prosemirrorCommands.toggleMark(type));
    bind("Mod-I", prosemirrorCommands.toggleMark(type));
  }

  if (type = schema.marks.code) bind("Mod-`", prosemirrorCommands.toggleMark(type));
  if (type = schema.nodes.bullet_list) bind("Shift-Ctrl-8", prosemirrorSchemaList.wrapInList(type));
  if (type = schema.nodes.ordered_list) bind("Shift-Ctrl-9", prosemirrorSchemaList.wrapInList(type));
  if (type = schema.nodes.blockquote) bind("Ctrl->", prosemirrorCommands.wrapIn(type));

  if (type = schema.nodes.hard_break) {
    var br = type,
        cmd = prosemirrorCommands.chainCommands(prosemirrorCommands.exitCode, function (state, dispatch) {
      if (dispatch) dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());
      return true;
    });
    bind("Mod-Enter", cmd);
    bind("Shift-Enter", cmd);
    if (mac) bind("Ctrl-Enter", cmd);
  }

  if (type = schema.nodes.list_item) {
    bind("Enter", prosemirrorSchemaList.splitListItem(type));
    bind("Mod-[", prosemirrorSchemaList.liftListItem(type));
    bind("Mod-]", prosemirrorSchemaList.sinkListItem(type));
  }

  if (type = schema.nodes.paragraph) bind("Shift-Ctrl-0", prosemirrorCommands.setBlockType(type));
  if (type = schema.nodes.code_block) bind("Shift-Ctrl-\\", prosemirrorCommands.setBlockType(type));
  if (type = schema.nodes.heading) for (var i = 1; i <= 6; i++) {
    bind("Shift-Ctrl-" + i, prosemirrorCommands.setBlockType(type, {
      level: i
    }));
  }

  if (type = schema.nodes.horizontal_rule) {
    var hr = type;
    bind("Mod-_", function (state, dispatch) {
      if (dispatch) dispatch(state.tr.replaceSelectionWith(hr.create()).scrollIntoView());
      return true;
    });
  }

  return keys;
}

function blockQuoteRule(nodeType) {
  return prosemirrorInputrules.wrappingInputRule(/^\s*>\s$/, nodeType);
}

function orderedListRule(nodeType) {
  return prosemirrorInputrules.wrappingInputRule(/^(\d+)\.\s$/, nodeType, function (match) {
    return {
      order: +match[1]
    };
  }, function (match, node) {
    return node.childCount + node.attrs.order == +match[1];
  });
}

function bulletListRule(nodeType) {
  return prosemirrorInputrules.wrappingInputRule(/^\s*([-+*])\s$/, nodeType);
}

function codeBlockRule(nodeType) {
  return prosemirrorInputrules.textblockTypeInputRule(/^```$/, nodeType);
}

function headingRule(nodeType, maxLevel) {
  return prosemirrorInputrules.textblockTypeInputRule(new RegExp("^(#{1," + maxLevel + "})\\s$"), nodeType, function (match) {
    return {
      level: match[1].length
    };
  });
}

function buildInputRules(schema) {
  var rules = prosemirrorInputrules.smartQuotes.concat(prosemirrorInputrules.ellipsis, prosemirrorInputrules.emDash),
      type;
  if (type = schema.nodes.blockquote) rules.push(blockQuoteRule(type));
  if (type = schema.nodes.ordered_list) rules.push(orderedListRule(type));
  if (type = schema.nodes.bullet_list) rules.push(bulletListRule(type));
  if (type = schema.nodes.code_block) rules.push(codeBlockRule(type));
  if (type = schema.nodes.heading) rules.push(headingRule(type, 6));
  return prosemirrorInputrules.inputRules({
    rules: rules
  });
}

function exampleSetup(options) {
  var plugins = [buildInputRules(options.schema), prosemirrorKeymap.keymap(buildKeymap(options.schema, options.mapKeys)), prosemirrorKeymap.keymap(prosemirrorCommands.baseKeymap), prosemirrorDropcursor.dropCursor(), prosemirrorGapcursor.gapCursor()];
  if (options.menuBar !== false) plugins.push(prosemirrorMenu.menuBar({
    floating: options.floatingMenu !== false,
    content: options.menuContent || buildMenuItems(options.schema).fullMenu
  }));
  if (options.history !== false) plugins.push(prosemirrorHistory.history());
  return plugins.concat(new prosemirrorState.Plugin({
    props: {
      attributes: {
        "class": "ProseMirror-example-setup-style"
      }
    }
  }));
}

exports.buildInputRules = buildInputRules;
exports.buildKeymap = buildKeymap;
exports.buildMenuItems = buildMenuItems;
exports.exampleSetup = exampleSetup;


/***/ }),

/***/ "./node_modules/prosemirror-gapcursor/dist/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-gapcursor/dist/index.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorKeymap = __webpack_require__(/*! prosemirror-keymap */ "./node_modules/prosemirror-keymap/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorView = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.cjs");

var GapCursor = function (_prosemirrorState$Sel) {
  _inherits(GapCursor, _prosemirrorState$Sel);

  var _super = _createSuper(GapCursor);

  function GapCursor($pos) {
    _classCallCheck(this, GapCursor);

    return _super.call(this, $pos, $pos);
  }

  _createClass(GapCursor, [{
    key: "map",
    value: function map(doc, mapping) {
      var $pos = doc.resolve(mapping.map(this.head));
      return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirrorState.Selection.near($pos);
    }
  }, {
    key: "content",
    value: function content() {
      return prosemirrorModel.Slice.empty;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof GapCursor && other.head == this.head;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "gapcursor",
        pos: this.head
      };
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return new GapBookmark(this.anchor);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (typeof json.pos != "number") throw new RangeError("Invalid input for GapCursor.fromJSON");
      return new GapCursor(doc.resolve(json.pos));
    }
  }, {
    key: "valid",
    value: function valid($pos) {
      var parent = $pos.parent;
      if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false;
      var override = parent.type.spec.allowGapCursor;
      if (override != null) return override;
      var deflt = parent.contentMatchAt($pos.index()).defaultType;
      return deflt && deflt.isTextblock;
    }
  }, {
    key: "findGapCursorFrom",
    value: function findGapCursorFrom($pos, dir) {
      var mustMove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      search: for (;;) {
        if (!mustMove && GapCursor.valid($pos)) return $pos;
        var pos = $pos.pos,
            next = null;

        for (var d = $pos.depth;; d--) {
          var parent = $pos.node(d);

          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }

          pos += dir;
          var $cur = $pos.doc.resolve(pos);
          if (GapCursor.valid($cur)) return $cur;
        }

        for (;;) {
          var inside = dir > 0 ? next.firstChild : next.lastChild;

          if (!inside) {
            if (next.isAtom && !next.isText && !prosemirrorState.NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }

            break;
          }

          next = inside;
          pos += dir;

          var _$cur = $pos.doc.resolve(pos);

          if (GapCursor.valid(_$cur)) return _$cur;
        }

        return null;
      }
    }
  }]);

  return GapCursor;
}(prosemirrorState.Selection);

GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
prosemirrorState.Selection.jsonID("gapcursor", GapCursor);

var GapBookmark = function () {
  function GapBookmark(pos) {
    _classCallCheck(this, GapBookmark);

    this.pos = pos;
  }

  _createClass(GapBookmark, [{
    key: "map",
    value: function map(mapping) {
      return new GapBookmark(mapping.map(this.pos));
    }
  }, {
    key: "resolve",
    value: function resolve(doc) {
      var $pos = doc.resolve(this.pos);
      return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirrorState.Selection.near($pos);
    }
  }]);

  return GapBookmark;
}();

function closedBefore($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index = $pos.index(d),
        parent = $pos.node(d);

    if (index == 0) {
      if (parent.type.spec.isolating) return true;
      continue;
    }

    for (var before = parent.child(index - 1);; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating) return true;
      if (before.inlineContent) return false;
    }
  }

  return true;
}

function closedAfter($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index = $pos.indexAfter(d),
        parent = $pos.node(d);

    if (index == parent.childCount) {
      if (parent.type.spec.isolating) return true;
      continue;
    }

    for (var after = parent.child(index);; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating) return true;
      if (after.inlineContent) return false;
    }
  }

  return true;
}

function gapCursor() {
  return new prosemirrorState.Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick: handleClick,
      handleKeyDown: handleKeyDown,
      handleDOMEvents: {
        beforeinput: beforeinput
      }
    }
  });
}

var handleKeyDown = prosemirrorKeymap.keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});

function arrow(axis, dir) {
  var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function (state, dispatch, view) {
    var sel = state.selection;
    var $start = dir > 0 ? sel.$to : sel.$from,
        mustMove = sel.empty;

    if (sel instanceof prosemirrorState.TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }

    var $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found) return false;
    if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}

function handleClick(view, pos, event) {
  if (!view || !view.editable) return false;
  var $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos)) return false;
  var clickPos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (clickPos && clickPos.inside > -1 && prosemirrorState.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside))) return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}

function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor)) return false;
  var $from = view.state.selection.$from;
  var insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert) return false;
  var frag = prosemirrorModel.Fragment.empty;

  for (var i = insert.length - 1; i >= 0; i--) {
    frag = prosemirrorModel.Fragment.from(insert[i].createAndFill(null, frag));
  }

  var tr = view.state.tr.replace($from.pos, $from.pos, new prosemirrorModel.Slice(frag, 0, 0));
  tr.setSelection(prosemirrorState.TextSelection.near(tr.doc.resolve($from.pos + 1)));
  view.dispatch(tr);
  return false;
}

function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor)) return null;
  var node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return prosemirrorView.DecorationSet.create(state.doc, [prosemirrorView.Decoration.widget(state.selection.head, node, {
    key: "gapcursor"
  })]);
}

exports.GapCursor = GapCursor;
exports.gapCursor = gapCursor;


/***/ }),

/***/ "./node_modules/prosemirror-history/dist/index.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-history/dist/index.cjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var RopeSequence = __webpack_require__(/*! rope-sequence */ "./node_modules/rope-sequence/dist/index.es.js");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

function _interopDefaultLegacy(e) {
  return e && _typeof(e) === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var RopeSequence__default = _interopDefaultLegacy(RopeSequence);

var max_empty_items = 500;

var Branch = function () {
  function Branch(items, eventCount) {
    _classCallCheck(this, Branch);

    this.items = items;
    this.eventCount = eventCount;
  }

  _createClass(Branch, [{
    key: "popEvent",
    value: function popEvent(state, preserveItems) {
      var _this = this;

      if (this.eventCount == 0) return null;
      var end = this.items.length;

      for (;; end--) {
        var next = this.items.get(end - 1);

        if (next.selection) {
          --end;
          break;
        }
      }

      var remap, mapFrom;

      if (preserveItems) {
        remap = this.remapping(end, this.items.length);
        mapFrom = remap.maps.length;
      }

      var transform = state.tr;
      var selection, remaining;
      var addAfter = [],
          addBefore = [];
      this.items.forEach(function (item, i) {
        if (!item.step) {
          if (!remap) {
            remap = _this.remapping(end, i + 1);
            mapFrom = remap.maps.length;
          }

          mapFrom--;
          addBefore.push(item);
          return;
        }

        if (remap) {
          addBefore.push(new Item(item.map));
          var step = item.step.map(remap.slice(mapFrom)),
              map;

          if (step && transform.maybeStep(step).doc) {
            map = transform.mapping.maps[transform.mapping.maps.length - 1];
            addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));
          }

          mapFrom--;
          if (map) remap.appendMap(map, mapFrom);
        } else {
          transform.maybeStep(item.step);
        }

        if (item.selection) {
          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
          remaining = new Branch(_this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), _this.eventCount - 1);
          return false;
        }
      }, this.items.length, 0);
      return {
        remaining: remaining,
        transform: transform,
        selection: selection
      };
    }
  }, {
    key: "addTransform",
    value: function addTransform(transform, selection, histOptions, preserveItems) {
      var newItems = [],
          eventCount = this.eventCount;
      var oldItems = this.items,
          lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;

      for (var i = 0; i < transform.steps.length; i++) {
        var step = transform.steps[i].invert(transform.docs[i]);
        var item = new Item(transform.mapping.maps[i], step, selection),
            merged = void 0;

        if (merged = lastItem && lastItem.merge(item)) {
          item = merged;
          if (i) newItems.pop();else oldItems = oldItems.slice(0, oldItems.length - 1);
        }

        newItems.push(item);

        if (selection) {
          eventCount++;
          selection = undefined;
        }

        if (!preserveItems) lastItem = item;
      }

      var overflow = eventCount - histOptions.depth;

      if (overflow > DEPTH_OVERFLOW) {
        oldItems = cutOffEvents(oldItems, overflow);
        eventCount -= overflow;
      }

      return new Branch(oldItems.append(newItems), eventCount);
    }
  }, {
    key: "remapping",
    value: function remapping(from, to) {
      var maps = new prosemirrorTransform.Mapping();
      this.items.forEach(function (item, i) {
        var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : undefined;
        maps.appendMap(item.map, mirrorPos);
      }, from, to);
      return maps;
    }
  }, {
    key: "addMaps",
    value: function addMaps(array) {
      if (this.eventCount == 0) return this;
      return new Branch(this.items.append(array.map(function (map) {
        return new Item(map);
      })), this.eventCount);
    }
  }, {
    key: "rebased",
    value: function rebased(rebasedTransform, rebasedCount) {
      if (!this.eventCount) return this;
      var rebasedItems = [],
          start = Math.max(0, this.items.length - rebasedCount);
      var mapping = rebasedTransform.mapping;
      var newUntil = rebasedTransform.steps.length;
      var eventCount = this.eventCount;
      this.items.forEach(function (item) {
        if (item.selection) eventCount--;
      }, start);
      var iRebased = rebasedCount;
      this.items.forEach(function (item) {
        var pos = mapping.getMirror(--iRebased);
        if (pos == null) return;
        newUntil = Math.min(newUntil, pos);
        var map = mapping.maps[pos];

        if (item.step) {
          var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
          var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
          if (selection) eventCount++;
          rebasedItems.push(new Item(map, step, selection));
        } else {
          rebasedItems.push(new Item(map));
        }
      }, start);
      var newMaps = [];

      for (var i = rebasedCount; i < newUntil; i++) {
        newMaps.push(new Item(mapping.maps[i]));
      }

      var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
      var branch = new Branch(items, eventCount);
      if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);
      return branch;
    }
  }, {
    key: "emptyItemCount",
    value: function emptyItemCount() {
      var count = 0;
      this.items.forEach(function (item) {
        if (!item.step) count++;
      });
      return count;
    }
  }, {
    key: "compress",
    value: function compress() {
      var upto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;
      var remap = this.remapping(0, upto),
          mapFrom = remap.maps.length;
      var items = [],
          events = 0;
      this.items.forEach(function (item, i) {
        if (i >= upto) {
          items.push(item);
          if (item.selection) events++;
        } else if (item.step) {
          var step = item.step.map(remap.slice(mapFrom)),
              map = step && step.getMap();
          mapFrom--;
          if (map) remap.appendMap(map, mapFrom);

          if (step) {
            var selection = item.selection && item.selection.map(remap.slice(mapFrom));
            if (selection) events++;
            var newItem = new Item(map.invert(), step, selection),
                merged,
                last = items.length - 1;
            if (merged = items.length && items[last].merge(newItem)) items[last] = merged;else items.push(newItem);
          }
        } else if (item.map) {
          mapFrom--;
        }
      }, this.items.length, 0);
      return new Branch(RopeSequence__default["default"].from(items.reverse()), events);
    }
  }]);

  return Branch;
}();

Branch.empty = new Branch(RopeSequence__default["default"].empty, 0);

function cutOffEvents(items, n) {
  var cutPoint;
  items.forEach(function (item, i) {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}

var Item = function () {
  function Item(map, step, selection, mirrorOffset) {
    _classCallCheck(this, Item);

    this.map = map;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }

  _createClass(Item, [{
    key: "merge",
    value: function merge(other) {
      if (this.step && other.step && !other.selection) {
        var step = other.step.merge(this.step);
        if (step) return new Item(step.getMap().invert(), step, this.selection);
      }
    }
  }]);

  return Item;
}();

var HistoryState = _createClass(function HistoryState(done, undone, prevRanges, prevTime) {
  _classCallCheck(this, HistoryState);

  this.done = done;
  this.undone = undone;
  this.prevRanges = prevRanges;
  this.prevTime = prevTime;
});

var DEPTH_OVERFLOW = 20;

function applyTransaction(history, state, tr, options) {
  var historyTr = tr.getMeta(historyKey),
      rebased;
  if (historyTr) return historyTr.historyState;
  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0);
  var appended = tr.getMeta("appendedTransaction");

  if (tr.steps.length == 0) {
    return history;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo) return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);else return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime);
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    var newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));
    var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);
  } else if (rebased = tr.getMeta("rebased")) {
    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);
  } else {
    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);
  }
}

function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges) return false;
  if (!transform.docChanged) return true;
  var adjacent = false;
  transform.mapping.maps[0].forEach(function (start, end) {
    for (var i = 0; i < prevRanges.length; i += 2) {
      if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;
    }
  });
  return adjacent;
}

function rangesFor(map) {
  var result = [];
  map.forEach(function (_from, _to, from, to) {
    return result.push(from, to);
  });
  return result;
}

function mapRanges(ranges, mapping) {
  if (!ranges) return null;
  var result = [];

  for (var i = 0; i < ranges.length; i += 2) {
    var from = mapping.map(ranges[i], 1),
        to = mapping.map(ranges[i + 1], -1);
    if (from <= to) result.push(from, to);
  }

  return result;
}

function histTransaction(history, state, dispatch, redo) {
  var preserveItems = mustPreserveItems(state);
  var histOptions = historyKey.get(state).spec.config;
  var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);
  if (!pop) return;
  var selection = pop.selection.resolve(pop.transform.doc);
  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);
  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {
    redo: redo,
    historyState: newHist
  }).scrollIntoView());
}

var cachedPreserveItems = false,
    cachedPreserveItemsPlugins = null;

function mustPreserveItems(state) {
  var plugins = state.plugins;

  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;

    for (var i = 0; i < plugins.length; i++) {
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
    }
  }

  return cachedPreserveItems;
}

function closeHistory(tr) {
  return tr.setMeta(closeHistoryKey, true);
}

var historyKey = new prosemirrorState.PluginKey("history");
var closeHistoryKey = new prosemirrorState.PluginKey("closeHistory");

function history() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new prosemirrorState.Plugin({
    key: historyKey,
    state: {
      init: function init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0);
      },
      apply: function apply(tr, hist, state) {
        return applyTransaction(hist, state, tr, config);
      }
    },
    config: config,
    props: {
      handleDOMEvents: {
        beforeinput: function beforeinput(view, e) {
          var inputType = e.inputType;
          var command = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command) return false;
          e.preventDefault();
          return command(view.state, view.dispatch);
        }
      }
    }
  });
}

var undo = function undo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0) return false;
  if (dispatch) histTransaction(hist, state, dispatch, false);
  return true;
};

var redo = function redo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0) return false;
  if (dispatch) histTransaction(hist, state, dispatch, true);
  return true;
};

function undoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.done.eventCount : 0;
}

function redoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.undone.eventCount : 0;
}

exports.closeHistory = closeHistory;
exports.history = history;
exports.redo = redo;
exports.redoDepth = redoDepth;
exports.undo = undo;
exports.undoDepth = undoDepth;


/***/ }),

/***/ "./node_modules/prosemirror-inputrules/dist/index.cjs":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-inputrules/dist/index.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var InputRule = _createClass(function InputRule(match, handler) {
  _classCallCheck(this, InputRule);

  this.match = match;
  this.match = match;
  this.handler = typeof handler == "string" ? stringHandler(handler) : handler;
});

function stringHandler(string) {
  return function (state, match, start, end) {
    var insert = string;

    if (match[1]) {
      var offset = match[0].lastIndexOf(match[1]);
      insert += match[0].slice(offset + match[1].length);
      start += offset;
      var cutOff = start - end;

      if (cutOff > 0) {
        insert = match[0].slice(offset - cutOff, offset) + insert;
        start = end;
      }
    }

    return state.tr.insertText(insert, start, end);
  };
}

var MAX_MATCH = 500;

function inputRules(_ref) {
  var rules = _ref.rules;
  var plugin = new prosemirrorState.Plugin({
    state: {
      init: function init() {
        return null;
      },
      apply: function apply(tr, prev) {
        var stored = tr.getMeta(this);
        if (stored) return stored;
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput: function handleTextInput(view, from, to, text) {
        return run(view, from, to, text, rules, plugin);
      },
      handleDOMEvents: {
        compositionend: function compositionend(view) {
          setTimeout(function () {
            var $cursor = view.state.selection.$cursor;
            if ($cursor) run(view, $cursor.pos, $cursor.pos, "", rules, plugin);
          });
        }
      }
    },
    isInputRules: true
  });
  return plugin;
}

function run(view, from, to, text, rules, plugin) {
  if (view.composing) return false;
  var state = view.state,
      $from = state.doc.resolve(from);
  if ($from.parent.type.spec.code) return false;
  var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, "\uFFFC") + text;

  for (var i = 0; i < rules.length; i++) {
    var match = rules[i].match.exec(textBefore);
    var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);
    if (!tr) continue;
    view.dispatch(tr.setMeta(plugin, {
      transform: tr,
      from: from,
      to: to,
      text: text
    }));
    return true;
  }

  return false;
}

var undoInputRule = function undoInputRule(state, dispatch) {
  var plugins = state.plugins;

  for (var i = 0; i < plugins.length; i++) {
    var plugin = plugins[i],
        undoable = void 0;

    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        var tr = state.tr,
            toUndo = undoable.transform;

        for (var j = toUndo.steps.length - 1; j >= 0; j--) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }

        if (undoable.text) {
          var marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr["delete"](undoable.from, undoable.to);
        }

        dispatch(tr);
      }

      return true;
    }
  }

  return false;
};

var emDash = new InputRule(/--$/, "—");
var ellipsis = new InputRule(/\.\.\.$/, "…");
var openDoubleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“");
var closeDoubleQuote = new InputRule(/"$/, "”");
var openSingleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘");
var closeSingleQuote = new InputRule(/'$/, "’");
var smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];

function wrappingInputRule(regexp, nodeType) {
  var getAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var joinPredicate = arguments.length > 3 ? arguments[3] : undefined;
  return new InputRule(regexp, function (state, match, start, end) {
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    var tr = state.tr["delete"](start, end);
    var $start = tr.doc.resolve(start),
        range = $start.blockRange(),
        wrapping = range && prosemirrorTransform.findWrapping(range, nodeType, attrs);
    if (!wrapping) return null;
    tr.wrap(range, wrapping);
    var before = tr.doc.resolve(start - 1).nodeBefore;
    if (before && before.type == nodeType && prosemirrorTransform.canJoin(tr.doc, start - 1) && (!joinPredicate || joinPredicate(match, before))) tr.join(start - 1);
    return tr;
  });
}

function textblockTypeInputRule(regexp, nodeType) {
  var getAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return new InputRule(regexp, function (state, match, start, end) {
    var $start = state.doc.resolve(start);
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null;
    return state.tr["delete"](start, end).setBlockType(start, start, nodeType, attrs);
  });
}

exports.InputRule = InputRule;
exports.closeDoubleQuote = closeDoubleQuote;
exports.closeSingleQuote = closeSingleQuote;
exports.ellipsis = ellipsis;
exports.emDash = emDash;
exports.inputRules = inputRules;
exports.openDoubleQuote = openDoubleQuote;
exports.openSingleQuote = openSingleQuote;
exports.smartQuotes = smartQuotes;
exports.textblockTypeInputRule = textblockTypeInputRule;
exports.undoInputRule = undoInputRule;
exports.wrappingInputRule = wrappingInputRule;


/***/ }),

/***/ "./node_modules/prosemirror-keymap/dist/index.cjs":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-keymap/dist/index.cjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var w3cKeyname = __webpack_require__(/*! w3c-keyname */ "./node_modules/w3c-keyname/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;

function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/),
      result = parts[parts.length - 1];
  if (result == "Space") result = " ";
  var alt, ctrl, shift, meta;

  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {
      if (mac) meta = true;else ctrl = true;
    } else throw new Error("Unrecognized modifier name: " + mod);
  }

  if (alt) result = "Alt-" + result;
  if (ctrl) result = "Ctrl-" + result;
  if (meta) result = "Meta-" + result;
  if (shift) result = "Shift-" + result;
  return result;
}

function normalize(map) {
  var copy = Object.create(null);

  for (var prop in map) {
    copy[normalizeKeyName(prop)] = map[prop];
  }

  return copy;
}

function modifiers(name, event, shift) {
  if (event.altKey) name = "Alt-" + name;
  if (event.ctrlKey) name = "Ctrl-" + name;
  if (event.metaKey) name = "Meta-" + name;
  if (shift !== false && event.shiftKey) name = "Shift-" + name;
  return name;
}

function keymap(bindings) {
  return new prosemirrorState.Plugin({
    props: {
      handleKeyDown: keydownHandler(bindings)
    }
  });
}

function keydownHandler(bindings) {
  var map = normalize(bindings);
  return function (view, event) {
    var name = w3cKeyname.keyName(event),
        isChar = name.length == 1 && name != " ",
        baseName;
    var direct = map[modifiers(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view)) return true;

    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = w3cKeyname.base[event.keyCode]) && baseName != name) {
      var fromCode = map[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view)) return true;
    } else if (isChar && event.shiftKey) {
      var withShift = map[modifiers(name, event, true)];
      if (withShift && withShift(view.state, view.dispatch, view)) return true;
    }

    return false;
  };
}

exports.keydownHandler = keydownHandler;
exports.keymap = keymap;


/***/ }),

/***/ "./node_modules/prosemirror-menu/dist/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-menu/dist/index.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var crel = __webpack_require__(/*! crelt */ "./node_modules/crelt/dist/index.cjs");

var prosemirrorCommands = __webpack_require__(/*! prosemirror-commands */ "./node_modules/prosemirror-commands/dist/index.cjs");

var prosemirrorHistory = __webpack_require__(/*! prosemirror-history */ "./node_modules/prosemirror-history/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

function _interopDefaultLegacy(e) {
  return e && _typeof(e) === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var crel__default = _interopDefaultLegacy(crel);

var SVG = "http://www.w3.org/2000/svg";
var XLINK = "http://www.w3.org/1999/xlink";
var prefix$2 = "ProseMirror-icon";

function hashPath(path) {
  var hash = 0;

  for (var i = 0; i < path.length; i++) {
    hash = (hash << 5) - hash + path.charCodeAt(i) | 0;
  }

  return hash;
}

function getIcon(icon) {
  var node = document.createElement("div");
  node.className = prefix$2;

  if (icon.path) {
    var path = icon.path,
        width = icon.width,
        height = icon.height;
    var name = "pm-icon-" + hashPath(path).toString(16);
    if (!document.getElementById(name)) buildSVG(name, icon);
    var svg = node.appendChild(document.createElementNS(SVG, "svg"));
    svg.style.width = width / height + "em";
    var use = svg.appendChild(document.createElementNS(SVG, "use"));
    use.setAttributeNS(XLINK, "href", /([^#]*)/.exec(document.location.toString())[1] + "#" + name);
  } else if (icon.dom) {
    node.appendChild(icon.dom.cloneNode(true));
  } else {
    var text = icon.text,
        css = icon.css;
    node.appendChild(document.createElement("span")).textContent = text || '';
    if (css) node.firstChild.style.cssText = css;
  }

  return node;
}

function buildSVG(name, data) {
  var collection = document.getElementById(prefix$2 + "-collection");

  if (!collection) {
    collection = document.createElementNS(SVG, "svg");
    collection.id = prefix$2 + "-collection";
    collection.style.display = "none";
    document.body.insertBefore(collection, document.body.firstChild);
  }

  var sym = document.createElementNS(SVG, "symbol");
  sym.id = name;
  sym.setAttribute("viewBox", "0 0 " + data.width + " " + data.height);
  var path = sym.appendChild(document.createElementNS(SVG, "path"));
  path.setAttribute("d", data.path);
  collection.appendChild(sym);
}

var prefix$1 = "ProseMirror-menu";

var MenuItem = function () {
  function MenuItem(spec) {
    _classCallCheck(this, MenuItem);

    this.spec = spec;
  }

  _createClass(MenuItem, [{
    key: "render",
    value: function render(view) {
      var spec = this.spec;
      var dom = spec.render ? spec.render(view) : spec.icon ? getIcon(spec.icon) : spec.label ? crel__default["default"]("div", null, translate(view, spec.label)) : null;
      if (!dom) throw new RangeError("MenuItem without icon or label property");

      if (spec.title) {
        var title = typeof spec.title === "function" ? spec.title(view.state) : spec.title;
        dom.setAttribute("title", translate(view, title));
      }

      if (spec["class"]) dom.classList.add(spec["class"]);
      if (spec.css) dom.style.cssText += spec.css;
      dom.addEventListener("mousedown", function (e) {
        e.preventDefault();
        if (!dom.classList.contains(prefix$1 + "-disabled")) spec.run(view.state, view.dispatch, view, e);
      });

      function update(state) {
        if (spec.select) {
          var selected = spec.select(state);
          dom.style.display = selected ? "" : "none";
          if (!selected) return false;
        }

        var enabled = true;

        if (spec.enable) {
          enabled = spec.enable(state) || false;
          setClass(dom, prefix$1 + "-disabled", !enabled);
        }

        if (spec.active) {
          var active = enabled && spec.active(state) || false;
          setClass(dom, prefix$1 + "-active", active);
        }

        return true;
      }

      return {
        dom: dom,
        update: update
      };
    }
  }]);

  return MenuItem;
}();

function translate(view, text) {
  return view._props.translate ? view._props.translate(text) : text;
}

var lastMenuEvent = {
  time: 0,
  node: null
};

function markMenuEvent(e) {
  lastMenuEvent.time = Date.now();
  lastMenuEvent.node = e.target;
}

function isMenuEvent(wrapper) {
  return Date.now() - 100 < lastMenuEvent.time && lastMenuEvent.node && wrapper.contains(lastMenuEvent.node);
}

var Dropdown = function () {
  function Dropdown(content) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Dropdown);

    this.options = options;
    this.options = options || {};
    this.content = Array.isArray(content) ? content : [content];
  }

  _createClass(Dropdown, [{
    key: "render",
    value: function render(view) {
      var _this = this;

      var content = renderDropdownItems(this.content, view);
      var label = crel__default["default"]("div", {
        "class": prefix$1 + "-dropdown " + (this.options["class"] || ""),
        style: this.options.css
      }, translate(view, this.options.label || ""));
      if (this.options.title) label.setAttribute("title", translate(view, this.options.title));
      var wrap = crel__default["default"]("div", {
        "class": prefix$1 + "-dropdown-wrap"
      }, label);
      var open = null;
      var listeningOnClose = null;

      var close = function close() {
        if (open && open.close()) {
          open = null;
          window.removeEventListener("mousedown", listeningOnClose);
        }
      };

      label.addEventListener("mousedown", function (e) {
        e.preventDefault();
        markMenuEvent(e);

        if (open) {
          close();
        } else {
          open = _this.expand(wrap, content.dom);
          window.addEventListener("mousedown", listeningOnClose = function listeningOnClose() {
            if (!isMenuEvent(wrap)) close();
          });
        }
      });

      function update(state) {
        var inner = content.update(state);
        wrap.style.display = inner ? "" : "none";
        return inner;
      }

      return {
        dom: wrap,
        update: update
      };
    }
  }, {
    key: "expand",
    value: function expand(dom, items) {
      var menuDOM = crel__default["default"]("div", {
        "class": prefix$1 + "-dropdown-menu " + (this.options["class"] || "")
      }, items);
      var done = false;

      function close() {
        if (done) return;
        done = true;
        dom.removeChild(menuDOM);
        return true;
      }

      dom.appendChild(menuDOM);
      return {
        close: close,
        node: menuDOM
      };
    }
  }]);

  return Dropdown;
}();

function renderDropdownItems(items, view) {
  var rendered = [],
      updates = [];

  for (var i = 0; i < items.length; i++) {
    var _items$i$render = items[i].render(view),
        dom = _items$i$render.dom,
        update = _items$i$render.update;

    rendered.push(crel__default["default"]("div", {
      "class": prefix$1 + "-dropdown-item"
    }, dom));
    updates.push(update);
  }

  return {
    dom: rendered,
    update: combineUpdates(updates, rendered)
  };
}

function combineUpdates(updates, nodes) {
  return function (state) {
    var something = false;

    for (var i = 0; i < updates.length; i++) {
      var up = updates[i](state);
      nodes[i].style.display = up ? "" : "none";
      if (up) something = true;
    }

    return something;
  };
}

var DropdownSubmenu = function () {
  function DropdownSubmenu(content) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, DropdownSubmenu);

    this.options = options;
    this.content = Array.isArray(content) ? content : [content];
  }

  _createClass(DropdownSubmenu, [{
    key: "render",
    value: function render(view) {
      var items = renderDropdownItems(this.content, view);
      var label = crel__default["default"]("div", {
        "class": prefix$1 + "-submenu-label"
      }, translate(view, this.options.label || ""));
      var wrap = crel__default["default"]("div", {
        "class": prefix$1 + "-submenu-wrap"
      }, label, crel__default["default"]("div", {
        "class": prefix$1 + "-submenu"
      }, items.dom));
      var _listeningOnClose = null;
      label.addEventListener("mousedown", function (e) {
        e.preventDefault();
        markMenuEvent(e);
        setClass(wrap, prefix$1 + "-submenu-wrap-active", false);
        if (!_listeningOnClose) window.addEventListener("mousedown", _listeningOnClose = function listeningOnClose() {
          if (!isMenuEvent(wrap)) {
            wrap.classList.remove(prefix$1 + "-submenu-wrap-active");
            window.removeEventListener("mousedown", _listeningOnClose);
            _listeningOnClose = null;
          }
        });
      });

      function update(state) {
        var inner = items.update(state);
        wrap.style.display = inner ? "" : "none";
        return inner;
      }

      return {
        dom: wrap,
        update: update
      };
    }
  }]);

  return DropdownSubmenu;
}();

function renderGrouped(view, content) {
  var result = document.createDocumentFragment();
  var updates = [],
      separators = [];

  for (var i = 0; i < content.length; i++) {
    var items = content[i],
        localUpdates = [],
        localNodes = [];

    for (var j = 0; j < items.length; j++) {
      var _items$j$render = items[j].render(view),
          dom = _items$j$render.dom,
          _update = _items$j$render.update;

      var span = crel__default["default"]("span", {
        "class": prefix$1 + "item"
      }, dom);
      result.appendChild(span);
      localNodes.push(span);
      localUpdates.push(_update);
    }

    if (localUpdates.length) {
      updates.push(combineUpdates(localUpdates, localNodes));
      if (i < content.length - 1) separators.push(result.appendChild(separator()));
    }
  }

  function update(state) {
    var something = false,
        needSep = false;

    for (var _i = 0; _i < updates.length; _i++) {
      var hasContent = updates[_i](state);

      if (_i) separators[_i - 1].style.display = needSep && hasContent ? "" : "none";
      needSep = hasContent;
      if (hasContent) something = true;
    }

    return something;
  }

  return {
    dom: result,
    update: update
  };
}

function separator() {
  return crel__default["default"]("span", {
    "class": prefix$1 + "separator"
  });
}

var icons = {
  join: {
    width: 800,
    height: 900,
    path: "M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z"
  },
  lift: {
    width: 1024,
    height: 1024,
    path: "M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z"
  },
  selectParentNode: {
    text: "\u2B1A",
    css: "font-weight: bold"
  },
  undo: {
    width: 1024,
    height: 1024,
    path: "M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z"
  },
  redo: {
    width: 1024,
    height: 1024,
    path: "M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z"
  },
  strong: {
    width: 805,
    height: 1024,
    path: "M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z"
  },
  em: {
    width: 585,
    height: 1024,
    path: "M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z"
  },
  code: {
    width: 896,
    height: 1024,
    path: "M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z"
  },
  link: {
    width: 951,
    height: 1024,
    path: "M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z"
  },
  bulletList: {
    width: 768,
    height: 896,
    path: "M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z"
  },
  orderedList: {
    width: 768,
    height: 896,
    path: "M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z"
  },
  blockquote: {
    width: 640,
    height: 896,
    path: "M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z"
  }
};
var joinUpItem = new MenuItem({
  title: "Join with above block",
  run: prosemirrorCommands.joinUp,
  select: function select(state) {
    return prosemirrorCommands.joinUp(state);
  },
  icon: icons.join
});
var liftItem = new MenuItem({
  title: "Lift out of enclosing block",
  run: prosemirrorCommands.lift,
  select: function select(state) {
    return prosemirrorCommands.lift(state);
  },
  icon: icons.lift
});
var selectParentNodeItem = new MenuItem({
  title: "Select parent node",
  run: prosemirrorCommands.selectParentNode,
  select: function select(state) {
    return prosemirrorCommands.selectParentNode(state);
  },
  icon: icons.selectParentNode
});
var undoItem = new MenuItem({
  title: "Undo last change",
  run: prosemirrorHistory.undo,
  enable: function enable(state) {
    return prosemirrorHistory.undo(state);
  },
  icon: icons.undo
});
var redoItem = new MenuItem({
  title: "Redo last undone change",
  run: prosemirrorHistory.redo,
  enable: function enable(state) {
    return prosemirrorHistory.redo(state);
  },
  icon: icons.redo
});

function wrapItem(nodeType, options) {
  var passedOptions = {
    run: function run(state, dispatch) {
      return prosemirrorCommands.wrapIn(nodeType, options.attrs)(state, dispatch);
    },
    select: function select(state) {
      return prosemirrorCommands.wrapIn(nodeType, options.attrs)(state);
    }
  };

  for (var prop in options) {
    passedOptions[prop] = options[prop];
  }

  return new MenuItem(passedOptions);
}

function blockTypeItem(nodeType, options) {
  var command = prosemirrorCommands.setBlockType(nodeType, options.attrs);
  var passedOptions = {
    run: command,
    enable: function enable(state) {
      return command(state);
    },
    active: function active(state) {
      var _state$selection = state.selection,
          $from = _state$selection.$from,
          to = _state$selection.to,
          node = _state$selection.node;
      if (node) return node.hasMarkup(nodeType, options.attrs);
      return to <= $from.end() && $from.parent.hasMarkup(nodeType, options.attrs);
    }
  };

  for (var prop in options) {
    passedOptions[prop] = options[prop];
  }

  return new MenuItem(passedOptions);
}

function setClass(dom, cls, on) {
  if (on) dom.classList.add(cls);else dom.classList.remove(cls);
}

var prefix = "ProseMirror-menubar";

function isIOS() {
  if (typeof navigator == "undefined") return false;
  var agent = navigator.userAgent;
  return !/Edge\/\d/.test(agent) && /AppleWebKit/.test(agent) && /Mobile\/\w+/.test(agent);
}

function menuBar(options) {
  return new prosemirrorState.Plugin({
    view: function view(editorView) {
      return new MenuBarView(editorView, options);
    }
  });
}

var MenuBarView = function () {
  function MenuBarView(editorView, options) {
    var _this2 = this;

    _classCallCheck(this, MenuBarView);

    this.editorView = editorView;
    this.options = options;
    this.spacer = null;
    this.maxHeight = 0;
    this.widthForMaxHeight = 0;
    this.floating = false;
    this.scrollHandler = null;
    this.wrapper = crel__default["default"]("div", {
      "class": prefix + "-wrapper"
    });
    this.menu = this.wrapper.appendChild(crel__default["default"]("div", {
      "class": prefix
    }));
    this.menu.className = prefix;
    if (editorView.dom.parentNode) editorView.dom.parentNode.replaceChild(this.wrapper, editorView.dom);
    this.wrapper.appendChild(editorView.dom);

    var _renderGrouped = renderGrouped(this.editorView, this.options.content),
        dom = _renderGrouped.dom,
        update = _renderGrouped.update;

    this.contentUpdate = update;
    this.menu.appendChild(dom);
    this.update();

    if (options.floating && !isIOS()) {
      this.updateFloat();
      var potentialScrollers = getAllWrapping(this.wrapper);

      this.scrollHandler = function (e) {
        var root = _this2.editorView.root;
        if (!(root.body || root).contains(_this2.wrapper)) potentialScrollers.forEach(function (el) {
          return el.removeEventListener("scroll", _this2.scrollHandler);
        });else _this2.updateFloat(e.target.getBoundingClientRect ? e.target : undefined);
      };

      potentialScrollers.forEach(function (el) {
        return el.addEventListener('scroll', _this2.scrollHandler);
      });
    }
  }

  _createClass(MenuBarView, [{
    key: "update",
    value: function update() {
      this.contentUpdate(this.editorView.state);

      if (this.floating) {
        this.updateScrollCursor();
      } else {
        if (this.menu.offsetWidth != this.widthForMaxHeight) {
          this.widthForMaxHeight = this.menu.offsetWidth;
          this.maxHeight = 0;
        }

        if (this.menu.offsetHeight > this.maxHeight) {
          this.maxHeight = this.menu.offsetHeight;
          this.menu.style.minHeight = this.maxHeight + "px";
        }
      }
    }
  }, {
    key: "updateScrollCursor",
    value: function updateScrollCursor() {
      var selection = this.editorView.root.getSelection();
      if (!selection.focusNode) return;
      var rects = selection.getRangeAt(0).getClientRects();
      var selRect = rects[selectionIsInverted(selection) ? 0 : rects.length - 1];
      if (!selRect) return;
      var menuRect = this.menu.getBoundingClientRect();

      if (selRect.top < menuRect.bottom && selRect.bottom > menuRect.top) {
        var scrollable = findWrappingScrollable(this.wrapper);
        if (scrollable) scrollable.scrollTop -= menuRect.bottom - selRect.top;
      }
    }
  }, {
    key: "updateFloat",
    value: function updateFloat(scrollAncestor) {
      var parent = this.wrapper,
          editorRect = parent.getBoundingClientRect(),
          top = scrollAncestor ? Math.max(0, scrollAncestor.getBoundingClientRect().top) : 0;

      if (this.floating) {
        if (editorRect.top >= top || editorRect.bottom < this.menu.offsetHeight + 10) {
          this.floating = false;
          this.menu.style.position = this.menu.style.left = this.menu.style.top = this.menu.style.width = "";
          this.menu.style.display = "";
          this.spacer.parentNode.removeChild(this.spacer);
          this.spacer = null;
        } else {
          var border = (parent.offsetWidth - parent.clientWidth) / 2;
          this.menu.style.left = editorRect.left + border + "px";
          this.menu.style.display = editorRect.top > window.innerHeight ? "none" : "";
          if (scrollAncestor) this.menu.style.top = top + "px";
        }
      } else {
        if (editorRect.top < top && editorRect.bottom >= this.menu.offsetHeight + 10) {
          this.floating = true;
          var menuRect = this.menu.getBoundingClientRect();
          this.menu.style.left = menuRect.left + "px";
          this.menu.style.width = menuRect.width + "px";
          if (scrollAncestor) this.menu.style.top = top + "px";
          this.menu.style.position = "fixed";
          this.spacer = crel__default["default"]("div", {
            "class": prefix + "-spacer",
            style: "height: ".concat(menuRect.height, "px")
          });
          parent.insertBefore(this.spacer, this.menu);
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.wrapper.parentNode) this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper);
    }
  }]);

  return MenuBarView;
}();

function selectionIsInverted(selection) {
  if (selection.anchorNode == selection.focusNode) return selection.anchorOffset > selection.focusOffset;
  return selection.anchorNode.compareDocumentPosition(selection.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING;
}

function findWrappingScrollable(node) {
  for (var cur = node.parentNode; cur; cur = cur.parentNode) {
    if (cur.scrollHeight > cur.clientHeight) return cur;
  }
}

function getAllWrapping(node) {
  var res = [window];

  for (var cur = node.parentNode; cur; cur = cur.parentNode) {
    res.push(cur);
  }

  return res;
}

exports.Dropdown = Dropdown;
exports.DropdownSubmenu = DropdownSubmenu;
exports.MenuItem = MenuItem;
exports.blockTypeItem = blockTypeItem;
exports.icons = icons;
exports.joinUpItem = joinUpItem;
exports.liftItem = liftItem;
exports.menuBar = menuBar;
exports.redoItem = redoItem;
exports.renderGrouped = renderGrouped;
exports.selectParentNodeItem = selectParentNodeItem;
exports.undoItem = undoItem;
exports.wrapItem = wrapItem;


/***/ }),

/***/ "./node_modules/prosemirror-model/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-model/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var OrderedMap = __webpack_require__(/*! orderedmap */ "./node_modules/orderedmap/dist/index.cjs");

function _interopDefaultLegacy(e) {
  return e && _typeof(e) === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var OrderedMap__default = _interopDefaultLegacy(OrderedMap);

function _findDiffStart(a, b, pos) {
  for (var i = 0;; i++) {
    if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;
    var childA = a.child(i),
        childB = b.child(i);

    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }

    if (!childA.sameMarkup(childB)) return pos;

    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }

      return pos;
    }

    if (childA.content.size || childB.content.size) {
      var inner = _findDiffStart(childA.content, childB.content, pos + 1);

      if (inner != null) return inner;
    }

    pos += childA.nodeSize;
  }
}

function _findDiffEnd(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount;;) {
    if (iA == 0 || iB == 0) return iA == iB ? null : {
      a: posA,
      b: posB
    };
    var childA = a.child(--iA),
        childB = b.child(--iB),
        size = childA.nodeSize;

    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }

    if (!childA.sameMarkup(childB)) return {
      a: posA,
      b: posB
    };

    if (childA.isText && childA.text != childB.text) {
      var same = 0,
          minSize = Math.min(childA.text.length, childB.text.length);

      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }

      return {
        a: posA,
        b: posB
      };
    }

    if (childA.content.size || childB.content.size) {
      var inner = _findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);

      if (inner) return inner;
    }

    posA -= size;
    posB -= size;
  }
}

var Fragment = function () {
  function Fragment(content, size) {
    _classCallCheck(this, Fragment);

    this.content = content;
    this.size = size || 0;
    if (size == null) for (var i = 0; i < content.length; i++) {
      this.size += content[i].nodeSize;
    }
  }

  _createClass(Fragment, [{
    key: "nodesBetween",
    value: function nodesBetween(from, to, f) {
      var nodeStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var parent = arguments.length > 4 ? arguments[4] : undefined;

      for (var i = 0, pos = 0; pos < to; i++) {
        var child = this.content[i],
            end = pos + child.nodeSize;

        if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
          var start = pos + 1;
          child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
        }

        pos = end;
      }
    }
  }, {
    key: "descendants",
    value: function descendants(f) {
      this.nodesBetween(0, this.size, f);
    }
  }, {
    key: "textBetween",
    value: function textBetween(from, to, blockSeparator, leafText) {
      var text = "",
          separated = true;
      this.nodesBetween(from, to, function (node, pos) {
        if (node.isText) {
          text += node.text.slice(Math.max(from, pos) - pos, to - pos);
          separated = !blockSeparator;
        } else if (node.isLeaf) {
          if (leafText) {
            text += typeof leafText === "function" ? leafText(node) : leafText;
          } else if (node.type.spec.leafText) {
            text += node.type.spec.leafText(node);
          }

          separated = !blockSeparator;
        } else if (!separated && node.isBlock) {
          text += blockSeparator;
          separated = true;
        }
      }, 0);
      return text;
    }
  }, {
    key: "append",
    value: function append(other) {
      if (!other.size) return this;
      if (!this.size) return other;
      var last = this.lastChild,
          first = other.firstChild,
          content = this.content.slice(),
          i = 0;

      if (last.isText && last.sameMarkup(first)) {
        content[content.length - 1] = last.withText(last.text + first.text);
        i = 1;
      }

      for (; i < other.content.length; i++) {
        content.push(other.content[i]);
      }

      return new Fragment(content, this.size + other.size);
    }
  }, {
    key: "cut",
    value: function cut(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;
      if (from == 0 && to == this.size) return this;
      var result = [],
          size = 0;
      if (to > from) for (var i = 0, pos = 0; pos < to; i++) {
        var child = this.content[i],
            end = pos + child.nodeSize;

        if (end > from) {
          if (pos < from || end > to) {
            if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
          }

          result.push(child);
          size += child.nodeSize;
        }

        pos = end;
      }
      return new Fragment(result, size);
    }
  }, {
    key: "cutByIndex",
    value: function cutByIndex(from, to) {
      if (from == to) return Fragment.empty;
      if (from == 0 && to == this.content.length) return this;
      return new Fragment(this.content.slice(from, to));
    }
  }, {
    key: "replaceChild",
    value: function replaceChild(index, node) {
      var current = this.content[index];
      if (current == node) return this;
      var copy = this.content.slice();
      var size = this.size + node.nodeSize - current.nodeSize;
      copy[index] = node;
      return new Fragment(copy, size);
    }
  }, {
    key: "addToStart",
    value: function addToStart(node) {
      return new Fragment([node].concat(this.content), this.size + node.nodeSize);
    }
  }, {
    key: "addToEnd",
    value: function addToEnd(node) {
      return new Fragment(this.content.concat(node), this.size + node.nodeSize);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      if (this.content.length != other.content.length) return false;

      for (var i = 0; i < this.content.length; i++) {
        if (!this.content[i].eq(other.content[i])) return false;
      }

      return true;
    }
  }, {
    key: "firstChild",
    get: function get() {
      return this.content.length ? this.content[0] : null;
    }
  }, {
    key: "lastChild",
    get: function get() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
  }, {
    key: "childCount",
    get: function get() {
      return this.content.length;
    }
  }, {
    key: "child",
    value: function child(index) {
      var found = this.content[index];
      if (!found) throw new RangeError("Index " + index + " out of range for " + this);
      return found;
    }
  }, {
    key: "maybeChild",
    value: function maybeChild(index) {
      return this.content[index] || null;
    }
  }, {
    key: "forEach",
    value: function forEach(f) {
      for (var i = 0, p = 0; i < this.content.length; i++) {
        var child = this.content[i];
        f(child, p, i);
        p += child.nodeSize;
      }
    }
  }, {
    key: "findDiffStart",
    value: function findDiffStart(other) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return _findDiffStart(this, other, pos);
    }
  }, {
    key: "findDiffEnd",
    value: function findDiffEnd(other) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;
      var otherPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : other.size;
      return _findDiffEnd(this, other, pos, otherPos);
    }
  }, {
    key: "findIndex",
    value: function findIndex(pos) {
      var round = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      if (pos == 0) return retIndex(0, pos);
      if (pos == this.size) return retIndex(this.content.length, pos);
      if (pos > this.size || pos < 0) throw new RangeError("Position ".concat(pos, " outside of fragment (").concat(this, ")"));

      for (var i = 0, curPos = 0;; i++) {
        var cur = this.child(i),
            end = curPos + cur.nodeSize;

        if (end >= pos) {
          if (end == pos || round > 0) return retIndex(i + 1, end);
          return retIndex(i, curPos);
        }

        curPos = end;
      }
    }
  }, {
    key: "toString",
    value: function toString() {
      return "<" + this.toStringInner() + ">";
    }
  }, {
    key: "toStringInner",
    value: function toStringInner() {
      return this.content.join(", ");
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.content.length ? this.content.map(function (n) {
        return n.toJSON();
      }) : null;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, value) {
      if (!value) return Fragment.empty;
      if (!Array.isArray(value)) throw new RangeError("Invalid input for Fragment.fromJSON");
      return new Fragment(value.map(schema.nodeFromJSON));
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      if (!array.length) return Fragment.empty;
      var joined,
          size = 0;

      for (var i = 0; i < array.length; i++) {
        var node = array[i];
        size += node.nodeSize;

        if (i && node.isText && array[i - 1].sameMarkup(node)) {
          if (!joined) joined = array.slice(0, i);
          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
        } else if (joined) {
          joined.push(node);
        }
      }

      return new Fragment(joined || array, size);
    }
  }, {
    key: "from",
    value: function from(nodes) {
      if (!nodes) return Fragment.empty;
      if (nodes instanceof Fragment) return nodes;
      if (Array.isArray(nodes)) return this.fromArray(nodes);
      if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize);
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
  }]);

  return Fragment;
}();

Fragment.empty = new Fragment([], 0);
var found = {
  index: 0,
  offset: 0
};

function retIndex(index, offset) {
  found.index = index;
  found.offset = offset;
  return found;
}

function compareDeep(a, b) {
  if (a === b) return true;
  if (!(a && _typeof(a) == "object") || !(b && _typeof(b) == "object")) return false;
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) return false;

  if (array) {
    if (a.length != b.length) return false;

    for (var i = 0; i < a.length; i++) {
      if (!compareDeep(a[i], b[i])) return false;
    }
  } else {
    for (var p in a) {
      if (!(p in b) || !compareDeep(a[p], b[p])) return false;
    }

    for (var _p in b) {
      if (!(_p in a)) return false;
    }
  }

  return true;
}

var Mark = function () {
  function Mark(type, attrs) {
    _classCallCheck(this, Mark);

    this.type = type;
    this.attrs = attrs;
  }

  _createClass(Mark, [{
    key: "addToSet",
    value: function addToSet(set) {
      var copy,
          placed = false;

      for (var i = 0; i < set.length; i++) {
        var other = set[i];
        if (this.eq(other)) return set;

        if (this.type.excludes(other.type)) {
          if (!copy) copy = set.slice(0, i);
        } else if (other.type.excludes(this.type)) {
          return set;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy) copy = set.slice(0, i);
            copy.push(this);
            placed = true;
          }

          if (copy) copy.push(other);
        }
      }

      if (!copy) copy = set.slice();
      if (!placed) copy.push(this);
      return copy;
    }
  }, {
    key: "removeFromSet",
    value: function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));
      }

      return set;
    }
  }, {
    key: "isInSet",
    value: function isInSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (this.eq(set[i])) return true;
      }

      return false;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var obj = {
        type: this.type.name
      };

      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }

      return obj;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json) throw new RangeError("Invalid input for Mark.fromJSON");
      var type = schema.marks[json.type];
      if (!type) throw new RangeError("There is no mark type ".concat(json.type, " in this schema"));
      return type.create(json.attrs);
    }
  }, {
    key: "sameSet",
    value: function sameSet(a, b) {
      if (a == b) return true;
      if (a.length != b.length) return false;

      for (var i = 0; i < a.length; i++) {
        if (!a[i].eq(b[i])) return false;
      }

      return true;
    }
  }, {
    key: "setFrom",
    value: function setFrom(marks) {
      if (!marks || Array.isArray(marks) && marks.length == 0) return Mark.none;
      if (marks instanceof Mark) return [marks];
      var copy = marks.slice();
      copy.sort(function (a, b) {
        return a.type.rank - b.type.rank;
      });
      return copy;
    }
  }]);

  return Mark;
}();

Mark.none = [];

var ReplaceError = function (_Error) {
  _inherits(ReplaceError, _Error);

  var _super = _createSuper(ReplaceError);

  function ReplaceError() {
    _classCallCheck(this, ReplaceError);

    return _super.apply(this, arguments);
  }

  return _createClass(ReplaceError);
}(_wrapNativeSuper(Error));

var Slice = function () {
  function Slice(content, openStart, openEnd) {
    _classCallCheck(this, Slice);

    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }

  _createClass(Slice, [{
    key: "size",
    get: function get() {
      return this.content.size - this.openStart - this.openEnd;
    }
  }, {
    key: "insertAt",
    value: function insertAt(pos, fragment) {
      var content = insertInto(this.content, pos + this.openStart, fragment);
      return content && new Slice(content, this.openStart, this.openEnd);
    }
  }, {
    key: "removeBetween",
    value: function removeBetween(from, to) {
      return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      if (!this.content.size) return null;
      var json = {
        content: this.content.toJSON()
      };
      if (this.openStart > 0) json.openStart = this.openStart;
      if (this.openEnd > 0) json.openEnd = this.openEnd;
      return json;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json) return Slice.empty;
      var openStart = json.openStart || 0,
          openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number") throw new RangeError("Invalid input for Slice.fromJSON");
      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    }
  }, {
    key: "maxOpen",
    value: function maxOpen(fragment) {
      var openIsolating = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var openStart = 0,
          openEnd = 0;

      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
        openStart++;
      }

      for (var _n = fragment.lastChild; _n && !_n.isLeaf && (openIsolating || !_n.type.spec.isolating); _n = _n.lastChild) {
        openEnd++;
      }

      return new Slice(fragment, openStart, openEnd);
    }
  }]);

  return Slice;
}();

Slice.empty = new Slice(Fragment.empty, 0, 0);

function removeRange(content, from, to) {
  var _content$findIndex = content.findIndex(from),
      index = _content$findIndex.index,
      offset = _content$findIndex.offset,
      child = content.maybeChild(index);

  var _content$findIndex2 = content.findIndex(to),
      indexTo = _content$findIndex2.index,
      offsetTo = _content$findIndex2.offset;

  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError("Removing non-flat range");
    return content.cut(0, from).append(content.cut(to));
  }

  if (index != indexTo) throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
}

function insertInto(content, dist, insert, parent) {
  var _content$findIndex3 = content.findIndex(dist),
      index = _content$findIndex3.index,
      offset = _content$findIndex3.offset,
      child = content.maybeChild(index);

  if (offset == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert)) return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }

  var inner = insertInto(child.content, dist - offset - 1, insert);
  return inner && content.replaceChild(index, child.copy(inner));
}

function _replace($from, $to, slice) {
  if (slice.openStart > $from.depth) throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice.openStart != $to.depth - slice.openEnd) throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice, 0);
}

function replaceOuter($from, $to, slice, depth) {
  var index = $from.index(depth),
      node = $from.node(depth);

  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
    var inner = replaceOuter($from, $to, slice, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent,
        content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
  } else {
    var _prepareSliceForRepla = prepareSliceForReplace(slice, $from),
        start = _prepareSliceForRepla.start,
        end = _prepareSliceForRepla.end;

    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}

function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type)) throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}

function joinable($before, $after, depth) {
  var node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}

function addNode(child, target) {
  var last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);else target.push(child);
}

function addRange($start, $end, depth, target) {
  var node = ($end || $start).node(depth);
  var startIndex = 0,
      endIndex = $end ? $end.index(depth) : node.childCount;

  if ($start) {
    startIndex = $start.index(depth);

    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }

  for (var i = startIndex; i < endIndex; i++) {
    addNode(node.child(i), target);
  }

  if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);
}

function close(node, content) {
  if (!node.type.validContent(content)) throw new ReplaceError("Invalid content for node " + node.type.name);
  return node.copy(content);
}

function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  var content = [];
  addRange(null, $from, depth, content);

  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }

  addRange($to, null, depth, content);
  return new Fragment(content);
}

function replaceTwoWay($from, $to, depth) {
  var content = [];
  addRange(null, $from, depth, content);

  if ($from.depth > depth) {
    var type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }

  addRange($to, null, depth, content);
  return new Fragment(content);
}

function prepareSliceForReplace(slice, $along) {
  var extra = $along.depth - slice.openStart,
      parent = $along.node(extra);
  var node = parent.copy(slice.content);

  for (var i = extra - 1; i >= 0; i--) {
    node = $along.node(i).copy(Fragment.from(node));
  }

  return {
    start: node.resolveNoCache(slice.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
  };
}

var ResolvedPos = function () {
  function ResolvedPos(pos, path, parentOffset) {
    _classCallCheck(this, ResolvedPos);

    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }

  _createClass(ResolvedPos, [{
    key: "resolveDepth",
    value: function resolveDepth(val) {
      if (val == null) return this.depth;
      if (val < 0) return this.depth + val;
      return val;
    }
  }, {
    key: "parent",
    get: function get() {
      return this.node(this.depth);
    }
  }, {
    key: "doc",
    get: function get() {
      return this.node(0);
    }
  }, {
    key: "node",
    value: function node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    }
  }, {
    key: "index",
    value: function index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    }
  }, {
    key: "indexAfter",
    value: function indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    }
  }, {
    key: "start",
    value: function start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    }
  }, {
    key: "end",
    value: function end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    }
  }, {
    key: "before",
    value: function before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) throw new RangeError("There is no position before the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    }
  }, {
    key: "after",
    value: function after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) throw new RangeError("There is no position after the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    }
  }, {
    key: "textOffset",
    get: function get() {
      return this.pos - this.path[this.path.length - 1];
    }
  }, {
    key: "nodeAfter",
    get: function get() {
      var parent = this.parent,
          index = this.index(this.depth);
      if (index == parent.childCount) return null;
      var dOff = this.pos - this.path[this.path.length - 1],
          child = parent.child(index);
      return dOff ? parent.child(index).cut(dOff) : child;
    }
  }, {
    key: "nodeBefore",
    get: function get() {
      var index = this.index(this.depth);
      var dOff = this.pos - this.path[this.path.length - 1];
      if (dOff) return this.parent.child(index).cut(0, dOff);
      return index == 0 ? null : this.parent.child(index - 1);
    }
  }, {
    key: "posAtIndex",
    value: function posAtIndex(index, depth) {
      depth = this.resolveDepth(depth);
      var node = this.path[depth * 3],
          pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;

      for (var i = 0; i < index; i++) {
        pos += node.child(i).nodeSize;
      }

      return pos;
    }
  }, {
    key: "marks",
    value: function marks() {
      var parent = this.parent,
          index = this.index();
      if (parent.content.size == 0) return Mark.none;
      if (this.textOffset) return parent.child(index).marks;
      var main = parent.maybeChild(index - 1),
          other = parent.maybeChild(index);

      if (!main) {
        var tmp = main;
        main = other;
        other = tmp;
      }

      var marks = main.marks;

      for (var i = 0; i < marks.length; i++) {
        if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) marks = marks[i--].removeFromSet(marks);
      }

      return marks;
    }
  }, {
    key: "marksAcross",
    value: function marksAcross($end) {
      var after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline) return null;
      var marks = after.marks,
          next = $end.parent.maybeChild($end.index());

      for (var i = 0; i < marks.length; i++) {
        if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);
      }

      return marks;
    }
  }, {
    key: "sharedDepth",
    value: function sharedDepth(pos) {
      for (var depth = this.depth; depth > 0; depth--) {
        if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;
      }

      return 0;
    }
  }, {
    key: "blockRange",
    value: function blockRange() {
      var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
      var pred = arguments.length > 1 ? arguments[1] : undefined;
      if (other.pos < this.pos) return other.blockRange(this);

      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);
      }

      return null;
    }
  }, {
    key: "sameParent",
    value: function sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    }
  }, {
    key: "max",
    value: function max(other) {
      return other.pos > this.pos ? other : this;
    }
  }, {
    key: "min",
    value: function min(other) {
      return other.pos < this.pos ? other : this;
    }
  }, {
    key: "toString",
    value: function toString() {
      var str = "";

      for (var i = 1; i <= this.depth; i++) {
        str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
      }

      return str + ":" + this.parentOffset;
    }
  }], [{
    key: "resolve",
    value: function resolve(doc, pos) {
      if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError("Position " + pos + " out of range");
      var path = [];
      var start = 0,
          parentOffset = pos;

      for (var node = doc;;) {
        var _node$content$findInd = node.content.findIndex(parentOffset),
            index = _node$content$findInd.index,
            offset = _node$content$findInd.offset;

        var rem = parentOffset - offset;
        path.push(node, index, start + offset);
        if (!rem) break;
        node = node.child(index);
        if (node.isText) break;
        parentOffset = rem - 1;
        start += offset + 1;
      }

      return new ResolvedPos(pos, path, parentOffset);
    }
  }, {
    key: "resolveCached",
    value: function resolveCached(doc, pos) {
      for (var i = 0; i < resolveCache.length; i++) {
        var cached = resolveCache[i];
        if (cached.pos == pos && cached.doc == doc) return cached;
      }

      var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);
      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
      return result;
    }
  }]);

  return ResolvedPos;
}();

var resolveCache = [],
    resolveCachePos = 0,
    resolveCacheSize = 12;

var NodeRange = function () {
  function NodeRange($from, $to, depth) {
    _classCallCheck(this, NodeRange);

    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }

  _createClass(NodeRange, [{
    key: "start",
    get: function get() {
      return this.$from.before(this.depth + 1);
    }
  }, {
    key: "end",
    get: function get() {
      return this.$to.after(this.depth + 1);
    }
  }, {
    key: "parent",
    get: function get() {
      return this.$from.node(this.depth);
    }
  }, {
    key: "startIndex",
    get: function get() {
      return this.$from.index(this.depth);
    }
  }, {
    key: "endIndex",
    get: function get() {
      return this.$to.indexAfter(this.depth);
    }
  }]);

  return NodeRange;
}();

var emptyAttrs = Object.create(null);

var Node = function () {
  function Node(type, attrs, content) {
    var marks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Mark.none;

    _classCallCheck(this, Node);

    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }

  _createClass(Node, [{
    key: "nodeSize",
    get: function get() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
  }, {
    key: "childCount",
    get: function get() {
      return this.content.childCount;
    }
  }, {
    key: "child",
    value: function child(index) {
      return this.content.child(index);
    }
  }, {
    key: "maybeChild",
    value: function maybeChild(index) {
      return this.content.maybeChild(index);
    }
  }, {
    key: "forEach",
    value: function forEach(f) {
      this.content.forEach(f);
    }
  }, {
    key: "nodesBetween",
    value: function nodesBetween(from, to, f) {
      var startPos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      this.content.nodesBetween(from, to, f, startPos, this);
    }
  }, {
    key: "descendants",
    value: function descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    }
  }, {
    key: "textContent",
    get: function get() {
      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
    }
  }, {
    key: "textBetween",
    value: function textBetween(from, to, blockSeparator, leafText) {
      return this.content.textBetween(from, to, blockSeparator, leafText);
    }
  }, {
    key: "firstChild",
    get: function get() {
      return this.content.firstChild;
    }
  }, {
    key: "lastChild",
    get: function get() {
      return this.content.lastChild;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    }
  }, {
    key: "sameMarkup",
    value: function sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    }
  }, {
    key: "hasMarkup",
    value: function hasMarkup(type, attrs, marks) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
    }
  }, {
    key: "copy",
    value: function copy() {
      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (content == this.content) return this;
      return new Node(this.type, this.attrs, content, this.marks);
    }
  }, {
    key: "mark",
    value: function mark(marks) {
      return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);
    }
  }, {
    key: "cut",
    value: function cut(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;
      if (from == 0 && to == this.content.size) return this;
      return this.copy(this.content.cut(from, to));
    }
  }, {
    key: "slice",
    value: function slice(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;
      var includeParents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (from == to) return Slice.empty;
      var $from = this.resolve(from),
          $to = this.resolve(to);
      var depth = includeParents ? 0 : $from.sharedDepth(to);
      var start = $from.start(depth),
          node = $from.node(depth);
      var content = node.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content, $from.depth - depth, $to.depth - depth);
    }
  }, {
    key: "replace",
    value: function replace(from, to, slice) {
      return _replace(this.resolve(from), this.resolve(to), slice);
    }
  }, {
    key: "nodeAt",
    value: function nodeAt(pos) {
      for (var node = this;;) {
        var _node$content$findInd2 = node.content.findIndex(pos),
            index = _node$content$findInd2.index,
            offset = _node$content$findInd2.offset;

        node = node.maybeChild(index);
        if (!node) return null;
        if (offset == pos || node.isText) return node;
        pos -= offset + 1;
      }
    }
  }, {
    key: "childAfter",
    value: function childAfter(pos) {
      var _this$content$findInd = this.content.findIndex(pos),
          index = _this$content$findInd.index,
          offset = _this$content$findInd.offset;

      return {
        node: this.content.maybeChild(index),
        index: index,
        offset: offset
      };
    }
  }, {
    key: "childBefore",
    value: function childBefore(pos) {
      if (pos == 0) return {
        node: null,
        index: 0,
        offset: 0
      };

      var _this$content$findInd2 = this.content.findIndex(pos),
          index = _this$content$findInd2.index,
          offset = _this$content$findInd2.offset;

      if (offset < pos) return {
        node: this.content.child(index),
        index: index,
        offset: offset
      };
      var node = this.content.child(index - 1);
      return {
        node: node,
        index: index - 1,
        offset: offset - node.nodeSize
      };
    }
  }, {
    key: "resolve",
    value: function resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    }
  }, {
    key: "resolveNoCache",
    value: function resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    }
  }, {
    key: "rangeHasMark",
    value: function rangeHasMark(from, to, type) {
      var found = false;
      if (to > from) this.nodesBetween(from, to, function (node) {
        if (type.isInSet(node.marks)) found = true;
        return !found;
      });
      return found;
    }
  }, {
    key: "isBlock",
    get: function get() {
      return this.type.isBlock;
    }
  }, {
    key: "isTextblock",
    get: function get() {
      return this.type.isTextblock;
    }
  }, {
    key: "inlineContent",
    get: function get() {
      return this.type.inlineContent;
    }
  }, {
    key: "isInline",
    get: function get() {
      return this.type.isInline;
    }
  }, {
    key: "isText",
    get: function get() {
      return this.type.isText;
    }
  }, {
    key: "isLeaf",
    get: function get() {
      return this.type.isLeaf;
    }
  }, {
    key: "isAtom",
    get: function get() {
      return this.type.isAtom;
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
      var name = this.type.name;
      if (this.content.size) name += "(" + this.content.toStringInner() + ")";
      return wrapMarks(this.marks, name);
    }
  }, {
    key: "contentMatchAt",
    value: function contentMatchAt(index) {
      var match = this.type.contentMatch.matchFragment(this.content, 0, index);
      if (!match) throw new Error("Called contentMatchAt on a node with invalid content");
      return match;
    }
  }, {
    key: "canReplace",
    value: function canReplace(from, to) {
      var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Fragment.empty;
      var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var end = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : replacement.childCount;
      var one = this.contentMatchAt(from).matchFragment(replacement, start, end);
      var two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd) return false;

      for (var i = start; i < end; i++) {
        if (!this.type.allowsMarks(replacement.child(i).marks)) return false;
      }

      return true;
    }
  }, {
    key: "canReplaceWith",
    value: function canReplaceWith(from, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks)) return false;
      var start = this.contentMatchAt(from).matchType(type);
      var end = start && start.matchFragment(this.content, to);
      return end ? end.validEnd : false;
    }
  }, {
    key: "canAppend",
    value: function canAppend(other) {
      if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);else return this.type.compatibleContent(other.type);
    }
  }, {
    key: "check",
    value: function check() {
      if (!this.type.validContent(this.content)) throw new RangeError("Invalid content for node ".concat(this.type.name, ": ").concat(this.content.toString().slice(0, 50)));
      var copy = Mark.none;

      for (var i = 0; i < this.marks.length; i++) {
        copy = this.marks[i].addToSet(copy);
      }

      if (!Mark.sameSet(copy, this.marks)) throw new RangeError("Invalid collection of marks for node ".concat(this.type.name, ": ").concat(this.marks.map(function (m) {
        return m.type.name;
      })));
      this.content.forEach(function (node) {
        return node.check();
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var obj = {
        type: this.type.name
      };

      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }

      if (this.content.size) obj.content = this.content.toJSON();
      if (this.marks.length) obj.marks = this.marks.map(function (n) {
        return n.toJSON();
      });
      return obj;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json) throw new RangeError("Invalid input for Node.fromJSON");
      var marks = null;

      if (json.marks) {
        if (!Array.isArray(json.marks)) throw new RangeError("Invalid mark data for Node.fromJSON");
        marks = json.marks.map(schema.markFromJSON);
      }

      if (json.type == "text") {
        if (typeof json.text != "string") throw new RangeError("Invalid text node in JSON");
        return schema.text(json.text, marks);
      }

      var content = Fragment.fromJSON(schema, json.content);
      return schema.nodeType(json.type).create(json.attrs, content, marks);
    }
  }]);

  return Node;
}();

Node.prototype.text = undefined;

var TextNode = function (_Node) {
  _inherits(TextNode, _Node);

  var _super2 = _createSuper(TextNode);

  function TextNode(type, attrs, content, marks) {
    var _this;

    _classCallCheck(this, TextNode);

    _this = _super2.call(this, type, attrs, null, marks);
    if (!content) throw new RangeError("Empty text nodes are not allowed");
    _this.text = content;
    return _this;
  }

  _createClass(TextNode, [{
    key: "toString",
    value: function toString() {
      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
      return wrapMarks(this.marks, JSON.stringify(this.text));
    }
  }, {
    key: "textContent",
    get: function get() {
      return this.text;
    }
  }, {
    key: "textBetween",
    value: function textBetween(from, to) {
      return this.text.slice(from, to);
    }
  }, {
    key: "nodeSize",
    get: function get() {
      return this.text.length;
    }
  }, {
    key: "mark",
    value: function mark(marks) {
      return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
    }
  }, {
    key: "withText",
    value: function withText(text) {
      if (text == this.text) return this;
      return new TextNode(this.type, this.attrs, text, this.marks);
    }
  }, {
    key: "cut",
    value: function cut() {
      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.text.length;
      if (from == 0 && to == this.text.length) return this;
      return this.withText(this.text.slice(from, to));
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this.sameMarkup(other) && this.text == other.text;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var base = _get(_getPrototypeOf(TextNode.prototype), "toJSON", this).call(this);

      base.text = this.text;
      return base;
    }
  }]);

  return TextNode;
}(Node);

function wrapMarks(marks, str) {
  for (var i = marks.length - 1; i >= 0; i--) {
    str = marks[i].type.name + "(" + str + ")";
  }

  return str;
}

var ContentMatch = function () {
  function ContentMatch(validEnd) {
    _classCallCheck(this, ContentMatch);

    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }

  _createClass(ContentMatch, [{
    key: "matchType",
    value: function matchType(type) {
      for (var i = 0; i < this.next.length; i++) {
        if (this.next[i].type == type) return this.next[i].next;
      }

      return null;
    }
  }, {
    key: "matchFragment",
    value: function matchFragment(frag) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : frag.childCount;
      var cur = this;

      for (var i = start; cur && i < end; i++) {
        cur = cur.matchType(frag.child(i).type);
      }

      return cur;
    }
  }, {
    key: "inlineContent",
    get: function get() {
      return this.next.length && this.next[0].type.isInline;
    }
  }, {
    key: "defaultType",
    get: function get() {
      for (var i = 0; i < this.next.length; i++) {
        var type = this.next[i].type;
        if (!(type.isText || type.hasRequiredAttrs())) return type;
      }

      return null;
    }
  }, {
    key: "compatible",
    value: function compatible(other) {
      for (var i = 0; i < this.next.length; i++) {
        for (var j = 0; j < other.next.length; j++) {
          if (this.next[i].type == other.next[j].type) return true;
        }
      }

      return false;
    }
  }, {
    key: "fillBefore",
    value: function fillBefore(after) {
      var toEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var seen = [this];

      function search(match, types) {
        var finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd)) return Fragment.from(types.map(function (tp) {
          return tp.createAndFill();
        }));

        for (var i = 0; i < match.next.length; i++) {
          var _match$next$i = match.next[i],
              type = _match$next$i.type,
              next = _match$next$i.next;

          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);

            var _found = search(next, types.concat(type));

            if (_found) return _found;
          }
        }

        return null;
      }

      return search(this, []);
    }
  }, {
    key: "findWrapping",
    value: function findWrapping(target) {
      for (var i = 0; i < this.wrapCache.length; i += 2) {
        if (this.wrapCache[i] == target) return this.wrapCache[i + 1];
      }

      var computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    }
  }, {
    key: "computeWrapping",
    value: function computeWrapping(target) {
      var seen = Object.create(null),
          active = [{
        match: this,
        type: null,
        via: null
      }];

      while (active.length) {
        var current = active.shift(),
            match = current.match;

        if (match.matchType(target)) {
          var result = [];

          for (var obj = current; obj.type; obj = obj.via) {
            result.push(obj.type);
          }

          return result.reverse();
        }

        for (var i = 0; i < match.next.length; i++) {
          var _match$next$i2 = match.next[i],
              type = _match$next$i2.type,
              next = _match$next$i2.next;

          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
            active.push({
              match: type.contentMatch,
              type: type,
              via: current
            });
            seen[type.name] = true;
          }
        }
      }

      return null;
    }
  }, {
    key: "edgeCount",
    get: function get() {
      return this.next.length;
    }
  }, {
    key: "edge",
    value: function edge(n) {
      if (n >= this.next.length) throw new RangeError("There's no ".concat(n, "th edge in this content match"));
      return this.next[n];
    }
  }, {
    key: "toString",
    value: function toString() {
      var seen = [];

      function scan(m) {
        seen.push(m);

        for (var i = 0; i < m.next.length; i++) {
          if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);
        }
      }

      scan(this);
      return seen.map(function (m, i) {
        var out = i + (m.validEnd ? "*" : " ") + " ";

        for (var _i = 0; _i < m.next.length; _i++) {
          out += (_i ? ", " : "") + m.next[_i].type.name + "->" + seen.indexOf(m.next[_i].next);
        }

        return out;
      }).join("\n");
    }
  }], [{
    key: "parse",
    value: function parse(string, nodeTypes) {
      var stream = new TokenStream(string, nodeTypes);
      if (stream.next == null) return ContentMatch.empty;
      var expr = parseExpr(stream);
      if (stream.next) stream.err("Unexpected trailing text");
      var match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    }
  }]);

  return ContentMatch;
}();

ContentMatch.empty = new ContentMatch(true);

var TokenStream = function () {
  function TokenStream(string, nodeTypes) {
    _classCallCheck(this, TokenStream);

    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "") this.tokens.pop();
    if (this.tokens[0] == "") this.tokens.shift();
  }

  _createClass(TokenStream, [{
    key: "next",
    get: function get() {
      return this.tokens[this.pos];
    }
  }, {
    key: "eat",
    value: function eat(tok) {
      return this.next == tok && (this.pos++ || true);
    }
  }, {
    key: "err",
    value: function err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    }
  }]);

  return TokenStream;
}();

function parseExpr(stream) {
  var exprs = [];

  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));

  return exprs.length == 1 ? exprs[0] : {
    type: "choice",
    exprs: exprs
  };
}

function parseExprSeq(stream) {
  var exprs = [];

  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");

  return exprs.length == 1 ? exprs[0] : {
    type: "seq",
    exprs: exprs
  };
}

function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);

  for (;;) {
    if (stream.eat("+")) expr = {
      type: "plus",
      expr: expr
    };else if (stream.eat("*")) expr = {
      type: "star",
      expr: expr
    };else if (stream.eat("?")) expr = {
      type: "opt",
      expr: expr
    };else if (stream.eat("{")) expr = parseExprRange(stream, expr);else break;
  }

  return expr;
}

function parseNum(stream) {
  if (/\D/.test(stream.next)) stream.err("Expected number, got '" + stream.next + "'");
  var result = Number(stream.next);
  stream.pos++;
  return result;
}

function parseExprRange(stream, expr) {
  var min = parseNum(stream),
      max = min;

  if (stream.eat(",")) {
    if (stream.next != "}") max = parseNum(stream);else max = -1;
  }

  if (!stream.eat("}")) stream.err("Unclosed braced range");
  return {
    type: "range",
    min: min,
    max: max,
    expr: expr
  };
}

function resolveName(stream, name) {
  var types = stream.nodeTypes,
      type = types[name];
  if (type) return [type];
  var result = [];

  for (var typeName in types) {
    var _type = types[typeName];
    if (_type.groups.indexOf(name) > -1) result.push(_type);
  }

  if (result.length == 0) stream.err("No node type or group '" + name + "' found");
  return result;
}

function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function (type) {
      if (stream.inline == null) stream.inline = type.isInline;else if (stream.inline != type.isInline) stream.err("Mixing inline and block content");
      return {
        type: "name",
        value: type
      };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : {
      type: "choice",
      exprs: exprs
    };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}

function nfa(expr) {
  var nfa = [[]];
  connect(compile(expr, 0), node());
  return nfa;

  function node() {
    return nfa.push([]) - 1;
  }

  function edge(from, to, term) {
    var edge = {
      term: term,
      to: to
    };
    nfa[from].push(edge);
    return edge;
  }

  function connect(edges, to) {
    edges.forEach(function (edge) {
      return edge.to = to;
    });
  }

  function compile(expr, from) {
    if (expr.type == "choice") {
      return expr.exprs.reduce(function (out, expr) {
        return out.concat(compile(expr, from));
      }, []);
    } else if (expr.type == "seq") {
      for (var i = 0;; i++) {
        var next = compile(expr.exprs[i], from);
        if (i == expr.exprs.length - 1) return next;
        connect(next, from = node());
      }
    } else if (expr.type == "star") {
      var loop = node();
      edge(from, loop);
      connect(compile(expr.expr, loop), loop);
      return [edge(loop)];
    } else if (expr.type == "plus") {
      var _loop = node();

      connect(compile(expr.expr, from), _loop);
      connect(compile(expr.expr, _loop), _loop);
      return [edge(_loop)];
    } else if (expr.type == "opt") {
      return [edge(from)].concat(compile(expr.expr, from));
    } else if (expr.type == "range") {
      var cur = from;

      for (var _i2 = 0; _i2 < expr.min; _i2++) {
        var _next = node();

        connect(compile(expr.expr, cur), _next);
        cur = _next;
      }

      if (expr.max == -1) {
        connect(compile(expr.expr, cur), cur);
      } else {
        for (var _i3 = expr.min; _i3 < expr.max; _i3++) {
          var _next2 = node();

          edge(cur, _next2);
          connect(compile(expr.expr, cur), _next2);
          cur = _next2;
        }
      }

      return [edge(cur)];
    } else if (expr.type == "name") {
      return [edge(from, undefined, expr.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}

function cmp(a, b) {
  return b - a;
}

function nullFrom(nfa, node) {
  var result = [];
  scan(node);
  return result.sort(cmp);

  function scan(node) {
    var edges = nfa[node];
    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);
    result.push(node);

    for (var i = 0; i < edges.length; i++) {
      var _edges$i = edges[i],
          term = _edges$i.term,
          to = _edges$i.to;
      if (!term && result.indexOf(to) == -1) scan(to);
    }
  }
}

function dfa(nfa) {
  var labeled = Object.create(null);
  return explore(nullFrom(nfa, 0));

  function explore(states) {
    var out = [];
    states.forEach(function (node) {
      nfa[node].forEach(function (_ref) {
        var term = _ref.term,
            to = _ref.to;
        if (!term) return;
        var set;

        for (var i = 0; i < out.length; i++) {
          if (out[i][0] == term) set = out[i][1];
        }

        nullFrom(nfa, to).forEach(function (node) {
          if (!set) out.push([term, set = []]);
          if (set.indexOf(node) == -1) set.push(node);
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);

    for (var i = 0; i < out.length; i++) {
      var _states = out[i][1].sort(cmp);

      state.next.push({
        type: out[i][0],
        next: labeled[_states.join(",")] || explore(_states)
      });
    }

    return state;
  }
}

function checkForDeadEnds(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i],
        dead = !state.validEnd,
        nodes = [];

    for (var j = 0; j < state.next.length; j++) {
      var _state$next$j = state.next[j],
          type = _state$next$j.type,
          next = _state$next$j.next;
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;
      if (work.indexOf(next) == -1) work.push(next);
    }

    if (dead) stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}

function defaultAttrs(attrs) {
  var defaults = Object.create(null);

  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) return null;
    defaults[attrName] = attr["default"];
  }

  return defaults;
}

function _computeAttrs(attrs, value) {
  var built = Object.create(null);

  for (var name in attrs) {
    var given = value && value[name];

    if (given === undefined) {
      var attr = attrs[name];
      if (attr.hasDefault) given = attr["default"];else throw new RangeError("No value supplied for attribute " + name);
    }

    built[name] = given;
  }

  return built;
}

function initAttrs(attrs) {
  var result = Object.create(null);
  if (attrs) for (var name in attrs) {
    result[name] = new Attribute(attrs[name]);
  }
  return result;
}

var NodeType = function () {
  function NodeType(name, schema, spec) {
    _classCallCheck(this, NodeType);

    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }

  _createClass(NodeType, [{
    key: "isInline",
    get: function get() {
      return !this.isBlock;
    }
  }, {
    key: "isTextblock",
    get: function get() {
      return this.isBlock && this.inlineContent;
    }
  }, {
    key: "isLeaf",
    get: function get() {
      return this.contentMatch == ContentMatch.empty;
    }
  }, {
    key: "isAtom",
    get: function get() {
      return this.isLeaf || !!this.spec.atom;
    }
  }, {
    key: "whitespace",
    get: function get() {
      return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
  }, {
    key: "hasRequiredAttrs",
    value: function hasRequiredAttrs() {
      for (var n in this.attrs) {
        if (this.attrs[n].isRequired) return true;
      }

      return false;
    }
  }, {
    key: "compatibleContent",
    value: function compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    }
  }, {
    key: "computeAttrs",
    value: function computeAttrs(attrs) {
      if (!attrs && this.defaultAttrs) return this.defaultAttrs;else return _computeAttrs(this.attrs, attrs);
    }
  }, {
    key: "create",
    value: function create() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      if (this.isText) throw new Error("NodeType.create can't construct text nodes");
      return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
    }
  }, {
    key: "createChecked",
    value: function createChecked() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      content = Fragment.from(content);
      if (!this.validContent(content)) throw new RangeError("Invalid content for node " + this.name);
      return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
    }
  }, {
    key: "createAndFill",
    value: function createAndFill() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      attrs = this.computeAttrs(attrs);
      content = Fragment.from(content);

      if (content.size) {
        var before = this.contentMatch.fillBefore(content);
        if (!before) return null;
        content = before.append(content);
      }

      var matched = this.contentMatch.matchFragment(content);
      var after = matched && matched.fillBefore(Fragment.empty, true);
      if (!after) return null;
      return new Node(this, attrs, content.append(after), Mark.setFrom(marks));
    }
  }, {
    key: "validContent",
    value: function validContent(content) {
      var result = this.contentMatch.matchFragment(content);
      if (!result || !result.validEnd) return false;

      for (var i = 0; i < content.childCount; i++) {
        if (!this.allowsMarks(content.child(i).marks)) return false;
      }

      return true;
    }
  }, {
    key: "allowsMarkType",
    value: function allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    }
  }, {
    key: "allowsMarks",
    value: function allowsMarks(marks) {
      if (this.markSet == null) return true;

      for (var i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) return false;
      }

      return true;
    }
  }, {
    key: "allowedMarks",
    value: function allowedMarks(marks) {
      if (this.markSet == null) return marks;
      var copy;

      for (var i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) {
          if (!copy) copy = marks.slice(0, i);
        } else if (copy) {
          copy.push(marks[i]);
        }
      }

      return !copy ? marks : copy.length ? copy : Mark.none;
    }
  }], [{
    key: "compile",
    value: function compile(nodes, schema) {
      var result = Object.create(null);
      nodes.forEach(function (name, spec) {
        return result[name] = new NodeType(name, schema, spec);
      });
      var topType = schema.spec.topNode || "doc";
      if (!result[topType]) throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      if (!result.text) throw new RangeError("Every schema needs a 'text' type");

      for (var _ in result.text.attrs) {
        throw new RangeError("The text node type should not have attributes");
      }

      return result;
    }
  }]);

  return NodeType;
}();

var Attribute = function () {
  function Attribute(options) {
    _classCallCheck(this, Attribute);

    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this["default"] = options["default"];
  }

  _createClass(Attribute, [{
    key: "isRequired",
    get: function get() {
      return !this.hasDefault;
    }
  }]);

  return Attribute;
}();

var MarkType = function () {
  function MarkType(name, rank, schema, spec) {
    _classCallCheck(this, MarkType);

    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.excluded = null;
    var defaults = defaultAttrs(this.attrs);
    this.instance = defaults ? new Mark(this, defaults) : null;
  }

  _createClass(MarkType, [{
    key: "create",
    value: function create() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (!attrs && this.instance) return this.instance;
      return new Mark(this, _computeAttrs(this.attrs, attrs));
    }
  }, {
    key: "removeFromSet",
    value: function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (set[i].type == this) {
          set = set.slice(0, i).concat(set.slice(i + 1));
          i--;
        }
      }

      return set;
    }
  }, {
    key: "isInSet",
    value: function isInSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (set[i].type == this) return set[i];
      }
    }
  }, {
    key: "excludes",
    value: function excludes(other) {
      return this.excluded.indexOf(other) > -1;
    }
  }], [{
    key: "compile",
    value: function compile(marks, schema) {
      var result = Object.create(null),
          rank = 0;
      marks.forEach(function (name, spec) {
        return result[name] = new MarkType(name, rank++, schema, spec);
      });
      return result;
    }
  }]);

  return MarkType;
}();

var Schema = function () {
  function Schema(spec) {
    _classCallCheck(this, Schema);

    this.cached = Object.create(null);
    this.spec = {
      nodes: OrderedMap__default["default"].from(spec.nodes),
      marks: OrderedMap__default["default"].from(spec.marks || {}),
      topNode: spec.topNode
    };
    this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    var contentExprCache = Object.create(null);

    for (var prop in this.nodes) {
      if (prop in this.marks) throw new RangeError(prop + " can not be both a node and a mark");
      var type = this.nodes[prop],
          contentExpr = type.spec.content || "",
          markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }

    for (var _prop in this.marks) {
      var _type2 = this.marks[_prop],
          excl = _type2.spec.excludes;
      _type2.excluded = excl == null ? [_type2] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }

    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = Object.create(null);
  }

  _createClass(Schema, [{
    key: "node",
    value: function node(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var content = arguments.length > 2 ? arguments[2] : undefined;
      var marks = arguments.length > 3 ? arguments[3] : undefined;
      if (typeof type == "string") type = this.nodeType(type);else if (!(type instanceof NodeType)) throw new RangeError("Invalid node type: " + type);else if (type.schema != this) throw new RangeError("Node type from different schema used (" + type.name + ")");
      return type.createChecked(attrs, content, marks);
    }
  }, {
    key: "text",
    value: function text(_text, marks) {
      var type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, _text, Mark.setFrom(marks));
    }
  }, {
    key: "mark",
    value: function mark(type, attrs) {
      if (typeof type == "string") type = this.marks[type];
      return type.create(attrs);
    }
  }, {
    key: "nodeFromJSON",
    value: function nodeFromJSON(json) {
      return Node.fromJSON(this, json);
    }
  }, {
    key: "markFromJSON",
    value: function markFromJSON(json) {
      return Mark.fromJSON(this, json);
    }
  }, {
    key: "nodeType",
    value: function nodeType(name) {
      var found = this.nodes[name];
      if (!found) throw new RangeError("Unknown node type: " + name);
      return found;
    }
  }]);

  return Schema;
}();

function gatherMarks(schema, marks) {
  var found = [];

  for (var i = 0; i < marks.length; i++) {
    var name = marks[i],
        mark = schema.marks[name],
        ok = mark;

    if (mark) {
      found.push(mark);
    } else {
      for (var prop in schema.marks) {
        var _mark = schema.marks[prop];
        if (name == "_" || _mark.spec.group && _mark.spec.group.split(" ").indexOf(name) > -1) found.push(ok = _mark);
      }
    }

    if (!ok) throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }

  return found;
}

var DOMParser = function () {
  function DOMParser(schema, rules) {
    var _this2 = this;

    _classCallCheck(this, DOMParser);

    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach(function (rule) {
      if (rule.tag) _this2.tags.push(rule);else if (rule.style) _this2.styles.push(rule);
    });
    this.normalizeLists = !this.tags.some(function (r) {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node) return false;
      var node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }

  _createClass(DOMParser, [{
    key: "parse",
    value: function parse(dom) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = new ParseContext(this, options, false);
      context.addAll(dom, options.from, options.to);
      return context.finish();
    }
  }, {
    key: "parseSlice",
    value: function parseSlice(dom) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = new ParseContext(this, options, true);
      context.addAll(dom, options.from, options.to);
      return Slice.maxOpen(context.finish());
    }
  }, {
    key: "matchTag",
    value: function matchTag(dom, context, after) {
      for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
        var rule = this.tags[i];

        if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            var result = rule.getAttrs(dom);
            if (result === false) continue;
            rule.attrs = result || undefined;
          }

          return rule;
        }
      }
    }
  }, {
    key: "matchStyle",
    value: function matchStyle(prop, value, context, after) {
      for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
        var rule = this.styles[i],
            style = rule.style;
        if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value)) continue;

        if (rule.getAttrs) {
          var result = rule.getAttrs(value);
          if (result === false) continue;
          rule.attrs = result || undefined;
        }

        return rule;
      }
    }
  }], [{
    key: "schemaRules",
    value: function schemaRules(schema) {
      var result = [];

      function insert(rule) {
        var priority = rule.priority == null ? 50 : rule.priority,
            i = 0;

        for (; i < result.length; i++) {
          var next = result[i],
              nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority) break;
        }

        result.splice(i, 0, rule);
      }

      var _loop2 = function _loop2(name) {
        var rules = schema.marks[name].spec.parseDOM;
        if (rules) rules.forEach(function (rule) {
          insert(rule = copy(rule));
          rule.mark = name;
        });
      };

      for (var name in schema.marks) {
        _loop2(name);
      }

      var _loop3 = function _loop3(_name) {
        var rules = schema.nodes[_name].spec.parseDOM;
        if (rules) rules.forEach(function (rule) {
          insert(rule = copy(rule));
          rule.node = _name;
        });
      };

      for (var _name in schema.nodes) {
        _loop3(_name);
      }

      return result;
    }
  }, {
    key: "fromSchema",
    value: function fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
    }
  }]);

  return DOMParser;
}();

var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = {
  ol: true,
  ul: true
};
var OPT_PRESERVE_WS = 1,
    OPT_PRESERVE_WS_FULL = 2,
    OPT_OPEN_LEFT = 4;

function wsOptionsFor(type, preserveWhitespace, base) {
  if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;
}

var NodeContext = function () {
  function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {
    _classCallCheck(this, NodeContext);

    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.stashMarks = [];
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }

  _createClass(NodeContext, [{
    key: "findWrapping",
    value: function findWrapping(node) {
      if (!this.match) {
        if (!this.type) return [];
        var fill = this.type.contentMatch.fillBefore(Fragment.from(node));

        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          var start = this.type.contentMatch,
              wrap;

          if (wrap = start.findWrapping(node.type)) {
            this.match = start;
            return wrap;
          } else {
            return null;
          }
        }
      }

      return this.match.findWrapping(node.type);
    }
  }, {
    key: "finish",
    value: function finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        var last = this.content[this.content.length - 1],
            m;

        if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
          var text = last;
          if (last.text.length == m[0].length) this.content.pop();else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
        }
      }

      var content = Fragment.from(this.content);
      if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment.empty, true));
      return this.type ? this.type.create(this.attrs, content, this.marks) : content;
    }
  }, {
    key: "popFromStashMark",
    value: function popFromStashMark(mark) {
      for (var i = this.stashMarks.length - 1; i >= 0; i--) {
        if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0];
      }
    }
  }, {
    key: "applyPending",
    value: function applyPending(nextType) {
      for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
        var mark = pending[i];

        if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
          this.activeMarks = mark.addToSet(this.activeMarks);
          this.pendingMarks = mark.removeFromSet(this.pendingMarks);
        }
      }
    }
  }, {
    key: "inlineContext",
    value: function inlineContext(node) {
      if (this.type) return this.type.inlineContent;
      if (this.content.length) return this.content[0].isInline;
      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
    }
  }]);

  return NodeContext;
}();

var ParseContext = function () {
  function ParseContext(parser, options, isOpen) {
    _classCallCheck(this, ParseContext);

    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    var topNode = options.topNode,
        topContext;
    var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);else if (isOpen) topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);else topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }

  _createClass(ParseContext, [{
    key: "top",
    get: function get() {
      return this.nodes[this.open];
    }
  }, {
    key: "addDOM",
    value: function addDOM(dom) {
      if (dom.nodeType == 3) {
        this.addTextNode(dom);
      } else if (dom.nodeType == 1) {
        var style = dom.getAttribute("style");
        var marks = style ? this.readStyles(parseStyles(style)) : null,
            top = this.top;
        if (marks != null) for (var i = 0; i < marks.length; i++) {
          this.addPendingMark(marks[i]);
        }
        this.addElement(dom);
        if (marks != null) for (var _i4 = 0; _i4 < marks.length; _i4++) {
          this.removePendingMark(marks[_i4], top);
        }
      }
    }
  }, {
    key: "addTextNode",
    value: function addTextNode(dom) {
      var value = dom.nodeValue;
      var top = this.top;

      if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!(top.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");

          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            var nodeBefore = top.content[top.content.length - 1];
            var domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == 'BR' || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) value = value.slice(1);
          }
        } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }

        if (value) this.insertNode(this.parser.schema.text(value));
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    }
  }, {
    key: "addElement",
    value: function addElement(dom, matchAfter) {
      var name = dom.nodeName.toLowerCase(),
          ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);
      var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));

      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);else if (rule && rule.skip.nodeType) dom = rule.skip;
        var sync,
            top = this.top,
            oldNeedsBlock = this.needsBlock;

        if (blockTags.hasOwnProperty(name)) {
          sync = true;
          if (!top.type) this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom);
          return;
        }

        this.addAll(dom);
        if (sync) this.sync(top);
        this.needsBlock = oldNeedsBlock;
      } else {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : undefined);
      }
    }
  }, {
    key: "leafFallback",
    value: function leafFallback(dom) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode("\n"));
    }
  }, {
    key: "ignoreFallback",
    value: function ignoreFallback(dom) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text("-"));
    }
  }, {
    key: "readStyles",
    value: function readStyles(styles) {
      var marks = Mark.none;

      style: for (var i = 0; i < styles.length; i += 2) {
        for (var after = undefined;;) {
          var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
          if (!rule) continue style;
          if (rule.ignore) return null;
          marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
          if (rule.consuming === false) after = rule;else break;
        }
      }

      return marks;
    }
  }, {
    key: "addElementByRule",
    value: function addElementByRule(dom, rule, continueAfter) {
      var _this3 = this;

      var sync, nodeType, mark;

      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];

        if (!nodeType.isLeaf) {
          sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
        } else if (!this.insertNode(nodeType.create(rule.attrs))) {
          this.leafFallback(dom);
        }
      } else {
        var markType = this.parser.schema.marks[rule.mark];
        mark = markType.create(rule.attrs);
        this.addPendingMark(mark);
      }

      var startIn = this.top;

      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach(function (node) {
          return _this3.insertNode(node);
        });
      } else {
        var contentDOM = dom;
        if (typeof rule.contentElement == "string") contentDOM = dom.querySelector(rule.contentElement);else if (typeof rule.contentElement == "function") contentDOM = rule.contentElement(dom);else if (rule.contentElement) contentDOM = rule.contentElement;
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM);
      }

      if (sync && this.sync(startIn)) this.open--;
      if (mark) this.removePendingMark(mark, startIn);
    }
  }, {
    key: "addAll",
    value: function addAll(parent, startIndex, endIndex) {
      var index = startIndex || 0;

      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
        this.findAtPoint(parent, index);
        this.addDOM(dom);
      }

      this.findAtPoint(parent, index);
    }
  }, {
    key: "findPlace",
    value: function findPlace(node) {
      var route, sync;

      for (var depth = this.open; depth >= 0; depth--) {
        var cx = this.nodes[depth];

        var _found2 = cx.findWrapping(node);

        if (_found2 && (!route || route.length > _found2.length)) {
          route = _found2;
          sync = cx;
          if (!_found2.length) break;
        }

        if (cx.solid) break;
      }

      if (!route) return false;
      this.sync(sync);

      for (var i = 0; i < route.length; i++) {
        this.enterInner(route[i], null, false);
      }

      return true;
    }
  }, {
    key: "insertNode",
    value: function insertNode(node) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        var block = this.textblockFromContext();
        if (block) this.enterInner(block);
      }

      if (this.findPlace(node)) {
        this.closeExtra();
        var top = this.top;
        top.applyPending(node.type);
        if (top.match) top.match = top.match.matchType(node.type);
        var marks = top.activeMarks;

        for (var i = 0; i < node.marks.length; i++) {
          if (!top.type || top.type.allowsMarkType(node.marks[i].type)) marks = node.marks[i].addToSet(marks);
        }

        top.content.push(node.mark(marks));
        return true;
      }

      return false;
    }
  }, {
    key: "enter",
    value: function enter(type, attrs, preserveWS) {
      var ok = this.findPlace(type.create(attrs));
      if (ok) this.enterInner(type, attrs, true, preserveWS);
      return ok;
    }
  }, {
    key: "enterInner",
    value: function enterInner(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var solid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var preserveWS = arguments.length > 3 ? arguments[3] : undefined;
      this.closeExtra();
      var top = this.top;
      top.applyPending(type);
      top.match = top.match && top.match.matchType(type);
      var options = wsOptionsFor(type, preserveWS, top.options);
      if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;
      this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
      this.open++;
    }
  }, {
    key: "closeExtra",
    value: function closeExtra() {
      var openEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var i = this.nodes.length - 1;

      if (i > this.open) {
        for (; i > this.open; i--) {
          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        }

        this.nodes.length = this.open + 1;
      }
    }
  }, {
    key: "finish",
    value: function finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    }
  }, {
    key: "sync",
    value: function sync(to) {
      for (var i = this.open; i >= 0; i--) {
        if (this.nodes[i] == to) {
          this.open = i;
          return true;
        }
      }

      return false;
    }
  }, {
    key: "currentPos",
    get: function get() {
      this.closeExtra();
      var pos = 0;

      for (var i = this.open; i >= 0; i--) {
        var content = this.nodes[i].content;

        for (var j = content.length - 1; j >= 0; j--) {
          pos += content[j].nodeSize;
        }

        if (i) pos++;
      }

      return pos;
    }
  }, {
    key: "findAtPoint",
    value: function findAtPoint(parent, offset) {
      if (this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset) this.find[i].pos = this.currentPos;
      }
    }
  }, {
    key: "findInside",
    value: function findInside(parent) {
      if (this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) this.find[i].pos = this.currentPos;
      }
    }
  }, {
    key: "findAround",
    value: function findAround(parent, content, before) {
      if (parent != content && this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          var pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;
        }
      }
    }
  }, {
    key: "findInText",
    value: function findInText(textNode) {
      if (this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode) this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
    }
  }, {
    key: "matchesContext",
    value: function matchesContext(context) {
      var _this4 = this;

      if (context.indexOf("|") > -1) return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      var parts = context.split("/");
      var option = this.options.context;
      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);

      var match = function match(i, depth) {
        for (; i >= 0; i--) {
          var part = parts[i];

          if (part == "") {
            if (i == parts.length - 1 || i == 0) continue;

            for (; depth >= minDepth; depth--) {
              if (match(i - 1, depth)) return true;
            }

            return false;
          } else {
            var next = depth > 0 || depth == 0 && useRoot ? _this4.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
            if (!next || next.name != part && next.groups.indexOf(part) == -1) return false;
            depth--;
          }
        }

        return true;
      };

      return match(parts.length - 1, this.open);
    }
  }, {
    key: "textblockFromContext",
    value: function textblockFromContext() {
      var $context = this.options.context;
      if ($context) for (var d = $context.depth; d >= 0; d--) {
        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;
      }

      for (var name in this.parser.schema.nodes) {
        var type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs) return type;
      }
    }
  }, {
    key: "addPendingMark",
    value: function addPendingMark(mark) {
      var found = findSameMarkInSet(mark, this.top.pendingMarks);
      if (found) this.top.stashMarks.push(found);
      this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
    }
  }, {
    key: "removePendingMark",
    value: function removePendingMark(mark, upto) {
      for (var depth = this.open; depth >= 0; depth--) {
        var level = this.nodes[depth];

        var _found3 = level.pendingMarks.lastIndexOf(mark);

        if (_found3 > -1) {
          level.pendingMarks = mark.removeFromSet(level.pendingMarks);
        } else {
          level.activeMarks = mark.removeFromSet(level.activeMarks);
          var stashMark = level.popFromStashMark(mark);
          if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) level.activeMarks = stashMark.addToSet(level.activeMarks);
        }

        if (level == upto) break;
      }
    }
  }]);

  return ParseContext;
}();

function normalizeList(dom) {
  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;

    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}

function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}

function parseStyles(style) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g,
      m,
      result = [];

  while (m = re.exec(style)) {
    result.push(m[1], m[2].trim());
  }

  return result;
}

function copy(obj) {
  var copy = {};

  for (var prop in obj) {
    copy[prop] = obj[prop];
  }

  return copy;
}

function markMayApply(markType, nodeType) {
  var nodes = nodeType.schema.nodes;

  var _loop4 = function _loop4(name) {
    var parent = nodes[name];
    if (!parent.allowsMarkType(markType)) return "continue";

    var seen = [],
        scan = function scan(match) {
      seen.push(match);

      for (var i = 0; i < match.edgeCount; i++) {
        var _match$edge = match.edge(i),
            type = _match$edge.type,
            next = _match$edge.next;

        if (type == nodeType) return true;
        if (seen.indexOf(next) < 0 && scan(next)) return true;
      }
    };

    if (scan(parent.contentMatch)) return {
      v: true
    };
  };

  for (var name in nodes) {
    var _ret = _loop4(name);

    if (_ret === "continue") continue;
    if (_typeof(_ret) === "object") return _ret.v;
  }
}

function findSameMarkInSet(mark, set) {
  for (var i = 0; i < set.length; i++) {
    if (mark.eq(set[i])) return set[i];
  }
}

var DOMSerializer = function () {
  function DOMSerializer(nodes, marks) {
    _classCallCheck(this, DOMSerializer);

    this.nodes = nodes;
    this.marks = marks;
  }

  _createClass(DOMSerializer, [{
    key: "serializeFragment",
    value: function serializeFragment(fragment) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var target = arguments.length > 2 ? arguments[2] : undefined;
      if (!target) target = doc(options).createDocumentFragment();
      var top = target,
          active = [];
      fragment.forEach(function (node) {
        if (active.length || node.marks.length) {
          var keep = 0,
              rendered = 0;

          while (keep < active.length && rendered < node.marks.length) {
            var next = node.marks[rendered];

            if (!_this5.marks[next.type.name]) {
              rendered++;
              continue;
            }

            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;
            keep++;
            rendered++;
          }

          while (keep < active.length) {
            top = active.pop()[1];
          }

          while (rendered < node.marks.length) {
            var add = node.marks[rendered++];

            var markDOM = _this5.serializeMark(add, node.isInline, options);

            if (markDOM) {
              active.push([add, top]);
              top.appendChild(markDOM.dom);
              top = markDOM.contentDOM || markDOM.dom;
            }
          }
        }

        top.appendChild(_this5.serializeNodeInner(node, options));
      });
      return target;
    }
  }, {
    key: "serializeNodeInner",
    value: function serializeNodeInner(node, options) {
      var _DOMSerializer$render = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node)),
          dom = _DOMSerializer$render.dom,
          contentDOM = _DOMSerializer$render.contentDOM;

      if (contentDOM) {
        if (node.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(node.content, options, contentDOM);
      }

      return dom;
    }
  }, {
    key: "serializeNode",
    value: function serializeNode(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var dom = this.serializeNodeInner(node, options);

      for (var i = node.marks.length - 1; i >= 0; i--) {
        var wrap = this.serializeMark(node.marks[i], node.isInline, options);

        if (wrap) {
          (wrap.contentDOM || wrap.dom).appendChild(dom);
          dom = wrap.dom;
        }
      }

      return dom;
    }
  }, {
    key: "serializeMark",
    value: function serializeMark(mark, inline) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var toDOM = this.marks[mark.type.name];
      return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));
    }
  }], [{
    key: "renderSpec",
    value: function renderSpec(doc, structure) {
      var xmlNS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (typeof structure == "string") return {
        dom: doc.createTextNode(structure)
      };
      if (structure.nodeType != null) return {
        dom: structure
      };
      if (structure.dom && structure.dom.nodeType != null) return structure;
      var tagName = structure[0],
          space = tagName.indexOf(" ");

      if (space > 0) {
        xmlNS = tagName.slice(0, space);
        tagName = tagName.slice(space + 1);
      }

      var contentDOM;
      var dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);
      var attrs = structure[1],
          start = 1;

      if (attrs && _typeof(attrs) == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start = 2;

        for (var name in attrs) {
          if (attrs[name] != null) {
            var _space = name.indexOf(" ");

            if (_space > 0) dom.setAttributeNS(name.slice(0, _space), name.slice(_space + 1), attrs[name]);else dom.setAttribute(name, attrs[name]);
          }
        }
      }

      for (var i = start; i < structure.length; i++) {
        var child = structure[i];

        if (child === 0) {
          if (i < structure.length - 1 || i > start) throw new RangeError("Content hole must be the only child of its parent node");
          return {
            dom: dom,
            contentDOM: dom
          };
        } else {
          var _DOMSerializer$render2 = DOMSerializer.renderSpec(doc, child, xmlNS),
              inner = _DOMSerializer$render2.dom,
              innerContent = _DOMSerializer$render2.contentDOM;

          dom.appendChild(inner);

          if (innerContent) {
            if (contentDOM) throw new RangeError("Multiple content holes");
            contentDOM = innerContent;
          }
        }
      }

      return {
        dom: dom,
        contentDOM: contentDOM
      };
    }
  }, {
    key: "fromSchema",
    value: function fromSchema(schema) {
      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    }
  }, {
    key: "nodesFromSchema",
    value: function nodesFromSchema(schema) {
      var result = gatherToDOM(schema.nodes);
      if (!result.text) result.text = function (node) {
        return node.text;
      };
      return result;
    }
  }, {
    key: "marksFromSchema",
    value: function marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    }
  }]);

  return DOMSerializer;
}();

function gatherToDOM(obj) {
  var result = {};

  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) result[name] = toDOM;
  }

  return result;
}

function doc(options) {
  return options.document || window.document;
}

exports.ContentMatch = ContentMatch;
exports.DOMParser = DOMParser;
exports.DOMSerializer = DOMSerializer;
exports.Fragment = Fragment;
exports.Mark = Mark;
exports.MarkType = MarkType;
exports.Node = Node;
exports.NodeRange = NodeRange;
exports.NodeType = NodeType;
exports.ReplaceError = ReplaceError;
exports.ResolvedPos = ResolvedPos;
exports.Schema = Schema;
exports.Slice = Slice;


/***/ }),

/***/ "./node_modules/prosemirror-schema-basic/dist/index.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/prosemirror-schema-basic/dist/index.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var pDOM = ["p", 0],
    blockquoteDOM = ["blockquote", 0],
    hrDOM = ["hr"],
    preDOM = ["pre", ["code", 0]],
    brDOM = ["br"];
var nodes = {
  doc: {
    content: "block+"
  },
  paragraph: {
    content: "inline*",
    group: "block",
    parseDOM: [{
      tag: "p"
    }],
    toDOM: function toDOM() {
      return pDOM;
    }
  },
  blockquote: {
    content: "block+",
    group: "block",
    defining: true,
    parseDOM: [{
      tag: "blockquote"
    }],
    toDOM: function toDOM() {
      return blockquoteDOM;
    }
  },
  horizontal_rule: {
    group: "block",
    parseDOM: [{
      tag: "hr"
    }],
    toDOM: function toDOM() {
      return hrDOM;
    }
  },
  heading: {
    attrs: {
      level: {
        "default": 1
      }
    },
    content: "inline*",
    group: "block",
    defining: true,
    parseDOM: [{
      tag: "h1",
      attrs: {
        level: 1
      }
    }, {
      tag: "h2",
      attrs: {
        level: 2
      }
    }, {
      tag: "h3",
      attrs: {
        level: 3
      }
    }, {
      tag: "h4",
      attrs: {
        level: 4
      }
    }, {
      tag: "h5",
      attrs: {
        level: 5
      }
    }, {
      tag: "h6",
      attrs: {
        level: 6
      }
    }],
    toDOM: function toDOM(node) {
      return ["h" + node.attrs.level, 0];
    }
  },
  code_block: {
    content: "text*",
    marks: "",
    group: "block",
    code: true,
    defining: true,
    parseDOM: [{
      tag: "pre",
      preserveWhitespace: "full"
    }],
    toDOM: function toDOM() {
      return preDOM;
    }
  },
  text: {
    group: "inline"
  },
  image: {
    inline: true,
    attrs: {
      src: {},
      alt: {
        "default": null
      },
      title: {
        "default": null
      }
    },
    group: "inline",
    draggable: true,
    parseDOM: [{
      tag: "img[src]",
      getAttrs: function getAttrs(dom) {
        return {
          src: dom.getAttribute("src"),
          title: dom.getAttribute("title"),
          alt: dom.getAttribute("alt")
        };
      }
    }],
    toDOM: function toDOM(node) {
      var _node$attrs = node.attrs,
          src = _node$attrs.src,
          alt = _node$attrs.alt,
          title = _node$attrs.title;
      return ["img", {
        src: src,
        alt: alt,
        title: title
      }];
    }
  },
  hard_break: {
    inline: true,
    group: "inline",
    selectable: false,
    parseDOM: [{
      tag: "br"
    }],
    toDOM: function toDOM() {
      return brDOM;
    }
  }
};
var emDOM = ["em", 0],
    strongDOM = ["strong", 0],
    codeDOM = ["code", 0];
var marks = {
  link: {
    attrs: {
      href: {},
      title: {
        "default": null
      }
    },
    inclusive: false,
    parseDOM: [{
      tag: "a[href]",
      getAttrs: function getAttrs(dom) {
        return {
          href: dom.getAttribute("href"),
          title: dom.getAttribute("title")
        };
      }
    }],
    toDOM: function toDOM(node) {
      var _node$attrs2 = node.attrs,
          href = _node$attrs2.href,
          title = _node$attrs2.title;
      return ["a", {
        href: href,
        title: title
      }, 0];
    }
  },
  em: {
    parseDOM: [{
      tag: "i"
    }, {
      tag: "em"
    }, {
      style: "font-style=italic"
    }],
    toDOM: function toDOM() {
      return emDOM;
    }
  },
  strong: {
    parseDOM: [{
      tag: "strong"
    }, {
      tag: "b",
      getAttrs: function getAttrs(node) {
        return node.style.fontWeight != "normal" && null;
      }
    }, {
      style: "font-weight",
      getAttrs: function getAttrs(value) {
        return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null;
      }
    }],
    toDOM: function toDOM() {
      return strongDOM;
    }
  },
  code: {
    parseDOM: [{
      tag: "code"
    }],
    toDOM: function toDOM() {
      return codeDOM;
    }
  }
};
var schema = new prosemirrorModel.Schema({
  nodes: nodes,
  marks: marks
});
exports.marks = marks;
exports.nodes = nodes;
exports.schema = schema;


/***/ }),

/***/ "./node_modules/prosemirror-schema-list/dist/index.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/prosemirror-schema-list/dist/index.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var olDOM = ["ol", 0],
    ulDOM = ["ul", 0],
    liDOM = ["li", 0];
var orderedList = {
  attrs: {
    order: {
      "default": 1
    }
  },
  parseDOM: [{
    tag: "ol",
    getAttrs: function getAttrs(dom) {
      return {
        order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1
      };
    }
  }],
  toDOM: function toDOM(node) {
    return node.attrs.order == 1 ? olDOM : ["ol", {
      start: node.attrs.order
    }, 0];
  }
};
var bulletList = {
  parseDOM: [{
    tag: "ul"
  }],
  toDOM: function toDOM() {
    return ulDOM;
  }
};
var listItem = {
  parseDOM: [{
    tag: "li"
  }],
  toDOM: function toDOM() {
    return liDOM;
  },
  defining: true
};

function add(obj, props) {
  var copy = {};

  for (var prop in obj) {
    copy[prop] = obj[prop];
  }

  for (var _prop in props) {
    copy[_prop] = props[_prop];
  }

  return copy;
}

function addListNodes(nodes, itemContent, listGroup) {
  return nodes.append({
    ordered_list: add(orderedList, {
      content: "list_item+",
      group: listGroup
    }),
    bullet_list: add(bulletList, {
      content: "list_item+",
      group: listGroup
    }),
    list_item: add(listItem, {
      content: itemContent
    })
  });
}

function wrapInList(listType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection = state.selection,
        $from = _state$selection.$from,
        $to = _state$selection.$to;
    var range = $from.blockRange($to),
        doJoin = false,
        outerRange = range;
    if (!range) return false;

    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if ($from.index(range.depth - 1) == 0) return false;
      var $insert = state.doc.resolve(range.start - 2);
      outerRange = new prosemirrorModel.NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount) range = new prosemirrorModel.NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
      doJoin = true;
    }

    var wrap = prosemirrorTransform.findWrapping(outerRange, listType, attrs, range);
    if (!wrap) return false;
    if (dispatch) dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());
    return true;
  };
}

function doWrapInList(tr, range, wrappers, joinBefore, listType) {
  var content = prosemirrorModel.Fragment.empty;

  for (var i = wrappers.length - 1; i >= 0; i--) {
    content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }

  tr.step(new prosemirrorTransform.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));
  var found = 0;

  for (var _i = 0; _i < wrappers.length; _i++) {
    if (wrappers[_i].type == listType) found = _i + 1;
  }

  var splitDepth = wrappers.length - found;
  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0),
      parent = range.parent;

  for (var _i2 = range.startIndex, e = range.endIndex, first = true; _i2 < e; _i2++, first = false) {
    if (!first && prosemirrorTransform.canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }

    splitPos += parent.child(_i2).nodeSize;
  }

  return tr;
}

function splitListItem(itemType) {
  return function (state, dispatch) {
    var _state$selection2 = state.selection,
        $from = _state$selection2.$from,
        $to = _state$selection2.$to,
        node = _state$selection2.node;
    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;
    var grandParent = $from.node(-1);
    if (grandParent.type != itemType) return false;

    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;

      if (dispatch) {
        var wrap = prosemirrorModel.Fragment.empty;
        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;

        for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d--) {
          wrap = prosemirrorModel.Fragment.from($from.node(d).copy(wrap));
        }

        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        wrap = wrap.append(prosemirrorModel.Fragment.from(itemType.createAndFill()));
        var start = $from.before($from.depth - (depthBefore - 1));

        var _tr = state.tr.replace(start, $from.after(-depthAfter), new prosemirrorModel.Slice(wrap, 4 - depthBefore, 0));

        var sel = -1;

        _tr.doc.nodesBetween(start, _tr.doc.content.size, function (node, pos) {
          if (sel > -1) return false;
          if (node.isTextblock && node.content.size == 0) sel = pos + 1;
        });

        if (sel > -1) _tr.setSelection(prosemirrorState.Selection.near(_tr.doc.resolve(sel)));
        dispatch(_tr.scrollIntoView());
      }

      return true;
    }

    var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    var tr = state.tr["delete"]($from.pos, $to.pos);
    var types = nextType ? [null, {
      type: nextType
    }] : undefined;
    if (!prosemirrorTransform.canSplit(tr.doc, $from.pos, 2, types)) return false;
    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());
    return true;
  };
}

function liftListItem(itemType) {
  return function (state, dispatch) {
    var _state$selection3 = state.selection,
        $from = _state$selection3.$from,
        $to = _state$selection3.$to;
    var range = $from.blockRange($to, function (node) {
      return node.childCount > 0 && node.firstChild.type == itemType;
    });
    if (!range) return false;
    if (!dispatch) return true;
    if ($from.node(range.depth - 1).type == itemType) return liftToOuterList(state, dispatch, itemType, range);else return liftOutOfList(state, dispatch, range);
  };
}

function liftToOuterList(state, dispatch, itemType, range) {
  var tr = state.tr,
      end = range.end,
      endOfList = range.$to.end(range.depth);

  if (end < endOfList) {
    tr.step(new prosemirrorTransform.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new prosemirrorModel.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }

  dispatch(tr.lift(range, prosemirrorTransform.liftTarget(range)).scrollIntoView());
  return true;
}

function liftOutOfList(state, dispatch, range) {
  var tr = state.tr,
      list = range.parent;

  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr["delete"](pos - 1, pos + 1);
  }

  var $start = tr.doc.resolve(range.start),
      item = $start.nodeAfter;
  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) return false;
  var atStart = range.startIndex == 0,
      atEnd = range.endIndex == list.childCount;
  var parent = $start.node(-1),
      indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list)))) return false;
  var start = $start.pos,
      end = start + item.nodeSize;
  tr.step(new prosemirrorTransform.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirrorModel.Slice((atStart ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))).append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true;
}

function sinkListItem(itemType) {
  return function (state, dispatch) {
    var _state$selection4 = state.selection,
        $from = _state$selection4.$from,
        $to = _state$selection4.$to;
    var range = $from.blockRange($to, function (node) {
      return node.childCount > 0 && node.firstChild.type == itemType;
    });
    if (!range) return false;
    var startIndex = range.startIndex;
    if (startIndex == 0) return false;
    var parent = range.parent,
        nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType) return false;

    if (dispatch) {
      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      var inner = prosemirrorModel.Fragment.from(nestedBefore ? itemType.create() : null);
      var slice = new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, prosemirrorModel.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      var before = range.start,
          after = range.end;
      dispatch(state.tr.step(new prosemirrorTransform.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
    }

    return true;
  };
}

exports.addListNodes = addListNodes;
exports.bulletList = bulletList;
exports.liftListItem = liftListItem;
exports.listItem = listItem;
exports.orderedList = orderedList;
exports.sinkListItem = sinkListItem;
exports.splitListItem = splitListItem;
exports.wrapInList = wrapInList;


/***/ }),

/***/ "./node_modules/prosemirror-state/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-state/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var classesById = Object.create(null);

var Selection = function () {
  function Selection($anchor, $head, ranges) {
    _classCallCheck(this, Selection);

    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }

  _createClass(Selection, [{
    key: "anchor",
    get: function get() {
      return this.$anchor.pos;
    }
  }, {
    key: "head",
    get: function get() {
      return this.$head.pos;
    }
  }, {
    key: "from",
    get: function get() {
      return this.$from.pos;
    }
  }, {
    key: "to",
    get: function get() {
      return this.$to.pos;
    }
  }, {
    key: "$from",
    get: function get() {
      return this.ranges[0].$from;
    }
  }, {
    key: "$to",
    get: function get() {
      return this.ranges[0].$to;
    }
  }, {
    key: "empty",
    get: function get() {
      var ranges = this.ranges;

      for (var i = 0; i < ranges.length; i++) {
        if (ranges[i].$from.pos != ranges[i].$to.pos) return false;
      }

      return true;
    }
  }, {
    key: "content",
    value: function content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
  }, {
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirrorModel.Slice.empty;
      var lastNode = content.content.lastChild,
          lastParent = null;

      for (var i = 0; i < content.openEnd; i++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }

      var mapFrom = tr.steps.length,
          ranges = this.ranges;

      for (var _i = 0; _i < ranges.length; _i++) {
        var _ranges$_i = ranges[_i],
            $from = _ranges$_i.$from,
            $to = _ranges$_i.$to,
            mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), _i ? prosemirrorModel.Slice.empty : content);
        if (_i == 0) selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    }
  }, {
    key: "replaceWith",
    value: function replaceWith(tr, node) {
      var mapFrom = tr.steps.length,
          ranges = this.ranges;

      for (var i = 0; i < ranges.length; i++) {
        var _ranges$i = ranges[i],
            $from = _ranges$i.$from,
            $to = _ranges$i.$to,
            mapping = tr.mapping.slice(mapFrom);
        var from = mapping.map($from.pos),
            to = mapping.map($to.pos);

        if (i) {
          tr.deleteRange(from, to);
        } else {
          tr.replaceRangeWith(from, to, node);
          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
        }
      }
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    }
  }], [{
    key: "findFrom",
    value: function findFrom($pos, dir) {
      var textOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner) return inner;

      for (var depth = $pos.depth - 1; depth >= 0; depth--) {
        var found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found) return found;
      }

      return null;
    }
  }, {
    key: "near",
    value: function near($pos) {
      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    }
  }, {
    key: "atStart",
    value: function atStart(doc) {
      return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);
    }
  }, {
    key: "atEnd",
    value: function atEnd(doc) {
      return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (!json || !json.type) throw new RangeError("Invalid input for Selection.fromJSON");
      var cls = classesById[json.type];
      if (!cls) throw new RangeError("No selection type ".concat(json.type, " defined"));
      return cls.fromJSON(doc, json);
    }
  }, {
    key: "jsonID",
    value: function jsonID(id, selectionClass) {
      if (id in classesById) throw new RangeError("Duplicate use of selection JSON ID " + id);
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    }
  }]);

  return Selection;
}();

Selection.prototype.visible = true;

var SelectionRange = _createClass(function SelectionRange($from, $to) {
  _classCallCheck(this, SelectionRange);

  this.$from = $from;
  this.$to = $to;
});

var warnedAboutTextSelection = false;

function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}

var TextSelection = function (_Selection) {
  _inherits(TextSelection, _Selection);

  var _super = _createSuper(TextSelection);

  function TextSelection($anchor) {
    var $head = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchor;

    _classCallCheck(this, TextSelection);

    checkTextSelection($anchor);
    checkTextSelection($head);
    return _super.call(this, $anchor, $head);
  }

  _createClass(TextSelection, [{
    key: "$cursor",
    get: function get() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
  }, {
    key: "map",
    value: function map(doc, mapping) {
      var $head = doc.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent) return Selection.near($head);
      var $anchor = doc.resolve(mapping.map(this.anchor));
      return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
    }
  }, {
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirrorModel.Slice.empty;

      _get(_getPrototypeOf(TextSelection.prototype), "replace", this).call(this, tr, content);

      if (content == prosemirrorModel.Slice.empty) {
        var marks = this.$from.marksAcross(this.$to);
        if (marks) tr.ensureMarks(marks);
      }
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return new TextBookmark(this.anchor, this.head);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "text",
        anchor: this.anchor,
        head: this.head
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (typeof json.anchor != "number" || typeof json.head != "number") throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));
    }
  }, {
    key: "create",
    value: function create(doc, anchor) {
      var head = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : anchor;
      var $anchor = doc.resolve(anchor);
      return new this($anchor, head == anchor ? $anchor : doc.resolve(head));
    }
  }, {
    key: "between",
    value: function between($anchor, $head, bias) {
      var dPos = $anchor.pos - $head.pos;
      if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;

      if (!$head.parent.inlineContent) {
        var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
        if (found) $head = found.$head;else return Selection.near($head, bias);
      }

      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0) $anchor = $head;
        }
      }

      return new TextSelection($anchor, $head);
    }
  }]);

  return TextSelection;
}(Selection);

Selection.jsonID("text", TextSelection);

var TextBookmark = function () {
  function TextBookmark(anchor, head) {
    _classCallCheck(this, TextBookmark);

    this.anchor = anchor;
    this.head = head;
  }

  _createClass(TextBookmark, [{
    key: "map",
    value: function map(mapping) {
      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
  }, {
    key: "resolve",
    value: function resolve(doc) {
      return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));
    }
  }]);

  return TextBookmark;
}();

var NodeSelection = function (_Selection2) {
  _inherits(NodeSelection, _Selection2);

  var _super2 = _createSuper(NodeSelection);

  function NodeSelection($pos) {
    var _this;

    _classCallCheck(this, NodeSelection);

    var node = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    _this = _super2.call(this, $pos, $end);
    _this.node = node;
    return _this;
  }

  _createClass(NodeSelection, [{
    key: "map",
    value: function map(doc, mapping) {
      var _mapping$mapResult = mapping.mapResult(this.anchor),
          deleted = _mapping$mapResult.deleted,
          pos = _mapping$mapResult.pos;

      var $pos = doc.resolve(pos);
      if (deleted) return Selection.near($pos);
      return new NodeSelection($pos);
    }
  }, {
    key: "content",
    value: function content() {
      return new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(this.node), 0, 0);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof NodeSelection && other.anchor == this.anchor;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "node",
        anchor: this.anchor
      };
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return new NodeBookmark(this.anchor);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (typeof json.anchor != "number") throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new NodeSelection(doc.resolve(json.anchor));
    }
  }, {
    key: "create",
    value: function create(doc, from) {
      return new NodeSelection(doc.resolve(from));
    }
  }, {
    key: "isSelectable",
    value: function isSelectable(node) {
      return !node.isText && node.type.spec.selectable !== false;
    }
  }]);

  return NodeSelection;
}(Selection);

NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);

var NodeBookmark = function () {
  function NodeBookmark(anchor) {
    _classCallCheck(this, NodeBookmark);

    this.anchor = anchor;
  }

  _createClass(NodeBookmark, [{
    key: "map",
    value: function map(mapping) {
      var _mapping$mapResult2 = mapping.mapResult(this.anchor),
          deleted = _mapping$mapResult2.deleted,
          pos = _mapping$mapResult2.pos;

      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
    }
  }, {
    key: "resolve",
    value: function resolve(doc) {
      var $pos = doc.resolve(this.anchor),
          node = $pos.nodeAfter;
      if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos);
      return Selection.near($pos);
    }
  }]);

  return NodeBookmark;
}();

var AllSelection = function (_Selection3) {
  _inherits(AllSelection, _Selection3);

  var _super3 = _createSuper(AllSelection);

  function AllSelection(doc) {
    _classCallCheck(this, AllSelection);

    return _super3.call(this, doc.resolve(0), doc.resolve(doc.content.size));
  }

  _createClass(AllSelection, [{
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirrorModel.Slice.empty;

      if (content == prosemirrorModel.Slice.empty) {
        tr["delete"](0, tr.doc.content.size);
        var sel = Selection.atStart(tr.doc);
        if (!sel.eq(tr.selection)) tr.setSelection(sel);
      } else {
        _get(_getPrototypeOf(AllSelection.prototype), "replace", this).call(this, tr, content);
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "all"
      };
    }
  }, {
    key: "map",
    value: function map(doc) {
      return new AllSelection(doc);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof AllSelection;
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return AllBookmark;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc) {
      return new AllSelection(doc);
    }
  }]);

  return AllSelection;
}(Selection);

Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map: function map() {
    return this;
  },
  resolve: function resolve(doc) {
    return new AllSelection(doc);
  }
};

function findSelectionIn(doc, node, pos, index, dir) {
  var text = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  if (node.inlineContent) return TextSelection.create(doc, pos);

  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    var child = node.child(i);

    if (!child.isAtom) {
      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner) return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));
    }

    pos += child.nodeSize * dir;
  }

  return null;
}

function selectionToInsertionEnd(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) return;
  var step = tr.steps[last];
  if (!(step instanceof prosemirrorTransform.ReplaceStep || step instanceof prosemirrorTransform.ReplaceAroundStep)) return;
  var map = tr.mapping.maps[last],
      end;
  map.forEach(function (_from, _to, _newFrom, newTo) {
    if (end == null) end = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}

var UPDATED_SEL = 1,
    UPDATED_MARKS = 2,
    UPDATED_SCROLL = 4;

var Transaction = function (_prosemirrorTransform) {
  _inherits(Transaction, _prosemirrorTransform);

  var _super4 = _createSuper(Transaction);

  function Transaction(state) {
    var _this2;

    _classCallCheck(this, Transaction);

    _this2 = _super4.call(this, state.doc);
    _this2.curSelectionFor = 0;
    _this2.updated = 0;
    _this2.meta = Object.create(null);
    _this2.time = Date.now();
    _this2.curSelection = state.selection;
    _this2.storedMarks = state.storedMarks;
    return _this2;
  }

  _createClass(Transaction, [{
    key: "selection",
    get: function get() {
      if (this.curSelectionFor < this.steps.length) {
        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
        this.curSelectionFor = this.steps.length;
      }

      return this.curSelection;
    }
  }, {
    key: "setSelection",
    value: function setSelection(selection) {
      if (selection.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document");
      this.curSelection = selection;
      this.curSelectionFor = this.steps.length;
      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
      this.storedMarks = null;
      return this;
    }
  }, {
    key: "selectionSet",
    get: function get() {
      return (this.updated & UPDATED_SEL) > 0;
    }
  }, {
    key: "setStoredMarks",
    value: function setStoredMarks(marks) {
      this.storedMarks = marks;
      this.updated |= UPDATED_MARKS;
      return this;
    }
  }, {
    key: "ensureMarks",
    value: function ensureMarks(marks) {
      if (!prosemirrorModel.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks)) this.setStoredMarks(marks);
      return this;
    }
  }, {
    key: "addStoredMark",
    value: function addStoredMark(mark) {
      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
    }
  }, {
    key: "removeStoredMark",
    value: function removeStoredMark(mark) {
      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }
  }, {
    key: "storedMarksSet",
    get: function get() {
      return (this.updated & UPDATED_MARKS) > 0;
    }
  }, {
    key: "addStep",
    value: function addStep(step, doc) {
      _get(_getPrototypeOf(Transaction.prototype), "addStep", this).call(this, step, doc);

      this.updated = this.updated & ~UPDATED_MARKS;
      this.storedMarks = null;
    }
  }, {
    key: "setTime",
    value: function setTime(time) {
      this.time = time;
      return this;
    }
  }, {
    key: "replaceSelection",
    value: function replaceSelection(slice) {
      this.selection.replace(this, slice);
      return this;
    }
  }, {
    key: "replaceSelectionWith",
    value: function replaceSelectionWith(node) {
      var inheritMarks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var selection = this.selection;
      if (inheritMarks) node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || prosemirrorModel.Mark.none));
      selection.replaceWith(this, node);
      return this;
    }
  }, {
    key: "deleteSelection",
    value: function deleteSelection() {
      this.selection.replace(this);
      return this;
    }
  }, {
    key: "insertText",
    value: function insertText(text, from, to) {
      var schema = this.doc.type.schema;

      if (from == null) {
        if (!text) return this.deleteSelection();
        return this.replaceSelectionWith(schema.text(text), true);
      } else {
        if (to == null) to = from;
        to = to == null ? from : to;
        if (!text) return this.deleteRange(from, to);
        var marks = this.storedMarks;

        if (!marks) {
          var $from = this.doc.resolve(from);
          marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
        }

        this.replaceRangeWith(from, to, schema.text(text, marks));
        if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to));
        return this;
      }
    }
  }, {
    key: "setMeta",
    value: function setMeta(key, value) {
      this.meta[typeof key == "string" ? key : key.key] = value;
      return this;
    }
  }, {
    key: "getMeta",
    value: function getMeta(key) {
      return this.meta[typeof key == "string" ? key : key.key];
    }
  }, {
    key: "isGeneric",
    get: function get() {
      for (var _ in this.meta) {
        return false;
      }

      return true;
    }
  }, {
    key: "scrollIntoView",
    value: function scrollIntoView() {
      this.updated |= UPDATED_SCROLL;
      return this;
    }
  }, {
    key: "scrolledIntoView",
    get: function get() {
      return (this.updated & UPDATED_SCROLL) > 0;
    }
  }]);

  return Transaction;
}(prosemirrorTransform.Transform);

function bind(f, self) {
  return !self || !f ? f : f.bind(self);
}

var FieldDesc = _createClass(function FieldDesc(name, desc, self) {
  _classCallCheck(this, FieldDesc);

  this.name = name;
  this.init = bind(desc.init, self);
  this.apply = bind(desc.apply, self);
});

var baseFields = [new FieldDesc("doc", {
  init: function init(config) {
    return config.doc || config.schema.topNodeType.createAndFill();
  },
  apply: function apply(tr) {
    return tr.doc;
  }
}), new FieldDesc("selection", {
  init: function init(config, instance) {
    return config.selection || Selection.atStart(instance.doc);
  },
  apply: function apply(tr) {
    return tr.selection;
  }
}), new FieldDesc("storedMarks", {
  init: function init(config) {
    return config.storedMarks || null;
  },
  apply: function apply(tr, _marks, _old, state) {
    return state.selection.$cursor ? tr.storedMarks : null;
  }
}), new FieldDesc("scrollToSelection", {
  init: function init() {
    return 0;
  },
  apply: function apply(tr, prev) {
    return tr.scrolledIntoView ? prev + 1 : prev;
  }
})];

var Configuration = _createClass(function Configuration(schema, plugins) {
  var _this3 = this;

  _classCallCheck(this, Configuration);

  this.schema = schema;
  this.plugins = [];
  this.pluginsByKey = Object.create(null);
  this.fields = baseFields.slice();
  if (plugins) plugins.forEach(function (plugin) {
    if (_this3.pluginsByKey[plugin.key]) throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");

    _this3.plugins.push(plugin);

    _this3.pluginsByKey[plugin.key] = plugin;
    if (plugin.spec.state) _this3.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
  });
});

var EditorState = function () {
  function EditorState(config) {
    _classCallCheck(this, EditorState);

    this.config = config;
  }

  _createClass(EditorState, [{
    key: "schema",
    get: function get() {
      return this.config.schema;
    }
  }, {
    key: "plugins",
    get: function get() {
      return this.config.plugins;
    }
  }, {
    key: "apply",
    value: function apply(tr) {
      return this.applyTransaction(tr).state;
    }
  }, {
    key: "filterTransaction",
    value: function filterTransaction(tr) {
      var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

      for (var i = 0; i < this.config.plugins.length; i++) {
        if (i != ignore) {
          var plugin = this.config.plugins[i];
          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) return false;
        }
      }

      return true;
    }
  }, {
    key: "applyTransaction",
    value: function applyTransaction(rootTr) {
      if (!this.filterTransaction(rootTr)) return {
        state: this,
        transactions: []
      };
      var trs = [rootTr],
          newState = this.applyInner(rootTr),
          seen = null;

      for (;;) {
        var haveNew = false;

        for (var i = 0; i < this.config.plugins.length; i++) {
          var plugin = this.config.plugins[i];

          if (plugin.spec.appendTransaction) {
            var n = seen ? seen[i].n : 0,
                oldState = seen ? seen[i].state : this;
            var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);

            if (tr && newState.filterTransaction(tr, i)) {
              tr.setMeta("appendedTransaction", rootTr);

              if (!seen) {
                seen = [];

                for (var j = 0; j < this.config.plugins.length; j++) {
                  seen.push(j < i ? {
                    state: newState,
                    n: trs.length
                  } : {
                    state: this,
                    n: 0
                  });
                }
              }

              trs.push(tr);
              newState = newState.applyInner(tr);
              haveNew = true;
            }

            if (seen) seen[i] = {
              state: newState,
              n: trs.length
            };
          }
        }

        if (!haveNew) return {
          state: newState,
          transactions: trs
        };
      }
    }
  }, {
    key: "applyInner",
    value: function applyInner(tr) {
      if (!tr.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction");
      var newInstance = new EditorState(this.config),
          fields = this.config.fields;

      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
      }

      return newInstance;
    }
  }, {
    key: "tr",
    get: function get() {
      return new Transaction(this);
    }
  }, {
    key: "reconfigure",
    value: function reconfigure(config) {
      var $config = new Configuration(this.schema, config.plugins);
      var fields = $config.fields,
          instance = new EditorState($config);

      for (var i = 0; i < fields.length; i++) {
        var name = fields[i].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
      }

      return instance;
    }
  }, {
    key: "toJSON",
    value: function toJSON(pluginFields) {
      var result = {
        doc: this.doc.toJSON(),
        selection: this.selection.toJSON()
      };
      if (this.storedMarks) result.storedMarks = this.storedMarks.map(function (m) {
        return m.toJSON();
      });
      if (pluginFields && _typeof(pluginFields) == 'object') for (var prop in pluginFields) {
        if (prop == "doc" || prop == "selection") throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        var plugin = pluginFields[prop],
            state = plugin.spec.state;
        if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
      return result;
    }
  }], [{
    key: "create",
    value: function create(config) {
      var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
      var instance = new EditorState($config);

      for (var i = 0; i < $config.fields.length; i++) {
        instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
      }

      return instance;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(config, json, pluginFields) {
      if (!json) throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!config.schema) throw new RangeError("Required config field 'schema' missing");
      var $config = new Configuration(config.schema, config.plugins);
      var instance = new EditorState($config);
      $config.fields.forEach(function (field) {
        if (field.name == "doc") {
          instance.doc = prosemirrorModel.Node.fromJSON(config.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
        } else {
          if (pluginFields) for (var prop in pluginFields) {
            var plugin = pluginFields[prop],
                state = plugin.spec.state;

            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
          instance[field.name] = field.init(config, instance);
        }
      });
      return instance;
    }
  }]);

  return EditorState;
}();

function bindProps(obj, self, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function) val = val.bind(self);else if (prop == "handleDOMEvents") val = bindProps(val, self, {});
    target[prop] = val;
  }

  return target;
}

var Plugin = function () {
  function Plugin(spec) {
    _classCallCheck(this, Plugin);

    this.spec = spec;
    this.props = {};
    if (spec.props) bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }

  _createClass(Plugin, [{
    key: "getState",
    value: function getState(state) {
      return state[this.key];
    }
  }]);

  return Plugin;
}();

var keys = Object.create(null);

function createKey(name) {
  if (name in keys) return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}

var PluginKey = function () {
  function PluginKey() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "key";

    _classCallCheck(this, PluginKey);

    this.key = createKey(name);
  }

  _createClass(PluginKey, [{
    key: "get",
    value: function get(state) {
      return state.config.pluginsByKey[this.key];
    }
  }, {
    key: "getState",
    value: function getState(state) {
      return state[this.key];
    }
  }]);

  return PluginKey;
}();

exports.AllSelection = AllSelection;
exports.EditorState = EditorState;
exports.NodeSelection = NodeSelection;
exports.Plugin = Plugin;
exports.PluginKey = PluginKey;
exports.Selection = Selection;
exports.SelectionRange = SelectionRange;
exports.TextSelection = TextSelection;
exports.Transaction = Transaction;


/***/ }),

/***/ "./node_modules/prosemirror-transform/dist/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var lower16 = 0xffff;
var factor16 = Math.pow(2, 16);

function makeRecover(index, offset) {
  return index + offset * factor16;
}

function recoverIndex(value) {
  return value & lower16;
}

function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}

var DEL_BEFORE = 1,
    DEL_AFTER = 2,
    DEL_ACROSS = 4,
    DEL_SIDE = 8;

var MapResult = function () {
  function MapResult(pos, delInfo, recover) {
    _classCallCheck(this, MapResult);

    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }

  _createClass(MapResult, [{
    key: "deleted",
    get: function get() {
      return (this.delInfo & DEL_SIDE) > 0;
    }
  }, {
    key: "deletedBefore",
    get: function get() {
      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
    }
  }, {
    key: "deletedAfter",
    get: function get() {
      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
    }
  }, {
    key: "deletedAcross",
    get: function get() {
      return (this.delInfo & DEL_ACROSS) > 0;
    }
  }]);

  return MapResult;
}();

var StepMap = function () {
  function StepMap(ranges) {
    var inverted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, StepMap);

    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty) return StepMap.empty;
  }

  _createClass(StepMap, [{
    key: "recover",
    value: function recover(value) {
      var diff = 0,
          index = recoverIndex(value);
      if (!this.inverted) for (var i = 0; i < index; i++) {
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
      }
      return this.ranges[index * 3] + diff + recoverOffset(value);
    }
  }, {
    key: "mapResult",
    value: function mapResult(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, false);
    }
  }, {
    key: "map",
    value: function map(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, true);
    }
  }, {
    key: "_map",
    value: function _map(pos, assoc, simple) {
      var diff = 0,
          oldIndex = this.inverted ? 2 : 1,
          newIndex = this.inverted ? 1 : 2;

      for (var i = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) break;
        var oldSize = this.ranges[i + oldIndex],
            newSize = this.ranges[i + newIndex],
            end = start + oldSize;

        if (pos <= end) {
          var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
          var result = start + diff + (side < 0 ? 0 : newSize);
          if (simple) return result;
          var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
          var del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
          if (assoc < 0 ? pos != start : pos != end) del |= DEL_SIDE;
          return new MapResult(result, del, recover);
        }

        diff += newSize - oldSize;
      }

      return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    }
  }, {
    key: "touches",
    value: function touches(pos, recover) {
      var diff = 0,
          index = recoverIndex(recover);
      var oldIndex = this.inverted ? 2 : 1,
          newIndex = this.inverted ? 1 : 2;

      for (var i = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) break;
        var oldSize = this.ranges[i + oldIndex],
            end = start + oldSize;
        if (pos <= end && i == index * 3) return true;
        diff += this.ranges[i + newIndex] - oldSize;
      }

      return false;
    }
  }, {
    key: "forEach",
    value: function forEach(f) {
      var oldIndex = this.inverted ? 2 : 1,
          newIndex = this.inverted ? 1 : 2;

      for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i],
            oldStart = start - (this.inverted ? diff : 0),
            newStart = start + (this.inverted ? 0 : diff);
        var oldSize = this.ranges[i + oldIndex],
            newSize = this.ranges[i + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      return new StepMap(this.ranges, !this.inverted);
    }
  }, {
    key: "toString",
    value: function toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
  }], [{
    key: "offset",
    value: function offset(n) {
      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    }
  }]);

  return StepMap;
}();

StepMap.empty = new StepMap([]);

var Mapping = function () {
  function Mapping() {
    var maps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var mirror = arguments.length > 1 ? arguments[1] : undefined;
    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : maps.length;

    _classCallCheck(this, Mapping);

    this.maps = maps;
    this.mirror = mirror;
    this.from = from;
    this.to = to;
  }

  _createClass(Mapping, [{
    key: "slice",
    value: function slice() {
      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.maps.length;
      return new Mapping(this.maps, this.mirror, from, to);
    }
  }, {
    key: "copy",
    value: function copy() {
      return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
    }
  }, {
    key: "appendMap",
    value: function appendMap(map, mirrors) {
      this.to = this.maps.push(map);
      if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors);
    }
  }, {
    key: "appendMapping",
    value: function appendMapping(mapping) {
      for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);
      }
    }
  }, {
    key: "getMirror",
    value: function getMirror(n) {
      if (this.mirror) for (var i = 0; i < this.mirror.length; i++) {
        if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)];
      }
    }
  }, {
    key: "setMirror",
    value: function setMirror(n, m) {
      if (!this.mirror) this.mirror = [];
      this.mirror.push(n, m);
    }
  }, {
    key: "appendMappingInverted",
    value: function appendMappingInverted(mapping) {
      for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverse = new Mapping();
      inverse.appendMappingInverted(this);
      return inverse;
    }
  }, {
    key: "map",
    value: function map(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (this.mirror) return this._map(pos, assoc, true);

      for (var i = this.from; i < this.to; i++) {
        pos = this.maps[i].map(pos, assoc);
      }

      return pos;
    }
  }, {
    key: "mapResult",
    value: function mapResult(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, false);
    }
  }, {
    key: "_map",
    value: function _map(pos, assoc, simple) {
      var delInfo = 0;

      for (var i = this.from; i < this.to; i++) {
        var map = this.maps[i],
            result = map.mapResult(pos, assoc);

        if (result.recover != null) {
          var corr = this.getMirror(i);

          if (corr != null && corr > i && corr < this.to) {
            i = corr;
            pos = this.maps[corr].recover(result.recover);
            continue;
          }
        }

        delInfo |= result.delInfo;
        pos = result.pos;
      }

      return simple ? pos : new MapResult(pos, delInfo, null);
    }
  }]);

  return Mapping;
}();

var stepsByID = Object.create(null);

var Step = function () {
  function Step() {
    _classCallCheck(this, Step);
  }

  _createClass(Step, [{
    key: "getMap",
    value: function getMap() {
      return StepMap.empty;
    }
  }, {
    key: "merge",
    value: function merge(other) {
      return null;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json || !json.stepType) throw new RangeError("Invalid input for Step.fromJSON");
      var type = stepsByID[json.stepType];
      if (!type) throw new RangeError("No step type ".concat(json.stepType, " defined"));
      return type.fromJSON(schema, json);
    }
  }, {
    key: "jsonID",
    value: function jsonID(id, stepClass) {
      if (id in stepsByID) throw new RangeError("Duplicate use of step JSON ID " + id);
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    }
  }]);

  return Step;
}();

var StepResult = function () {
  function StepResult(doc, failed) {
    _classCallCheck(this, StepResult);

    this.doc = doc;
    this.failed = failed;
  }

  _createClass(StepResult, null, [{
    key: "ok",
    value: function ok(doc) {
      return new StepResult(doc, null);
    }
  }, {
    key: "fail",
    value: function fail(message) {
      return new StepResult(null, message);
    }
  }, {
    key: "fromReplace",
    value: function fromReplace(doc, from, to, slice) {
      try {
        return StepResult.ok(doc.replace(from, to, slice));
      } catch (e) {
        if (e instanceof prosemirrorModel.ReplaceError) return StepResult.fail(e.message);
        throw e;
      }
    }
  }]);

  return StepResult;
}();

function mapFragment(fragment, f, parent) {
  var mapped = [];

  for (var i = 0; i < fragment.childCount; i++) {
    var child = fragment.child(i);
    if (child.content.size) child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline) child = f(child, parent, i);
    mapped.push(child);
  }

  return prosemirrorModel.Fragment.fromArray(mapped);
}

var AddMarkStep = function (_Step) {
  _inherits(AddMarkStep, _Step);

  var _super = _createSuper(AddMarkStep);

  function AddMarkStep(from, to, mark) {
    var _this;

    _classCallCheck(this, AddMarkStep);

    _this = _super.call(this);
    _this.from = from;
    _this.to = to;
    _this.mark = mark;
    return _this;
  }

  _createClass(AddMarkStep, [{
    key: "apply",
    value: function apply(doc) {
      var _this2 = this;

      var oldSlice = doc.slice(this.from, this.to),
          $from = doc.resolve(this.from);
      var parent = $from.node($from.sharedDepth(this.to));
      var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function (node, parent) {
        if (!node.isAtom || !parent.type.allowsMarkType(_this2.mark.type)) return node;
        return node.mark(_this2.mark.addToSet(node.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
          to = mapping.mapResult(this.to, -1);
      if (from.deleted && to.deleted || from.pos >= to.pos) return null;
      return new AddMarkStep(from.pos, to.pos, this.mark);
    }
  }, {
    key: "merge",
    value: function merge(other) {
      if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  }]);

  return AddMarkStep;
}(Step);

Step.jsonID("addMark", AddMarkStep);

var RemoveMarkStep = function (_Step2) {
  _inherits(RemoveMarkStep, _Step2);

  var _super2 = _createSuper(RemoveMarkStep);

  function RemoveMarkStep(from, to, mark) {
    var _this3;

    _classCallCheck(this, RemoveMarkStep);

    _this3 = _super2.call(this);
    _this3.from = from;
    _this3.to = to;
    _this3.mark = mark;
    return _this3;
  }

  _createClass(RemoveMarkStep, [{
    key: "apply",
    value: function apply(doc) {
      var _this4 = this;

      var oldSlice = doc.slice(this.from, this.to);
      var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function (node) {
        return node.mark(_this4.mark.removeFromSet(node.marks));
      }, doc), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new AddMarkStep(this.from, this.to, this.mark);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
          to = mapping.mapResult(this.to, -1);
      if (from.deleted && to.deleted || from.pos >= to.pos) return null;
      return new RemoveMarkStep(from.pos, to.pos, this.mark);
    }
  }, {
    key: "merge",
    value: function merge(other) {
      if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  }]);

  return RemoveMarkStep;
}(Step);

Step.jsonID("removeMark", RemoveMarkStep);

var ReplaceStep = function (_Step3) {
  _inherits(ReplaceStep, _Step3);

  var _super3 = _createSuper(ReplaceStep);

  function ReplaceStep(from, to, slice) {
    var _this5;

    var structure = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    _classCallCheck(this, ReplaceStep);

    _this5 = _super3.call(this);
    _this5.from = from;
    _this5.to = to;
    _this5.slice = slice;
    _this5.structure = structure;
    return _this5;
  }

  _createClass(ReplaceStep, [{
    key: "apply",
    value: function apply(doc) {
      if (this.structure && contentBetween(doc, this.from, this.to)) return StepResult.fail("Structure replace would overwrite content");
      return StepResult.fromReplace(doc, this.from, this.to, this.slice);
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
          to = mapping.mapResult(this.to, -1);
      if (from.deletedAcross && to.deletedAcross) return null;
      return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);
    }
  }, {
    key: "merge",
    value: function merge(other) {
      if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null;

      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        var slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        var _slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);

        return new ReplaceStep(other.from, this.to, _slice, this.structure);
      } else {
        return null;
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {
        stepType: "replace",
        from: this.from,
        to: this.to
      };
      if (this.slice.size) json.slice = this.slice.toJSON();
      if (this.structure) json.structure = true;
      return json;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new ReplaceStep(json.from, json.to, prosemirrorModel.Slice.fromJSON(schema, json.slice), !!json.structure);
    }
  }]);

  return ReplaceStep;
}(Step);

Step.jsonID("replace", ReplaceStep);

var ReplaceAroundStep = function (_Step4) {
  _inherits(ReplaceAroundStep, _Step4);

  var _super4 = _createSuper(ReplaceAroundStep);

  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert) {
    var _this6;

    var structure = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

    _classCallCheck(this, ReplaceAroundStep);

    _this6 = _super4.call(this);
    _this6.from = from;
    _this6.to = to;
    _this6.gapFrom = gapFrom;
    _this6.gapTo = gapTo;
    _this6.slice = slice;
    _this6.insert = insert;
    _this6.structure = structure;
    return _this6;
  }

  _createClass(ReplaceAroundStep, [{
    key: "apply",
    value: function apply(doc) {
      if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) return StepResult.fail("Structure gap-replace would overwrite content");
      var gap = doc.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd) return StepResult.fail("Gap is not a flat range");
      var inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted) return StepResult.fail("Content does not fit in gap");
      return StepResult.fromReplace(doc, this.from, this.to, inserted);
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      var gap = this.gapTo - this.gapFrom;
      return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
          to = mapping.mapResult(this.to, -1);
      var gapFrom = mapping.map(this.gapFrom, -1),
          gapTo = mapping.map(this.gapTo, 1);
      if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos) return null;
      return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size) json.slice = this.slice.toJSON();
      if (this.structure) json.structure = true;
      return json;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirrorModel.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
    }
  }]);

  return ReplaceAroundStep;
}(Step);

Step.jsonID("replaceAround", ReplaceAroundStep);

function contentBetween(doc, from, to) {
  var $from = doc.resolve(from),
      dist = to - from,
      depth = $from.depth;

  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }

  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));

    while (dist > 0) {
      if (!next || next.isLeaf) return true;
      next = next.firstChild;
      dist--;
    }
  }

  return false;
}

function _addMark(tr, from, to, mark) {
  var removed = [],
      added = [];
  var removing, adding;
  tr.doc.nodesBetween(from, to, function (node, pos, parent) {
    if (!node.isInline) return;
    var marks = node.marks;

    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      var start = Math.max(pos, from),
          end = Math.min(pos + node.nodeSize, to);
      var newSet = mark.addToSet(marks);

      for (var i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i])) removing.to = end;else removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }

      if (adding && adding.to == start) adding.to = end;else added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach(function (s) {
    return tr.step(s);
  });
  added.forEach(function (s) {
    return tr.step(s);
  });
}

function _removeMark(tr, from, to, mark) {
  var matched = [],
      step = 0;
  tr.doc.nodesBetween(from, to, function (node, pos) {
    if (!node.isInline) return;
    step++;
    var toRemove = null;

    if (mark instanceof prosemirrorModel.MarkType) {
      var set = node.marks,
          found;

      while (found = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found);
        set = found.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks)) toRemove = [mark];
    } else {
      toRemove = node.marks;
    }

    if (toRemove && toRemove.length) {
      var end = Math.min(pos + node.nodeSize, to);

      for (var i = 0; i < toRemove.length; i++) {
        var style = toRemove[i],
            _found = void 0;

        for (var j = 0; j < matched.length; j++) {
          var m = matched[j];
          if (m.step == step - 1 && style.eq(matched[j].style)) _found = m;
        }

        if (_found) {
          _found.to = end;
          _found.step = step;
        } else {
          matched.push({
            style: style,
            from: Math.max(pos, from),
            to: end,
            step: step
          });
        }
      }
    }
  });
  matched.forEach(function (m) {
    return tr.step(new RemoveMarkStep(m.from, m.to, m.style));
  });
}

function _clearIncompatible(tr, pos, parentType) {
  var match = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : parentType.contentMatch;
  var node = tr.doc.nodeAt(pos);
  var delSteps = [],
      cur = pos + 1;

  for (var i = 0; i < node.childCount; i++) {
    var child = node.child(i),
        end = cur + child.nodeSize;
    var allowed = match.matchType(child.type);

    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end, prosemirrorModel.Slice.empty));
    } else {
      match = allowed;

      for (var j = 0; j < child.marks.length; j++) {
        if (!parentType.allowsMarkType(child.marks[j].type)) tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
      }
    }

    cur = end;
  }

  if (!match.validEnd) {
    var fill = match.fillBefore(prosemirrorModel.Fragment.empty, true);
    tr.replace(cur, cur, new prosemirrorModel.Slice(fill, 0, 0));
  }

  for (var _i = delSteps.length - 1; _i >= 0; _i--) {
    tr.step(delSteps[_i]);
  }
}

function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}

function liftTarget(range) {
  var parent = range.parent;
  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);

  for (var depth = range.depth;; --depth) {
    var node = range.$from.node(depth);
    var index = range.$from.index(depth),
        endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content)) return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break;
  }

  return null;
}

function _lift(tr, range, target) {
  var $from = range.$from,
      $to = range.$to,
      depth = range.depth;
  var gapStart = $from.before(depth + 1),
      gapEnd = $to.after(depth + 1);
  var start = gapStart,
      end = gapEnd;
  var before = prosemirrorModel.Fragment.empty,
      openStart = 0;

  for (var d = depth, splitting = false; d > target; d--) {
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = prosemirrorModel.Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
  }

  var after = prosemirrorModel.Fragment.empty,
      openEnd = 0;

  for (var _d = depth, _splitting = false; _d > target; _d--) {
    if (_splitting || $to.after(_d + 1) < $to.end(_d)) {
      _splitting = true;
      after = prosemirrorModel.Fragment.from($to.node(_d).copy(after));
      openEnd++;
    } else {
      end++;
    }
  }

  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirrorModel.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}

function findWrapping(range, nodeType) {
  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var innerRange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : range;
  var around = findWrappingOutside(range, nodeType);
  var inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner) return null;
  return around.map(withAttrs).concat({
    type: nodeType,
    attrs: attrs
  }).concat(inner.map(withAttrs));
}

function withAttrs(type) {
  return {
    type: type,
    attrs: null
  };
}

function findWrappingOutside(range, type) {
  var parent = range.parent,
      startIndex = range.startIndex,
      endIndex = range.endIndex;
  var around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around) return null;
  var outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}

function findWrappingInside(range, type) {
  var parent = range.parent,
      startIndex = range.startIndex,
      endIndex = range.endIndex;
  var inner = parent.child(startIndex);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (!inside) return null;
  var lastType = inside.length ? inside[inside.length - 1] : type;
  var innerMatch = lastType.contentMatch;

  for (var i = startIndex; innerMatch && i < endIndex; i++) {
    innerMatch = innerMatch.matchType(parent.child(i).type);
  }

  if (!innerMatch || !innerMatch.validEnd) return null;
  return inside;
}

function _wrap2(tr, range, wrappers) {
  var content = prosemirrorModel.Fragment.empty;

  for (var i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      var match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }

    content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }

  var start = range.start,
      end = range.end;
  tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));
}

function _setBlockType(tr, from, to, type, attrs) {
  if (!type.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock");
  var mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from, to, function (node, pos) {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
      tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);
      var mapping = tr.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1),
          endM = mapping.map(pos + node.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false;
    }
  });
}

function canChangeType(doc, pos, type) {
  var $pos = doc.resolve(pos),
      index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}

function _setNodeMarkup(tr, pos, type, attrs, marks) {
  var node = tr.doc.nodeAt(pos);
  if (!node) throw new RangeError("No node at given position");
  if (!type) type = node.type;
  var newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf) return tr.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content)) throw new RangeError("Invalid content for node type " + type.name);
  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(newNode), 0, 0), 1, true));
}

function canSplit(doc, pos) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;
  var $pos = doc.resolve(pos),
      base = $pos.depth - depth;
  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;

  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
    var node = $pos.node(d),
        _index = $pos.index(d);

    if (node.type.spec.isolating) return false;
    var rest = node.content.cutByIndex(_index, node.childCount);
    var after = typesAfter && typesAfter[i] || node;
    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs));
    if (!node.canReplace(_index + 1, node.childCount) || !after.type.validContent(rest)) return false;
  }

  var index = $pos.indexAfter(base);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);
}

function _split(tr, pos) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;
  var $pos = tr.doc.resolve(pos),
      before = prosemirrorModel.Fragment.empty,
      after = prosemirrorModel.Fragment.empty;

  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = prosemirrorModel.Fragment.from($pos.node(d).copy(before));
    var typeAfter = typesAfter && typesAfter[i];
    after = prosemirrorModel.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }

  tr.step(new ReplaceStep(pos, pos, new prosemirrorModel.Slice(before.append(after), depth, depth), true));
}

function canJoin(doc, pos) {
  var $pos = doc.resolve(pos),
      index = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}

function joinable(a, b) {
  return !!(a && b && !a.isLeaf && a.canAppend(b));
}

function joinPoint(doc, pos) {
  var dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
  var $pos = doc.resolve(pos);

  for (var d = $pos.depth;; d--) {
    var before = void 0,
        after = void 0,
        index = $pos.index(d);

    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }

    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) return pos;
    if (d == 0) break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}

function _join(tr, pos, depth) {
  var step = new ReplaceStep(pos - depth, pos + depth, prosemirrorModel.Slice.empty, true);
  tr.step(step);
}

function insertPoint(doc, pos, nodeType) {
  var $pos = doc.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos;
  if ($pos.parentOffset == 0) for (var d = $pos.depth - 1; d >= 0; d--) {
    var index = $pos.index(d);
    if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1);
    if (index > 0) return null;
  }
  if ($pos.parentOffset == $pos.parent.content.size) for (var _d2 = $pos.depth - 1; _d2 >= 0; _d2--) {
    var _index2 = $pos.indexAfter(_d2);

    if ($pos.node(_d2).canReplaceWith(_index2, _index2, nodeType)) return $pos.after(_d2 + 1);
    if (_index2 < $pos.node(_d2).childCount) return null;
  }
  return null;
}

function dropPoint(doc, pos, slice) {
  var $pos = doc.resolve(pos);
  if (!slice.content.size) return pos;
  var content = slice.content;

  for (var i = 0; i < slice.openStart; i++) {
    content = content.firstChild.content;
  }

  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
    for (var d = $pos.depth; d >= 0; d--) {
      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d),
          fits = false;

      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }

      if (fits) return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }

  return null;
}

function replaceStep(doc, from) {
  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : from;
  var slice = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prosemirrorModel.Slice.empty;
  if (from == to && !slice.size) return null;
  var $from = doc.resolve(from),
      $to = doc.resolve(to);
  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice);
  return new Fitter($from, $to, slice).fit();
}

function fitsTrivially($from, $to, slice) {
  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
}

var Fitter = function () {
  function Fitter($from, $to, unplaced) {
    _classCallCheck(this, Fitter);

    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = prosemirrorModel.Fragment.empty;

    for (var i = 0; i <= $from.depth; i++) {
      var node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }

    for (var _i2 = $from.depth; _i2 > 0; _i2--) {
      this.placed = prosemirrorModel.Fragment.from($from.node(_i2).copy(this.placed));
    }
  }

  _createClass(Fitter, [{
    key: "depth",
    get: function get() {
      return this.frontier.length - 1;
    }
  }, {
    key: "fit",
    value: function fit() {
      while (this.unplaced.size) {
        var fit = this.findFittable();
        if (fit) this.placeNodes(fit);else this.openMore() || this.dropNode();
      }

      var moveInline = this.mustMoveInline(),
          placedSize = this.placed.size - this.depth - this.$from.depth;
      var $from = this.$from,
          $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to) return null;
      var content = this.placed,
          openStart = $from.depth,
          openEnd = $to.depth;

      while (openStart && openEnd && content.childCount == 1) {
        content = content.firstChild.content;
        openStart--;
        openEnd--;
      }

      var slice = new prosemirrorModel.Slice(content, openStart, openEnd);
      if (moveInline > -1) return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
      if (slice.size || $from.pos != this.$to.pos) return new ReplaceStep($from.pos, $to.pos, slice);
      return null;
    }
  }, {
    key: "findFittable",
    value: function findFittable() {
      for (var pass = 1; pass <= 2; pass++) {
        for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          var fragment = void 0,
              parent = null;

          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }

          var first = fragment.firstChild;

          for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            var _this$frontier$fronti = this.frontier[frontierDepth],
                type = _this$frontier$fronti.type,
                match = _this$frontier$fronti.match,
                _wrap = void 0,
                inject = null;

            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirrorModel.Fragment.from(first), false)) : parent && type.compatibleContent(parent.type))) return {
              sliceDepth: sliceDepth,
              frontierDepth: frontierDepth,
              parent: parent,
              inject: inject
            };else if (pass == 2 && first && (_wrap = match.findWrapping(first.type))) return {
              sliceDepth: sliceDepth,
              frontierDepth: frontierDepth,
              parent: parent,
              wrap: _wrap
            };
            if (parent && match.matchType(parent.type)) break;
          }
        }
      }
    }
  }, {
    key: "openMore",
    value: function openMore() {
      var _this$unplaced = this.unplaced,
          content = _this$unplaced.content,
          openStart = _this$unplaced.openStart,
          openEnd = _this$unplaced.openEnd;
      var inner = contentAt(content, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf) return false;
      this.unplaced = new prosemirrorModel.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
      return true;
    }
  }, {
    key: "dropNode",
    value: function dropNode() {
      var _this$unplaced2 = this.unplaced,
          content = _this$unplaced2.content,
          openStart = _this$unplaced2.openStart,
          openEnd = _this$unplaced2.openEnd;
      var inner = contentAt(content, openStart);

      if (inner.childCount <= 1 && openStart > 0) {
        var openAtEnd = content.size - openStart <= openStart + inner.size;
        this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
      }
    }
  }, {
    key: "placeNodes",
    value: function placeNodes(_ref) {
      var sliceDepth = _ref.sliceDepth,
          frontierDepth = _ref.frontierDepth,
          parent = _ref.parent,
          inject = _ref.inject,
          wrap = _ref.wrap;

      while (this.depth > frontierDepth) {
        this.closeFrontierNode();
      }

      if (wrap) for (var i = 0; i < wrap.length; i++) {
        this.openFrontierNode(wrap[i]);
      }
      var slice = this.unplaced,
          fragment = parent ? parent.content : slice.content;
      var openStart = slice.openStart - sliceDepth;
      var taken = 0,
          add = [];
      var _this$frontier$fronti2 = this.frontier[frontierDepth],
          match = _this$frontier$fronti2.match,
          type = _this$frontier$fronti2.type;

      if (inject) {
        for (var i = 0; i < inject.childCount; i++) {
          add.push(inject.child(i));
        }

        match = match.matchFragment(inject);
      }

      var openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);

      while (taken < fragment.childCount) {
        var next = fragment.child(taken),
            matches = match.matchType(next.type);
        if (!matches) break;
        taken++;

        if (taken > 1 || openStart == 0 || next.content.size) {
          match = matches;
          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
        }
      }

      var toEnd = taken == fragment.childCount;
      if (!toEnd) openEndCount = -1;
      this.placed = addToFragment(this.placed, frontierDepth, prosemirrorModel.Fragment.from(add));
      this.frontier[frontierDepth].match = match;
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) this.closeFrontierNode();

      for (var _i3 = 0, cur = fragment; _i3 < openEndCount; _i3++) {
        var node = cur.lastChild;
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt(node.childCount)
        });
        cur = node.content;
      }

      this.unplaced = !toEnd ? new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
    }
  }, {
    key: "mustMoveInline",
    value: function mustMoveInline() {
      if (!this.$to.parent.isTextblock) return -1;
      var top = this.frontier[this.depth],
          level;
      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) return -1;
      var depth = this.$to.depth,
          after = this.$to.after(depth);

      while (depth > 1 && after == this.$to.end(--depth)) {
        ++after;
      }

      return after;
    }
  }, {
    key: "findCloseLevel",
    value: function findCloseLevel($to) {
      scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        var _this$frontier$i = this.frontier[i],
            match = _this$frontier$i.match,
            type = _this$frontier$i.type;
        var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        var fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit) continue;

        for (var d = i - 1; d >= 0; d--) {
          var _this$frontier$d = this.frontier[d],
              _match = _this$frontier$d.match,
              _type = _this$frontier$d.type;
          var matches = contentAfterFits($to, d, _type, _match, true);
          if (!matches || matches.childCount) continue scan;
        }

        return {
          depth: i,
          fit: fit,
          move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to
        };
      }
    }
  }, {
    key: "close",
    value: function close($to) {
      var close = this.findCloseLevel($to);
      if (!close) return null;

      while (this.depth > close.depth) {
        this.closeFrontierNode();
      }

      if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit);
      $to = close.move;

      for (var d = close.depth + 1; d <= $to.depth; d++) {
        var node = $to.node(d),
            add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
        this.openFrontierNode(node.type, node.attrs, add);
      }

      return $to;
    }
  }, {
    key: "openFrontierNode",
    value: function openFrontierNode(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var content = arguments.length > 2 ? arguments[2] : undefined;
      var top = this.frontier[this.depth];
      top.match = top.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, prosemirrorModel.Fragment.from(type.create(attrs, content)));
      this.frontier.push({
        type: type,
        match: type.contentMatch
      });
    }
  }, {
    key: "closeFrontierNode",
    value: function closeFrontierNode() {
      var open = this.frontier.pop();
      var add = open.match.fillBefore(prosemirrorModel.Fragment.empty, true);
      if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add);
    }
  }]);

  return Fitter;
}();

function dropFromFragment(fragment, depth, count) {
  if (depth == 0) return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}

function addToFragment(fragment, depth, content) {
  if (depth == 0) return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}

function contentAt(fragment, depth) {
  for (var i = 0; i < depth; i++) {
    fragment = fragment.firstChild.content;
  }

  return fragment;
}

function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0) return node;
  var frag = node.content;
  if (openStart > 1) frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));

  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirrorModel.Fragment.empty, true));
  }

  return node.copy(frag);
}

function contentAfterFits($to, depth, type, match, open) {
  var node = $to.node(depth),
      index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type)) return null;
  var fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}

function invalidMarks(type, fragment, start) {
  for (var i = start; i < fragment.childCount; i++) {
    if (!type.allowsMarks(fragment.child(i).marks)) return true;
  }

  return false;
}

function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}

function _replaceRange(tr, from, to, slice) {
  if (!slice.size) return tr.deleteRange(from, to);
  var $from = tr.doc.resolve(from),
      $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice)) return tr.step(new ReplaceStep(from, to, slice));
  var targetDepths = coveredDepths($from, tr.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop();
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);

  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating) break;
    if (targetDepths.indexOf(d) > -1) preferredTarget = d;else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d);
  }

  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [],
      preferredDepth = slice.openStart;

  for (var content = slice.content, i = 0;; i++) {
    var node = content.firstChild;
    leftNodes.push(node);
    if (i == slice.openStart) break;
    content = node.content;
  }

  for (var _d3 = preferredDepth - 1; _d3 >= 0; _d3--) {
    var type = leftNodes[_d3].type,
        def = definesContent(type);
    if (def && $from.node(preferredTargetIndex).type != type) preferredDepth = _d3;else if (def || !type.isTextblock) break;
  }

  for (var j = slice.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) continue;

    for (var _i4 = 0; _i4 < targetDepths.length; _i4++) {
      var targetDepth = targetDepths[(_i4 + preferredTargetIndex) % targetDepths.length],
          expand = true;

      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }

      var parent = $from.node(targetDepth - 1),
          index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks)) return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirrorModel.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
    }
  }

  var startSteps = tr.steps.length;

  for (var _i5 = targetDepths.length - 1; _i5 >= 0; _i5--) {
    tr.replace(from, to, slice);
    if (tr.steps.length > startSteps) break;
    var depth = targetDepths[_i5];
    if (depth < 0) continue;
    from = $from.before(depth);
    to = $to.after(depth);
  }
}

function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }

  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(prosemirrorModel.Fragment.empty, true));
  }

  return fragment;
}

function _replaceRangeWith(tr, from, to, node) {
  if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {
    var point = insertPoint(tr.doc, from, node.type);
    if (point != null) from = to = point;
  }

  tr.replaceRange(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(node), 0, 0));
}

function _deleteRange(tr, from, to) {
  var $from = tr.doc.resolve(from),
      $to = tr.doc.resolve(to);
  var covered = coveredDepths($from, $to);

  for (var i = 0; i < covered.length; i++) {
    var depth = covered[i],
        last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) return tr["delete"]($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) return tr["delete"]($from.before(depth), $to.after(depth));
  }

  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) return tr["delete"]($from.before(d), to);
  }

  tr["delete"](from, to);
}

function coveredDepths($from, $to) {
  var result = [],
      minDepth = Math.min($from.depth, $to.depth);

  for (var d = minDepth; d >= 0; d--) {
    var start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) result.push(d);
  }

  return result;
}

exports.TransformError = function (_Error) {
  _inherits(_class, _Error);

  var _super5 = _createSuper(_class);

  function _class() {
    _classCallCheck(this, _class);

    return _super5.apply(this, arguments);
  }

  return _createClass(_class);
}(_wrapNativeSuper(Error));

exports.TransformError = function TransformError(message) {
  var err = Error.call(this, message);
  err.__proto__ = TransformError.prototype;
  return err;
};

exports.TransformError.prototype = Object.create(Error.prototype);
exports.TransformError.prototype.constructor = exports.TransformError;
exports.TransformError.prototype.name = "TransformError";

var Transform = function () {
  function Transform(doc) {
    _classCallCheck(this, Transform);

    this.doc = doc;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }

  _createClass(Transform, [{
    key: "before",
    get: function get() {
      return this.docs.length ? this.docs[0] : this.doc;
    }
  }, {
    key: "step",
    value: function step(_step) {
      var result = this.maybeStep(_step);
      if (result.failed) throw new exports.TransformError(result.failed);
      return this;
    }
  }, {
    key: "maybeStep",
    value: function maybeStep(step) {
      var result = step.apply(this.doc);
      if (!result.failed) this.addStep(step, result.doc);
      return result;
    }
  }, {
    key: "docChanged",
    get: function get() {
      return this.steps.length > 0;
    }
  }, {
    key: "addStep",
    value: function addStep(step, doc) {
      this.docs.push(this.doc);
      this.steps.push(step);
      this.mapping.appendMap(step.getMap());
      this.doc = doc;
    }
  }, {
    key: "replace",
    value: function replace(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
      var slice = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prosemirrorModel.Slice.empty;
      var step = replaceStep(this.doc, from, to, slice);
      if (step) this.step(step);
      return this;
    }
  }, {
    key: "replaceWith",
    value: function replaceWith(from, to, content) {
      return this.replace(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(content), 0, 0));
    }
  }, {
    key: "delete",
    value: function _delete(from, to) {
      return this.replace(from, to, prosemirrorModel.Slice.empty);
    }
  }, {
    key: "insert",
    value: function insert(pos, content) {
      return this.replaceWith(pos, pos, content);
    }
  }, {
    key: "replaceRange",
    value: function replaceRange(from, to, slice) {
      _replaceRange(this, from, to, slice);

      return this;
    }
  }, {
    key: "replaceRangeWith",
    value: function replaceRangeWith(from, to, node) {
      _replaceRangeWith(this, from, to, node);

      return this;
    }
  }, {
    key: "deleteRange",
    value: function deleteRange(from, to) {
      _deleteRange(this, from, to);

      return this;
    }
  }, {
    key: "lift",
    value: function lift(range, target) {
      _lift(this, range, target);

      return this;
    }
  }, {
    key: "join",
    value: function join(pos) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      _join(this, pos, depth);

      return this;
    }
  }, {
    key: "wrap",
    value: function wrap(range, wrappers) {
      _wrap2(this, range, wrappers);

      return this;
    }
  }, {
    key: "setBlockType",
    value: function setBlockType(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
      var type = arguments.length > 2 ? arguments[2] : undefined;
      var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      _setBlockType(this, from, to, type, attrs);

      return this;
    }
  }, {
    key: "setNodeMarkup",
    value: function setNodeMarkup(pos, type) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var marks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

      _setNodeMarkup(this, pos, type, attrs, marks);

      return this;
    }
  }, {
    key: "split",
    value: function split(pos) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var typesAfter = arguments.length > 2 ? arguments[2] : undefined;

      _split(this, pos, depth, typesAfter);

      return this;
    }
  }, {
    key: "addMark",
    value: function addMark(from, to, mark) {
      _addMark(this, from, to, mark);

      return this;
    }
  }, {
    key: "removeMark",
    value: function removeMark(from, to, mark) {
      _removeMark(this, from, to, mark);

      return this;
    }
  }, {
    key: "clearIncompatible",
    value: function clearIncompatible(pos, parentType, match) {
      _clearIncompatible(this, pos, parentType, match);

      return this;
    }
  }]);

  return Transform;
}();

exports.AddMarkStep = AddMarkStep;
exports.MapResult = MapResult;
exports.Mapping = Mapping;
exports.RemoveMarkStep = RemoveMarkStep;
exports.ReplaceAroundStep = ReplaceAroundStep;
exports.ReplaceStep = ReplaceStep;
exports.Step = Step;
exports.StepMap = StepMap;
exports.StepResult = StepResult;
exports.Transform = Transform;
exports.canJoin = canJoin;
exports.canSplit = canSplit;
exports.dropPoint = dropPoint;
exports.findWrapping = findWrapping;
exports.insertPoint = insertPoint;
exports.joinPoint = joinPoint;
exports.liftTarget = liftTarget;
exports.replaceStep = replaceStep;


/***/ }),

/***/ "./node_modules/prosemirror-view/dist/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var nav = typeof navigator != "undefined" ? navigator : null;
var doc = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];

var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);

var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var android = /Android \d/.test(agent);
var webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;

var domIndex = function domIndex(node) {
  for (var index = 0;; index++) {
    node = node.previousSibling;
    if (!node) return index;
  }
};

var parentNode = function parentNode(node) {
  var parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};

var reusedRange = null;

var textRange = function textRange(node, from, to) {
  var range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from || 0);
  return range;
};

var isEquivalentPosition = function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};

var atomElements = /^(img|br|input|textarea|hr)$/i;

function scanFor(node, off, targetNode, targetOff, dir) {
  for (;;) {
    if (node == targetNode && off == targetOff) return true;

    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      var parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false") return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false") return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}

function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}

function isOnEdge(node, offset, parent) {
  for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {
    if (node == parent) return true;
    var index = domIndex(node);
    node = node.parentNode;
    if (!node) return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}

function hasBlockDesc(dom) {
  var desc;

  for (var cur = dom; cur; cur = cur.parentNode) {
    if (desc = cur.pmViewDesc) break;
  }

  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}

var selectionCollapsed = function selectionCollapsed(domSel) {
  var collapsed = domSel.isCollapsed;
  if (collapsed && chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) collapsed = false;
  return collapsed;
};

function keyEvent(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}

function windowRect(doc) {
  return {
    left: 0,
    right: doc.documentElement.clientWidth,
    top: 0,
    bottom: doc.documentElement.clientHeight
  };
}

function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}

function clientRect(node) {
  var rect = node.getBoundingClientRect();
  var scaleX = rect.width / node.offsetWidth || 1;
  var scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}

function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0,
      scrollMargin = view.someProp("scrollMargin") || 5;
  var doc = view.dom.ownerDocument;

  for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {
    if (!parent) break;
    if (parent.nodeType != 1) continue;
    var elt = parent;
    var atTop = elt == doc.body;
    var bounding = atTop ? windowRect(doc) : clientRect(elt);
    var moveX = 0,
        moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top")) moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left")) moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) moveX = rect.right - bounding.right + getSide(scrollMargin, "right");

    if (moveX || moveY) {
      if (atTop) {
        doc.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = elt.scrollLeft,
            startY = elt.scrollTop;
        if (moveY) elt.scrollTop += moveY;
        if (moveX) elt.scrollLeft += moveX;
        var dX = elt.scrollLeft - startX,
            dY = elt.scrollTop - startY;
        rect = {
          left: rect.left - dX,
          top: rect.top - dY,
          right: rect.right - dX,
          bottom: rect.bottom - dY
        };
      }
    }

    if (atTop) break;
  }
}

function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(),
      startY = Math.max(0, rect.top);
  var refDOM, refTop;

  for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    var dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom)) continue;
    var localRect = dom.getBoundingClientRect();

    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }

  return {
    refDOM: refDOM,
    refTop: refTop,
    stack: scrollStack(view.dom)
  };
}

function scrollStack(dom) {
  var stack = [],
      doc = dom.ownerDocument;

  for (var cur = dom; cur; cur = parentNode(cur)) {
    stack.push({
      dom: cur,
      top: cur.scrollTop,
      left: cur.scrollLeft
    });
    if (dom == doc) break;
  }

  return stack;
}

function resetScrollPos(_ref) {
  var refDOM = _ref.refDOM,
      refTop = _ref.refTop,
      stack = _ref.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}

function restoreScrollStack(stack, dTop) {
  for (var i = 0; i < stack.length; i++) {
    var _stack$i = stack[i],
        dom = _stack$i.dom,
        top = _stack$i.top,
        left = _stack$i.left;
    if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left) dom.scrollLeft = left;
  }
}

var preventScrollSupported = null;

function focusPreventScroll(dom) {
  if (dom.setActive) return dom.setActive();
  if (preventScrollSupported) return dom.focus(preventScrollSupported);
  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = {
        preventScroll: true
      };
      return true;
    }

  } : undefined);

  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}

function findOffsetInNode(node, coords) {
  var closest,
      dxClosest = 2e8,
      coordsClosest,
      offset = 0;
  var rowBot = coords.top,
      rowTop = coords.top;

  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    var rects = void 0;
    if (child.nodeType == 1) rects = child.getClientRects();else if (child.nodeType == 3) rects = textRange(child).getClientRects();else continue;

    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];

      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;

        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      }

      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) offset = childIndex + 1;
    }
  }

  if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1) return {
    node: node,
    offset: offset
  };
  return findOffsetInNode(closest, coordsClosest);
}

function findOffsetInText(node, coords) {
  var len = node.nodeValue.length;
  var range = document.createRange();

  for (var i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    var rect = singleRect(range, 1);
    if (rect.top == rect.bottom) continue;
    if (inRect(coords, rect)) return {
      node: node,
      offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)
    };
  }

  return {
    node: node,
    offset: 0
  };
}

function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}

function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) return parent;
  return dom;
}

function posFromElement(view, elt, coords) {
  var _findOffsetInNode = findOffsetInNode(elt, coords),
      node = _findOffsetInNode.node,
      offset = _findOffsetInNode.offset,
      bias = -1;

  if (node.nodeType == 1 && !node.firstChild) {
    var rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }

  return view.docView.posFromDOM(node, offset, bias);
}

function posFromCaret(view, node, offset, coords) {
  var outside = -1;

  for (var cur = node;;) {
    if (cur == view.dom) break;
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) return null;

    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) outside = desc.posBefore;else if (rect.right < coords.left || rect.bottom < coords.top) outside = desc.posAfter;else break;
    }

    cur = desc.dom.parentNode;
  }

  return outside > -1 ? outside : view.docView.posFromDOM(node, offset, 1);
}

function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;

  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {
      var child = element.childNodes[i];

      if (child.nodeType == 1) {
        var rects = child.getClientRects();

        for (var j = 0; j < rects.length; j++) {
          var rect = rects[j];
          if (inRect(coords, rect)) return elementFromPoint(child, coords, rect);
        }
      }

      if ((i = (i + 1) % len) == startI) break;
    }
  }

  return element;
}

function _posAtCoords(view, coords) {
  var doc = view.dom.ownerDocument,
      node,
      offset = 0;

  if (doc.caretPositionFromPoint) {
    try {
      var _pos = doc.caretPositionFromPoint(coords.left, coords.top);

      if (_pos) {
        node = _pos.offsetNode;
        offset = _pos.offset;
      }
    } catch (_) {}
  }

  if (!node && doc.caretRangeFromPoint) {
    var range = doc.caretRangeFromPoint(coords.left, coords.top);

    if (range) {
      node = range.startContainer;
      offset = range.startOffset;
    }
  }

  var elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top + 1);
  var pos;

  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) return null;
  }

  if (safari) {
    for (var p = elt; node && p; p = parentNode(p)) {
      if (p.draggable) node = undefined;
    }
  }

  elt = targetKludge(elt, coords);

  if (node) {
    if (gecko && node.nodeType == 1) {
      offset = Math.min(offset, node.childNodes.length);

      if (offset < node.childNodes.length) {
        var next = node.childNodes[offset],
            _box;

        if (next.nodeName == "IMG" && (_box = next.getBoundingClientRect()).right <= coords.left && _box.bottom > coords.top) offset++;
      }
    }

    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) pos = view.state.doc.content.size;else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR") pos = posFromCaret(view, node, offset, coords);
  }

  if (pos == null) pos = posFromElement(view, elt, coords);
  var desc = view.docView.nearestDesc(elt, true);
  return {
    pos: pos,
    inside: desc ? desc.posAtStart - desc.border : -1
  };
}

function singleRect(target, bias) {
  var rects = target.getClientRects();
  return !rects.length ? target.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}

var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;

function _coordsAtPos(view, pos, side) {
  var _view$docView$domFrom = view.docView.domFromPos(pos, side < 0 ? -1 : 1),
      node = _view$docView$domFrom.node,
      offset = _view$docView$domFrom.offset;

  var supportEmptyRange = webkit || gecko;

  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
      var rect = singleRect(textRange(node, offset, offset), side);

      if (gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
        var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);

        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
          if (rectAfter.top != rect.top) return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }

      return rect;
    } else {
      var from = offset,
          to = offset,
          takeSide = side < 0 ? 1 : -1;

      if (side < 0 && !offset) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset == node.nodeValue.length) {
        from--;
        takeSide = 1;
      } else if (side < 0) {
        from--;
      } else {
        to++;
      }

      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);
    }
  }

  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset && (side < 0 || offset == nodeSize(node))) {
      var before = node.childNodes[offset - 1];
      if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false);
    }

    if (offset < nodeSize(node)) {
      var after = node.childNodes[offset];
      if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true);
    }

    return flattenH(node.getBoundingClientRect(), side >= 0);
  }

  if (offset && (side < 0 || offset == nodeSize(node))) {
    var _before = node.childNodes[offset - 1];
    var target = _before.nodeType == 3 ? textRange(_before, nodeSize(_before) - (supportEmptyRange ? 0 : 1)) : _before.nodeType == 1 && (_before.nodeName != "BR" || !_before.nextSibling) ? _before : null;
    if (target) return flattenV(singleRect(target, 1), false);
  }

  if (offset < nodeSize(node)) {
    var _after = node.childNodes[offset];

    while (_after.pmViewDesc && _after.pmViewDesc.ignoreForCoords) {
      _after = _after.nextSibling;
    }

    var _target = !_after ? null : _after.nodeType == 3 ? textRange(_after, 0, supportEmptyRange ? 0 : 1) : _after.nodeType == 1 ? _after : null;

    if (_target) return flattenV(singleRect(_target, -1), true);
  }

  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}

function flattenV(rect, left) {
  if (rect.width == 0) return rect;
  var x = left ? rect.left : rect.right;
  return {
    top: rect.top,
    bottom: rect.bottom,
    left: x,
    right: x
  };
}

function flattenH(rect, top) {
  if (rect.height == 0) return rect;
  var y = top ? rect.top : rect.bottom;
  return {
    top: y,
    bottom: y,
    left: rect.left,
    right: rect.right
  };
}

function withFlushedState(view, state, f) {
  var viewState = view.state,
      active = view.root.activeElement;
  if (viewState != state) view.updateState(state);
  if (active != view.dom) view.focus();

  try {
    return f();
  } finally {
    if (viewState != state) view.updateState(viewState);
    if (active != view.dom && active) active.focus();
  }
}

function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function () {
    var _view$docView$domFrom2 = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1),
        dom = _view$docView$domFrom2.node;

    for (;;) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) break;

      if (nearest.node.isBlock) {
        dom = nearest.dom;
        break;
      }

      dom = nearest.dom.parentNode;
    }

    var coords = _coordsAtPos(view, $pos.pos, 1);

    for (var child = dom.firstChild; child; child = child.nextSibling) {
      var boxes = void 0;
      if (child.nodeType == 1) boxes = child.getClientRects();else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();else continue;

      for (var i = 0; i < boxes.length; i++) {
        var box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) return false;
      }
    }

    return true;
  });
}

var maybeRTL = /[\u0590-\u08ac]/;

function endOfTextblockHorizontal(view, state, dir) {
  var $head = state.selection.$head;
  if (!$head.parent.isTextblock) return false;
  var offset = $head.parentOffset,
      atStart = !offset,
      atEnd = offset == $head.parent.content.size;
  var sel = view.domSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify) return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, function () {
    var oldRange = sel.getRangeAt(0),
        oldNode = sel.focusNode,
        oldOff = sel.focusOffset;
    var oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}

var cachedState = null;
var cachedDir = null;
var cachedResult = false;

function _endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}

var NOT_DIRTY = 0,
    CHILD_DIRTY = 1,
    CONTENT_DIRTY = 2,
    NODE_DIRTY = 3;

var ViewDesc = function () {
  function ViewDesc(parent, children, dom, contentDOM) {
    _classCallCheck(this, ViewDesc);

    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }

  _createClass(ViewDesc, [{
    key: "matchesWidget",
    value: function matchesWidget(widget) {
      return false;
    }
  }, {
    key: "matchesMark",
    value: function matchesMark(mark) {
      return false;
    }
  }, {
    key: "matchesNode",
    value: function matchesNode(node, outerDeco, innerDeco) {
      return false;
    }
  }, {
    key: "matchesHack",
    value: function matchesHack(nodeName) {
      return false;
    }
  }, {
    key: "parseRule",
    value: function parseRule() {
      return null;
    }
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      return false;
    }
  }, {
    key: "size",
    get: function get() {
      var size = 0;

      for (var i = 0; i < this.children.length; i++) {
        size += this.children[i].size;
      }

      return size;
    }
  }, {
    key: "border",
    get: function get() {
      return 0;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.parent = undefined;
      if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = undefined;

      for (var i = 0; i < this.children.length; i++) {
        this.children[i].destroy();
      }
    }
  }, {
    key: "posBeforeChild",
    value: function posBeforeChild(child) {
      for (var i = 0, pos = this.posAtStart;; i++) {
        var cur = this.children[i];
        if (cur == child) return pos;
        pos += cur.size;
      }
    }
  }, {
    key: "posBefore",
    get: function get() {
      return this.parent.posBeforeChild(this);
    }
  }, {
    key: "posAtStart",
    get: function get() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
  }, {
    key: "posAfter",
    get: function get() {
      return this.posBefore + this.size;
    }
  }, {
    key: "posAtEnd",
    get: function get() {
      return this.posAtStart + this.size - 2 * this.border;
    }
  }, {
    key: "localPosFromDOM",
    value: function localPosFromDOM(dom, offset, bias) {
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          var domBefore, desc;

          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset - 1];
          } else {
            while (dom.parentNode != this.contentDOM) {
              dom = dom.parentNode;
            }

            domBefore = dom.previousSibling;
          }

          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
            domBefore = domBefore.previousSibling;
          }

          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          var domAfter, _desc;

          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset];
          } else {
            while (dom.parentNode != this.contentDOM) {
              dom = dom.parentNode;
            }

            domAfter = dom.nextSibling;
          }

          while (domAfter && !((_desc = domAfter.pmViewDesc) && _desc.parent == this)) {
            domAfter = domAfter.nextSibling;
          }

          return domAfter ? this.posBeforeChild(_desc) : this.posAtEnd;
        }
      }

      var atEnd;

      if (dom == this.dom && this.contentDOM) {
        atEnd = offset > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset == 0) for (var search = dom;; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }

          if (search.previousSibling) break;
        }
        if (atEnd == null && offset == dom.childNodes.length) for (var _search = dom;; _search = _search.parentNode) {
          if (_search == this.dom) {
            atEnd = true;
            break;
          }

          if (_search.nextSibling) break;
        }
      }

      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    }
  }, {
    key: "nearestDesc",
    value: function nearestDesc(dom) {
      var onlyNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      for (var first = true, cur = dom; cur; cur = cur.parentNode) {
        var desc = this.getDesc(cur),
            nodeDOM = void 0;

        if (desc && (!onlyNodes || desc.node)) {
          if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom)) first = false;else return desc;
        }
      }
    }
  }, {
    key: "getDesc",
    value: function getDesc(dom) {
      var desc = dom.pmViewDesc;

      for (var cur = desc; cur; cur = cur.parent) {
        if (cur == this) return desc;
      }
    }
  }, {
    key: "posFromDOM",
    value: function posFromDOM(dom, offset, bias) {
      for (var scan = dom; scan; scan = scan.parentNode) {
        var desc = this.getDesc(scan);
        if (desc) return desc.localPosFromDOM(dom, offset, bias);
      }

      return -1;
    }
  }, {
    key: "descAt",
    value: function descAt(pos) {
      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i],
            end = offset + child.size;

        if (offset == pos && end != offset) {
          while (!child.border && child.children.length) {
            child = child.children[0];
          }

          return child;
        }

        if (pos < end) return child.descAt(pos - offset - child.border);
        offset = end;
      }
    }
  }, {
    key: "domFromPos",
    value: function domFromPos(pos, side) {
      if (!this.contentDOM) return {
        node: this.dom,
        offset: 0
      };
      var i = 0,
          offset = 0;

      for (var curPos = 0; i < this.children.length; i++) {
        var child = this.children[i],
            end = curPos + child.size;

        if (end > pos || child instanceof TrailingHackViewDesc) {
          offset = pos - curPos;
          break;
        }

        curPos = end;
      }

      if (offset) return this.children[i].domFromPos(offset - this.children[i].border, side);

      for (var prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {}

      if (side <= 0) {
        var _prev,
            enter = true;

        for (;; i--, enter = false) {
          _prev = i ? this.children[i - 1] : null;
          if (!_prev || _prev.dom.parentNode == this.contentDOM) break;
        }

        if (_prev && side && enter && !_prev.border && !_prev.domAtom) return _prev.domFromPos(_prev.size, side);
        return {
          node: this.contentDOM,
          offset: _prev ? domIndex(_prev.dom) + 1 : 0
        };
      } else {
        var next,
            _enter = true;

        for (;; i++, _enter = false) {
          next = i < this.children.length ? this.children[i] : null;
          if (!next || next.dom.parentNode == this.contentDOM) break;
        }

        if (next && _enter && !next.border && !next.domAtom) return next.domFromPos(0, side);
        return {
          node: this.contentDOM,
          offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length
        };
      }
    }
  }, {
    key: "parseRange",
    value: function parseRange(from, to) {
      var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (this.children.length == 0) return {
        node: this.contentDOM,
        from: from,
        to: to,
        fromOffset: 0,
        toOffset: this.contentDOM.childNodes.length
      };
      var fromOffset = -1,
          toOffset = -1;

      for (var offset = base, i = 0;; i++) {
        var child = this.children[i],
            end = offset + child.size;

        if (fromOffset == -1 && from <= end) {
          var childBase = offset + child.border;
          if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) return child.parseRange(from, to, childBase);
          from = offset;

          for (var j = i; j > 0; j--) {
            var prev = this.children[j - 1];

            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }

            from -= prev.size;
          }

          if (fromOffset == -1) fromOffset = 0;
        }

        if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
          to = end;

          for (var _j = i + 1; _j < this.children.length; _j++) {
            var next = this.children[_j];

            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break;
            }

            to += next.size;
          }

          if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;
          break;
        }

        offset = end;
      }

      return {
        node: this.contentDOM,
        from: from,
        to: to,
        fromOffset: fromOffset,
        toOffset: toOffset
      };
    }
  }, {
    key: "emptyChildAt",
    value: function emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length) return false;
      var child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side);
    }
  }, {
    key: "domAfterPos",
    value: function domAfterPos(pos) {
      var _this$domFromPos = this.domFromPos(pos, 0),
          node = _this$domFromPos.node,
          offset = _this$domFromPos.offset;

      if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError("No node after pos " + pos);
      return node.childNodes[offset];
    }
  }, {
    key: "setSelection",
    value: function setSelection(anchor, head, root) {
      var force = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var from = Math.min(anchor, head),
          to = Math.max(anchor, head);

      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i],
            end = offset + child.size;
        if (from > offset && to < end) return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);
        offset = end;
      }

      var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
      var domSel = root.getSelection();
      var brKludge = false;

      if ((gecko || safari) && anchor == head) {
        var _anchorDOM = anchorDOM,
            node = _anchorDOM.node,
            _offset = _anchorDOM.offset;

        if (node.nodeType == 3) {
          brKludge = !!(_offset && node.nodeValue[_offset - 1] == "\n");

          if (brKludge && _offset == node.nodeValue.length) {
            for (var scan = node, after; scan; scan = scan.parentNode) {
              if (after = scan.nextSibling) {
                if (after.nodeName == "BR") anchorDOM = headDOM = {
                  node: after.parentNode,
                  offset: domIndex(after) + 1
                };
                break;
              }

              var desc = scan.pmViewDesc;
              if (desc && desc.node && desc.node.isBlock) break;
            }
          }
        } else {
          var prev = node.childNodes[_offset - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }

      if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
        var _after2 = domSel.focusNode.childNodes[domSel.focusOffset];
        if (_after2 && _after2.contentEditable == "false") force = true;
      }

      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) return;
      var domSelExtended = false;

      if ((domSel.extend || anchor == head) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);

        try {
          if (anchor != head) domSel.extend(headDOM.node, headDOM.offset);
          domSelExtended = true;
        } catch (err) {
          if (!(err instanceof DOMException)) throw err;
        }
      }

      if (!domSelExtended) {
        if (anchor > head) {
          var tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }

        var range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    }
  }, {
    key: "contentLost",
    get: function get() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    }
  }, {
    key: "markDirty",
    value: function markDirty(from, to) {
      for (var offset = 0, i = 0; i < this.children.length; i++) {
        var child = this.children[i],
            end = offset + child.size;

        if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
          var startInside = offset + child.border,
              endInside = end - child.border;

          if (from >= startInside && to <= endInside) {
            this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY;else child.markDirty(from - startInside, to - startInside);
            return;
          } else {
            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
          }
        }

        offset = end;
      }

      this.dirty = CONTENT_DIRTY;
    }
  }, {
    key: "markParentsDirty",
    value: function markParentsDirty() {
      var level = 1;

      for (var node = this.parent; node; node = node.parent, level++) {
        var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node.dirty < dirty) node.dirty = dirty;
      }
    }
  }, {
    key: "domAtom",
    get: function get() {
      return false;
    }
  }, {
    key: "ignoreForCoords",
    get: function get() {
      return false;
    }
  }]);

  return ViewDesc;
}();

var WidgetViewDesc = function (_ViewDesc) {
  _inherits(WidgetViewDesc, _ViewDesc);

  var _super = _createSuper(WidgetViewDesc);

  function WidgetViewDesc(parent, widget, view, pos) {
    var _this;

    _classCallCheck(this, WidgetViewDesc);

    var self,
        dom = widget.type.toDOM;
    if (typeof dom == "function") dom = dom(view, function () {
      if (!self) return pos;
      if (self.parent) return self.parent.posBeforeChild(self);
    });

    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }

      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }

    _this = _super.call(this, parent, [], dom, null);
    _this.widget = widget;
    _this.widget = widget;
    self = _assertThisInitialized(_this);
    return _this;
  }

  _createClass(WidgetViewDesc, [{
    key: "matchesWidget",
    value: function matchesWidget(widget) {
      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
    }
  }, {
    key: "parseRule",
    value: function parseRule() {
      return {
        ignore: true
      };
    }
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      var stop = this.widget.spec.stopEvent;
      return stop ? stop(event) : false;
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return mutation.type != "selection" || this.widget.spec.ignoreSelection;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.widget.type.destroy(this.dom);

      _get(_getPrototypeOf(WidgetViewDesc.prototype), "destroy", this).call(this);
    }
  }, {
    key: "domAtom",
    get: function get() {
      return true;
    }
  }, {
    key: "side",
    get: function get() {
      return this.widget.type.side;
    }
  }]);

  return WidgetViewDesc;
}(ViewDesc);

var CompositionViewDesc = function (_ViewDesc2) {
  _inherits(CompositionViewDesc, _ViewDesc2);

  var _super2 = _createSuper(CompositionViewDesc);

  function CompositionViewDesc(parent, dom, textDOM, text) {
    var _this2;

    _classCallCheck(this, CompositionViewDesc);

    _this2 = _super2.call(this, parent, [], dom, null);
    _this2.textDOM = textDOM;
    _this2.text = text;
    return _this2;
  }

  _createClass(CompositionViewDesc, [{
    key: "size",
    get: function get() {
      return this.text.length;
    }
  }, {
    key: "localPosFromDOM",
    value: function localPosFromDOM(dom, offset) {
      if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0);
      return this.posAtStart + offset;
    }
  }, {
    key: "domFromPos",
    value: function domFromPos(pos) {
      return {
        node: this.textDOM,
        offset: pos
      };
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mut) {
      return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue;
    }
  }]);

  return CompositionViewDesc;
}(ViewDesc);

var MarkViewDesc = function (_ViewDesc3) {
  _inherits(MarkViewDesc, _ViewDesc3);

  var _super3 = _createSuper(MarkViewDesc);

  function MarkViewDesc(parent, mark, dom, contentDOM) {
    var _this3;

    _classCallCheck(this, MarkViewDesc);

    _this3 = _super3.call(this, parent, [], dom, contentDOM);
    _this3.mark = mark;
    return _this3;
  }

  _createClass(MarkViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) return null;
      return {
        mark: this.mark.type.name,
        attrs: this.mark.attrs,
        contentElement: this.contentDOM || undefined
      };
    }
  }, {
    key: "matchesMark",
    value: function matchesMark(mark) {
      return this.dirty != NODE_DIRTY && this.mark.eq(mark);
    }
  }, {
    key: "markDirty",
    value: function markDirty(from, to) {
      _get(_getPrototypeOf(MarkViewDesc.prototype), "markDirty", this).call(this, from, to);

      if (this.dirty != NOT_DIRTY) {
        var parent = this.parent;

        while (!parent.node) {
          parent = parent.parent;
        }

        if (parent.dirty < this.dirty) parent.dirty = this.dirty;
        this.dirty = NOT_DIRTY;
      }
    }
  }, {
    key: "slice",
    value: function slice(from, to, view) {
      var copy = MarkViewDesc.create(this.parent, this.mark, true, view);
      var nodes = this.children,
          size = this.size;
      if (to < size) nodes = replaceNodes(nodes, to, size, view);
      if (from > 0) nodes = replaceNodes(nodes, 0, from, view);

      for (var i = 0; i < nodes.length; i++) {
        nodes[i].parent = copy;
      }

      copy.children = nodes;
      return copy;
    }
  }], [{
    key: "create",
    value: function create(parent, mark, inline, view) {
      var custom = view.nodeViews[mark.type.name];
      var spec = custom && custom(mark, view, inline);
      if (!spec || !spec.dom) spec = prosemirrorModel.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
      return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
    }
  }]);

  return MarkViewDesc;
}(ViewDesc);

var NodeViewDesc = function (_ViewDesc4) {
  _inherits(NodeViewDesc, _ViewDesc4);

  var _super4 = _createSuper(NodeViewDesc);

  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    var _this4;

    _classCallCheck(this, NodeViewDesc);

    _this4 = _super4.call(this, parent, [], dom, contentDOM);
    _this4.node = node;
    _this4.outerDeco = outerDeco;
    _this4.innerDeco = innerDeco;
    _this4.nodeDOM = nodeDOM;
    if (contentDOM) _this4.updateChildren(view, pos);
    return _this4;
  }

  _createClass(NodeViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      var _this5 = this;

      if (this.node.type.spec.reparseInView) return null;
      var rule = {
        node: this.node.type.name,
        attrs: this.node.attrs
      };
      if (this.node.type.whitespace == "pre") rule.preserveWhitespace = "full";

      if (!this.contentDOM) {
        rule.getContent = function () {
          return _this5.node.content;
        };
      } else if (!this.contentLost) {
        rule.contentElement = this.contentDOM;
      } else {
        for (var i = this.children.length - 1; i >= 0; i--) {
          var child = this.children[i];

          if (this.dom.contains(child.dom.parentNode)) {
            rule.contentElement = child.dom.parentNode;
            break;
          }
        }

        if (!rule.contentElement) rule.getContent = function () {
          return prosemirrorModel.Fragment.empty;
        };
      }

      return rule;
    }
  }, {
    key: "matchesNode",
    value: function matchesNode(node, outerDeco, innerDeco) {
      return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
    }
  }, {
    key: "size",
    get: function get() {
      return this.node.nodeSize;
    }
  }, {
    key: "border",
    get: function get() {
      return this.node.isLeaf ? 0 : 1;
    }
  }, {
    key: "updateChildren",
    value: function updateChildren(view, pos) {
      var _this6 = this;

      var inline = this.node.inlineContent,
          off = pos;
      var composition = view.composing ? this.localCompositionInfo(view, pos) : null;
      var localComposition = composition && composition.pos > -1 ? composition : null;
      var compositionInChild = composition && composition.pos < 0;
      var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
      iterDeco(this.node, this.innerDeco, function (widget, i, insideNode) {
        if (widget.spec.marks) updater.syncToMarks(widget.spec.marks, inline, view);else if (widget.type.side >= 0 && !insideNode) updater.syncToMarks(i == _this6.node.childCount ? prosemirrorModel.Mark.none : _this6.node.child(i).marks, inline, view);
        updater.placeWidget(widget, view, off);
      }, function (child, outerDeco, innerDeco, i) {
        updater.syncToMarks(child.marks, inline, view);
        var compIndex;
        if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i)) ;else {
          updater.addNode(child, outerDeco, innerDeco, view, off);
        }
        off += child.nodeSize;
      });
      updater.syncToMarks([], inline, view);
      if (this.node.isTextblock) updater.addTextblockHacks();
      updater.destroyRest();

      if (updater.changed || this.dirty == CONTENT_DIRTY) {
        if (localComposition) this.protectLocalComposition(view, localComposition);
        renderDescs(this.contentDOM, this.children, view);
        if (ios) iosHacks(this.dom);
      }
    }
  }, {
    key: "localCompositionInfo",
    value: function localCompositionInfo(view, pos) {
      var _view$state$selection = view.state.selection,
          from = _view$state$selection.from,
          to = _view$state$selection.to;
      if (!(view.state.selection instanceof prosemirrorState.TextSelection) || from < pos || to > pos + this.node.content.size) return null;
      var sel = view.domSelection();
      var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
      if (!textNode || !this.dom.contains(textNode.parentNode)) return null;

      if (this.node.inlineContent) {
        var text = textNode.nodeValue;
        var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
        return textPos < 0 ? null : {
          node: textNode,
          pos: textPos,
          text: text
        };
      } else {
        return {
          node: textNode,
          pos: -1,
          text: ""
        };
      }
    }
  }, {
    key: "protectLocalComposition",
    value: function protectLocalComposition(view, _ref2) {
      var node = _ref2.node,
          pos = _ref2.pos,
          text = _ref2.text;
      if (this.getDesc(node)) return;
      var topNode = node;

      for (;; topNode = topNode.parentNode) {
        if (topNode.parentNode == this.contentDOM) break;

        while (topNode.previousSibling) {
          topNode.parentNode.removeChild(topNode.previousSibling);
        }

        while (topNode.nextSibling) {
          topNode.parentNode.removeChild(topNode.nextSibling);
        }

        if (topNode.pmViewDesc) topNode.pmViewDesc = undefined;
      }

      var desc = new CompositionViewDesc(this, topNode, node, text);
      view.input.compositionNodes.push(desc);
      this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
    }
  }, {
    key: "update",
    value: function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) return false;
      this.updateInner(node, outerDeco, innerDeco, view);
      return true;
    }
  }, {
    key: "updateInner",
    value: function updateInner(node, outerDeco, innerDeco, view) {
      this.updateOuterDeco(outerDeco);
      this.node = node;
      this.innerDeco = innerDeco;
      if (this.contentDOM) this.updateChildren(view, this.posAtStart);
      this.dirty = NOT_DIRTY;
    }
  }, {
    key: "updateOuterDeco",
    value: function updateOuterDeco(outerDeco) {
      if (sameOuterDeco(outerDeco, this.outerDeco)) return;
      var needsWrap = this.nodeDOM.nodeType != 1;
      var oldDOM = this.dom;
      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));

      if (this.dom != oldDOM) {
        oldDOM.pmViewDesc = undefined;
        this.dom.pmViewDesc = this;
      }

      this.outerDeco = outerDeco;
    }
  }, {
    key: "selectNode",
    value: function selectNode() {
      if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true;
    }
  }, {
    key: "deselectNode",
    value: function deselectNode() {
      if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable) this.dom.removeAttribute("draggable");
    }
  }, {
    key: "domAtom",
    get: function get() {
      return this.node.isAtom;
    }
  }], [{
    key: "create",
    value: function create(parent, node, outerDeco, innerDeco, view, pos) {
      var custom = view.nodeViews[node.type.name],
          descObj;
      var spec = custom && custom(node, view, function () {
        if (!descObj) return pos;
        if (descObj.parent) return descObj.parent.posBeforeChild(descObj);
      }, outerDeco, innerDeco);
      var dom = spec && spec.dom,
          contentDOM = spec && spec.contentDOM;

      if (node.isText) {
        if (!dom) dom = document.createTextNode(node.text);else if (dom.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node");
      } else if (!dom) {
        var _prosemirrorModel$DOM = prosemirrorModel.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node));

        dom = _prosemirrorModel$DOM.dom;
        contentDOM = _prosemirrorModel$DOM.contentDOM;
      }

      if (!contentDOM && !node.isText && dom.nodeName != "BR") {
        if (!dom.hasAttribute("contenteditable")) dom.contentEditable = "false";
        if (node.type.spec.draggable) dom.draggable = true;
      }

      var nodeDOM = dom;
      dom = applyOuterDeco(dom, outerDeco, node);
      if (spec) return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);else if (node.isText) return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);else return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
    }
  }]);

  return NodeViewDesc;
}(ViewDesc);

function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc);
  return new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);
}

var TextViewDesc = function (_NodeViewDesc) {
  _inherits(TextViewDesc, _NodeViewDesc);

  var _super5 = _createSuper(TextViewDesc);

  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    _classCallCheck(this, TextViewDesc);

    return _super5.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }

  _createClass(TextViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      var skip = this.nodeDOM.parentNode;

      while (skip && skip != this.dom && !skip.pmIsDeco) {
        skip = skip.parentNode;
      }

      return {
        skip: skip || true
      };
    }
  }, {
    key: "update",
    value: function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) return false;
      this.updateOuterDeco(outerDeco);

      if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
        this.nodeDOM.nodeValue = node.text;
        if (view.trackWrites == this.nodeDOM) view.trackWrites = null;
      }

      this.node = node;
      this.dirty = NOT_DIRTY;
      return true;
    }
  }, {
    key: "inParent",
    value: function inParent() {
      var parentDOM = this.parent.contentDOM;

      for (var n = this.nodeDOM; n; n = n.parentNode) {
        if (n == parentDOM) return true;
      }

      return false;
    }
  }, {
    key: "domFromPos",
    value: function domFromPos(pos) {
      return {
        node: this.nodeDOM,
        offset: pos
      };
    }
  }, {
    key: "localPosFromDOM",
    value: function localPosFromDOM(dom, offset, bias) {
      if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length);
      return _get(_getPrototypeOf(TextViewDesc.prototype), "localPosFromDOM", this).call(this, dom, offset, bias);
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return mutation.type != "characterData" && mutation.type != "selection";
    }
  }, {
    key: "slice",
    value: function slice(from, to, view) {
      var node = this.node.cut(from, to),
          dom = document.createTextNode(node.text);
      return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
    }
  }, {
    key: "markDirty",
    value: function markDirty(from, to) {
      _get(_getPrototypeOf(TextViewDesc.prototype), "markDirty", this).call(this, from, to);

      if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length)) this.dirty = NODE_DIRTY;
    }
  }, {
    key: "domAtom",
    get: function get() {
      return false;
    }
  }]);

  return TextViewDesc;
}(NodeViewDesc);

var TrailingHackViewDesc = function (_ViewDesc5) {
  _inherits(TrailingHackViewDesc, _ViewDesc5);

  var _super6 = _createSuper(TrailingHackViewDesc);

  function TrailingHackViewDesc() {
    _classCallCheck(this, TrailingHackViewDesc);

    return _super6.apply(this, arguments);
  }

  _createClass(TrailingHackViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      return {
        ignore: true
      };
    }
  }, {
    key: "matchesHack",
    value: function matchesHack(nodeName) {
      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
    }
  }, {
    key: "domAtom",
    get: function get() {
      return true;
    }
  }, {
    key: "ignoreForCoords",
    get: function get() {
      return this.dom.nodeName == "IMG";
    }
  }]);

  return TrailingHackViewDesc;
}(ViewDesc);

var CustomNodeViewDesc = function (_NodeViewDesc2) {
  _inherits(CustomNodeViewDesc, _NodeViewDesc2);

  var _super7 = _createSuper(CustomNodeViewDesc);

  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    var _this7;

    _classCallCheck(this, CustomNodeViewDesc);

    _this7 = _super7.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    _this7.spec = spec;
    return _this7;
  }

  _createClass(CustomNodeViewDesc, [{
    key: "update",
    value: function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY) return false;

      if (this.spec.update) {
        var result = this.spec.update(node, outerDeco, innerDeco);
        if (result) this.updateInner(node, outerDeco, innerDeco, view);
        return result;
      } else if (!this.contentDOM && !node.isLeaf) {
        return false;
      } else {
        return _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "update", this).call(this, node, outerDeco, innerDeco, view);
      }
    }
  }, {
    key: "selectNode",
    value: function selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "selectNode", this).call(this);
    }
  }, {
    key: "deselectNode",
    value: function deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "deselectNode", this).call(this);
    }
  }, {
    key: "setSelection",
    value: function setSelection(anchor, head, root, force) {
      this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "setSelection", this).call(this, anchor, head, root, force);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.spec.destroy) this.spec.destroy();

      _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "destroy", this).call(this);
    }
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "ignoreMutation", this).call(this, mutation);
    }
  }]);

  return CustomNodeViewDesc;
}(NodeViewDesc);

function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild,
      written = false;

  for (var i = 0; i < descs.length; i++) {
    var desc = descs[i],
        childDOM = desc.dom;

    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }

      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }

    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }

  while (dom) {
    dom = rm(dom);
    written = true;
  }

  if (written && view.trackWrites == parentDOM) view.trackWrites = null;
}

var OuterDecoLevel = function OuterDecoLevel(nodeName) {
  if (nodeName) this.nodeName = nodeName;
};

OuterDecoLevel.prototype = Object.create(null);
var noDeco = [new OuterDecoLevel()];

function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0) return noDeco;
  var top = needsWrap ? noDeco[0] : new OuterDecoLevel(),
      result = [top];

  for (var i = 0; i < outerDeco.length; i++) {
    var attrs = outerDeco[i].type.attrs;
    if (!attrs) continue;
    if (attrs.nodeName) result.push(top = new OuterDecoLevel(attrs.nodeName));

    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) continue;
      if (needsWrap && result.length == 1) result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class") top["class"] = (top["class"] ? top["class"] + " " : "") + val;else if (name == "style") top.style = (top.style ? top.style + ";" : "") + val;else if (name != "nodeName") top[name] = val;
    }
  }

  return result;
}

function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM;
  var curDOM = nodeDOM;

  for (var i = 0; i < curComputed.length; i++) {
    var deco = curComputed[i],
        prev = prevComputed[i];

    if (i) {
      var parent = void 0;

      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }

    patchAttributes(curDOM, prev || noDeco[0], deco);
  }

  return curDOM;
}

function patchAttributes(dom, prev, cur) {
  for (var name in prev) {
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) dom.removeAttribute(name);
  }

  for (var _name in cur) {
    if (_name != "class" && _name != "style" && _name != "nodeName" && cur[_name] != prev[_name]) dom.setAttribute(_name, cur[_name]);
  }

  if (prev["class"] != cur["class"]) {
    var prevList = prev["class"] ? prev["class"].split(" ").filter(Boolean) : [];
    var curList = cur["class"] ? cur["class"].split(" ").filter(Boolean) : [];

    for (var i = 0; i < prevList.length; i++) {
      if (curList.indexOf(prevList[i]) == -1) dom.classList.remove(prevList[i]);
    }

    for (var _i = 0; _i < curList.length; _i++) {
      if (prevList.indexOf(curList[_i]) == -1) dom.classList.add(curList[_i]);
    }

    if (dom.classList.length == 0) dom.removeAttribute("class");
  }

  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
          m;

      while (m = prop.exec(prev.style)) {
        dom.style.removeProperty(m[1]);
      }
    }

    if (cur.style) dom.style.cssText += cur.style;
  }
}

function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}

function sameOuterDeco(a, b) {
  if (a.length != b.length) return false;

  for (var i = 0; i < a.length; i++) {
    if (!a[i].type.eq(b[i].type)) return false;
  }

  return true;
}

function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}

var ViewTreeUpdater = function () {
  function ViewTreeUpdater(top, lock) {
    _classCallCheck(this, ViewTreeUpdater);

    this.lock = lock;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }

  _createClass(ViewTreeUpdater, [{
    key: "destroyBetween",
    value: function destroyBetween(start, end) {
      if (start == end) return;

      for (var i = start; i < end; i++) {
        this.top.children[i].destroy();
      }

      this.top.children.splice(start, end - start);
      this.changed = true;
    }
  }, {
    key: "destroyRest",
    value: function destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    }
  }, {
    key: "syncToMarks",
    value: function syncToMarks(marks, inline, view) {
      var keep = 0,
          depth = this.stack.length >> 1;
      var maxKeep = Math.min(depth, marks.length);

      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false) {
        keep++;
      }

      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }

      while (depth < marks.length) {
        this.stack.push(this.top, this.index + 1);
        var found = -1;

        for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
          if (this.top.children[i].matchesMark(marks[depth])) {
            found = i;
            break;
          }
        }

        if (found > -1) {
          if (found > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found);
          }

          this.top = this.top.children[this.index];
        } else {
          var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }

        this.index = 0;
        depth++;
      }
    }
  }, {
    key: "findNodeMatch",
    value: function findNodeMatch(node, outerDeco, innerDeco, index) {
      var found = -1,
          targetDesc;

      if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
        found = this.top.children.indexOf(targetDesc, this.index);
      } else {
        for (var i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
          var child = this.top.children[i];

          if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
            found = i;
            break;
          }
        }
      }

      if (found < 0) return false;
      this.destroyBetween(this.index, found);
      this.index++;
      return true;
    }
  }, {
    key: "updateNodeAt",
    value: function updateNodeAt(node, outerDeco, innerDeco, index, view) {
      var child = this.top.children[index];
      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM) child.dirty = CONTENT_DIRTY;
      if (!child.update(node, outerDeco, innerDeco, view)) return false;
      this.destroyBetween(this.index, index);
      this.index = index + 1;
      return true;
    }
  }, {
    key: "findIndexWithChild",
    value: function findIndexWithChild(domNode) {
      for (;;) {
        var parent = domNode.parentNode;
        if (!parent) return -1;

        if (parent == this.top.contentDOM) {
          var desc = domNode.pmViewDesc;
          if (desc) for (var i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc) return i;
          }
          return -1;
        }

        domNode = parent;
      }
    }
  }, {
    key: "updateNextNode",
    value: function updateNextNode(node, outerDeco, innerDeco, view, index) {
      for (var i = this.index; i < this.top.children.length; i++) {
        var next = this.top.children[i];

        if (next instanceof NodeViewDesc) {
          var _preMatch = this.preMatch.matched.get(next);

          if (_preMatch != null && _preMatch != index) return false;
          var nextDOM = next.dom;
          var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));

          if (!locked && next.update(node, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i);
            if (next.dom != nextDOM) this.changed = true;
            this.index++;
            return true;
          }

          break;
        }
      }

      return false;
    }
  }, {
    key: "addNode",
    value: function addNode(node, outerDeco, innerDeco, view, pos) {
      this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));
      this.changed = true;
    }
  }, {
    key: "placeWidget",
    value: function placeWidget(widget, view, pos) {
      var next = this.index < this.top.children.length ? this.top.children[this.index] : null;

      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        var desc = new WidgetViewDesc(this.top, widget, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    }
  }, {
    key: "addTextblockHacks",
    value: function addTextblockHacks() {
      var lastChild = this.top.children[this.index - 1],
          parent = this.top;

      while (lastChild instanceof MarkViewDesc) {
        parent = lastChild;
        lastChild = parent.children[parent.children.length - 1];
      }

      if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text)) {
        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false") this.addHackNode("IMG", parent);
        this.addHackNode("BR", this.top);
      }
    }
  }, {
    key: "addHackNode",
    value: function addHackNode(nodeName, parent) {
      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
        this.index++;
      } else {
        var dom = document.createElement(nodeName);

        if (nodeName == "IMG") {
          dom.className = "ProseMirror-separator";
          dom.alt = "";
        }

        if (nodeName == "BR") dom.className = "ProseMirror-trailingBreak";
        var hack = new TrailingHackViewDesc(this.top, [], dom, null);
        if (parent != this.top) parent.children.push(hack);else parent.children.splice(this.index++, 0, hack);
        this.changed = true;
      }
    }
  }]);

  return ViewTreeUpdater;
}();

function preMatch(frag, parentDesc) {
  var curDesc = parentDesc,
      descI = curDesc.children.length;
  var fI = frag.childCount,
      matched = new Map(),
      matches = [];

  outer: while (fI > 0) {
    var desc = void 0;

    for (;;) {
      if (descI) {
        var next = curDesc.children[descI - 1];

        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }

    var node = desc.node;
    if (!node) continue;
    if (node != frag.child(fI - 1)) break;
    --fI;
    matched.set(desc, fI);
    matches.push(desc);
  }

  return {
    index: fI,
    matched: matched,
    matches: matches.reverse()
  };
}

function compareSide(a, b) {
  return a.type.side - b.type.side;
}

function iterDeco(parent, deco, onWidget, onNode) {
  var locals = deco.locals(parent),
      offset = 0;

  if (locals.length == 0) {
    for (var i = 0; i < parent.childCount; i++) {
      var child = parent.child(i);
      onNode(child, locals, deco.forChild(offset, child), i);
      offset += child.nodeSize;
    }

    return;
  }

  var decoIndex = 0,
      active = [],
      restNode = null;

  for (var parentIndex = 0;;) {
    if (decoIndex < locals.length && locals[decoIndex].to == offset) {
      var widget = locals[decoIndex++],
          widgets = void 0;

      while (decoIndex < locals.length && locals[decoIndex].to == offset) {
        (widgets || (widgets = [widget])).push(locals[decoIndex++]);
      }

      if (widgets) {
        widgets.sort(compareSide);

        for (var _i2 = 0; _i2 < widgets.length; _i2++) {
          onWidget(widgets[_i2], parentIndex, !!restNode);
        }
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }

    var _child = void 0,
        index = void 0;

    if (restNode) {
      index = -1;
      _child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      _child = parent.child(parentIndex++);
    } else {
      break;
    }

    for (var _i3 = 0; _i3 < active.length; _i3++) {
      if (active[_i3].to <= offset) active.splice(_i3--, 1);
    }

    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset) {
      active.push(locals[decoIndex++]);
    }

    var end = offset + _child.nodeSize;

    if (_child.isText) {
      var cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;

      for (var _i4 = 0; _i4 < active.length; _i4++) {
        if (active[_i4].to < cutAt) cutAt = active[_i4].to;
      }

      if (cutAt < end) {
        restNode = _child.cut(cutAt - offset);
        _child = _child.cut(0, cutAt - offset);
        end = cutAt;
        index = -1;
      }
    }

    var outerDeco = _child.isInline && !_child.isLeaf ? active.filter(function (d) {
      return !d.inline;
    }) : active.slice();
    onNode(_child, outerDeco, deco.forChild(offset, _child), index);
    offset = end;
  }
}

function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}

function nearbyTextNode(node, offset) {
  for (;;) {
    if (node.nodeType == 3) return node;

    if (node.nodeType == 1 && offset > 0) {
      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3) return node.childNodes[offset];
      node = node.childNodes[offset - 1];
      offset = nodeSize(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null;
    }
  }
}

function findTextInFragment(frag, text, from, to) {
  for (var i = 0, pos = 0; i < frag.childCount && pos <= to;) {
    var child = frag.child(i++),
        childStart = pos;
    pos += child.nodeSize;
    if (!child.isText) continue;
    var str = child.text;

    while (i < frag.childCount) {
      var next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText) break;
      str += next.text;
    }

    if (pos >= from) {
      var found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found >= 0 && found + text.length + childStart >= from) return childStart + found;
      if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text) return to;
    }
  }

  return -1;
}

function replaceNodes(nodes, from, to, view, replacement) {
  var result = [];

  for (var i = 0, off = 0; i < nodes.length; i++) {
    var child = nodes[i],
        start = off,
        end = off += child.size;

    if (start >= to || end <= from) {
      result.push(child);
    } else {
      if (start < from) result.push(child.slice(0, from - start, view));

      if (replacement) {
        result.push(replacement);
        replacement = undefined;
      }

      if (end > to) result.push(child.slice(to - start, child.size, view));
    }
  }

  return result;
}

function selectionFromDOM(view) {
  var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var domSel = view.domSelection(),
      doc = view.state.doc;
  if (!domSel.focusNode) return null;
  var nearestDesc = view.docView.nearestDesc(domSel.focusNode),
      inWidget = nearestDesc && nearestDesc.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0) return null;
  var $head = doc.resolve(head),
      $anchor,
      selection;

  if (selectionCollapsed(domSel)) {
    $anchor = $head;

    while (nearestDesc && !nearestDesc.node) {
      nearestDesc = nearestDesc.parent;
    }

    var nearestDescNode = nearestDesc.node;

    if (nearestDesc && nearestDescNode.isAtom && prosemirrorState.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      var pos = nearestDesc.posBefore;
      selection = new prosemirrorState.NodeSelection(head == pos ? $head : doc.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0) return null;
    $anchor = doc.resolve(anchor);
  }

  if (!selection) {
    var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }

  return selection;
}

function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}

function selectionToDOM(view) {
  var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view)) return;

  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    var domSel = view.domSelection(),
        curSel = view.domObserver.currentSelection;

    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }

  view.domObserver.disconnectSelection();

  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor = sel.anchor,
        head = sel.head,
        resetEditableFrom,
        resetEditableTo;

    if (brokenSelectBetweenUneditable && !(sel instanceof prosemirrorState.TextSelection)) {
      if (!sel.$from.parent.inlineContent) resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent) resetEditableTo = temporarilyEditableNear(view, sel.to);
    }

    view.docView.setSelection(anchor, head, view.root, force);

    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) resetEditable(resetEditableFrom);
      if (resetEditableTo) resetEditable(resetEditableTo);
    }

    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) removeClassOnSelectionChange(view);
    }
  }

  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}

var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;

function temporarilyEditableNear(view, pos) {
  var _view$docView$domFrom3 = view.docView.domFromPos(pos, 0),
      node = _view$docView$domFrom3.node,
      offset = _view$docView$domFrom3.offset;

  var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
  var before = offset ? node.childNodes[offset - 1] : null;
  if (safari && after && after.contentEditable == "false") return setEditable(after);

  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after) return setEditable(after);else if (before) return setEditable(before);
  }
}

function setEditable(element) {
  element.contentEditable = "true";

  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }

  return element;
}

function resetEditable(element) {
  element.contentEditable = "false";

  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}

function removeClassOnSelectionChange(view) {
  var doc = view.dom.ownerDocument;
  doc.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  var domSel = view.domSelection();
  var node = domSel.anchorNode,
      offset = domSel.anchorOffset;
  doc.addEventListener("selectionchange", view.input.hideSelectionGuard = function () {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
      doc.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(function () {
        if (!editorOwnsSelection(view) || view.state.selection.visible) view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}

function selectCursorWrapper(view) {
  var domSel = view.domSelection(),
      range = document.createRange();
  var node = view.cursorWrapper.dom,
      img = node.nodeName == "IMG";
  if (img) range.setEnd(node.parentNode, domIndex(node) + 1);else range.setEnd(node, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);

  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}

function syncNodeSelection(view, sel) {
  if (sel instanceof prosemirrorState.NodeSelection) {
    var desc = view.docView.descAt(sel.from);

    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}

function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent) view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = undefined;
  }
}

function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function (f) {
    return f(view, $anchor, $head);
  }) || prosemirrorState.TextSelection.between($anchor, $head, bias);
}

function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom) return false;
  return hasSelection(view);
}

function hasSelection(view) {
  var sel = view.domSelection();
  if (!sel.anchorNode) return false;

  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}

function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.domSelection();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}

function moveSelectionBlock(state, dir) {
  var _state$selection = state.selection,
      $anchor = _state$selection.$anchor,
      $head = _state$selection.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && prosemirrorState.Selection.findFrom($start, dir);
}

function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}

function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;

  if (sel instanceof prosemirrorState.TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof prosemirrorState.NodeSelection) return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head,
          node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter,
          desc;
      if (!node || node.isText) return false;
      var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false;

      if (prosemirrorState.NodeSelection.isSelectable(node)) {
        return apply(view, new prosemirrorState.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new prosemirrorState.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof prosemirrorState.NodeSelection && sel.node.isInline) {
    return apply(view, new prosemirrorState.TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var _next = moveSelectionBlock(view.state, dir);

    if (_next) return apply(view, _next);
    return false;
  }
}

function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}

function isIgnorable(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}

function skipIgnoredNodesLeft(view) {
  var sel = view.domSelection();
  var node = sel.focusNode,
      offset = sel.focusOffset;
  if (!node) return;
  var moveNode,
      moveOffset,
      force = false;
  if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) force = true;

  for (;;) {
    if (offset > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        var before = node.childNodes[offset - 1];

        if (isIgnorable(before)) {
          moveNode = node;
          moveOffset = --offset;
        } else if (before.nodeType == 3) {
          node = before;
          offset = node.nodeValue.length;
        } else break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      var prev = node.previousSibling;

      while (prev && isIgnorable(prev)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }

      if (!prev) {
        node = node.parentNode;
        if (node == view.dom) break;
        offset = 0;
      } else {
        node = prev;
        offset = nodeLen(node);
      }
    }
  }

  if (force) setSelFocus(view, sel, node, offset);else if (moveNode) setSelFocus(view, sel, moveNode, moveOffset);
}

function skipIgnoredNodesRight(view) {
  var sel = view.domSelection();
  var node = sel.focusNode,
      offset = sel.focusOffset;
  if (!node) return;
  var len = nodeLen(node);
  var moveNode, moveOffset;

  for (;;) {
    if (offset < len) {
      if (node.nodeType != 1) break;
      var after = node.childNodes[offset];

      if (isIgnorable(after)) {
        moveNode = node;
        moveOffset = ++offset;
      } else break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      var next = node.nextSibling;

      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }

      if (!next) {
        node = node.parentNode;
        if (node == view.dom) break;
        offset = len = 0;
      } else {
        node = next;
        offset = 0;
        len = nodeLen(node);
      }
    }
  }

  if (moveNode) setSelFocus(view, sel, moveNode, moveOffset);
}

function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}

function setSelFocus(view, sel, node, offset) {
  if (selectionCollapsed(sel)) {
    var range = document.createRange();
    range.setEnd(node, offset);
    range.setStart(node, offset);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset);
  }

  view.domObserver.setCurSelection();
  var state = view.state;
  setTimeout(function () {
    if (view.state == state) selectionToDOM(view);
  }, 50);
}

function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof prosemirrorState.TextSelection && !sel.empty || mods.indexOf("s") > -1) return false;
  if (mac && mods.indexOf("m") > -1) return false;
  var $from = sel.$from,
      $to = sel.$to;

  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof prosemirrorState.NodeSelection) return apply(view, next);
  }

  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof prosemirrorState.AllSelection ? prosemirrorState.Selection.near(side, dir) : prosemirrorState.Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }

  return false;
}

function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof prosemirrorState.TextSelection)) return true;
  var _view$state$selection2 = view.state.selection,
      $head = _view$state$selection2.$head,
      $anchor = _view$state$selection2.$anchor,
      empty = _view$state$selection2.empty;
  if (!$head.sameParent($anchor)) return true;
  if (!empty) return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) return true;
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);

  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) tr["delete"]($head.pos - nextNode.nodeSize, $head.pos);else tr["delete"]($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }

  return false;
}

function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}

function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0) return false;

  var _view$domSelection = view.domSelection(),
      focusNode = _view$domSelection.focusNode,
      focusOffset = _view$domSelection.focusOffset;

  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(function () {
      return switchEditable(view, child, "false");
    }, 20);
  }

  return false;
}

function getMods(event) {
  var result = "";
  if (event.ctrlKey) result += "c";
  if (event.metaKey) result += "m";
  if (event.altKey) result += "a";
  if (event.shiftKey) result += "s";
  return result;
}

function captureKeyDown(view, event) {
  var code = event.keyCode,
      mods = getMods(event);

  if (code == 8 || mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
  } else if (code == 46 || mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }

  return false;
}

function serializeForClipboard(view, slice) {
  var context = [],
      content = slice.content,
      openStart = slice.openStart,
      openEnd = slice.openEnd;

  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }

  var serializer = view.someProp("clipboardSerializer") || prosemirrorModel.DOMSerializer.fromSchema(view.state.schema);
  var doc = detachedDoc(),
      wrap = doc.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, {
    document: doc
  }));
  var firstChild = wrap.firstChild,
      needsWrap,
      wrappers = 0;

  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i = needsWrap.length - 1; i >= 0; i--) {
      var wrapper = doc.createElement(needsWrap[i]);

      while (wrap.firstChild) {
        wrapper.appendChild(wrap.firstChild);
      }

      wrap.appendChild(wrapper);
      wrappers++;
    }

    firstChild = wrap.firstChild;
  }

  if (firstChild && firstChild.nodeType == 1) firstChild.setAttribute("data-pm-slice", "".concat(openStart, " ").concat(openEnd).concat(wrappers ? " -".concat(wrappers) : "", " ").concat(JSON.stringify(context)));
  var text = view.someProp("clipboardTextSerializer", function (f) {
    return f(slice);
  }) || slice.content.textBetween(0, slice.content.size, "\n\n");
  return {
    dom: wrap,
    text: text
  };
}

function parseFromClipboard(view, text, html, plainText, $context) {
  var inCode = $context.parent.type.spec.code;
  var dom, slice;
  if (!html && !text) return null;
  var asText = text && (plainText || inCode || !html);

  if (asText) {
    view.someProp("transformPastedText", function (f) {
      text = f(text, inCode || plainText);
    });
    if (inCode) return text ? new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : prosemirrorModel.Slice.empty;
    var parsed = view.someProp("clipboardTextParser", function (f) {
      return f(text, $context, plainText);
    });

    if (parsed) {
      slice = parsed;
    } else {
      var marks = $context.marks();
      var schema = view.state.schema,
          serializer = prosemirrorModel.DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach(function (block) {
        var p = dom.appendChild(document.createElement("p"));
        if (block) p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", function (f) {
      html = f(html);
    });
    dom = readHTML(html);
    if (webkit) restoreReplacedSpaces(dom);
  }

  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3]) for (var i = +sliceData[3]; i > 0 && dom.firstChild; i--) {
    dom = dom.firstChild;
  }

  if (!slice) {
    var parser = view.someProp("clipboardParser") || view.someProp("domParser") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);
    slice = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode: function ruleFromNode(dom) {
        if (dom.nodeName == "BR" && !dom.nextSibling && dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) return {
          ignore: true
        };
        return null;
      }
    });
  }

  if (sliceData) {
    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice = prosemirrorModel.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);

    if (slice.openStart || slice.openEnd) {
      var openStart = 0,
          openEnd = 0;

      for (var node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {}

      for (var _node = slice.content.lastChild; openEnd < slice.openEnd && !_node.type.spec.isolating; openEnd++, _node = _node.lastChild) {}

      slice = closeSlice(slice, openStart, openEnd);
    }
  }

  view.someProp("transformPasted", function (f) {
    slice = f(slice);
  });
  return slice;
}

var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;

function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) return fragment;

  var _loop = function _loop(d) {
    var parent = $context.node(d);
    var match = parent.contentMatchAt($context.index(d));
    var lastWrap = void 0,
        result = [];
    fragment.forEach(function (node) {
      if (!result) return;
      var wrap = match.findWrapping(node.type),
          inLast;
      if (!wrap) return result = null;

      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        var wrapped = withWrappers(node, wrap);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap;
      }
    });
    if (result) return {
      v: prosemirrorModel.Fragment.from(result)
    };
  };

  for (var d = $context.depth; d >= 0; d--) {
    var _ret = _loop(d);

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return fragment;
}

function withWrappers(node, wrap) {
  var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  for (var i = wrap.length - 1; i >= from; i--) {
    node = wrap[i].create(null, prosemirrorModel.Fragment.from(node));
  }

  return node;
}

function addToSibling(wrap, lastWrap, node, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) return sibling.copy(sibling.content.append(prosemirrorModel.Fragment.from(withWrappers(node, wrap, depth + 1))));
  }
}

function closeRight(node, depth) {
  if (depth == 0) return node;
  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true);
  return node.copy(fragment.append(fill));
}

function closeRange(fragment, side, from, to, depth, openEnd) {
  var node = side < 0 ? fragment.firstChild : fragment.lastChild,
      inner = node.content;
  if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd);
  if (depth >= from) inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}

function closeSlice(slice, openStart, openEnd) {
  if (openStart < slice.openStart) slice = new prosemirrorModel.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
  if (openEnd < slice.openEnd) slice = new prosemirrorModel.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
  return slice;
}

var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;

function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}

function readHTML(html) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas) html = html.slice(metas[0].length);
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html),
      wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) html = wrap.map(function (n) {
    return "<" + n + ">";
  }).join("") + html + wrap.map(function (n) {
    return "</" + n + ">";
  }).reverse().join("");
  elt.innerHTML = html;
  if (wrap) for (var i = 0; i < wrap.length; i++) {
    elt = elt.querySelector(wrap[i]) || elt;
  }
  return elt;
}

function restoreReplacedSpaces(dom) {
  var nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode) node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}

function addContext(slice, context) {
  if (!slice.size) return slice;
  var schema = slice.content.firstChild.type.schema,
      array;

  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice;
  }

  var content = slice.content,
      openStart = slice.openStart,
      openEnd = slice.openEnd;

  for (var i = array.length - 2; i >= 0; i -= 2) {
    var type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs()) break;
    content = prosemirrorModel.Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }

  return new prosemirrorModel.Slice(content, openStart, openEnd);
}

var handlers = {};
var editHandlers = {};

var InputState = _createClass(function InputState() {
  _classCallCheck(this, InputState);

  this.shiftKey = false;
  this.mouseDown = null;
  this.lastKeyCode = null;
  this.lastKeyCodeTime = 0;
  this.lastClick = {
    time: 0,
    x: 0,
    y: 0,
    type: ""
  };
  this.lastSelectionOrigin = null;
  this.lastSelectionTime = 0;
  this.lastIOSEnter = 0;
  this.lastIOSEnterFallbackTimeout = -1;
  this.lastAndroidDelete = 0;
  this.composing = false;
  this.composingTimeout = -1;
  this.compositionNodes = [];
  this.compositionEndedAt = -2e8;
  this.domChangeCount = 0;
  this.eventHandlers = Object.create(null);
  this.hideSelectionGuard = null;
});

function initInput(view) {
  var _loop2 = function _loop2(event) {
    var handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = function (event) {
      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) && (view.editable || !(event.type in editHandlers))) handler(view, event);
    });
  };

  for (var event in handlers) {
    _loop2(event);
  }

  if (safari) view.dom.addEventListener("input", function () {
    return null;
  });
  ensureListeners(view);
}

function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}

function destroyInput(view) {
  view.domObserver.stop();

  for (var type in view.input.eventHandlers) {
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  }

  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}

function ensureListeners(view) {
  view.someProp("handleDOMEvents", function (currentHandlers) {
    for (var type in currentHandlers) {
      if (!view.input.eventHandlers[type]) view.dom.addEventListener(type, view.input.eventHandlers[type] = function (event) {
        return runCustomHandler(view, event);
      });
    }
  });
}

function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function (handlers) {
    var handler = handlers[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}

function eventBelongsToView(view, event) {
  if (!event.bubbles) return true;
  if (event.defaultPrevented) return false;

  for (var node = event.target; node != view.dom; node = node.parentNode) {
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) return false;
  }

  return true;
}

function _dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) handlers[event.type](view, event);
}

editHandlers.keydown = function (view, _event) {
  var event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event)) return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13) return;
  if (event.keyCode != 229) view.domObserver.forceFlush();

  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(function () {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", function (f) {
          return f(view, keyEvent(13, "Enter"));
        });
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function (f) {
    return f(view, event);
  }) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};

editHandlers.keyup = function (view, event) {
  if (event.keyCode == 16) view.input.shiftKey = false;
};

editHandlers.keypress = function (view, _event) {
  var event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey) return;

  if (view.someProp("handleKeyPress", function (f) {
    return f(view, event);
  })) {
    event.preventDefault();
    return;
  }

  var sel = view.state.selection;

  if (!(sel instanceof prosemirrorState.TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", function (f) {
      return f(view, sel.$from.pos, sel.$to.pos, text);
    })) view.dispatch(view.state.tr.insertText(text).scrollIntoView());
    event.preventDefault();
  }
};

function eventCoords(event) {
  return {
    left: event.clientX,
    top: event.clientY
  };
}

function isNear(event, click) {
  var dx = click.x - event.clientX,
      dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}

function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) return false;
  var $pos = view.state.doc.resolve(inside);

  var _loop3 = function _loop3(i) {
    if (view.someProp(propName, function (f) {
      return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false);
    })) return {
      v: true
    };
  };

  for (var i = $pos.depth + 1; i > 0; i--) {
    var _ret2 = _loop3(i);

    if (_typeof(_ret2) === "object") return _ret2.v;
  }

  return false;
}

function updateSelection(view, selection, origin) {
  if (!view.focused) view.focus();
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") tr.setMeta("pointer", true);
  view.dispatch(tr);
}

function selectClickedLeaf(view, inside) {
  if (inside == -1) return false;
  var $pos = view.state.doc.resolve(inside),
      node = $pos.nodeAfter;

  if (node && node.isAtom && prosemirrorState.NodeSelection.isSelectable(node)) {
    updateSelection(view, new prosemirrorState.NodeSelection($pos), "pointer");
    return true;
  }

  return false;
}

function selectClickedNode(view, inside) {
  if (inside == -1) return false;
  var sel = view.state.selection,
      selectedNode,
      selectAt;
  if (sel instanceof prosemirrorState.NodeSelection) selectedNode = sel.node;
  var $pos = view.state.doc.resolve(inside);

  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);

    if (prosemirrorState.NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) selectAt = $pos.before(sel.$from.depth);else selectAt = $pos.before(i);
      break;
    }
  }

  if (selectAt != null) {
    updateSelection(view, prosemirrorState.NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}

function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function (f) {
    return f(view, pos, event);
  }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}

function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function (f) {
    return f(view, pos, event);
  });
}

function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function (f) {
    return f(view, pos, event);
  }) || defaultTripleClick(view, inside, event);
}

function defaultTripleClick(view, inside, event) {
  if (event.button != 0) return false;
  var doc = view.state.doc;

  if (inside == -1) {
    if (doc.inlineContent) {
      updateSelection(view, prosemirrorState.TextSelection.create(doc, 0, doc.content.size), "pointer");
      return true;
    }

    return false;
  }

  var $pos = doc.resolve(inside);

  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    var nodePos = $pos.before(i);
    if (node.inlineContent) updateSelection(view, prosemirrorState.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer");else if (prosemirrorState.NodeSelection.isSelectable(node)) updateSelection(view, prosemirrorState.NodeSelection.create(doc, nodePos), "pointer");else continue;
    return true;
  }
}

function forceDOMFlush(view) {
  return endComposition(view);
}

var selectNodeModifier = mac ? "metaKey" : "ctrlKey";

handlers.mousedown = function (view, _event) {
  var event = _event;
  view.input.shiftKey = event.shiftKey;
  var flushed = forceDOMFlush(view);
  var now = Date.now(),
      type = "singleClick";

  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick") type = "doubleClick";else if (view.input.lastClick.type == "doubleClick") type = "tripleClick";
  }

  view.input.lastClick = {
    time: now,
    x: event.clientX,
    y: event.clientY,
    type: type
  };
  var pos = view.posAtCoords(eventCoords(event));
  if (!pos) return;

  if (type == "singleClick") {
    if (view.input.mouseDown) view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};

var MouseDown = function () {
  function MouseDown(view, pos, event, flushed) {
    var _this8 = this;

    _classCallCheck(this, MouseDown);

    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    var targetNode, targetPos;

    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      var $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }

    var target = flushed ? null : event.target;
    var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    var selection = view.state.selection;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirrorState.NodeSelection && selection.from <= targetPos && selection.to > targetPos) this.mightDrag = {
      node: targetNode,
      pos: targetPos,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
    };

    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr) this.target.draggable = true;
      if (this.mightDrag.setUneditable) setTimeout(function () {
        if (_this8.view.input.mouseDown == _this8) _this8.target.setAttribute("contentEditable", "false");
      }, 20);
      this.view.domObserver.start();
    }

    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }

  _createClass(MouseDown, [{
    key: "done",
    value: function done() {
      var _this9 = this;

      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);

      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) this.target.removeAttribute("draggable");
        if (this.mightDrag.setUneditable) this.target.removeAttribute("contentEditable");
        this.view.domObserver.start();
      }

      if (this.delayedSelectionSync) setTimeout(function () {
        return selectionToDOM(_this9.view);
      });
      this.view.input.mouseDown = null;
    }
  }, {
    key: "up",
    value: function up(event) {
      this.done();
      if (!this.view.dom.contains(event.target)) return;
      var pos = this.pos;
      if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));

      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (event.button == 0 && (this.flushed || safari && this.mightDrag && !this.mightDrag.node.isAtom || chrome && !(this.view.state.selection instanceof prosemirrorState.TextSelection) && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
        updateSelection(this.view, prosemirrorState.Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    }
  }, {
    key: "move",
    value: function move(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) this.allowDefault = true;
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0) this.done();
    }
  }]);

  return MouseDown;
}();

handlers.touchdown = function (view) {
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};

handlers.contextmenu = function (view) {
  return forceDOMFlush(view);
};

function inOrNearComposition(view, event) {
  if (view.composing) return true;

  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }

  return false;
}

var timeoutComposition = android ? 5000 : -1;

editHandlers.compositionstart = editHandlers.compositionupdate = function (view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state,
        $pos = state.selection.$from;

    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function (m) {
      return m.type.spec.inclusive === false;
    }))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);

      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.domSelection();

        for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {
          var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
          if (!before) break;

          if (before.nodeType == 3) {
            sel.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset = -1;
          }
        }
      }
    }

    view.input.composing = true;
  }

  scheduleComposeEnd(view, timeoutComposition);
};

editHandlers.compositionend = function (view, event) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view, 20);
  }
};

function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1) view.input.composingTimeout = setTimeout(function () {
    return endComposition(view);
  }, delay);
}

function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }

  while (view.input.compositionNodes.length > 0) {
    view.input.compositionNodes.pop().markParentsDirty();
  }
}

function timestampFromCustomEvent() {
  var event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}

function endComposition(view) {
  var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (android && view.domObserver.flushingSoon >= 0) return;
  view.domObserver.forceFlush();
  clearComposition(view);

  if (forceUpdate || view.docView && view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel));else view.updateState(view.state);
    return true;
  }

  return false;
}

function captureCopy(view, dom) {
  if (!view.dom.parentNode) return;
  var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(),
      range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function () {
    if (wrap.parentNode) wrap.parentNode.removeChild(wrap);
    view.focus();
  }, 50);
}

var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;

handlers.copy = editHandlers.cut = function (view, _event) {
  var event = _event;
  var sel = view.state.selection,
      cut = event.type == "cut";
  if (sel.empty) return;
  var data = brokenClipboardAPI ? null : event.clipboardData;

  var slice = sel.content(),
      _serializeForClipboar = serializeForClipboard(view, slice),
      dom = _serializeForClipboar.dom,
      text = _serializeForClipboar.text;

  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }

  if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};

function sliceSingleNode(slice) {
  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
}

function capturePaste(view, event) {
  if (!view.dom.parentNode) return;
  var plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function () {
    view.focus();
    if (target.parentNode) target.parentNode.removeChild(target);
    if (plainText) doPaste(view, target.value, null, event);else doPaste(view, target.textContent, target.innerHTML, event);
  }, 50);
}

function doPaste(view, text, html, event) {
  var slice = parseFromClipboard(view, text, html, view.input.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", function (f) {
    return f(view, event, slice || prosemirrorModel.Slice.empty);
  })) return true;
  if (!slice) return false;
  var singleNode = sliceSingleNode(slice);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.input.shiftKey) : view.state.tr.replaceSelection(slice);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}

editHandlers.paste = function (view, _event) {
  var event = _event;
  if (view.composing && !android) return;
  var data = brokenClipboardAPI ? null : event.clipboardData;
  if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), event)) event.preventDefault();else capturePaste(view, event);
};

var Dragging = _createClass(function Dragging(slice, move) {
  _classCallCheck(this, Dragging);

  this.slice = slice;
  this.move = move;
});

var dragCopyModifier = mac ? "altKey" : "ctrlKey";

handlers.dragstart = function (view, _event) {
  var event = _event;
  var mouseDown = view.input.mouseDown;
  if (mouseDown) mouseDown.done();
  if (!event.dataTransfer) return;
  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirrorState.NodeSelection ? sel.to - 1 : sel.to)) ;else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (event.target && event.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView) view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, desc.posBefore)));
  }

  var slice = view.state.selection.content(),
      _serializeForClipboar2 = serializeForClipboard(view, slice),
      dom = _serializeForClipboar2.dom,
      text = _serializeForClipboar2.text;

  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI) event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice, !event[dragCopyModifier]);
};

handlers.dragend = function (view) {
  var dragging = view.dragging;
  window.setTimeout(function () {
    if (view.dragging == dragging) view.dragging = null;
  }, 50);
};

editHandlers.dragover = editHandlers.dragenter = function (_, e) {
  return e.preventDefault();
};

editHandlers.drop = function (view, _event) {
  var event = _event;
  var dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer) return;
  var eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos) return;
  var $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse) return;
  var slice = dragging && dragging.slice;

  if (slice) {
    view.someProp("transformPasted", function (f) {
      slice = f(slice);
    });
  } else {
    slice = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }

  var move = !!(dragging && !event[dragCopyModifier]);

  if (view.someProp("handleDrop", function (f) {
    return f(view, event, slice || prosemirrorModel.Slice.empty, move);
  })) {
    event.preventDefault();
    return;
  }

  if (!slice) return;
  event.preventDefault();
  var insertPos = slice ? prosemirrorTransform.dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
  if (insertPos == null) insertPos = $mouse.pos;
  var tr = view.state.tr;
  if (move) tr.deleteSelection();
  var pos = tr.mapping.map(insertPos);
  var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode) tr.replaceRangeWith(pos, pos, slice.content.firstChild);else tr.replaceRange(pos, pos, slice);
  if (tr.doc.eq(beforeInsert)) return;
  var $pos = tr.doc.resolve(pos);

  if (isNode && prosemirrorState.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
    tr.setSelection(new prosemirrorState.NodeSelection($pos));
  } else {
    var end = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function (_from, _to, _newFrom, newTo) {
      return end = newTo;
    });
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
  }

  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};

handlers.focus = function (view) {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function () {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelection())) selectionToDOM(view);
    }, 20);
  }
};

handlers.blur = function (view, _event) {
  var event = _event;

  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget)) view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};

handlers.beforeinput = function (view, _event) {
  var event = _event;

  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    var domChangeCount = view.input.domChangeCount;
    setTimeout(function () {
      if (view.input.domChangeCount != domChangeCount) return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function (f) {
        return f(view, keyEvent(8, "Backspace"));
      })) return;
      var $cursor = view.state.selection.$cursor;
      if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr["delete"]($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};

for (var prop in editHandlers) {
  handlers[prop] = editHandlers[prop];
}

function compareObjs(a, b) {
  if (a == b) return true;

  for (var p in a) {
    if (a[p] !== b[p]) return false;
  }

  for (var _p in b) {
    if (!(_p in a)) return false;
  }

  return true;
}

var WidgetType = function () {
  function WidgetType(toDOM, spec) {
    _classCallCheck(this, WidgetType);

    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }

  _createClass(WidgetType, [{
    key: "map",
    value: function map(mapping, span, offset, oldOffset) {
      var _mapping$mapResult = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1),
          pos = _mapping$mapResult.pos,
          deleted = _mapping$mapResult.deleted;

      return deleted ? null : new Decoration(pos - offset, pos - offset, this);
    }
  }, {
    key: "valid",
    value: function valid() {
      return true;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    }
  }, {
    key: "destroy",
    value: function destroy(node) {
      if (this.spec.destroy) this.spec.destroy(node);
    }
  }]);

  return WidgetType;
}();

var InlineType = function () {
  function InlineType(attrs, spec) {
    _classCallCheck(this, InlineType);

    this.attrs = attrs;
    this.spec = spec || noSpec;
  }

  _createClass(InlineType, [{
    key: "map",
    value: function map(mapping, span, offset, oldOffset) {
      var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
      var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
      return from >= to ? null : new Decoration(from, to, this);
    }
  }, {
    key: "valid",
    value: function valid(_, span) {
      return span.from < span.to;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }], [{
    key: "is",
    value: function is(span) {
      return span.type instanceof InlineType;
    }
  }]);

  return InlineType;
}();

var NodeType = function () {
  function NodeType(attrs, spec) {
    _classCallCheck(this, NodeType);

    this.attrs = attrs;
    this.spec = spec || noSpec;
  }

  _createClass(NodeType, [{
    key: "map",
    value: function map(mapping, span, offset, oldOffset) {
      var from = mapping.mapResult(span.from + oldOffset, 1);
      if (from.deleted) return null;
      var to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from.pos) return null;
      return new Decoration(from.pos - offset, to.pos - offset, this);
    }
  }, {
    key: "valid",
    value: function valid(node, span) {
      var _node$content$findInd = node.content.findIndex(span.from),
          index = _node$content$findInd.index,
          offset = _node$content$findInd.offset,
          child;

      return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);

  return NodeType;
}();

var Decoration = function () {
  function Decoration(from, to, type) {
    _classCallCheck(this, Decoration);

    this.from = from;
    this.to = to;
    this.type = type;
  }

  _createClass(Decoration, [{
    key: "copy",
    value: function copy(from, to) {
      return new Decoration(from, to, this.type);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
    }
  }, {
    key: "map",
    value: function map(mapping, offset, oldOffset) {
      return this.type.map(mapping, this, offset, oldOffset);
    }
  }, {
    key: "spec",
    get: function get() {
      return this.type.spec;
    }
  }, {
    key: "inline",
    get: function get() {
      return this.type instanceof InlineType;
    }
  }], [{
    key: "widget",
    value: function widget(pos, toDOM, spec) {
      return new Decoration(pos, pos, new WidgetType(toDOM, spec));
    }
  }, {
    key: "inline",
    value: function inline(from, to, attrs, spec) {
      return new Decoration(from, to, new InlineType(attrs, spec));
    }
  }, {
    key: "node",
    value: function node(from, to, attrs, spec) {
      return new Decoration(from, to, new NodeType(attrs, spec));
    }
  }]);

  return Decoration;
}();

var none = [],
    noSpec = {};

var DecorationSet = function () {
  function DecorationSet(local, children) {
    _classCallCheck(this, DecorationSet);

    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }

  _createClass(DecorationSet, [{
    key: "find",
    value: function find(start, end, predicate) {
      var result = [];
      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
      return result;
    }
  }, {
    key: "findInner",
    value: function findInner(start, end, result, offset, predicate) {
      for (var i = 0; i < this.local.length; i++) {
        var span = this.local[i];
        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) result.push(span.copy(span.from + offset, span.to + offset));
      }

      for (var _i5 = 0; _i5 < this.children.length; _i5 += 3) {
        if (this.children[_i5] < end && this.children[_i5 + 1] > start) {
          var childOff = this.children[_i5] + 1;

          this.children[_i5 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
        }
      }
    }
  }, {
    key: "map",
    value: function map(mapping, doc, options) {
      if (this == empty || mapping.maps.length == 0) return this;
      return this.mapInner(mapping, doc, 0, 0, options || noSpec);
    }
  }, {
    key: "mapInner",
    value: function mapInner(mapping, node, offset, oldOffset, options) {
      var newLocal;

      for (var i = 0; i < this.local.length; i++) {
        var mapped = this.local[i].map(mapping, offset, oldOffset);
        if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);else if (options.onRemove) options.onRemove(this.local[i].spec);
      }

      if (this.children.length) return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);else return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
    }
  }, {
    key: "add",
    value: function add(doc, decorations) {
      if (!decorations.length) return this;
      if (this == empty) return DecorationSet.create(doc, decorations);
      return this.addInner(doc, decorations, 0);
    }
  }, {
    key: "addInner",
    value: function addInner(doc, decorations, offset) {
      var _this10 = this;

      var children,
          childIndex = 0;
      doc.forEach(function (childNode, childOffset) {
        var baseOffset = childOffset + offset,
            found;
        if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return;
        if (!children) children = _this10.children.slice();

        while (childIndex < children.length && children[childIndex] < childOffset) {
          childIndex += 3;
        }

        if (children[childIndex] == childOffset) children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);else children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
        childIndex += 3;
      });
      var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);

      for (var i = 0; i < local.length; i++) {
        if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1);
      }

      return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    }
  }, {
    key: "remove",
    value: function remove(decorations) {
      if (decorations.length == 0 || this == empty) return this;
      return this.removeInner(decorations, 0);
    }
  }, {
    key: "removeInner",
    value: function removeInner(decorations, offset) {
      var children = this.children,
          local = this.local;

      for (var i = 0; i < children.length; i += 3) {
        var found = void 0;
        var from = children[i] + offset,
            to = children[i + 1] + offset;

        for (var j = 0, span; j < decorations.length; j++) {
          if (span = decorations[j]) {
            if (span.from > from && span.to < to) {
              decorations[j] = null;
              (found || (found = [])).push(span);
            }
          }
        }

        if (!found) continue;
        if (children == this.children) children = this.children.slice();
        var removed = children[i + 2].removeInner(found, from + 1);

        if (removed != empty) {
          children[i + 2] = removed;
        } else {
          children.splice(i, 3);
          i -= 3;
        }
      }

      if (local.length) for (var _i6 = 0, _span; _i6 < decorations.length; _i6++) {
        if (_span = decorations[_i6]) {
          for (var _j2 = 0; _j2 < local.length; _j2++) {
            if (local[_j2].eq(_span, offset)) {
              if (local == this.local) local = this.local.slice();
              local.splice(_j2--, 1);
            }
          }
        }
      }
      if (children == this.children && local == this.local) return this;
      return local.length || children.length ? new DecorationSet(local, children) : empty;
    }
  }, {
    key: "forChild",
    value: function forChild(offset, node) {
      if (this == empty) return this;
      if (node.isLeaf) return DecorationSet.empty;
      var child, local;

      for (var i = 0; i < this.children.length; i += 3) {
        if (this.children[i] >= offset) {
          if (this.children[i] == offset) child = this.children[i + 2];
          break;
        }
      }

      var start = offset + 1,
          end = start + node.content.size;

      for (var _i7 = 0; _i7 < this.local.length; _i7++) {
        var dec = this.local[_i7];

        if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
          var from = Math.max(start, dec.from) - start,
              to = Math.min(end, dec.to) - start;
          if (from < to) (local || (local = [])).push(dec.copy(from, to));
        }
      }

      if (local) {
        var localSet = new DecorationSet(local.sort(byPos), none);
        return child ? new DecorationGroup([localSet, child]) : localSet;
      }

      return child || empty;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      if (this == other) return true;
      if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) return false;

      for (var i = 0; i < this.local.length; i++) {
        if (!this.local[i].eq(other.local[i])) return false;
      }

      for (var _i8 = 0; _i8 < this.children.length; _i8 += 3) {
        if (this.children[_i8] != other.children[_i8] || this.children[_i8 + 1] != other.children[_i8 + 1] || !this.children[_i8 + 2].eq(other.children[_i8 + 2])) return false;
      }

      return true;
    }
  }, {
    key: "locals",
    value: function locals(node) {
      return removeOverlap(this.localsInner(node));
    }
  }, {
    key: "localsInner",
    value: function localsInner(node) {
      if (this == empty) return none;
      if (node.inlineContent || !this.local.some(InlineType.is)) return this.local;
      var result = [];

      for (var i = 0; i < this.local.length; i++) {
        if (!(this.local[i].type instanceof InlineType)) result.push(this.local[i]);
      }

      return result;
    }
  }], [{
    key: "create",
    value: function create(doc, decorations) {
      return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;
    }
  }]);

  return DecorationSet;
}();

DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty = DecorationSet.empty;

var DecorationGroup = function () {
  function DecorationGroup(members) {
    _classCallCheck(this, DecorationGroup);

    this.members = members;
  }

  _createClass(DecorationGroup, [{
    key: "map",
    value: function map(mapping, doc) {
      var mappedDecos = this.members.map(function (member) {
        return member.map(mapping, doc, noSpec);
      });
      return DecorationGroup.from(mappedDecos);
    }
  }, {
    key: "forChild",
    value: function forChild(offset, child) {
      if (child.isLeaf) return DecorationSet.empty;
      var found = [];

      for (var i = 0; i < this.members.length; i++) {
        var result = this.members[i].forChild(offset, child);
        if (result == empty) continue;
        if (result instanceof DecorationGroup) found = found.concat(result.members);else found.push(result);
      }

      return DecorationGroup.from(found);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) return false;

      for (var i = 0; i < this.members.length; i++) {
        if (!this.members[i].eq(other.members[i])) return false;
      }

      return true;
    }
  }, {
    key: "locals",
    value: function locals(node) {
      var result,
          sorted = true;

      for (var i = 0; i < this.members.length; i++) {
        var locals = this.members[i].localsInner(node);
        if (!locals.length) continue;

        if (!result) {
          result = locals;
        } else {
          if (sorted) {
            result = result.slice();
            sorted = false;
          }

          for (var j = 0; j < locals.length; j++) {
            result.push(locals[j]);
          }
        }
      }

      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
    }
  }], [{
    key: "from",
    value: function from(members) {
      switch (members.length) {
        case 0:
          return empty;

        case 1:
          return members[0];

        default:
          return new DecorationGroup(members);
      }
    }
  }]);

  return DecorationGroup;
}();

function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
  var children = oldChildren.slice();

  var shift = function shift(oldStart, oldEnd, newStart, newEnd) {
    for (var i = 0; i < children.length; i += 3) {
      var end = children[i + 1],
          dSize = void 0;
      if (end < 0 || oldStart > end + oldOffset) continue;
      var start = children[i] + oldOffset;

      if (oldEnd >= start) {
        children[i + 1] = oldStart <= start ? -2 : -1;
      } else if (newStart >= offset && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
        children[i] += dSize;
        children[i + 1] += dSize;
      }
    }
  };

  for (var i = 0; i < mapping.maps.length; i++) {
    mapping.maps[i].forEach(shift);
  }

  var mustRebuild = false;

  for (var _i9 = 0; _i9 < children.length; _i9 += 3) {
    if (children[_i9 + 1] < 0) {
      if (children[_i9 + 1] == -2) {
        mustRebuild = true;
        children[_i9 + 1] = -1;
        continue;
      }

      var from = mapping.map(oldChildren[_i9] + oldOffset),
          fromLocal = from - offset;

      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }

      var to = mapping.map(oldChildren[_i9 + 1] + oldOffset, -1),
          toLocal = to - offset;

      var _node$content$findInd2 = node.content.findIndex(fromLocal),
          index = _node$content$findInd2.index,
          childOffset = _node$content$findInd2.offset;

      var childNode = node.maybeChild(index);

      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[_i9 + 2].mapInner(mapping, childNode, from + 1, oldChildren[_i9] + oldOffset + 1, options);

        if (mapped != empty) {
          children[_i9] = fromLocal;
          children[_i9 + 1] = toLocal;
          children[_i9 + 2] = mapped;
        } else {
          children[_i9 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  }

  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
    var built = buildTree(decorations, node, 0, options);
    newLocal = built.local;

    for (var _i10 = 0; _i10 < children.length; _i10 += 3) {
      if (children[_i10 + 1] < 0) {
        children.splice(_i10, 3);
        _i10 -= 3;
      }
    }

    for (var _i11 = 0, j = 0; _i11 < built.children.length; _i11 += 3) {
      var _from2 = built.children[_i11];

      while (j < children.length && children[j] < _from2) {
        j += 3;
      }

      children.splice(j, 0, built.children[_i11], built.children[_i11 + 1], built.children[_i11 + 2]);
    }
  }

  return new DecorationSet(newLocal.sort(byPos), children);
}

function moveSpans(spans, offset) {
  if (!offset || !spans.length) return spans;
  var result = [];

  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    result.push(new Decoration(span.from + offset, span.to + offset, span.type));
  }

  return result;
}

function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
  function gather(set, oldOffset) {
    for (var i = 0; i < set.local.length; i++) {
      var mapped = set.local[i].map(mapping, offset, oldOffset);
      if (mapped) decorations.push(mapped);else if (options.onRemove) options.onRemove(set.local[i].spec);
    }

    for (var _i12 = 0; _i12 < set.children.length; _i12 += 3) {
      gather(set.children[_i12 + 2], set.children[_i12] + oldOffset + 1);
    }
  }

  for (var i = 0; i < children.length; i += 3) {
    if (children[i + 1] == -1) gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  }

  return decorations;
}

function takeSpansForNode(spans, node, offset) {
  if (node.isLeaf) return null;
  var end = offset + node.nodeSize,
      found = null;

  for (var i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset && span.to < end) {
      (found || (found = [])).push(span);
      spans[i] = null;
    }
  }

  return found;
}

function withoutNulls(array) {
  var result = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i] != null) result.push(array[i]);
  }

  return result;
}

function buildTree(spans, node, offset, options) {
  var children = [],
      hasNulls = false;
  node.forEach(function (childNode, localStart) {
    var found = takeSpansForNode(spans, childNode, localStart + offset);

    if (found) {
      hasNulls = true;
      var subtree = buildTree(found, childNode, offset + localStart + 1, options);
      if (subtree != empty) children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);

  for (var i = 0; i < locals.length; i++) {
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove) options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  }

  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}

function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}

function removeOverlap(spans) {
  var working = spans;

  for (var i = 0; i < working.length - 1; i++) {
    var span = working[i];
    if (span.from != span.to) for (var j = i + 1; j < working.length; j++) {
      var next = working[j];

      if (next.from == span.from) {
        if (next.to != span.to) {
          if (working == spans) working = spans.slice();
          working[j] = next.copy(next.from, span.to);
          insertAhead(working, j + 1, next.copy(span.to, next.to));
        }

        continue;
      } else {
        if (next.from < span.to) {
          if (working == spans) working = spans.slice();
          working[i] = span.copy(span.from, next.from);
          insertAhead(working, j, span.copy(next.from, span.to));
        }

        break;
      }
    }
  }

  return working;
}

function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0) {
    i++;
  }

  array.splice(i, 0, deco);
}

function viewDecorations(view) {
  var found = [];
  view.someProp("decorations", function (f) {
    var result = f(view.state);
    if (result && result != empty) found.push(result);
  });
  if (view.cursorWrapper) found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found);
}

var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;

var SelectionState = function () {
  function SelectionState() {
    _classCallCheck(this, SelectionState);

    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }

  _createClass(SelectionState, [{
    key: "set",
    value: function set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.anchorNode = this.focusNode = null;
    }
  }, {
    key: "eq",
    value: function eq(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    }
  }]);

  return SelectionState;
}();

var DOMObserver = function () {
  function DOMObserver(view, handleDOMChange) {
    var _this11 = this;

    _classCallCheck(this, DOMObserver);

    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.observer = window.MutationObserver && new window.MutationObserver(function (mutations) {
      for (var i = 0; i < mutations.length; i++) {
        _this11.queue.push(mutations[i]);
      }

      if (ie && ie_version <= 11 && mutations.some(function (m) {
        return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
      })) _this11.flushSoon();else _this11.flush();
    });

    if (useCharData) {
      this.onCharData = function (e) {
        _this11.queue.push({
          target: e.target,
          type: "characterData",
          oldValue: e.prevValue
        });

        _this11.flushSoon();
      };
    }

    this.onSelectionChange = this.onSelectionChange.bind(this);
  }

  _createClass(DOMObserver, [{
    key: "flushSoon",
    value: function flushSoon() {
      var _this12 = this;

      if (this.flushingSoon < 0) this.flushingSoon = window.setTimeout(function () {
        _this12.flushingSoon = -1;

        _this12.flush();
      }, 20);
    }
  }, {
    key: "forceFlush",
    value: function forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    }
  }, {
    key: "start",
    value: function start() {
      if (this.observer) this.observer.observe(this.view.dom, observeOptions);
      if (this.onCharData) this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.connectSelection();
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this13 = this;

      if (this.observer) {
        var take = this.observer.takeRecords();

        if (take.length) {
          for (var i = 0; i < take.length; i++) {
            this.queue.push(take[i]);
          }

          window.setTimeout(function () {
            return _this13.flush();
          }, 20);
        }

        this.observer.disconnect();
      }

      if (this.onCharData) this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      this.disconnectSelection();
    }
  }, {
    key: "connectSelection",
    value: function connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
  }, {
    key: "disconnectSelection",
    value: function disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    }
  }, {
    key: "suppressSelectionUpdates",
    value: function suppressSelectionUpdates() {
      var _this14 = this;

      this.suppressingSelectionUpdates = true;
      setTimeout(function () {
        return _this14.suppressingSelectionUpdates = false;
      }, 50);
    }
  }, {
    key: "onSelectionChange",
    value: function onSelectionChange() {
      if (!hasFocusAndSelection(this.view)) return;
      if (this.suppressingSelectionUpdates) return selectionToDOM(this.view);

      if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
        var sel = this.view.domSelection();
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) return this.flushSoon();
      }

      this.flush();
    }
  }, {
    key: "setCurSelection",
    value: function setCurSelection() {
      this.currentSelection.set(this.view.domSelection());
    }
  }, {
    key: "ignoreSelectionChange",
    value: function ignoreSelectionChange(sel) {
      if (sel.rangeCount == 0) return true;
      var container = sel.getRangeAt(0).commonAncestorContainer;
      var desc = this.view.docView.nearestDesc(container);

      if (desc && desc.ignoreMutation({
        type: "selection",
        target: container.nodeType == 3 ? container.parentNode : container
      })) {
        this.setCurSelection();
        return true;
      }
    }
  }, {
    key: "flush",
    value: function flush() {
      if (!this.view.docView || this.flushingSoon > -1) return;
      var mutations = this.observer ? this.observer.takeRecords() : [];

      if (this.queue.length) {
        mutations = this.queue.concat(mutations);
        this.queue.length = 0;
      }

      var sel = this.view.domSelection();
      var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(this.view) && !this.ignoreSelectionChange(sel);
      var from = -1,
          to = -1,
          typeOver = false,
          added = [];

      if (this.view.editable) {
        for (var i = 0; i < mutations.length; i++) {
          var result = this.registerMutation(mutations[i], added);

          if (result) {
            from = from < 0 ? result.from : Math.min(result.from, from);
            to = to < 0 ? result.to : Math.max(result.to, to);
            if (result.typeOver) typeOver = true;
          }
        }
      }

      if (gecko && added.length > 1) {
        var brs = added.filter(function (n) {
          return n.nodeName == "BR";
        });

        if (brs.length == 2) {
          var a = brs[0],
              b = brs[1];
          if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove();else a.remove();
        }
      }

      if (from > -1 || newSel) {
        if (from > -1) {
          this.view.docView.markDirty(from, to);
          checkCSS(this.view);
        }

        this.handleDOMChange(from, to, typeOver, added);
        if (this.view.docView && this.view.docView.dirty) this.view.updateState(this.view.state);else if (!this.currentSelection.eq(sel)) selectionToDOM(this.view);
        this.currentSelection.set(sel);
      }
    }
  }, {
    key: "registerMutation",
    value: function registerMutation(mut, added) {
      if (added.indexOf(mut.target) > -1) return null;
      var desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) return null;
      if (!desc || desc.ignoreMutation(mut)) return null;

      if (mut.type == "childList") {
        for (var i = 0; i < mut.addedNodes.length; i++) {
          added.push(mut.addedNodes[i]);
        }

        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) return {
          from: desc.posBefore,
          to: desc.posAfter
        };
        var prev = mut.previousSibling,
            next = mut.nextSibling;

        if (ie && ie_version <= 11 && mut.addedNodes.length) {
          for (var _i13 = 0; _i13 < mut.addedNodes.length; _i13++) {
            var _mut$addedNodes$_i = mut.addedNodes[_i13],
                previousSibling = _mut$addedNodes$_i.previousSibling,
                nextSibling = _mut$addedNodes$_i.nextSibling;
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling;
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling;
          }
        }

        var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        var from = desc.localPosFromDOM(mut.target, fromOffset, -1);
        var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
        var to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return {
          from: from,
          to: to
        };
      } else if (mut.type == "attributes") {
        return {
          from: desc.posAtStart - desc.border,
          to: desc.posAtEnd + desc.border
        };
      } else {
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    }
  }]);

  return DOMObserver;
}();

var cssChecked = false;

function checkCSS(view) {
  if (cssChecked) return;
  cssChecked = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal") console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
}

function parseBetween(view, from_, to_) {
  var _view$docView$parseRa = view.docView.parseRange(from_, to_),
      parent = _view$docView$parseRa.node,
      fromOffset = _view$docView$parseRa.fromOffset,
      toOffset = _view$docView$parseRa.toOffset,
      from = _view$docView$parseRa.from,
      to = _view$docView$parseRa.to;

  var domSel = view.domSelection();
  var find;
  var anchor = domSel.anchorNode;

  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{
      node: anchor,
      offset: domSel.anchorOffset
    }];
    if (!selectionCollapsed(domSel)) find.push({
      node: domSel.focusNode,
      offset: domSel.focusOffset
    });
  }

  if (chrome && view.input.lastKeyCode === 8) {
    for (var off = toOffset; off > fromOffset; off--) {
      var node = parent.childNodes[off - 1],
          desc = node.pmViewDesc;

      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }

      if (!desc || desc.size) break;
    }
  }

  var startDoc = view.state.doc;
  var parser = view.someProp("domParser") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from);
  var sel = null,
      doc = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find,
    ruleFromNode: ruleFromNode,
    context: $from
  });

  if (find && find[0].pos != null) {
    var _anchor = find[0].pos,
        head = find[1] && find[1].pos;
    if (head == null) head = _anchor;
    sel = {
      anchor: _anchor + from,
      head: head + from
    };
  }

  return {
    doc: doc,
    sel: sel,
    from: from,
    to: to
  };
}

function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;

  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return {
        skip: skip
      };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return {
        ignore: true
      };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return {
      ignore: true
    };
  }

  return null;
}

function readDOMChange(view, from, to, typeOver, addedNodes) {
  if (from < 0) {
    var origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);

    if (newSel && !view.state.selection.eq(newSel)) {
      var _tr = view.state.tr.setSelection(newSel);

      if (origin == "pointer") _tr.setMeta("pointer", true);else if (origin == "key") _tr.scrollIntoView();
      view.dispatch(_tr);
    }

    return;
  }

  var $before = view.state.doc.resolve(from);
  var shared = $before.sharedDepth(to);
  from = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  var sel = view.state.selection;
  var parse = parseBetween(view, from, to);

  if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {
    var text = view.cursorWrapper.deco.type.toDOM.nextSibling;
    var size = text && text.nodeValue ? text.nodeValue.length : 1;
    parse.sel = {
      anchor: parse.sel.anchor + size,
      head: parse.sel.anchor + size
    };
  }

  var doc = view.state.doc,
      compare = doc.slice(parse.from, parse.to);
  var preferredPos, preferredSide;

  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }

  view.input.lastKeyCode = null;
  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);

  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some(function (n) {
    return n.nodeName == "DIV" || n.nodeName == "P";
  }) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", function (f) {
    return f(view, keyEvent(13, "Enter"));
  })) {
    view.input.lastIOSEnter = 0;
    return;
  }

  if (!change) {
    if (typeOver && sel instanceof prosemirrorState.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = {
        start: sel.from,
        endA: sel.to,
        endB: sel.to
      };
    } else {
      if (parse.sel) {
        var _sel = resolveSelection(view, view.state.doc, parse.sel);

        if (_sel && !_sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(_sel));
      }

      return;
    }
  }

  view.input.domChangeCount++;

  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirrorState.TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }

  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }

  var $from = parse.doc.resolveNoCache(change.start - parse.from);
  var $to = parse.doc.resolveNoCache(change.endB - parse.from);
  var $fromA = doc.resolve(change.start);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  var nextSel;

  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function (n) {
    return n.nodeName == "DIV" || n.nodeName == "P";
  })) || !inlineChange && $from.pos < parse.doc.content.size && (nextSel = prosemirrorState.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function (f) {
    return f(view, keyEvent(13, "Enter"));
  })) {
    view.input.lastIOSEnter = 0;
    return;
  }

  if (view.state.selection.anchor > change.start && looksLikeJoin(doc, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function (f) {
    return f(view, keyEvent(8, "Backspace"));
  })) {
    if (android && chrome) view.domObserver.suppressSelectionUpdates();
    return;
  }

  if (chrome && android && change.endB == change.start) view.input.lastAndroidDelete = Date.now();

  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(function () {
      view.someProp("handleKeyDown", function (f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }

  var chFrom = change.start,
      chTo = change.endA;
  var tr, storedMarks, markChange;

  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function () {
          return selectionToDOM(view);
        }, 20);
      }

      tr = view.state.tr["delete"](chFrom, chTo);
      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
    } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {
      tr = view.state.tr;
      if (markChange.type == "add") tr.addMark(chFrom, chTo, markChange.mark);else tr.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var _text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);

      if (view.someProp("handleTextInput", function (f) {
        return f(view, chFrom, chTo, _text);
      })) return;
      tr = view.state.tr.insertText(_text, chFrom, chTo);
    }
  }

  if (!tr) tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));

  if (parse.sel) {
    var _sel2 = resolveSelection(view, tr.doc, parse.sel);

    if (_sel2 && !(chrome && android && view.composing && _sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (_sel2.head == chFrom || _sel2.head == tr.mapping.map(chTo) - 1) || ie && _sel2.empty && _sel2.head == chFrom)) tr.setSelection(_sel2);
  }

  if (storedMarks) tr.ensureMarks(storedMarks);
  view.dispatch(tr.scrollIntoView());
}

function resolveSelection(view, doc, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null;
  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));
}

function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks,
      prevMarks = prev.firstChild.marks;
  var added = curMarks,
      removed = prevMarks,
      type,
      mark,
      update;

  for (var i = 0; i < prevMarks.length; i++) {
    added = prevMarks[i].removeFromSet(added);
  }

  for (var _i14 = 0; _i14 < curMarks.length; _i14++) {
    removed = curMarks[_i14].removeFromSet(removed);
  }

  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";

    update = function update(node) {
      return node.mark(mark.addToSet(node.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";

    update = function update(node) {
      return node.mark(mark.removeFromSet(node.marks));
    };
  } else {
    return null;
  }

  var updated = [];

  for (var _i15 = 0; _i15 < prev.childCount; _i15++) {
    updated.push(update(prev.child(_i15)));
  }

  if (prosemirrorModel.Fragment.from(updated).eq(cur)) return {
    mark: mark,
    type: type
  };
}

function looksLikeJoin(old, start, end, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end - start <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) return false;
  var $start = old.resolve(start);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) return false;
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}

function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth,
      end = fromEnd ? $pos.end() : $pos.pos;

  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }

  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));

    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }

  return end;
}

function findDiff(a, b, pos, preferredPos, preferredSide) {
  var start = a.findDiffStart(b, pos);
  if (start == null) return null;

  var _a$findDiffEnd = a.findDiffEnd(b, pos + a.size, pos + b.size),
      endA = _a$findDiffEnd.a,
      endB = _a$findDiffEnd.b;

  if (preferredSide == "end") {
    var adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }

  if (endA < start && a.size < b.size) {
    var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    var _move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;

    start -= _move;
    endA = start + (endA - endB);
    endB = start;
  }

  return {
    start: start,
    endA: endA,
    endB: endB
  };
}

var __serializeForClipboard = serializeForClipboard;
var __parseFromClipboard = parseFromClipboard;
var __endComposition = endComposition;

var EditorView = function () {
  function EditorView(place, props) {
    var _this15 = this;

    _classCallCheck(this, EditorView);

    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = undefined;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");

    if (place) {
      if (place.appendChild) place.appendChild(this.dom);else if (typeof place == "function") place(this.dom);else if (place.mount) this.mounted = true;
    }

    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, function (from, to, typeOver, added) {
      return readDOMChange(_this15, from, to, typeOver, added);
    });
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }

  _createClass(EditorView, [{
    key: "composing",
    get: function get() {
      return this.input.composing;
    }
  }, {
    key: "props",
    get: function get() {
      if (this._props.state != this.state) {
        var prev = this._props;
        this._props = {};

        for (var name in prev) {
          this._props[name] = prev[name];
        }

        this._props.state = this.state;
      }

      return this._props;
    }
  }, {
    key: "update",
    value: function update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);
      this._props = props;

      if (props.plugins) {
        props.plugins.forEach(checkStateComponent);
        this.directPlugins = props.plugins;
      }

      this.updateStateInner(props.state, true);
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      var updated = {};

      for (var name in this._props) {
        updated[name] = this._props[name];
      }

      updated.state = this.state;

      for (var _name2 in props) {
        updated[_name2] = props[_name2];
      }

      this.update(updated);
    }
  }, {
    key: "updateState",
    value: function updateState(state) {
      this.updateStateInner(state, this.state.plugins != state.plugins);
    }
  }, {
    key: "updateStateInner",
    value: function updateStateInner(state, reconfigured) {
      var _this16 = this;

      var prev = this.state,
          redraw = false,
          updateSel = false;

      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }

      this.state = state;

      if (reconfigured) {
        var nodeViews = buildNodeViews(this);

        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }

        ensureListeners(this);
      }

      this.editable = getEditable(this);
      updateCursorWrapper(this);
      var innerDeco = viewDecorations(this),
          outerDeco = computeDocDeco(this);
      var scroll = reconfigured ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true;
      var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);

      if (updateSel) {
        this.domObserver.stop();
        var forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);

        if (updateDoc) {
          var chromeKludge = chrome ? this.trackWrites = this.domSelection().focusNode : null;

          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco([]);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }

          if (chromeKludge && !this.trackWrites) forceSelUpdate = true;
        }

        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelection()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }

        this.domObserver.start();
      }

      this.updatePluginViews(prev);

      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        var startDOM = this.domSelection().focusNode;
        if (this.someProp("handleScrollToSelection", function (f) {
          return f(_this16);
        })) ;else if (state.selection instanceof prosemirrorState.NodeSelection) {
          var target = this.docView.domAfterPos(state.selection.from);
          if (target.nodeType == 1) scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
        } else {
          scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM);
        }
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    }
  }, {
    key: "destroyPluginViews",
    value: function destroyPluginViews() {
      var view;

      while (view = this.pluginViews.pop()) {
        if (view.destroy) view.destroy();
      }
    }
  }, {
    key: "updatePluginViews",
    value: function updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins;
        this.destroyPluginViews();

        for (var i = 0; i < this.directPlugins.length; i++) {
          var plugin = this.directPlugins[i];
          if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));
        }

        for (var _i16 = 0; _i16 < this.state.plugins.length; _i16++) {
          var _plugin = this.state.plugins[_i16];
          if (_plugin.spec.view) this.pluginViews.push(_plugin.spec.view(this));
        }
      } else {
        for (var _i17 = 0; _i17 < this.pluginViews.length; _i17++) {
          var pluginView = this.pluginViews[_i17];
          if (pluginView.update) pluginView.update(this, prevState);
        }
      }
    }
  }, {
    key: "someProp",
    value: function someProp(propName, f) {
      var prop = this._props && this._props[propName],
          value;
      if (prop != null && (value = f ? f(prop) : prop)) return value;

      for (var i = 0; i < this.directPlugins.length; i++) {
        var _prop = this.directPlugins[i].props[propName];
        if (_prop != null && (value = f ? f(_prop) : _prop)) return value;
      }

      var plugins = this.state.plugins;
      if (plugins) for (var _i18 = 0; _i18 < plugins.length; _i18++) {
        var _prop2 = plugins[_i18].props[propName];
        if (_prop2 != null && (value = f ? f(_prop2) : _prop2)) return value;
      }
    }
  }, {
    key: "hasFocus",
    value: function hasFocus() {
      return this.root.activeElement == this.dom;
    }
  }, {
    key: "focus",
    value: function focus() {
      this.domObserver.stop();
      if (this.editable) focusPreventScroll(this.dom);
      selectionToDOM(this);
      this.domObserver.start();
    }
  }, {
    key: "root",
    get: function get() {
      var _this17 = this;

      var cached = this._root;

      if (cached == null) {
        var _loop4 = function _loop4(search) {
          if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
            if (!search.getSelection) Object.getPrototypeOf(search).getSelection = function () {
              return search.ownerDocument.getSelection();
            };
            return {
              v: _this17._root = search
            };
          }
        };

        for (var search = this.dom.parentNode; search; search = search.parentNode) {
          var _ret3 = _loop4(search);

          if (_typeof(_ret3) === "object") return _ret3.v;
        }
      }

      return cached || document;
    }
  }, {
    key: "posAtCoords",
    value: function posAtCoords(coords) {
      return _posAtCoords(this, coords);
    }
  }, {
    key: "coordsAtPos",
    value: function coordsAtPos(pos) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return _coordsAtPos(this, pos, side);
    }
  }, {
    key: "domAtPos",
    value: function domAtPos(pos) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.docView.domFromPos(pos, side);
    }
  }, {
    key: "nodeDOM",
    value: function nodeDOM(pos) {
      var desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    }
  }, {
    key: "posAtDOM",
    value: function posAtDOM(node, offset) {
      var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      var pos = this.docView.posFromDOM(node, offset, bias);
      if (pos == null) throw new RangeError("DOM position not inside the editor");
      return pos;
    }
  }, {
    key: "endOfTextblock",
    value: function endOfTextblock(dir, state) {
      return _endOfTextblock(this, state || this.state, dir);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.docView) return;
      destroyInput(this);
      this.destroyPluginViews();

      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }

      this.docView.destroy();
      this.docView = null;
    }
  }, {
    key: "isDestroyed",
    get: function get() {
      return this.docView == null;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      return _dispatchEvent(this, event);
    }
  }, {
    key: "dispatch",
    value: function dispatch(tr) {
      var dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction) dispatchTransaction.call(this, tr);else this.updateState(this.state.apply(tr));
    }
  }, {
    key: "domSelection",
    value: function domSelection() {
      return this.root.getSelection();
    }
  }]);

  return EditorView;
}();

function computeDocDeco(view) {
  var attrs = Object.create(null);
  attrs["class"] = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  attrs.translate = "no";
  view.someProp("attributes", function (value) {
    if (typeof value == "function") value = value(view.state);
    if (value) for (var attr in value) {
      if (attr == "class") attrs["class"] += " " + value[attr];

      if (attr == "style") {
        attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
      } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") attrs[attr] = String(value[attr]);
    }
  });
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}

function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = {
      dom: dom,
      deco: Decoration.widget(view.state.selection.head, dom, {
        raw: true,
        marks: view.markCursor
      })
    };
  } else {
    view.cursorWrapper = null;
  }
}

function getEditable(view) {
  return !view.someProp("editable", function (value) {
    return value(view.state) === false;
  });
}

function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}

function buildNodeViews(view) {
  var result = Object.create(null);

  function add(obj) {
    for (var _prop3 in obj) {
      if (!Object.prototype.hasOwnProperty.call(result, _prop3)) result[_prop3] = obj[_prop3];
    }
  }

  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}

function changedNodeViews(a, b) {
  var nA = 0,
      nB = 0;

  for (var _prop4 in a) {
    if (a[_prop4] != b[_prop4]) return true;
    nA++;
  }

  for (var _ in b) {
    nB++;
  }

  return nA != nB;
}

function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component");
}

exports.Decoration = Decoration;
exports.DecorationSet = DecorationSet;
exports.EditorView = EditorView;
exports.__endComposition = __endComposition;
exports.__parseFromClipboard = __parseFromClipboard;
exports.__serializeForClipboard = __serializeForClipboard;


/***/ }),

/***/ "./node_modules/w3c-keyname/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/w3c-keyname/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({ value: true }));

var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\"",
  229: "Q"
};

var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac;

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];

function keyName(event) {
  // Don't trust event.key in Chrome when there are modifiers until
  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||
    (safari || ie) && event.shiftKey && event.key && event.key.length == 1;
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified";
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name
}

exports.base = base;
exports.keyName = keyName;
exports.shift = shift;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./demo/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFtQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsUUFBUTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLFFBQVE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0UsbUJBQW1CO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLG9CQUFvQjs7Ozs7Ozs7Ozs7QUNyakJQOztBQUViLHdCQUF3QiwyQkFBMkIsc0dBQXNHLHFCQUFxQixtQkFBbUIsOEhBQThIOztBQUUvVCxrREFBa0QsMENBQTBDOztBQUU1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQsa0RBQWtELGlCQUFpQixHQUFHOztBQUV4USwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRywrQ0FBK0MsaUJBQWlCLEdBQUc7O0FBRTVZLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlLDRCQUE0QixtRkFBbUY7O0FBRTFQLHdDQUF3Qyx1QkFBdUIseUZBQXlGOztBQUV4Six1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSw0RUFBNEUsSUFBSSxlQUFlLFlBQVk7O0FBRXhULDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTCw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUYsd0JBQXdCLG1CQUFPLENBQUMsNEVBQW9COztBQUVwRCx1QkFBdUIsbUJBQU8sQ0FBQywwRUFBbUI7O0FBRWxELHVCQUF1QixtQkFBTyxDQUFDLDBFQUFtQjs7QUFFbEQsc0JBQXNCLG1CQUFPLENBQUMsd0VBQWtCOztBQUVoRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdB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QU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIscUJBQXFCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUFFO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQixxQkFBcUI7QUFDckIsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixxQkFBcUI7QUFDckIsNEJBQTRCO0FBQzVCLGdCQUFnQjtBQUNoQixnQkFBZ0I7Ozs7Ozs7Ozs7O0FDL3NCSDs7QUFFYixrQkFBa0IscURBQXFELHNCQUFzQixPQUFPLG1EQUFtRCw2Q0FBNkMsbUJBQW1CLDREQUE0RCxnQkFBZ0Isa0VBQWtFLHdCQUF3Qjs7QUFFN1gsNENBQTRDLGtFQUFrRSxrQ0FBa0MsOEJBQThCOztBQUU5SywyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRywrQ0FBK0MsaUJBQWlCLEdBQUc7O0FBRTVZLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlLDRCQUE0QixtRkFBbUY7O0FBRTFQLHdDQUF3Qyx1QkFBdUIseUZBQXlGOztBQUV4SixtQ0FBbUMsZ0VBQWdFLHNEQUFzRCwrREFBK0QsbUNBQW1DLDZFQUE2RSxxQ0FBcUMsaURBQWlELDhCQUE4QixxQkFBcUIsMEVBQTBFLHFEQUFxRCxlQUFlLHlFQUF5RSxHQUFHLDJDQUEyQzs7QUFFdHRCLDJDQUEyQyxtQ0FBbUMsa0NBQWtDLE9BQU8sd0RBQXdELGdCQUFnQix1QkFBdUIsa0RBQWtELGtDQUFrQyx1REFBdUQsc0JBQXNCOztBQUV2WCx1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSw0RUFBNEUsSUFBSSxlQUFlLFlBQVk7O0FBRXhULGlDQUFpQzs7QUFFakMsaUNBQWlDLDRFQUE0RSxpQkFBaUIsYUFBYTs7QUFFM0ksOEJBQThCLGdHQUFnRyxtREFBbUQ7O0FBRWpMLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7O0FBRXhRLHdCQUF3QiwyQkFBMkIsc0dBQXNHLHFCQUFxQixtQkFBbUIsOEhBQThIOztBQUUvVCw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUYsaUJBQWlCLG1CQUFPLENBQUMsNERBQVk7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnSEFBZ0g7QUFDaEg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkJBQTZCLHlCQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsNkRBQTZEO0FBQ3JHO0FBQ0E7O0FBRUEsd0NBQXdDLGdFQUFnRTtBQUN4RztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpSUFBaUk7QUFDakk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEZBQThGLFFBQVE7QUFDdEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FB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QUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtREFBbUQsb0JBQW9CO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxRQUFRO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJHQUEyRztBQUMzRztBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLHNCQUFzQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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Q0E7O0FBRUEsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsd0NBQXdDO0FBQ2xGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFD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QUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWlFLDBDQUEwQztBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7QUFDdkg7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCxxREFBcUQ7QUFDOUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsa0NBQWtDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyx1QkFBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNB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QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BOzs7OztVRUFBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9zcmMvY29kZW1hcmsuY3NzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3JvcGUtc2VxdWVuY2UvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL3NyYy9jb2RlbWFyay5jc3M/MzU5MCIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vZGVtby9jb21wYXJlLnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vZGVtby9pbmRleC50cyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL3NyYy9hY3Rpb25zLnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vc3JjL2lucHV0UnVsZXMudHMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9zcmMvcGx1Z2luLnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vc3JjL3R5cGVzLnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vc3JjL3V0aWxzLnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL2NyZWx0L2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL29yZGVyZWRtYXAvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZHJvcGN1cnNvci9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1leGFtcGxlLXNldHVwL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWdhcGN1cnNvci9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1oaXN0b3J5L2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWlucHV0cnVsZXMvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Ita2V5bWFwL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLW1lbnUvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc2NoZW1hLWJhc2ljL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXNjaGVtYS1saXN0L2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXN0YXRlL2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXRyYW5zZm9ybS9kaXN0L2luZGV4LmNqcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci12aWV3L2Rpc3QvaW5kZXguY2pzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrLy4vbm9kZV9tb2R1bGVzL3czYy1rZXluYW1lL2luZGV4LmNqcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItY29kZW1hcmsvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrL3dlYnBhY2svcnVudGltZS9ub25jZSIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL3Byb3NlbWlycm9yLWNvZGVtYXJrL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1jb2RlbWFyay93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJAa2V5ZnJhbWVzIGJsaW5rIHtcXG4gIDQ5JSB7XFxuICAgIGJvcmRlci1jb2xvcjogdW5zZXQ7XFxuICB9XFxuICA1MCUge1xcbiAgICBib3JkZXItY29sb3I6ICNmZmY7XFxuICB9XFxuICA5OSUge1xcbiAgICBib3JkZXItY29sb3I6ICNmZmY7XFxuICB9XFxufVxcbi5uby1jdXJzb3Ige1xcbiAgY2FyZXQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5kaXY6Zm9jdXMgLmZha2UtY3Vyc29yLFxcbnNwYW46Zm9jdXMgLmZha2UtY3Vyc29yIHtcXG4gIG1hcmdpbi1yaWdodDogLTFweDtcXG4gIGJvcmRlci1sZWZ0LXdpZHRoOiAxcHg7XFxuICBib3JkZXItbGVmdC1zdHlsZTogc29saWQ7XFxuICBhbmltYXRpb246IGJsaW5rIDFzO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB6LWluZGV4OiAxO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY29kZW1hcmsuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0U7SUFDRSxtQkFBbUI7RUFDckI7RUFDQTtJQUNFLGtCQUFrQjtFQUNwQjtFQUNBO0lBQ0Usa0JBQWtCO0VBQ3BCO0FBQ0Y7QUFDQTtFQUNFLHdCQUF3QjtBQUMxQjtBQUNBOztFQUVFLGtCQUFrQjtFQUNsQixzQkFBc0I7RUFDdEIsd0JBQXdCO0VBQ3hCLG1CQUFtQjtFQUNuQixtQ0FBbUM7RUFDbkMsa0JBQWtCO0VBQ2xCLFVBQVU7QUFDWlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAa2V5ZnJhbWVzIGJsaW5rIHtcXG4gIDQ5JSB7XFxuICAgIGJvcmRlci1jb2xvcjogdW5zZXQ7XFxuICB9XFxuICA1MCUge1xcbiAgICBib3JkZXItY29sb3I6ICNmZmY7XFxuICB9XFxuICA5OSUge1xcbiAgICBib3JkZXItY29sb3I6ICNmZmY7XFxuICB9XFxufVxcbi5uby1jdXJzb3Ige1xcbiAgY2FyZXQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5kaXY6Zm9jdXMgLmZha2UtY3Vyc29yLFxcbnNwYW46Zm9jdXMgLmZha2UtY3Vyc29yIHtcXG4gIG1hcmdpbi1yaWdodDogLTFweDtcXG4gIGJvcmRlci1sZWZ0LXdpZHRoOiAxcHg7XFxuICBib3JkZXItbGVmdC1zdHlsZTogc29saWQ7XFxuICBhbmltYXRpb246IGJsaW5rIDFzO1xcbiAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB6LWluZGV4OiAxO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwidmFyIEdPT0RfTEVBRl9TSVpFID0gMjAwO1xuXG4vLyA6OiBjbGFzczxUPiBBIHJvcGUgc2VxdWVuY2UgaXMgYSBwZXJzaXN0ZW50IHNlcXVlbmNlIGRhdGEgc3RydWN0dXJlXG4vLyB0aGF0IHN1cHBvcnRzIGFwcGVuZGluZywgcHJlcGVuZGluZywgYW5kIHNsaWNpbmcgd2l0aG91dCBkb2luZyBhXG4vLyBmdWxsIGNvcHkuIEl0IGlzIHJlcHJlc2VudGVkIGFzIGEgbW9zdGx5LWJhbGFuY2VkIHRyZWUuXG52YXIgUm9wZVNlcXVlbmNlID0gZnVuY3Rpb24gUm9wZVNlcXVlbmNlICgpIHt9O1xuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAob3RoZXIpIHtcbiAgaWYgKCFvdGhlci5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICBvdGhlciA9IFJvcGVTZXF1ZW5jZS5mcm9tKG90aGVyKTtcblxuICByZXR1cm4gKCF0aGlzLmxlbmd0aCAmJiBvdGhlcikgfHxcbiAgICAob3RoZXIubGVuZ3RoIDwgR09PRF9MRUFGX1NJWkUgJiYgdGhpcy5sZWFmQXBwZW5kKG90aGVyKSkgfHxcbiAgICAodGhpcy5sZW5ndGggPCBHT09EX0xFQUZfU0laRSAmJiBvdGhlci5sZWFmUHJlcGVuZCh0aGlzKSkgfHxcbiAgICB0aGlzLmFwcGVuZElubmVyKG90aGVyKVxufTtcblxuLy8gOjogKHVuaW9uPFtUXSwgUm9wZVNlcXVlbmNlPFQ+Pikg4oaSIFJvcGVTZXF1ZW5jZTxUPlxuLy8gUHJlcGVuZCBhbiBhcnJheSBvciBvdGhlciByb3BlIHRvIHRoaXMgb25lLCByZXR1cm5pbmcgYSBuZXcgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQgKG90aGVyKSB7XG4gIGlmICghb3RoZXIubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgcmV0dXJuIFJvcGVTZXF1ZW5jZS5mcm9tKG90aGVyKS5hcHBlbmQodGhpcylcbn07XG5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuYXBwZW5kSW5uZXIgPSBmdW5jdGlvbiBhcHBlbmRJbm5lciAob3RoZXIpIHtcbiAgcmV0dXJuIG5ldyBBcHBlbmQodGhpcywgb3RoZXIpXG59O1xuXG4vLyA6OiAoP251bWJlciwgP251bWJlcikg4oaSIFJvcGVTZXF1ZW5jZTxUPlxuLy8gQ3JlYXRlIGEgcm9wZSByZXBlc2VudGluZyBhIHN1Yi1zZXF1ZW5jZSBvZiB0aGlzIHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChmcm9tID49IHRvKSB7IHJldHVybiBSb3BlU2VxdWVuY2UuZW1wdHkgfVxuICByZXR1cm4gdGhpcy5zbGljZUlubmVyKE1hdGgubWF4KDAsIGZyb20pLCBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdG8pKVxufTtcblxuLy8gOjogKG51bWJlcikg4oaSIFRcbi8vIFJldHJpZXZlIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBmcm9tIHRoaXMgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB7IHJldHVybiB1bmRlZmluZWQgfVxuICByZXR1cm4gdGhpcy5nZXRJbm5lcihpKVxufTtcblxuLy8gOjogKChlbGVtZW50OiBULCBpbmRleDogbnVtYmVyKSDihpIgP2Jvb2wsID9udW1iZXIsID9udW1iZXIpXG4vLyBDYWxsIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGJldHdlZW4gdGhlIGdpdmVuXG4vLyBpbmRpY2VzLiBUaGlzIHRlbmRzIHRvIGJlIG1vcmUgZWZmaWNpZW50IHRoYW4gbG9vcGluZyBvdmVyIHRoZVxuLy8gaW5kaWNlcyBhbmQgY2FsbGluZyBgZ2V0YCwgYmVjYXVzZSBpdCBkb2Vzbid0IGhhdmUgdG8gZGVzY2VuZCB0aGVcbi8vIHRyZWUgZm9yIGV2ZXJ5IGVsZW1lbnQuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChmLCBmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZnJvbSA8PSB0bylcbiAgICB7IHRoaXMuZm9yRWFjaElubmVyKGYsIGZyb20sIHRvLCAwKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmZvckVhY2hJbnZlcnRlZElubmVyKGYsIGZyb20sIHRvLCAwKTsgfVxufTtcblxuLy8gOjogKChlbGVtZW50OiBULCBpbmRleDogbnVtYmVyKSDihpIgVSwgP251bWJlciwgP251bWJlcikg4oaSIFtVXVxuLy8gTWFwIHRoZSBnaXZlbiBmdW5jdGlvbnMgb3ZlciB0aGUgZWxlbWVudHMgb2YgdGhlIHJvcGUsIHByb2R1Y2luZ1xuLy8gYSBmbGF0IGFycmF5LlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKGYsIGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbHQsIGkpIHsgcmV0dXJuIHJlc3VsdC5wdXNoKGYoZWx0LCBpKSk7IH0sIGZyb20sIHRvKTtcbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuLy8gOjogKD91bmlvbjxbVF0sIFJvcGVTZXF1ZW5jZTxUPj4pIOKGkiBSb3BlU2VxdWVuY2U8VD5cbi8vIENyZWF0ZSBhIHJvcGUgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBhcnJheSwgb3IgcmV0dXJuIHRoZSByb3BlXG4vLyBpdHNlbGYgaWYgYSByb3BlIHdhcyBnaXZlbi5cblJvcGVTZXF1ZW5jZS5mcm9tID0gZnVuY3Rpb24gZnJvbSAodmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBSb3BlU2VxdWVuY2UpIHsgcmV0dXJuIHZhbHVlcyB9XG4gIHJldHVybiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCA/IG5ldyBMZWFmKHZhbHVlcykgOiBSb3BlU2VxdWVuY2UuZW1wdHlcbn07XG5cbnZhciBMZWFmID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUm9wZVNlcXVlbmNlKSB7XG4gIGZ1bmN0aW9uIExlYWYodmFsdWVzKSB7XG4gICAgUm9wZVNlcXVlbmNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cblxuICBpZiAoIFJvcGVTZXF1ZW5jZSApIExlYWYuX19wcm90b19fID0gUm9wZVNlcXVlbmNlO1xuICBMZWFmLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJvcGVTZXF1ZW5jZSAmJiBSb3BlU2VxdWVuY2UucHJvdG90eXBlICk7XG4gIExlYWYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGVhZjtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBsZW5ndGg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZGVwdGg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBMZWFmLnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuc2xpY2VJbm5lciA9IGZ1bmN0aW9uIHNsaWNlSW5uZXIgKGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gICAgcmV0dXJuIG5ldyBMZWFmKHRoaXMudmFsdWVzLnNsaWNlKGZyb20sIHRvKSlcbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5nZXRJbm5lciA9IGZ1bmN0aW9uIGdldElubmVyIChpKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzW2ldXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZm9yRWFjaElubmVyID0gZnVuY3Rpb24gZm9yRWFjaElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICB7IGlmIChmKHRoaXMudmFsdWVzW2ldLCBzdGFydCArIGkpID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZm9yRWFjaEludmVydGVkSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW52ZXJ0ZWRJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IGZyb20gLSAxOyBpID49IHRvOyBpLS0pXG4gICAgICB7IGlmIChmKHRoaXMudmFsdWVzW2ldLCBzdGFydCArIGkpID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUubGVhZkFwcGVuZCA9IGZ1bmN0aW9uIGxlYWZBcHBlbmQgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoIDw9IEdPT0RfTEVBRl9TSVpFKVxuICAgICAgeyByZXR1cm4gbmV3IExlYWYodGhpcy52YWx1ZXMuY29uY2F0KG90aGVyLmZsYXR0ZW4oKSkpIH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5sZWFmUHJlcGVuZCA9IGZ1bmN0aW9uIGxlYWZQcmVwZW5kIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCA8PSBHT09EX0xFQUZfU0laRSlcbiAgICAgIHsgcmV0dXJuIG5ldyBMZWFmKG90aGVyLmZsYXR0ZW4oKS5jb25jYXQodGhpcy52YWx1ZXMpKSB9XG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmxlbmd0aC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGggfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuZGVwdGguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMZWFmLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIExlYWY7XG59KFJvcGVTZXF1ZW5jZSkpO1xuXG4vLyA6OiBSb3BlU2VxdWVuY2Vcbi8vIFRoZSBlbXB0eSByb3BlIHNlcXVlbmNlLlxuUm9wZVNlcXVlbmNlLmVtcHR5ID0gbmV3IExlYWYoW10pO1xuXG52YXIgQXBwZW5kID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUm9wZVNlcXVlbmNlKSB7XG4gIGZ1bmN0aW9uIEFwcGVuZChsZWZ0LCByaWdodCkge1xuICAgIFJvcGVTZXF1ZW5jZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMubGVuZ3RoID0gbGVmdC5sZW5ndGggKyByaWdodC5sZW5ndGg7XG4gICAgdGhpcy5kZXB0aCA9IE1hdGgubWF4KGxlZnQuZGVwdGgsIHJpZ2h0LmRlcHRoKSArIDE7XG4gIH1cblxuICBpZiAoIFJvcGVTZXF1ZW5jZSApIEFwcGVuZC5fX3Byb3RvX18gPSBSb3BlU2VxdWVuY2U7XG4gIEFwcGVuZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSb3BlU2VxdWVuY2UgJiYgUm9wZVNlcXVlbmNlLnByb3RvdHlwZSApO1xuICBBcHBlbmQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXBwZW5kO1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4gKCkge1xuICAgIHJldHVybiB0aGlzLmxlZnQuZmxhdHRlbigpLmNvbmNhdCh0aGlzLnJpZ2h0LmZsYXR0ZW4oKSlcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmdldElubmVyID0gZnVuY3Rpb24gZ2V0SW5uZXIgKGkpIHtcbiAgICByZXR1cm4gaSA8IHRoaXMubGVmdC5sZW5ndGggPyB0aGlzLmxlZnQuZ2V0KGkpIDogdGhpcy5yaWdodC5nZXQoaSAtIHRoaXMubGVmdC5sZW5ndGgpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mb3JFYWNoSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAoZnJvbSA8IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hJbm5lcihmLCBmcm9tLCBNYXRoLm1pbih0bywgbGVmdExlbiksIHN0YXJ0KSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRvID4gbGVmdExlbiAmJlxuICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hJbm5lcihmLCBNYXRoLm1heChmcm9tIC0gbGVmdExlbiwgMCksIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykgLSBsZWZ0TGVuLCBzdGFydCArIGxlZnRMZW4pID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmZvckVhY2hJbnZlcnRlZElubmVyID0gZnVuY3Rpb24gZm9yRWFjaEludmVydGVkSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAoZnJvbSA+IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBmcm9tIC0gbGVmdExlbiwgTWF0aC5tYXgodG8sIGxlZnRMZW4pIC0gbGVmdExlbiwgc3RhcnQgKyBsZWZ0TGVuKSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRvIDwgbGVmdExlbiAmJlxuICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgTWF0aC5taW4oZnJvbSwgbGVmdExlbiksIHRvLCBzdGFydCkgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuc2xpY2VJbm5lciA9IGZ1bmN0aW9uIHNsaWNlSW5uZXIgKGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmICh0byA8PSBsZWZ0TGVuKSB7IHJldHVybiB0aGlzLmxlZnQuc2xpY2UoZnJvbSwgdG8pIH1cbiAgICBpZiAoZnJvbSA+PSBsZWZ0TGVuKSB7IHJldHVybiB0aGlzLnJpZ2h0LnNsaWNlKGZyb20gLSBsZWZ0TGVuLCB0byAtIGxlZnRMZW4pIH1cbiAgICByZXR1cm4gdGhpcy5sZWZ0LnNsaWNlKGZyb20sIGxlZnRMZW4pLmFwcGVuZCh0aGlzLnJpZ2h0LnNsaWNlKDAsIHRvIC0gbGVmdExlbikpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5sZWFmQXBwZW5kID0gZnVuY3Rpb24gbGVhZkFwcGVuZCAob3RoZXIpIHtcbiAgICB2YXIgaW5uZXIgPSB0aGlzLnJpZ2h0LmxlYWZBcHBlbmQob3RoZXIpO1xuICAgIGlmIChpbm5lcikgeyByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLmxlZnQsIGlubmVyKSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5sZWFmUHJlcGVuZCA9IGZ1bmN0aW9uIGxlYWZQcmVwZW5kIChvdGhlcikge1xuICAgIHZhciBpbm5lciA9IHRoaXMubGVmdC5sZWFmUHJlcGVuZChvdGhlcik7XG4gICAgaWYgKGlubmVyKSB7IHJldHVybiBuZXcgQXBwZW5kKGlubmVyLCB0aGlzLnJpZ2h0KSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5hcHBlbmRJbm5lciA9IGZ1bmN0aW9uIGFwcGVuZElubmVyIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlZnQuZGVwdGggPj0gTWF0aC5tYXgodGhpcy5yaWdodC5kZXB0aCwgb3RoZXIuZGVwdGgpICsgMSlcbiAgICAgIHsgcmV0dXJuIG5ldyBBcHBlbmQodGhpcy5sZWZ0LCBuZXcgQXBwZW5kKHRoaXMucmlnaHQsIG90aGVyKSkgfVxuICAgIHJldHVybiBuZXcgQXBwZW5kKHRoaXMsIG90aGVyKVxuICB9O1xuXG4gIHJldHVybiBBcHBlbmQ7XG59KFJvcGVTZXF1ZW5jZSkpO1xuXG52YXIgcm9wZVNlcXVlbmNlID0gUm9wZVNlcXVlbmNlO1xuXG5leHBvcnQgZGVmYXVsdCByb3BlU2VxdWVuY2U7XG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vY29kZW1hcmsuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9jb2RlbWFyay5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcblxuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdXBkYXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cblxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cblxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuXG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cblxuICBjc3MgKz0gb2JqLmNzcztcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwiaW1wb3J0IHsgSW5wdXRSdWxlLCBpbnB1dFJ1bGVzIH0gZnJvbSAncHJvc2VtaXJyb3ItaW5wdXRydWxlcyc7XG5pbXBvcnQgeyBNYXJrVHlwZSwgU2NoZW1hIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG4vLyBodHRwczovL2Rpc2N1c3MucHJvc2VtaXJyb3IubmV0L3QvaW5wdXQtcnVsZXMtZm9yLXdyYXBwaW5nLW1hcmtzLzUzNy8xMVxuZnVuY3Rpb24gbWFya0lucHV0UnVsZShyZWdleHA6IFJlZ0V4cCwgbWFya1R5cGU6IE1hcmtUeXBlKSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHJlZ2V4cCwgKHN0YXRlLCBtYXRjaCwgc3RhcnQsIGVuZCkgPT4ge1xuICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xuICAgIGlmIChzdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKHN0YXJ0LCBlbmQsIG1hcmtUeXBlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1hcmsgPSBtYXJrVHlwZS5jcmVhdGUoKTtcbiAgICB0ci5kZWxldGUoc3RhcnQsIGVuZCk7XG4gICAgY29uc3QgdGV4dCA9IG1hdGNoWzFdO1xuICAgIHRyLmluc2VydFRleHQodGV4dCk7XG4gICAgdHIuYWRkTWFyayhzdGFydCwgc3RhcnQgKyB0ZXh0Lmxlbmd0aCwgbWFyayk7XG4gICAgdHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSk7XG4gICAgcmV0dXJuIHRyO1xuICB9KTtcbn1cblxuY29uc3QgY29kZUlubGluZSA9IChzY2hlbWE6IFNjaGVtYSkgPT4gW21hcmtJbnB1dFJ1bGUoL2AoW1xcV1xcd10rKWAkLywgc2NoZW1hLm1hcmtzLmNvZGUpXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2ljUGx1Z2luKHNjaGVtYTogU2NoZW1hKSB7XG4gIHJldHVybiBbaW5wdXRSdWxlcyh7IHJ1bGVzOiBjb2RlSW5saW5lKHNjaGVtYSkgfSldO1xufVxuIiwiaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5pbXBvcnQgeyBET01QYXJzZXIgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBzY2hlbWEgfSBmcm9tICdwcm9zZW1pcnJvci1zY2hlbWEtYmFzaWMnO1xuaW1wb3J0IHsgZXhhbXBsZVNldHVwIH0gZnJvbSAncHJvc2VtaXJyb3ItZXhhbXBsZS1zZXR1cCc7XG5pbXBvcnQgY29kZW1hcmsgZnJvbSAnLi4vc3JjJztcbmltcG9ydCAnLi4vc3JjL2NvZGVtYXJrLmNzcyc7XG5pbXBvcnQgeyBiYXNpY1BsdWdpbiB9IGZyb20gJy4vY29tcGFyZSc7XG5cbmNvbnN0IGVkaXRvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNlZGl0b3InKSBhcyBIVE1MRGl2RWxlbWVudDtcbmNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY29udGVudCcpIGFzIEhUTUxEaXZFbGVtZW50O1xuXG4od2luZG93IGFzIGFueSkudmlldyA9IG5ldyBFZGl0b3JWaWV3KGVkaXRvciwge1xuICBzdGF0ZTogRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICBkb2M6IERPTVBhcnNlci5mcm9tU2NoZW1hKHNjaGVtYSkucGFyc2UoY29udGVudCksXG4gICAgcGx1Z2luczogW1xuICAgICAgLi4uY29kZW1hcmsoeyBtYXJrVHlwZTogc2NoZW1hLm1hcmtzLmNvZGUgfSksXG4gICAgICAuLi5leGFtcGxlU2V0dXAoeyBzY2hlbWEsIG1lbnVCYXI6IGZhbHNlIH0pLFxuICAgIF0sXG4gIH0pLFxufSk7XG5cbi8vIFRoaXMgaXMgc2hvd2luZyB3aGF0IG5vdCB0byBkbyEhXG5jb25zdCBlZGl0b3IxID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2VkaXRvcjEnKSBhcyBIVE1MRGl2RWxlbWVudDtcbmNvbnN0IGNvbnRlbnQxID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NvbnRlbnQxJykgYXMgSFRNTERpdkVsZW1lbnQ7XG4od2luZG93IGFzIGFueSkudmlldzEgPSBuZXcgRWRpdG9yVmlldyhlZGl0b3IxLCB7XG4gIHN0YXRlOiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgIGRvYzogRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShjb250ZW50MSksXG4gICAgcGx1Z2luczogWy4uLmJhc2ljUGx1Z2luKHNjaGVtYSksIC4uLmV4YW1wbGVTZXR1cCh7IHNjaGVtYSwgbWVudUJhcjogZmFsc2UgfSldLFxuICB9KSxcbn0pO1xuIiwiaW1wb3J0IHR5cGUgeyBNYXJrVHlwZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IEVkaXRvclN0YXRlLCBQbHVnaW4sIFRleHRTZWxlY3Rpb24sIFRyYW5zYWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHR5cGUgeyBFZGl0b3JWaWV3IH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5pbXBvcnQgdHlwZSB7IENvZGVtYXJrU3RhdGUsIEN1cnNvck1ldGFUciB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgTUFYX01BVENILCBzYWZlUmVzb2x2ZSB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RlcE91dHNpZGVOZXh0VHJBbmRQYXNzKFxuICB2aWV3OiBFZGl0b3JWaWV3LFxuICBwbHVnaW46IFBsdWdpbixcbiAgYWN0aW9uOiAnY2xpY2snIHwgJ25leHQnID0gJ25leHQnLFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IG1ldGE6IEN1cnNvck1ldGFUciA9IHsgYWN0aW9uIH07XG4gIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRNZXRhKHBsdWdpbiwgbWV0YSkpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkJhY2t0aWNrKFxuICB2aWV3OiBFZGl0b3JWaWV3LFxuICBwbHVnaW46IFBsdWdpbixcbiAgZXZlbnQ6IEtleWJvYXJkRXZlbnQsXG4gIG1hcmtUeXBlOiBNYXJrVHlwZSxcbik6IGJvb2xlYW4ge1xuICBpZiAodmlldy5zdGF0ZS5zZWxlY3Rpb24uZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkpIHJldHVybiBmYWxzZTtcbiAgLy8gQ3JlYXRlIGEgY29kZSBtYXJrIVxuICBjb25zdCB7IGZyb20sIHRvIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKHRvIC0gZnJvbSA+PSBNQVhfTUFUQ0ggfHwgdmlldy5zdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKGZyb20sIHRvLCBtYXJrVHlwZSkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyLmFkZE1hcmsoZnJvbSwgdG8sIG1hcmtUeXBlLmNyZWF0ZSgpKTtcbiAgY29uc3Qgc2VsZWN0ZWQgPSB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCB0bykpLnJlbW92ZVN0b3JlZE1hcmsobWFya1R5cGUpO1xuICB2aWV3LmRpc3BhdGNoKHNlbGVjdGVkKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQXJyb3dSaWdodEluc2lkZShcbiAgdmlldzogRWRpdG9yVmlldyxcbiAgcGx1Z2luOiBQbHVnaW4sXG4gIGV2ZW50OiBLZXlib2FyZEV2ZW50LFxuICBtYXJrVHlwZTogTWFya1R5cGUsXG4pOiBib29sZWFuIHtcbiAgaWYgKGV2ZW50Lm1ldGFLZXkpIHJldHVybiBzdGVwT3V0c2lkZU5leHRUckFuZFBhc3ModmlldywgcGx1Z2luKTtcbiAgaWYgKGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5KSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHZpZXcuc3RhdGU7XG4gIGlmICghc2VsZWN0aW9uLmVtcHR5KSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHBsdWdpblN0YXRlID0gcGx1Z2luLmdldFN0YXRlKHZpZXcuc3RhdGUpIGFzIENvZGVtYXJrU3RhdGU7XG4gIGNvbnN0IHBvcyA9IHNlbGVjdGlvbi4kZnJvbTtcbiAgY29uc3QgaW5Db2RlID0gISFtYXJrVHlwZS5pc0luU2V0KHBvcy5tYXJrcygpKTtcbiAgY29uc3QgbmV4dENvZGUgPSAhIW1hcmtUeXBlLmlzSW5TZXQocG9zLm1hcmtzQWNyb3NzKHNhZmVSZXNvbHZlKGRvYywgc2VsZWN0aW9uLmZyb20gKyAxKSkgPz8gW10pO1xuXG4gIGlmIChcbiAgICBwb3MucG9zID09PSB2aWV3LnN0YXRlLmRvYy5ub2RlU2l6ZSAtIDMgJiZcbiAgICBwb3MucGFyZW50T2Zmc2V0ID09PSBwb3MucGFyZW50Lm5vZGVTaXplIC0gMiAmJlxuICAgIHBsdWdpblN0YXRlPy5hY3RpdmVcbiAgKSB7XG4gICAgLy8gQmVoYXZpb3VyIHN0b3BzOiBgY29kZWB8IGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnJlbW92ZVN0b3JlZE1hcmsobWFya1R5cGUpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaW5Db2RlID09PSBuZXh0Q29kZSAmJiBwb3MucGFyZW50T2Zmc2V0ICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmIChpbkNvZGUgJiYgKCFwbHVnaW5TdGF0ZT8uYWN0aXZlIHx8IHBsdWdpblN0YXRlLnNpZGUgPT09IC0xKSAmJiBwb3MucGFyZW50T2Zmc2V0ICE9PSAwKSB7XG4gICAgLy8gYGNvZGV8YCAtLT4gYGNvZGVgfFxuICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG5leHRDb2RlICYmIHBsdWdpblN0YXRlPy5zaWRlID09PSAtMSkge1xuICAgIC8vIHxgY29kZWAgLS0+IGB8Y29kZWBcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoKSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uQXJyb3dSaWdodChcbiAgdmlldzogRWRpdG9yVmlldyxcbiAgcGx1Z2luOiBQbHVnaW4sXG4gIGV2ZW50OiBLZXlib2FyZEV2ZW50LFxuICBtYXJrVHlwZTogTWFya1R5cGUsXG4pOiBib29sZWFuIHtcbiAgY29uc3QgaGFuZGxlZCA9IG9uQXJyb3dSaWdodEluc2lkZSh2aWV3LCBwbHVnaW4sIGV2ZW50LCBtYXJrVHlwZSk7XG4gIGlmIChoYW5kbGVkKSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHZpZXcuc3RhdGU7XG4gIGNvbnN0IHBvcyA9IHNlbGVjdGlvbi4kZnJvbTtcbiAgaWYgKHNlbGVjdGlvbi5lbXB0eSAmJiBwb3MucGFyZW50T2Zmc2V0ID09PSBwb3MucGFyZW50Lm5vZGVTaXplIC0gMikge1xuICAgIHJldHVybiBzdGVwT3V0c2lkZU5leHRUckFuZFBhc3ModmlldywgcGx1Z2luKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQXJyb3dMZWZ0SW5zaWRlKFxuICB2aWV3OiBFZGl0b3JWaWV3LFxuICBwbHVnaW46IFBsdWdpbixcbiAgZXZlbnQ6IEtleWJvYXJkRXZlbnQsXG4gIG1hcmtUeXBlOiBNYXJrVHlwZSxcbik6IGJvb2xlYW4ge1xuICBpZiAoZXZlbnQubWV0YUtleSkgcmV0dXJuIHN0ZXBPdXRzaWRlTmV4dFRyQW5kUGFzcyh2aWV3LCBwbHVnaW4pO1xuICBpZiAoZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdmlldy5zdGF0ZTtcbiAgY29uc3QgcGx1Z2luU3RhdGUgPSBwbHVnaW4uZ2V0U3RhdGUodmlldy5zdGF0ZSkgYXMgQ29kZW1hcmtTdGF0ZTtcbiAgY29uc3QgaW5Db2RlID0gISFtYXJrVHlwZS5pc0luU2V0KHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgY29uc3QgbmV4dENvZGUgPSAhIW1hcmtUeXBlLmlzSW5TZXQoXG4gICAgc2FmZVJlc29sdmUoZG9jLCBzZWxlY3Rpb24uZW1wdHkgPyBzZWxlY3Rpb24uZnJvbSAtIDEgOiBzZWxlY3Rpb24uZnJvbSArIDEpLm1hcmtzKCkgPz8gW10sXG4gICk7XG4gIGlmIChpbkNvZGUgJiYgcGx1Z2luU3RhdGU/LnNpZGUgPT09IC0xICYmIHNlbGVjdGlvbi4kZnJvbS5wYXJlbnRPZmZzZXQgPT09IDApIHtcbiAgICAvLyBOZXcgbGluZSFcbiAgICAvLyBefGBjb2RlYCAtLT4gfF5gY29kZWBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHBsdWdpblN0YXRlPy5zaWRlID09PSAwICYmIHNlbGVjdGlvbi4kZnJvbS5wYXJlbnRPZmZzZXQgPT09IDApIHtcbiAgICAvLyBOZXcgbGluZSFcbiAgICAvLyBeYHxjb2RlYCAtLT4gXnxgY29kZWBcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbkNvZGUgJiYgbmV4dENvZGUgJiYgcGx1Z2luU3RhdGU/LnNpZGUgPT09IDApIHtcbiAgICAvLyBgY29kZWB8IC0tPiBgY29kZXxgXG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKCkpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaW5Db2RlICYmICFuZXh0Q29kZSAmJiBwbHVnaW5TdGF0ZT8uYWN0aXZlICYmIHNlbGVjdGlvbi4kZnJvbS5wYXJlbnRPZmZzZXQgPT09IDApIHtcbiAgICAvLyBeYHxjb2RlYCAtLT4gXnxgY29kZWBcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaW5Db2RlICYmIHBsdWdpblN0YXRlPy5hY3RpdmUgJiYgcGx1Z2luU3RhdGU/LnNpZGUgPT09IDApIHtcbiAgICAvLyBgfGNvZGVgIC0tPiB8YGNvZGVgXG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnJlbW92ZVN0b3JlZE1hcmsobWFya1R5cGUpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaW5Db2RlID09PSBuZXh0Q29kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobmV4dENvZGUgfHwgKCFzZWxlY3Rpb24uZW1wdHkgJiYgaW5Db2RlKSkge1xuICAgIC8vIGBjb2RlYF98XyAtLT4gYGNvZGVgfCAgIG5leHRDb2RlXG4gICAgLy8gYGNvZGVg4paI4paI4paIIC0tPiBgY29kZWB8ICAgIXNlbGVjdGlvbi5lbXB0eSAmJiBpbkNvZGVcbiAgICAvLyBg4paI4paIZGVgX19fIC0tPiBgfGNvZGVgICAgIXNlbGVjdGlvbi5lbXB0eSAmJiBuZXh0Q29kZVxuICAgIGNvbnN0IGZyb20gPSBzZWxlY3Rpb24uZW1wdHkgPyBzZWxlY3Rpb24uZnJvbSAtIDEgOiBzZWxlY3Rpb24uZnJvbTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgZnJvbSkpO1xuICAgIGlmICghc2VsZWN0aW9uLmVtcHR5ICYmIG5leHRDb2RlKSB7XG4gICAgICB2aWV3LmRpc3BhdGNoKHNlbGVjdGVkLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKCkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5kaXNwYXRjaChzZWxlY3RlZC5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgobmV4dENvZGUgfHwgKCFzZWxlY3Rpb24uZW1wdHkgJiYgaW5Db2RlKSkgJiYgIXBsdWdpblN0YXRlPy5hY3RpdmUpIHtcbiAgICAvLyBgY29kZWBffF8gLS0+IGBjb2RlYHxcbiAgICAvLyBgY29kZWDilojilojiloggLS0+IGBjb2RlYHxcbiAgICBjb25zdCBmcm9tID0gc2VsZWN0aW9uLmVtcHR5ID8gc2VsZWN0aW9uLmZyb20gLSAxIDogc2VsZWN0aW9uLmZyb207XG4gICAgdmlldy5kaXNwYXRjaChcbiAgICAgIHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgZnJvbSkpLnJlbW92ZVN0b3JlZE1hcmsobWFya1R5cGUpLFxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGluQ29kZSAmJiAhcGx1Z2luU3RhdGU/LmFjdGl2ZSAmJiBzZWxlY3Rpb24uJGZyb20ucGFyZW50T2Zmc2V0ID4gMCkge1xuICAgIC8vIGBjfG9kZWAgLS0+IGB8Y29kZWBcbiAgICB2aWV3LmRpc3BhdGNoKFxuICAgICAgdmlldy5zdGF0ZS50clxuICAgICAgICAuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgc2VsZWN0aW9uLmZyb20gLSAxKSlcbiAgICAgICAgLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKCkpLFxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGluQ29kZSAmJiAhbmV4dENvZGUgJiYgcGx1Z2luU3RhdGU/LmFjdGl2ZSAmJiBwbHVnaW5TdGF0ZS5zaWRlICE9PSAtMSkge1xuICAgIC8vIGB4YHwgLS0+IGB4fGAgLSBTaW5nbGUgY2hhcmFjdGVyXG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKCkpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaW5Db2RlICYmICFuZXh0Q29kZSAmJiBwbHVnaW5TdGF0ZT8uYWN0aXZlKSB7XG4gICAgLy8gYHh8YCAtLT4gYHx4YCAtIFNpbmdsZSBjaGFyYWN0ZXIgaW5zaWRlXG4gICAgY29uc3QgcG9zID0gc2VsZWN0aW9uLmZyb20gLSAxO1xuICAgIHZpZXcuZGlzcGF0Y2goXG4gICAgICB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcykpLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKCkpLFxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25BcnJvd0xlZnQoXG4gIHZpZXc6IEVkaXRvclZpZXcsXG4gIHBsdWdpbjogUGx1Z2luLFxuICBldmVudDogS2V5Ym9hcmRFdmVudCxcbiAgbWFya1R5cGU6IE1hcmtUeXBlLFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGhhbmRsZWQgPSBvbkFycm93TGVmdEluc2lkZSh2aWV3LCBwbHVnaW4sIGV2ZW50LCBtYXJrVHlwZSk7XG4gIGlmIChoYW5kbGVkKSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHZpZXcuc3RhdGU7XG4gIGNvbnN0IHBvcyA9IHNlbGVjdGlvbi4kZnJvbTtcbiAgY29uc3QgcGx1Z2luU3RhdGUgPSBwbHVnaW4uZ2V0U3RhdGUodmlldy5zdGF0ZSkgYXMgQ29kZW1hcmtTdGF0ZTtcbiAgaWYgKHBvcy5wb3MgPT09IDEgJiYgcG9zLnBhcmVudE9mZnNldCA9PT0gMCAmJiBwbHVnaW5TdGF0ZT8uc2lkZSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc2VsZWN0aW9uLmVtcHR5ICYmIHBvcy5wYXJlbnRPZmZzZXQgPT09IDApIHtcbiAgICByZXR1cm4gc3RlcE91dHNpZGVOZXh0VHJBbmRQYXNzKHZpZXcsIHBsdWdpbik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25CYWNrc3BhY2UoXG4gIHZpZXc6IEVkaXRvclZpZXcsXG4gIHBsdWdpbjogUGx1Z2luLFxuICBldmVudDogS2V5Ym9hcmRFdmVudCxcbiAgbWFya1R5cGU6IE1hcmtUeXBlLFxuKTogYm9vbGVhbiB7XG4gIGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5KSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHZpZXcuc3RhdGU7XG4gIGNvbnN0IGZyb20gPSBzYWZlUmVzb2x2ZShkb2MsIHNlbGVjdGlvbi5mcm9tIC0gMSk7XG4gIGNvbnN0IGZyb21Db2RlID0gISFtYXJrVHlwZS5pc0luU2V0KGZyb20ubWFya3MoKSk7XG4gIGNvbnN0IHN0YXJ0T2ZMaW5lID0gZnJvbS5wYXJlbnRPZmZzZXQgPT09IDA7XG4gIGNvbnN0IHRvQ29kZSA9ICEhbWFya1R5cGUuaXNJblNldChzYWZlUmVzb2x2ZShkb2MsIHNlbGVjdGlvbi50byArIDEpLm1hcmtzKCkpO1xuICBpZiAoKCFmcm9tQ29kZSB8fCBzdGFydE9mTGluZSkgJiYgIXRvQ29kZSkge1xuICAgIC8vIGB4fGAgICAg4oaSIHxcbiAgICAvLyBgfOKWiOKWiOKWiOKWiGAg4oaSIHxcbiAgICAvLyBgfOKWiOKWiOKWiGDilogg4oaSIHxcbiAgICByZXR1cm4gc3RlcE91dHNpZGVOZXh0VHJBbmRQYXNzKHZpZXcsIHBsdWdpbik7XG4gIH1cbiAgLy8gRmlyZWZveCBoYXMgZGlmZmljdWx0eSB3aXRoIHRoZSBkZWNvcmF0aW9ucyBvbiAtMS5cbiAgY29uc3QgcGx1Z2luU3RhdGUgPSBwbHVnaW4uZ2V0U3RhdGUodmlldy5zdGF0ZSkgYXMgQ29kZW1hcmtTdGF0ZTtcbiAgaWYgKHNlbGVjdGlvbi5lbXB0eSAmJiBwbHVnaW5TdGF0ZT8uc2lkZSA9PT0gLTEpIHtcbiAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHIuZGVsZXRlKHNlbGVjdGlvbi5mcm9tIC0gMSwgc2VsZWN0aW9uLmZyb20pO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uRGVsZXRlKFxuICB2aWV3OiBFZGl0b3JWaWV3LFxuICBwbHVnaW46IFBsdWdpbixcbiAgZXZlbnQ6IEtleWJvYXJkRXZlbnQsXG4gIG1hcmtUeXBlOiBNYXJrVHlwZSxcbik6IGJvb2xlYW4ge1xuICBpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSB2aWV3LnN0YXRlO1xuICBjb25zdCBmcm9tQ29kZSA9ICEhbWFya1R5cGUuaXNJblNldChzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gIGNvbnN0IHN0YXJ0T2ZMaW5lID0gc2VsZWN0aW9uLiRmcm9tLnBhcmVudE9mZnNldCA9PT0gMDtcbiAgY29uc3QgdG9Db2RlID0gISFtYXJrVHlwZS5pc0luU2V0KHNhZmVSZXNvbHZlKGRvYywgc2VsZWN0aW9uLnRvICsgMikubWFya3MoKSk7XG4gIGlmICgoIWZyb21Db2RlIHx8IHN0YXJ0T2ZMaW5lKSAmJiAhdG9Db2RlKSB7XG4gICAgcmV0dXJuIHN0ZXBPdXRzaWRlTmV4dFRyQW5kUGFzcyh2aWV3LCBwbHVnaW4pO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBPdXRzaWRlKHN0YXRlOiBFZGl0b3JTdGF0ZSwgbWFya1R5cGU6IE1hcmtUeXBlKTogVHJhbnNhY3Rpb24gfCBudWxsIHtcbiAgaWYgKCFzdGF0ZSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHN0YXRlO1xuICBpZiAoIXNlbGVjdGlvbi5lbXB0eSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHN0b3JlZCA9ICEhbWFya1R5cGUuaXNJblNldChzdGF0ZS5zdG9yZWRNYXJrcyA/PyBbXSk7XG4gIGNvbnN0IGluQ29kZSA9ICEhbWFya1R5cGUuaXNJblNldChzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gIGNvbnN0IG5leHRDb2RlID0gISFtYXJrVHlwZS5pc0luU2V0KHNhZmVSZXNvbHZlKGRvYywgc2VsZWN0aW9uLmZyb20gKyAxKS5tYXJrcygpID8/IFtdKTtcbiAgY29uc3Qgc3RhcnRPZkxpbmUgPSBzZWxlY3Rpb24uJGZyb20ucGFyZW50T2Zmc2V0ID09PSAwO1xuICAvLyBgY29kZXxgIC0tPiBgY29kZWB8XG4gIC8vIGB8Y29kZWAgLS0+IHxgY29kZWBcbiAgLy8gXmB8Y29kZWAgLS0+IF58YGNvZGVgXG4gIGlmIChpbkNvZGUgIT09IG5leHRDb2RlIHx8ICghaW5Db2RlICYmIHN0b3JlZCAhPT0gaW5Db2RlKSB8fCAoaW5Db2RlICYmIHN0YXJ0T2ZMaW5lKSlcbiAgICByZXR1cm4gc3RhdGUudHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSk7XG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IHsgY29kZW1hcmsgfSBmcm9tICcuL3BsdWdpbic7XG5cbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjb2RlbWFyaztcbiIsImltcG9ydCB0eXBlIHsgTWFya1R5cGUgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBQbHVnaW4sIFRleHRTZWxlY3Rpb24sIFRyYW5zYWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHR5cGUgeyBQbHVnaW5TcGVjIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHR5cGUgeyBFZGl0b3JWaWV3IH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5pbXBvcnQgdHlwZSB7IE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGdldE1hcmtUeXBlLCBNQVhfTUFUQ0ggfSBmcm9tICcuL3V0aWxzJztcblxudHlwZSBJbnB1dFJ1bGVTdGF0ZSA9IHtcbiAgdHJhbnNmb3JtOiBUcmFuc2FjdGlvbjtcbiAgZnJvbTogbnVtYmVyO1xuICB0bzogbnVtYmVyO1xuICB0ZXh0OiBzdHJpbmc7XG59IHwgbnVsbDtcblxudHlwZSBQbHVnaW5zID0geyBpbnB1dDogUGx1Z2luOyBjdXJzb3I6IFBsdWdpbiB9O1xuXG50eXBlIEhhbmRsZXIgPSAoXG4gIG1hcmtUeXBlOiBNYXJrVHlwZSxcbiAgc3RhdGU6IEVkaXRvclZpZXcsXG4gIHRleHQ6IHN0cmluZyxcbiAgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSxcbiAgZnJvbTogbnVtYmVyLFxuICB0bzogbnVtYmVyLFxuICBwbHVnaW46IFBsdWdpbnMsXG4pID0+IGJvb2xlYW47XG5cbnR5cGUgUnVsZSA9IHtcbiAgbWF0Y2g6IFJlZ0V4cDtcbiAgaGFuZGxlcjogSGFuZGxlcjtcbn07XG5cbmZ1bmN0aW9uIHN0b3BNYXRjaChtYXJrVHlwZTogTWFya1R5cGUsIHZpZXc6IEVkaXRvclZpZXcsIGZyb206IG51bWJlciwgdG86IG51bWJlcik6IGJvb2xlYW4ge1xuICBjb25zdCBzdG9yZWQgPSBtYXJrVHlwZS5pc0luU2V0KHZpZXcuc3RhdGUuc3RvcmVkTWFya3MgPz8gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShmcm9tKS5tYXJrcygpKTtcbiAgY29uc3QgcmFuZ2UgPSB2aWV3LnN0YXRlLmRvYy5yYW5nZUhhc01hcmsoZnJvbSwgdG8sIG1hcmtUeXBlKTtcbiAgLy8gRG9uJ3QgY3JlYXRlIGl0IGlmIHRoZXJlIGlzIGNvZGUgaW4gYmV0d2VlbiFcbiAgaWYgKHN0b3JlZCB8fCByYW5nZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgbWFya0JlZm9yZTogUnVsZSA9IHtcbiAgbWF0Y2g6IC9gKCg/OlteYFxcd118W1xcd10pKylgJC8sXG4gIGhhbmRsZXI6IChtYXJrVHlwZSwgdmlldywgdGV4dCwgbWF0Y2gsIGZyb20sIHRvLCBwbHVnaW5zKSA9PiB7XG4gICAgaWYgKHN0b3BNYXRjaChtYXJrVHlwZSwgdmlldywgZnJvbSwgdG8pKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY29kZSA9IG1hdGNoWzFdO1xuICAgIGNvbnN0IG1hcmsgPSBtYXJrVHlwZS5jcmVhdGUoKTtcbiAgICBjb25zdCBwb3MgPSBmcm9tICsgY29kZS5sZW5ndGg7XG4gICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyLmRlbGV0ZShmcm9tLCB0bykuaW5zZXJ0VGV4dChjb2RlKS5hZGRNYXJrKGZyb20sIHBvcywgbWFyayk7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb3MpKS5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKTtcbiAgICBjb25zdCB3aXRoTWV0YSA9IHNlbGVjdGVkLnNldE1ldGEocGx1Z2lucy5pbnB1dCwge1xuICAgICAgdHJhbnNmb3JtOiBzZWxlY3RlZCxcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIHRleHQ6IGBcXGAke2NvZGV9JHt0ZXh0fWAsXG4gICAgfSk7XG4gICAgdmlldy5kaXNwYXRjaCh3aXRoTWV0YSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG59O1xuXG5jb25zdCBtYXJrQWZ0ZXI6IFJ1bGUgPSB7XG4gIG1hdGNoOiAvXmAoKD86W15gXFx3XXxbXFx3XSkrKWAvLFxuICBoYW5kbGVyOiAobWFya1R5cGUsIHZpZXcsIHRleHQsIG1hdGNoLCBmcm9tLCB0bywgcGx1Z2lucykgPT4ge1xuICAgIGlmIChzdG9wTWF0Y2gobWFya1R5cGUsIHZpZXcsIGZyb20sIHRvKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IG1hcmsgPSBtYXJrVHlwZS5jcmVhdGUoKTtcbiAgICBjb25zdCBjb2RlID0gbWF0Y2hbMV07XG4gICAgY29uc3QgcG9zID0gZnJvbTtcbiAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHJcbiAgICAgIC5kZWxldGUoZnJvbSwgdG8pXG4gICAgICAuaW5zZXJ0VGV4dChjb2RlKVxuICAgICAgLmFkZE1hcmsoZnJvbSwgZnJvbSArIGNvZGUubGVuZ3RoLCBtYXJrKTtcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRyXG4gICAgICAuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9zKSlcbiAgICAgIC5hZGRTdG9yZWRNYXJrKG1hcmtUeXBlLmNyZWF0ZSgpKTtcbiAgICBjb25zdCB3aXRoTWV0YSA9IHNlbGVjdGVkLnNldE1ldGEocGx1Z2lucy5pbnB1dCwge1xuICAgICAgdHJhbnNmb3JtOiBzZWxlY3RlZCxcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIHRleHQ6IGBcXGAke2NvZGV9JHt0ZXh0fWAsXG4gICAgfSk7XG4gICAgdmlldy5kaXNwYXRjaCh3aXRoTWV0YSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBydW4oXG4gIG1hcmtUeXBlOiBNYXJrVHlwZSxcbiAgdmlldzogRWRpdG9yVmlldyxcbiAgZnJvbTogbnVtYmVyLFxuICB0bzogbnVtYmVyLFxuICB0ZXh0OiBzdHJpbmcsXG4gIHBsdWdpbnM6IFBsdWdpbnMsXG4pIHtcbiAgaWYgKHZpZXcuY29tcG9zaW5nKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXc7XG4gIGNvbnN0ICRmcm9tID0gc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gIGlmICgkZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGUpIHJldHVybiBmYWxzZTtcblxuICBjb25zdCBsZWFmVGV4dCA9ICdcXHVmZmZjJztcbiAgY29uc3QgdGV4dEJlZm9yZSA9XG4gICAgJGZyb20ucGFyZW50LnRleHRCZXR3ZWVuKFxuICAgICAgTWF0aC5tYXgoMCwgJGZyb20ucGFyZW50T2Zmc2V0IC0gTUFYX01BVENIKSxcbiAgICAgICRmcm9tLnBhcmVudE9mZnNldCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGxlYWZUZXh0LFxuICAgICkgKyB0ZXh0O1xuICBjb25zdCB0ZXh0QWZ0ZXIgPVxuICAgIHRleHQgK1xuICAgICRmcm9tLnBhcmVudC50ZXh0QmV0d2VlbihcbiAgICAgICRmcm9tLnBhcmVudE9mZnNldCxcbiAgICAgIE1hdGgubWluKCRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDIsICRmcm9tLnBhcmVudE9mZnNldCArIE1BWF9NQVRDSCksXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBsZWFmVGV4dCxcbiAgICApO1xuICBjb25zdCBtYXRjaEIgPSBtYXJrQmVmb3JlLm1hdGNoLmV4ZWModGV4dEJlZm9yZSk7XG4gIGNvbnN0IG1hdGNoQSA9IG1hcmtBZnRlci5tYXRjaC5leGVjKHRleHRBZnRlcik7XG4gIGlmIChtYXRjaEIpIHtcbiAgICBjb25zdCBoYW5kbGVkID0gbWFya0JlZm9yZS5oYW5kbGVyKFxuICAgICAgbWFya1R5cGUsXG4gICAgICB2aWV3LFxuICAgICAgdGV4dCxcbiAgICAgIG1hdGNoQixcbiAgICAgIGZyb20gLSBtYXRjaEJbMF0ubGVuZ3RoICsgdGV4dC5sZW5ndGgsXG4gICAgICB0byxcbiAgICAgIHBsdWdpbnMsXG4gICAgKTtcbiAgICBpZiAoaGFuZGxlZCkgcmV0dXJuIGhhbmRsZWQ7XG4gIH1cbiAgaWYgKG1hdGNoQSlcbiAgICByZXR1cm4gbWFya0FmdGVyLmhhbmRsZXIoXG4gICAgICBtYXJrVHlwZSxcbiAgICAgIHZpZXcsXG4gICAgICB0ZXh0LFxuICAgICAgbWF0Y2hBLFxuICAgICAgZnJvbSxcbiAgICAgIHRvICsgbWF0Y2hBWzBdLmxlbmd0aCAtIHRleHQubGVuZ3RoLFxuICAgICAgcGx1Z2lucyxcbiAgICApO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnB1dFJ1bGUoY3Vyc29yUGx1Z2luOiBQbHVnaW4sIG9wdHM/OiBPcHRpb25zKSB7XG4gIGNvbnN0IHBsdWdpbjogUGx1Z2luPElucHV0UnVsZVN0YXRlPiA9IG5ldyBQbHVnaW4oe1xuICAgIGlzSW5wdXRSdWxlczogdHJ1ZSxcbiAgICBzdGF0ZToge1xuICAgICAgaW5pdDogKCkgPT4gbnVsbCxcbiAgICAgIGFwcGx5KHRyLCBwcmV2KSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0ci5nZXRNZXRhKHBsdWdpbik7XG4gICAgICAgIGlmIChtZXRhKSByZXR1cm4gbWV0YTtcbiAgICAgICAgcmV0dXJuIHRyLnNlbGVjdGlvblNldCB8fCB0ci5kb2NDaGFuZ2VkID8gbnVsbCA6IHByZXY7XG4gICAgICB9LFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGhhbmRsZVRleHRJbnB1dCh2aWV3LCBmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBjb25zdCBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHZpZXcsIG9wdHMpO1xuICAgICAgICByZXR1cm4gcnVuKG1hcmtUeXBlLCB2aWV3LCBmcm9tLCB0bywgdGV4dCwgeyBpbnB1dDogcGx1Z2luLCBjdXJzb3I6IGN1cnNvclBsdWdpbiB9KTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfSBhcyBQbHVnaW5TcGVjPElucHV0UnVsZVN0YXRlPik7XG4gIHJldHVybiBwbHVnaW47XG59XG4iLCJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgdHlwZSB7IFBsdWdpblNwZWMgfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0IH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5pbXBvcnQgdHlwZSB7IENvZGVtYXJrU3RhdGUsIEN1cnNvck1ldGFUciwgT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0TWFya1R5cGUsIHBsdWdpbktleSwgc2FmZVJlc29sdmUgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUlucHV0UnVsZSB9IGZyb20gJy4vaW5wdXRSdWxlcyc7XG5pbXBvcnQge1xuICBvbkFycm93TGVmdCxcbiAgb25BcnJvd1JpZ2h0LFxuICBvbkJhY2tzcGFjZSxcbiAgb25CYWNrdGljayxcbiAgb25EZWxldGUsXG4gIHN0ZXBPdXRzaWRlLFxuICBzdGVwT3V0c2lkZU5leHRUckFuZFBhc3MsXG59IGZyb20gJy4vYWN0aW9ucyc7XG5cbmZ1bmN0aW9uIHRvRG9tKCk6IE5vZGUge1xuICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBzcGFuLmNsYXNzTGlzdC5hZGQoJ2Zha2UtY3Vyc29yJyk7XG4gIHJldHVybiBzcGFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVjb3JhdGlvblBsdWdpbihvcHRzPzogT3B0aW9ucykge1xuICBjb25zdCBwbHVnaW46IFBsdWdpbjxDb2RlbWFya1N0YXRlPiA9IG5ldyBQbHVnaW4oe1xuICAgIGtleTogcGx1Z2luS2V5LFxuICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJzLCBvbGRTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHByZXYgPSBwbHVnaW4uZ2V0U3RhdGUob2xkU3RhdGUpIGFzIENvZGVtYXJrU3RhdGU7XG4gICAgICBjb25zdCBtZXRhID0gdHJzWzBdPy5nZXRNZXRhKHBsdWdpbikgYXMgQ3Vyc29yTWV0YVRyIHwgbnVsbDtcbiAgICAgIGlmIChwcmV2Py5uZXh0IHx8IG1ldGE/LmFjdGlvbiA9PT0gJ2NsaWNrJykge1xuICAgICAgICByZXR1cm4gc3RlcE91dHNpZGUobmV3U3RhdGUsIGdldE1hcmtUeXBlKG5ld1N0YXRlLCBvcHRzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICBpbml0OiAoKSA9PiBudWxsLFxuICAgICAgYXBwbHkodHIsIHZhbHVlLCBvbGRTdGF0ZSwgc3RhdGUpOiBDb2RlbWFya1N0YXRlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0ci5nZXRNZXRhKHBsdWdpbikgYXMgQ3Vyc29yTWV0YVRyIHwgbnVsbDtcbiAgICAgICAgaWYgKG1ldGE/LmFjdGlvbiA9PT0gJ25leHQnKSByZXR1cm4geyBuZXh0OiB0cnVlIH07XG5cbiAgICAgICAgY29uc3QgbWFya1R5cGUgPSBnZXRNYXJrVHlwZShzdGF0ZSwgb3B0cyk7XG4gICAgICAgIGNvbnN0IG5leHRNYXJrID0gbWFya1R5cGUuaXNJblNldChcbiAgICAgICAgICBzdGF0ZS5zdG9yZWRNYXJrcyA/PyBzdGF0ZS5kb2MucmVzb2x2ZSh0ci5zZWxlY3Rpb24uZnJvbSkubWFya3MoKSxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW5Db2RlID0gbWFya1R5cGUuaXNJblNldChzdGF0ZS5kb2MucmVzb2x2ZSh0ci5zZWxlY3Rpb24uZnJvbSkubWFya3MoKSk7XG4gICAgICAgIGNvbnN0IG5leHRDb2RlID0gbWFya1R5cGUuaXNJblNldChzYWZlUmVzb2x2ZShzdGF0ZS5kb2MsIHRyLnNlbGVjdGlvbi5mcm9tICsgMSkubWFya3MoKSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZMaW5lID0gdHIuc2VsZWN0aW9uLiRmcm9tLnBhcmVudE9mZnNldCA9PT0gMDtcbiAgICAgICAgaWYgKCF0ci5zZWxlY3Rpb24uZW1wdHkpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIW5leHRNYXJrICYmIG5leHRDb2RlICYmICghaW5Db2RlIHx8IHN0YXJ0T2ZMaW5lKSkge1xuICAgICAgICAgIC8vIHxgY29kZWBcbiAgICAgICAgICByZXR1cm4geyBhY3RpdmU6IHRydWUsIHNpZGU6IC0xIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRNYXJrICYmICghaW5Db2RlIHx8IHN0YXJ0T2ZMaW5lKSkge1xuICAgICAgICAgIC8vIGB8Y29kZWBcbiAgICAgICAgICByZXR1cm4geyBhY3RpdmU6IHRydWUsIHNpZGU6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5leHRNYXJrICYmIGluQ29kZSAmJiAhbmV4dENvZGUpIHtcbiAgICAgICAgICAvLyBgY29kZWB8XG4gICAgICAgICAgcmV0dXJuIHsgYWN0aXZlOiB0cnVlLCBzaWRlOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRNYXJrICYmIGluQ29kZSAmJiAhbmV4dENvZGUpIHtcbiAgICAgICAgICAvLyBgY29kZXxgXG4gICAgICAgICAgcmV0dXJuIHsgYWN0aXZlOiB0cnVlLCBzaWRlOiAtMSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBhdHRyaWJ1dGVzOiAoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBhY3RpdmUgPSBmYWxzZSB9ID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKSA/PyB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi4oYWN0aXZlID8geyBjbGFzczogJ25vLWN1cnNvcicgfSA6IHt9KSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBkZWNvcmF0aW9uczogKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYWN0aXZlLCBzaWRlIH0gPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpID8/IHt9O1xuICAgICAgICBpZiAoIWFjdGl2ZSkgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGNvbnN0IGRlY28gPSBEZWNvcmF0aW9uLndpZGdldChzdGF0ZS5zZWxlY3Rpb24uZnJvbSwgdG9Eb20sIHsgc2lkZSB9KTtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKHN0YXRlLmRvYywgW2RlY29dKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgY2FzZSAnYCc6XG4gICAgICAgICAgICByZXR1cm4gb25CYWNrdGljayh2aWV3LCBwbHVnaW4sIGV2ZW50LCBnZXRNYXJrVHlwZSh2aWV3LCBvcHRzKSk7XG4gICAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAgICByZXR1cm4gb25BcnJvd1JpZ2h0KHZpZXcsIHBsdWdpbiwgZXZlbnQsIGdldE1hcmtUeXBlKHZpZXcsIG9wdHMpKTtcbiAgICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgICAgcmV0dXJuIG9uQXJyb3dMZWZ0KHZpZXcsIHBsdWdpbiwgZXZlbnQsIGdldE1hcmtUeXBlKHZpZXcsIG9wdHMpKTtcbiAgICAgICAgICBjYXNlICdCYWNrc3BhY2UnOlxuICAgICAgICAgICAgcmV0dXJuIG9uQmFja3NwYWNlKHZpZXcsIHBsdWdpbiwgZXZlbnQsIGdldE1hcmtUeXBlKHZpZXcsIG9wdHMpKTtcbiAgICAgICAgICBjYXNlICdEZWxldGUnOlxuICAgICAgICAgICAgcmV0dXJuIG9uRGVsZXRlKHZpZXcsIHBsdWdpbiwgZXZlbnQsIGdldE1hcmtUeXBlKHZpZXcsIG9wdHMpKTtcbiAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgIGNhc2UgJ0hvbWUnOlxuICAgICAgICAgIGNhc2UgJ0VuZCc6XG4gICAgICAgICAgICByZXR1cm4gc3RlcE91dHNpZGVOZXh0VHJBbmRQYXNzKHZpZXcsIHBsdWdpbik7XG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICBpZiAoIWV2ZW50LmN0cmxLZXkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBzdGVwT3V0c2lkZU5leHRUckFuZFBhc3ModmlldywgcGx1Z2luKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2xpY2sodmlldykge1xuICAgICAgICByZXR1cm4gc3RlcE91dHNpZGVOZXh0VHJBbmRQYXNzKHZpZXcsIHBsdWdpbiwgJ2NsaWNrJyk7XG4gICAgICB9LFxuICAgIH0sXG4gIH0gYXMgUGx1Z2luU3BlYzxDb2RlbWFya1N0YXRlPik7XG4gIHJldHVybiBwbHVnaW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2RlbWFyayhvcHRzPzogT3B0aW9ucykge1xuICBjb25zdCBjdXJzb3JQbHVnaW4gPSBnZXREZWNvcmF0aW9uUGx1Z2luKG9wdHMpO1xuICBjb25zdCBpbnB1dFJ1bGUgPSBjcmVhdGVJbnB1dFJ1bGUoY3Vyc29yUGx1Z2luLCBvcHRzKTtcbiAgY29uc3QgcnVsZXM6IFBsdWdpbltdID0gW2N1cnNvclBsdWdpbiwgaW5wdXRSdWxlXTtcbiAgcmV0dXJuIHJ1bGVzO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBNYXJrVHlwZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcblxuZXhwb3J0IHR5cGUgT3B0aW9ucyA9IHtcbiAgbWFya1R5cGU/OiBNYXJrVHlwZTtcbn07XG5cbmV4cG9ydCB0eXBlIENvZGVtYXJrU3RhdGUgPSB7XG4gIGFjdGl2ZT86IGJvb2xlYW47XG4gIHNpZGU/OiAtMSB8IDA7XG4gIG5leHQ/OiB0cnVlOyAvLyBNb3ZlIG91dHNpZGUgb2YgY29kZSBhZnRlciBuZXh0IHRyYW5zYWN0aW9uXG4gIGNsaWNrPzogdHJ1ZTsgLy8gV2hlbiB0aGUgZWRpdG9yIGlzIGNsaWNrZWQgb25cbn0gfCBudWxsO1xuXG5leHBvcnQgdHlwZSBDdXJzb3JNZXRhVHIgPSB7IGFjdGlvbjogJ25leHQnIH0gfCB7IGFjdGlvbjogJ2NsaWNrJyB9O1xuIiwiaW1wb3J0IHR5cGUgeyBNYXJrVHlwZSwgTm9kZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IEVkaXRvclN0YXRlLCBQbHVnaW5LZXkgfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgdHlwZSB7IEVkaXRvclZpZXcgfSBmcm9tICdwcm9zZW1pcnJvci12aWV3JztcbmltcG9ydCB0eXBlIHsgT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9JRCA9ICdjb2RlbWFyayc7XG5leHBvcnQgY29uc3QgTUFYX01BVENIID0gMTAwO1xuZXhwb3J0IGNvbnN0IHBsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoREVGQVVMVF9JRCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrVHlwZSh2aWV3OiBFZGl0b3JWaWV3IHwgRWRpdG9yU3RhdGUsIG9wdHM/OiBPcHRpb25zKTogTWFya1R5cGUge1xuICBpZiAoJ3NjaGVtYScgaW4gdmlldykgcmV0dXJuIG9wdHM/Lm1hcmtUeXBlID8/IHZpZXcuc2NoZW1hLm1hcmtzLmNvZGU7XG4gIHJldHVybiBvcHRzPy5tYXJrVHlwZSA/PyB2aWV3LnN0YXRlLnNjaGVtYS5tYXJrcy5jb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FmZVJlc29sdmUoZG9jOiBOb2RlLCBwb3M6IG51bWJlcikge1xuICByZXR1cm4gZG9jLnJlc29sdmUoTWF0aC5taW4oTWF0aC5tYXgoMSwgcG9zKSwgZG9jLm5vZGVTaXplIC0gMikpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjcmVsdCgpIHtcbiAgdmFyIGVsdCA9IGFyZ3VtZW50c1swXTtcbiAgaWYgKHR5cGVvZiBlbHQgPT0gXCJzdHJpbmdcIikgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbHQpO1xuICB2YXIgaSA9IDEsIG5leHQgPSBhcmd1bWVudHNbMV07XG4gIGlmIChuZXh0ICYmIHR5cGVvZiBuZXh0ID09IFwib2JqZWN0XCIgJiYgbmV4dC5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBuZXh0KSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHQsIG5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXh0W25hbWVdO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSBlbHQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIGVsdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFkZChlbHQsIGFyZ3VtZW50c1tpXSk7XG4gIHJldHVybiBlbHRcbn1cblxuZnVuY3Rpb24gYWRkKGVsdCwgY2hpbGQpIHtcbiAgaWYgKHR5cGVvZiBjaGlsZCA9PSBcInN0cmluZ1wiKSB7XG4gICAgZWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkKSk7XG4gIH0gZWxzZSBpZiAoY2hpbGQgPT0gbnVsbCkgOyBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSAhPSBudWxsKSB7XG4gICAgZWx0LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGQubGVuZ3RoOyBpKyspIGFkZChlbHQsIGNoaWxkW2ldKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVuc3VwcG9ydGVkIGNoaWxkIG5vZGU6IFwiICsgY2hpbGQpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVsdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gOjotIFBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGFuIG9yZGVyZWQgbWFwcGluZyBmcm9tXG4vLyBzdHJpbmdzIHRvIHZhbHVlcywgd2l0aCBzb21lIGNvbnZlbmllbnQgdXBkYXRlIG1ldGhvZHMuXG5mdW5jdGlvbiBPcmRlcmVkTWFwKGNvbnRlbnQpIHtcbiAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbn1cblxuT3JkZXJlZE1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBPcmRlcmVkTWFwLFxuXG4gIGZpbmQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgaWYgKHRoaXMuY29udGVudFtpXSA9PT0ga2V5KSByZXR1cm4gaVxuICAgIHJldHVybiAtMVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcpIOKGkiA/YW55XG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZSBzdG9yZWQgdW5kZXIgYGtleWAsIG9yIHJldHVybiB1bmRlZmluZWQgd2hlblxuICAvLyBubyBzdWNoIGtleSBleGlzdHMuXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKGtleSk7XG4gICAgcmV0dXJuIGZvdW5kID09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5jb250ZW50W2ZvdW5kICsgMV1cbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnksID9zdHJpbmcpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgcmVwbGFjaW5nIHRoZSB2YWx1ZSBvZiBga2V5YCB3aXRoIGEgbmV3XG4gIC8vIHZhbHVlLCBvciBhZGRpbmcgYSBiaW5kaW5nIHRvIHRoZSBlbmQgb2YgdGhlIG1hcC4gSWYgYG5ld0tleWAgaXNcbiAgLy8gZ2l2ZW4sIHRoZSBrZXkgb2YgdGhlIGJpbmRpbmcgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoYXQga2V5LlxuICB1cGRhdGU6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG5ld0tleSkge1xuICAgIHZhciBzZWxmID0gbmV3S2V5ICYmIG5ld0tleSAhPSBrZXkgPyB0aGlzLnJlbW92ZShuZXdLZXkpIDogdGhpcztcbiAgICB2YXIgZm91bmQgPSBzZWxmLmZpbmQoa2V5KSwgY29udGVudCA9IHNlbGYuY29udGVudC5zbGljZSgpO1xuICAgIGlmIChmb3VuZCA9PSAtMSkge1xuICAgICAgY29udGVudC5wdXNoKG5ld0tleSB8fCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudFtmb3VuZCArIDFdID0gdmFsdWU7XG4gICAgICBpZiAobmV3S2V5KSBjb250ZW50W2ZvdW5kXSA9IG5ld0tleTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZykg4oaSIE9yZGVyZWRNYXBcbiAgLy8gUmV0dXJuIGEgbWFwIHdpdGggdGhlIGdpdmVuIGtleSByZW1vdmVkLCBpZiBpdCBleGlzdGVkLlxuICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZChrZXkpO1xuICAgIGlmIChmb3VuZCA9PSAtMSkgcmV0dXJuIHRoaXNcbiAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudC5zbGljZSgpO1xuICAgIGNvbnRlbnQuc3BsaWNlKGZvdW5kLCAyKTtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnkpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIG5ldyBrZXkgdG8gdGhlIHN0YXJ0IG9mIHRoZSBtYXAuXG4gIGFkZFRvU3RhcnQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoW2tleSwgdmFsdWVdLmNvbmNhdCh0aGlzLnJlbW92ZShrZXkpLmNvbnRlbnQpKVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIGFueSkg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQWRkIGEgbmV3IGtleSB0byB0aGUgZW5kIG9mIHRoZSBtYXAuXG4gIGFkZFRvRW5kOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLnJlbW92ZShrZXkpLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBjb250ZW50LnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgc3RyaW5nLCBhbnkpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIGtleSBhZnRlciB0aGUgZ2l2ZW4ga2V5LiBJZiBgcGxhY2VgIGlzIG5vdCBmb3VuZCwgdGhlIG5ld1xuICAvLyBrZXkgaXMgYWRkZWQgdG8gdGhlIGVuZC5cbiAgYWRkQmVmb3JlOiBmdW5jdGlvbihwbGFjZSwga2V5LCB2YWx1ZSkge1xuICAgIHZhciB3aXRob3V0ID0gdGhpcy5yZW1vdmUoa2V5KSwgY29udGVudCA9IHdpdGhvdXQuY29udGVudC5zbGljZSgpO1xuICAgIHZhciBmb3VuZCA9IHdpdGhvdXQuZmluZChwbGFjZSk7XG4gICAgY29udGVudC5zcGxpY2UoZm91bmQgPT0gLTEgPyBjb250ZW50Lmxlbmd0aCA6IGZvdW5kLCAwLCBrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSlcbiAgLy8gQ2FsbCB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIG1hcCwgaW5cbiAgLy8gb3JkZXIuXG4gIGZvckVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIGYodGhpcy5jb250ZW50W2ldLCB0aGlzLmNvbnRlbnRbaSArIDFdKTtcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBieSBwcmVwZW5kaW5nIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgIGJlZm9yZSB0aGUga2V5cyBpbiBgbWFwYC5cbiAgcHJlcGVuZDogZnVuY3Rpb24obWFwKSB7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgaWYgKCFtYXAuc2l6ZSkgcmV0dXJuIHRoaXNcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAobWFwLmNvbnRlbnQuY29uY2F0KHRoaXMuc3VidHJhY3QobWFwKS5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBieSBhcHBlbmRpbmcgdGhlIGtleXMgaW4gdGhpcyBtYXAgdGhhdCBkb24ndFxuICAvLyBhcHBlYXIgaW4gYG1hcGAgYWZ0ZXIgdGhlIGtleXMgaW4gYG1hcGAuXG4gIGFwcGVuZDogZnVuY3Rpb24obWFwKSB7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgaWYgKCFtYXAuc2l6ZSkgcmV0dXJuIHRoaXNcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAodGhpcy5zdWJ0cmFjdChtYXApLmNvbnRlbnQuY29uY2F0KG1hcC5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgLlxuICBzdWJ0cmFjdDogZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZW1vdmUobWFwLmNvbnRlbnRbaV0pO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSxcblxuICAvLyA6OiBudW1iZXJcbiAgLy8gVGhlIGFtb3VudCBvZiBrZXlzIGluIHRoaXMgbWFwLlxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA+PiAxXG4gIH1cbn07XG5cbi8vIDo6ICg/dW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikg4oaSIE9yZGVyZWRNYXBcbi8vIFJldHVybiBhIG1hcCB3aXRoIHRoZSBnaXZlbiBjb250ZW50LiBJZiBudWxsLCBjcmVhdGUgYW4gZW1wdHlcbi8vIG1hcC4gSWYgZ2l2ZW4gYW4gb3JkZXJlZCBtYXAsIHJldHVybiB0aGF0IG1hcCBpdHNlbGYuIElmIGdpdmVuIGFuXG4vLyBvYmplY3QsIGNyZWF0ZSBhIG1hcCBmcm9tIHRoZSBvYmplY3QncyBwcm9wZXJ0aWVzLlxuT3JkZXJlZE1hcC5mcm9tID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT3JkZXJlZE1hcCkgcmV0dXJuIHZhbHVlXG4gIHZhciBjb250ZW50ID0gW107XG4gIGlmICh2YWx1ZSkgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkgY29udGVudC5wdXNoKHByb3AsIHZhbHVlW3Byb3BdKTtcbiAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9yZGVyZWRNYXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBwcm9zZW1pcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXRyYW5zZm9ybScpO1xuXG52YXIgcHJvc2VtaXJyb3JNb2RlbCA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLW1vZGVsJyk7XG5cbnZhciBwcm9zZW1pcnJvclN0YXRlID0gcmVxdWlyZSgncHJvc2VtaXJyb3Itc3RhdGUnKTtcblxudmFyIGRlbGV0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIGRlbGV0ZVNlbGVjdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKHN0YXRlLnNlbGVjdGlvbi5lbXB0eSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBqb2luQmFja3dhcmQgPSBmdW5jdGlvbiBqb2luQmFja3dhcmQoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gIHZhciAkY3Vyc29yID0gc3RhdGUuc2VsZWN0aW9uLiRjdXJzb3I7XG4gIGlmICghJGN1cnNvciB8fCAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPiAwKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGN1cnNvcik7XG5cbiAgaWYgKCEkY3V0KSB7XG4gICAgdmFyIHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksXG4gICAgICAgIHRhcmdldCA9IHJhbmdlICYmIHByb3NlbWlycm9yVHJhbnNmb3JtLmxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmU7XG4gIGlmICghYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcgJiYgZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiYgKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikgfHwgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShiZWZvcmUpKSkge1xuICAgIHZhciBkZWxTdGVwID0gcHJvc2VtaXJyb3JUcmFuc2Zvcm0ucmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkpO1xuXG4gICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpID8gcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MsIC0xKSksIC0xKSA6IHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGJlZm9yZS5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHJbXCJkZWxldGVcIl0oJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRjdXQucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHRleHRibG9ja0F0KG5vZGUsIHNpZGUpIHtcbiAgdmFyIG9ubHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIGZvciAodmFyIHNjYW4gPSBub2RlOyBzY2FuOyBzY2FuID0gc2lkZSA9PSBcInN0YXJ0XCIgPyBzY2FuLmZpcnN0Q2hpbGQgOiBzY2FuLmxhc3RDaGlsZCkge1xuICAgIGlmIChzY2FuLmlzVGV4dGJsb2NrKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAob25seSAmJiBzY2FuLmNoaWxkQ291bnQgIT0gMSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgc2VsZWN0Tm9kZUJhY2t3YXJkID0gZnVuY3Rpb24gc2VsZWN0Tm9kZUJhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICB2YXIgX3N0YXRlJHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICRoZWFkID0gX3N0YXRlJHNlbGVjdGlvbi4kaGVhZCxcbiAgICAgIGVtcHR5ID0gX3N0YXRlJHNlbGVjdGlvbi5lbXB0eSxcbiAgICAgICRjdXQgPSAkaGVhZDtcbiAgaWYgKCFlbXB0eSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICgkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0ID4gMCkgcmV0dXJuIGZhbHNlO1xuICAgICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRoZWFkKTtcbiAgfVxuXG4gIHZhciBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVCZWZvcmU7XG4gIGlmICghbm9kZSB8fCAhcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MgLSBub2RlLm5vZGVTaXplKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gZmluZEN1dEJlZm9yZSgkcG9zKSB7XG4gIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZykgZm9yICh2YXIgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmICgkcG9zLmluZGV4KGkpID4gMCkgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5iZWZvcmUoaSArIDEpKTtcbiAgICBpZiAoJHBvcy5ub2RlKGkpLnR5cGUuc3BlYy5pc29sYXRpbmcpIGJyZWFrO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgam9pbkZvcndhcmQgPSBmdW5jdGlvbiBqb2luRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyICRjdXJzb3IgPSBzdGF0ZS5zZWxlY3Rpb24uJGN1cnNvcjtcbiAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKSA6ICRjdXJzb3IucGFyZW50T2Zmc2V0IDwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgaWYgKCEkY3V0KSByZXR1cm4gZmFsc2U7XG4gIHZhciBhZnRlciA9ICRjdXQubm9kZUFmdGVyO1xuICBpZiAoZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiYgKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpIHx8IHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoYWZ0ZXIpKSkge1xuICAgIHZhciBkZWxTdGVwID0gcHJvc2VtaXJyb3JUcmFuc2Zvcm0ucmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkpO1xuXG4gICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSA/IHByb3NlbWlycm9yU3RhdGUuU2VsZWN0aW9uLmZpbmRGcm9tKHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSksIDEpIDogcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFmdGVyLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50cltcImRlbGV0ZVwiXSgkY3V0LnBvcywgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgc2VsZWN0Tm9kZUZvcndhcmQgPSBmdW5jdGlvbiBzZWxlY3ROb2RlRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24yID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJGhlYWQgPSBfc3RhdGUkc2VsZWN0aW9uMi4kaGVhZCxcbiAgICAgIGVtcHR5ID0gX3N0YXRlJHNlbGVjdGlvbjIuZW1wdHksXG4gICAgICAkY3V0ID0gJGhlYWQ7XG4gIGlmICghZW1wdHkpIHJldHVybiBmYWxzZTtcblxuICBpZiAoJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKSB7XG4gICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0IDwgJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGhlYWQpO1xuICB9XG5cbiAgdmFyIG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUFmdGVyO1xuICBpZiAoIW5vZGUgfHwgIXByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24ocHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gZmluZEN1dEFmdGVyKCRwb3MpIHtcbiAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSBmb3IgKHZhciBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcmVudCA9ICRwb3Mubm9kZShpKTtcbiAgICBpZiAoJHBvcy5pbmRleChpKSArIDEgPCBwYXJlbnQuY2hpbGRDb3VudCkgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5hZnRlcihpICsgMSkpO1xuICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZykgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBqb2luVXAgPSBmdW5jdGlvbiBqb2luVXAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICBub2RlU2VsID0gc2VsIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLFxuICAgICAgcG9pbnQ7XG5cbiAgaWYgKG5vZGVTZWwpIHtcbiAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIXByb3NlbWlycm9yVHJhbnNmb3JtLmNhbkpvaW4oc3RhdGUuZG9jLCBzZWwuZnJvbSkpIHJldHVybiBmYWxzZTtcbiAgICBwb2ludCA9IHNlbC5mcm9tO1xuICB9IGVsc2Uge1xuICAgIHBvaW50ID0gcHJvc2VtaXJyb3JUcmFuc2Zvcm0uam9pblBvaW50KHN0YXRlLmRvYywgc2VsLmZyb20sIC0xKTtcbiAgICBpZiAocG9pbnQgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdmFyIHRyID0gc3RhdGUudHIuam9pbihwb2ludCk7XG4gICAgaWYgKG5vZGVTZWwpIHRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9pbnQgLSBzdGF0ZS5kb2MucmVzb2x2ZShwb2ludCkubm9kZUJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgam9pbkRvd24gPSBmdW5jdGlvbiBqb2luRG93bihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIHNlbCA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgIHBvaW50O1xuXG4gIGlmIChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIXByb3NlbWlycm9yVHJhbnNmb3JtLmNhbkpvaW4oc3RhdGUuZG9jLCBzZWwudG8pKSByZXR1cm4gZmFsc2U7XG4gICAgcG9pbnQgPSBzZWwudG87XG4gIH0gZWxzZSB7XG4gICAgcG9pbnQgPSBwcm9zZW1pcnJvclRyYW5zZm9ybS5qb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwudG8sIDEpO1xuICAgIGlmIChwb2ludCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLmpvaW4ocG9pbnQpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBsaWZ0ID0gZnVuY3Rpb24gbGlmdChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24zID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uMy4kZnJvbSxcbiAgICAgICR0byA9IF9zdGF0ZSRzZWxlY3Rpb24zLiR0bztcbiAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLFxuICAgICAgdGFyZ2V0ID0gcmFuZ2UgJiYgcHJvc2VtaXJyb3JUcmFuc2Zvcm0ubGlmdFRhcmdldChyYW5nZSk7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIG5ld2xpbmVJbkNvZGUgPSBmdW5jdGlvbiBuZXdsaW5lSW5Db2RlKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgX3N0YXRlJHNlbGVjdGlvbjQgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAkaGVhZCA9IF9zdGF0ZSRzZWxlY3Rpb240LiRoZWFkLFxuICAgICAgJGFuY2hvciA9IF9zdGF0ZSRzZWxlY3Rpb240LiRhbmNob3I7XG4gIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuaW5zZXJ0VGV4dChcIlxcblwiKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBkZWZhdWx0QmxvY2tBdChtYXRjaCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgdmFyIF9tYXRjaCRlZGdlID0gbWF0Y2guZWRnZShpKSxcbiAgICAgICAgdHlwZSA9IF9tYXRjaCRlZGdlLnR5cGU7XG5cbiAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpIHJldHVybiB0eXBlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBleGl0Q29kZSA9IGZ1bmN0aW9uIGV4aXRDb2RlKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgX3N0YXRlJHNlbGVjdGlvbjUgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAkaGVhZCA9IF9zdGF0ZSRzZWxlY3Rpb241LiRoZWFkLFxuICAgICAgJGFuY2hvciA9IF9zdGF0ZSRzZWxlY3Rpb241LiRhbmNob3I7XG4gIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBhYm92ZSA9ICRoZWFkLm5vZGUoLTEpLFxuICAgICAgYWZ0ZXIgPSAkaGVhZC5pbmRleEFmdGVyKC0xKSxcbiAgICAgIHR5cGUgPSBkZWZhdWx0QmxvY2tBdChhYm92ZS5jb250ZW50TWF0Y2hBdChhZnRlcikpO1xuICBpZiAoIXR5cGUgfHwgIWFib3ZlLmNhblJlcGxhY2VXaXRoKGFmdGVyLCBhZnRlciwgdHlwZSkpIHJldHVybiBmYWxzZTtcblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB2YXIgcG9zID0gJGhlYWQuYWZ0ZXIoKSxcbiAgICAgICAgdHIgPSBzdGF0ZS50ci5yZXBsYWNlV2l0aChwb3MsIHBvcywgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuICAgIHRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHBvcyksIDEpKTtcbiAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGNyZWF0ZVBhcmFncmFwaE5lYXIgPSBmdW5jdGlvbiBjcmVhdGVQYXJhZ3JhcGhOZWFyKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgc2VsID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJGZyb20gPSBzZWwuJGZyb20sXG4gICAgICAkdG8gPSBzZWwuJHRvO1xuICBpZiAoc2VsIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5BbGxTZWxlY3Rpb24gfHwgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50KSByZXR1cm4gZmFsc2U7XG4gIHZhciB0eXBlID0gZGVmYXVsdEJsb2NrQXQoJHRvLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkdG8uaW5kZXhBZnRlcigpKSk7XG4gIGlmICghdHlwZSB8fCAhdHlwZS5pc1RleHRibG9jaykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHZhciBzaWRlID0gKCEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJHRvLmluZGV4KCkgPCAkdG8ucGFyZW50LmNoaWxkQ291bnQgPyAkZnJvbSA6ICR0bykucG9zO1xuICAgIHZhciB0ciA9IHN0YXRlLnRyLmluc2VydChzaWRlLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBzaWRlICsgMSkpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgbGlmdEVtcHR5QmxvY2sgPSBmdW5jdGlvbiBsaWZ0RW1wdHlCbG9jayhzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyICRjdXJzb3IgPSBzdGF0ZS5zZWxlY3Rpb24uJGN1cnNvcjtcbiAgaWYgKCEkY3Vyc29yIHx8ICRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICgkY3Vyc29yLmRlcHRoID4gMSAmJiAkY3Vyc29yLmFmdGVyKCkgIT0gJGN1cnNvci5lbmQoLTEpKSB7XG4gICAgdmFyIGJlZm9yZSA9ICRjdXJzb3IuYmVmb3JlKCk7XG5cbiAgICBpZiAocHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuU3BsaXQoc3RhdGUuZG9jLCBiZWZvcmUpKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KGJlZm9yZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSxcbiAgICAgIHRhcmdldCA9IHJhbmdlICYmIHByb3NlbWlycm9yVHJhbnNmb3JtLmxpZnRUYXJnZXQocmFuZ2UpO1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBzcGxpdEJsb2NrID0gZnVuY3Rpb24gc3BsaXRCbG9jayhzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb242ID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uNi4kZnJvbSxcbiAgICAgICR0byA9IF9zdGF0ZSRzZWxlY3Rpb242LiR0bztcblxuICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uICYmIHN0YXRlLnNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhcHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuU3BsaXQoc3RhdGUuZG9jLCAkZnJvbS5wb3MpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCEkZnJvbS5wYXJlbnQuaXNCbG9jaykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHZhciBhdEVuZCA9ICR0by5wYXJlbnRPZmZzZXQgPT0gJHRvLnBhcmVudC5jb250ZW50LnNpemU7XG4gICAgdmFyIHRyID0gc3RhdGUudHI7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbiB8fCBzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLkFsbFNlbGVjdGlvbikgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgdmFyIGRlZmx0ID0gJGZyb20uZGVwdGggPT0gMCA/IG51bGwgOiBkZWZhdWx0QmxvY2tBdCgkZnJvbS5ub2RlKC0xKS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKC0xKSkpO1xuICAgIHZhciB0eXBlcyA9IGF0RW5kICYmIGRlZmx0ID8gW3tcbiAgICAgIHR5cGU6IGRlZmx0XG4gICAgfV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGNhbiA9IHByb3NlbWlycm9yVHJhbnNmb3JtLmNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuXG4gICAgaWYgKCF0eXBlcyAmJiAhY2FuICYmIHByb3NlbWlycm9yVHJhbnNmb3JtLmNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgZGVmbHQgPyBbe1xuICAgICAgdHlwZTogZGVmbHRcbiAgICB9XSA6IHVuZGVmaW5lZCkpIHtcbiAgICAgIGlmIChkZWZsdCkgdHlwZXMgPSBbe1xuICAgICAgICB0eXBlOiBkZWZsdFxuICAgICAgfV07XG4gICAgICBjYW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjYW4pIHtcbiAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcblxuICAgICAgaWYgKCFhdEVuZCAmJiAhJGZyb20ucGFyZW50T2Zmc2V0ICYmICRmcm9tLnBhcmVudC50eXBlICE9IGRlZmx0KSB7XG4gICAgICAgIHZhciBmaXJzdCA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSxcbiAgICAgICAgICAgICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0KTtcbiAgICAgICAgaWYgKGRlZmx0ICYmICRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSkgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksIGRlZmx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNwbGl0QmxvY2tLZWVwTWFya3MgPSBmdW5jdGlvbiBzcGxpdEJsb2NrS2VlcE1hcmtzKHN0YXRlLCBkaXNwYXRjaCkge1xuICByZXR1cm4gc3BsaXRCbG9jayhzdGF0ZSwgZGlzcGF0Y2ggJiYgZnVuY3Rpb24gKHRyKSB7XG4gICAgdmFyIG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCk7XG4gICAgaWYgKG1hcmtzKSB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgZGlzcGF0Y2godHIpO1xuICB9KTtcbn07XG5cbnZhciBzZWxlY3RQYXJlbnROb2RlID0gZnVuY3Rpb24gc2VsZWN0UGFyZW50Tm9kZShzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb243ID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uNy4kZnJvbSxcbiAgICAgIHRvID0gX3N0YXRlJHNlbGVjdGlvbjcudG8sXG4gICAgICBwb3M7XG4gIHZhciBzYW1lID0gJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICBpZiAoc2FtZSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gIHBvcyA9ICRmcm9tLmJlZm9yZShzYW1lKTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24ocHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsIHBvcykpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgc2VsZWN0QWxsID0gZnVuY3Rpb24gc2VsZWN0QWxsKHN0YXRlLCBkaXNwYXRjaCkge1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgcHJvc2VtaXJyb3JTdGF0ZS5BbGxTZWxlY3Rpb24oc3RhdGUuZG9jKSkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkcG9zLCBkaXNwYXRjaCkge1xuICB2YXIgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLFxuICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcixcbiAgICAgIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICBpZiAoIWJlZm9yZSB8fCAhYWZ0ZXIgfHwgIWJlZm9yZS50eXBlLmNvbXBhdGlibGVDb250ZW50KGFmdGVyLnR5cGUpKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKCFiZWZvcmUuY29udGVudC5zaXplICYmICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXggLSAxLCBpbmRleCkpIHtcbiAgICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyW1wiZGVsZXRlXCJdKCRwb3MucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkcG9zLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoISRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkgfHwgIShhZnRlci5pc1RleHRibG9jayB8fCBwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5Kb2luKHN0YXRlLmRvYywgJHBvcy5wb3MpKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLmNsZWFySW5jb21wYXRpYmxlKCRwb3MucG9zLCBiZWZvcmUudHlwZSwgYmVmb3JlLmNvbnRlbnRNYXRjaEF0KGJlZm9yZS5jaGlsZENvdW50KSkuam9pbigkcG9zLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICB2YXIgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLFxuICAgICAgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlcixcbiAgICAgIGNvbm4sXG4gICAgICBtYXRjaDtcbiAgaWYgKGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpIHJldHVybiBmYWxzZTtcbiAgaWYgKGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpIHJldHVybiB0cnVlO1xuICB2YXIgY2FuRGVsQWZ0ZXIgPSAkY3V0LnBhcmVudC5jYW5SZXBsYWNlKCRjdXQuaW5kZXgoKSwgJGN1dC5pbmRleCgpICsgMSk7XG5cbiAgaWYgKGNhbkRlbEFmdGVyICYmIChjb25uID0gKG1hdGNoID0gYmVmb3JlLmNvbnRlbnRNYXRjaEF0KGJlZm9yZS5jaGlsZENvdW50KSkuZmluZFdyYXBwaW5nKGFmdGVyLnR5cGUpKSAmJiBtYXRjaC5tYXRjaFR5cGUoY29ublswXSB8fCBhZnRlci50eXBlKS52YWxpZEVuZCkge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgdmFyIGVuZCA9ICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUsXG4gICAgICAgICAgd3JhcCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBjb25uLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHdyYXAgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oY29ubltpXS5jcmVhdGUobnVsbCwgd3JhcCkpO1xuICAgICAgfVxuXG4gICAgICB3cmFwID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGJlZm9yZS5jb3B5KHdyYXApKTtcbiAgICAgIHZhciB0ciA9IHN0YXRlLnRyLnN0ZXAobmV3IHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gMSwgZW5kLCAkY3V0LnBvcywgZW5kLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZSh3cmFwLCAxLCAwKSwgY29ubi5sZW5ndGgsIHRydWUpKTtcbiAgICAgIHZhciBqb2luQXQgPSBlbmQgKyAyICogY29ubi5sZW5ndGg7XG4gICAgICBpZiAocHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuSm9pbih0ci5kb2MsIGpvaW5BdCkpIHRyLmpvaW4oam9pbkF0KTtcbiAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHNlbEFmdGVyID0gcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24uZmluZEZyb20oJGN1dCwgMSk7XG4gIHZhciByYW5nZSA9IHNlbEFmdGVyICYmIHNlbEFmdGVyLiRmcm9tLmJsb2NrUmFuZ2Uoc2VsQWZ0ZXIuJHRvKSxcbiAgICAgIHRhcmdldCA9IHJhbmdlICYmIHByb3NlbWlycm9yVHJhbnNmb3JtLmxpZnRUYXJnZXQocmFuZ2UpO1xuXG4gIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQgPj0gJGN1dC5kZXB0aCkge1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChjYW5EZWxBZnRlciAmJiB0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiLCB0cnVlKSAmJiB0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpKSB7XG4gICAgdmFyIGF0ID0gYmVmb3JlLFxuICAgICAgICBfd3JhcCA9IFtdO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgX3dyYXAucHVzaChhdCk7XG5cbiAgICAgIGlmIChhdC5pc1RleHRibG9jaykgYnJlYWs7XG4gICAgICBhdCA9IGF0Lmxhc3RDaGlsZDtcbiAgICB9XG5cbiAgICB2YXIgYWZ0ZXJUZXh0ID0gYWZ0ZXIsXG4gICAgICAgIGFmdGVyRGVwdGggPSAxO1xuXG4gICAgZm9yICg7ICFhZnRlclRleHQuaXNUZXh0YmxvY2s7IGFmdGVyVGV4dCA9IGFmdGVyVGV4dC5maXJzdENoaWxkKSB7XG4gICAgICBhZnRlckRlcHRoKys7XG4gICAgfVxuXG4gICAgaWYgKGF0LmNhblJlcGxhY2UoYXQuY2hpbGRDb3VudCwgYXQuY2hpbGRDb3VudCwgYWZ0ZXJUZXh0LmNvbnRlbnQpKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIF9lbmQgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5O1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gX3dyYXAubGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2ktLSkge1xuICAgICAgICAgIF9lbmQgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oX3dyYXBbX2ldLmNvcHkoX2VuZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF90ciA9IHN0YXRlLnRyLnN0ZXAobmV3IHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gX3dyYXAubGVuZ3RoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCAkY3V0LnBvcyArIGFmdGVyRGVwdGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUgLSBhZnRlckRlcHRoLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShfZW5kLCBfd3JhcC5sZW5ndGgsIDApLCAwLCB0cnVlKSk7XG5cbiAgICAgICAgZGlzcGF0Y2goX3RyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdFRleHRibG9ja1NpZGUoc2lkZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAgICRwb3MgPSBzaWRlIDwgMCA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgdmFyIGRlcHRoID0gJHBvcy5kZXB0aDtcblxuICAgIHdoaWxlICgkcG9zLm5vZGUoZGVwdGgpLmlzSW5saW5lKSB7XG4gICAgICBpZiAoIWRlcHRoKSByZXR1cm4gZmFsc2U7XG4gICAgICBkZXB0aC0tO1xuICAgIH1cblxuICAgIGlmICghJHBvcy5ub2RlKGRlcHRoKS5pc1RleHRibG9jaykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBzaWRlIDwgMCA/ICRwb3Muc3RhcnQoZGVwdGgpIDogJHBvcy5lbmQoZGVwdGgpKSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgc2VsZWN0VGV4dGJsb2NrU3RhcnQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKC0xKTtcbnZhciBzZWxlY3RUZXh0YmxvY2tFbmQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKDEpO1xuXG5mdW5jdGlvbiB3cmFwSW4obm9kZVR5cGUpIHtcbiAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciBfc3RhdGUkc2VsZWN0aW9uOCA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uOC4kZnJvbSxcbiAgICAgICAgJHRvID0gX3N0YXRlJHNlbGVjdGlvbjguJHRvO1xuICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSxcbiAgICAgICAgd3JhcHBpbmcgPSByYW5nZSAmJiBwcm9zZW1pcnJvclRyYW5zZm9ybS5maW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgaWYgKCF3cmFwcGluZykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIud3JhcChyYW5nZSwgd3JhcHBpbmcpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZXRCbG9ja1R5cGUobm9kZVR5cGUpIHtcbiAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciBfc3RhdGUkc2VsZWN0aW9uOSA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgZnJvbSA9IF9zdGF0ZSRzZWxlY3Rpb245LmZyb20sXG4gICAgICAgIHRvID0gX3N0YXRlJHNlbGVjdGlvbjkudG87XG4gICAgdmFyIGFwcGxpY2FibGUgPSBmYWxzZTtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgICBpZiAoYXBwbGljYWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUuaGFzTWFya3VwKG5vZGVUeXBlLCBhdHRycykpIHJldHVybjtcblxuICAgICAgaWYgKG5vZGUudHlwZSA9PSBub2RlVHlwZSkge1xuICAgICAgICBhcHBsaWNhYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciAkcG9zID0gc3RhdGUuZG9jLnJlc29sdmUocG9zKSxcbiAgICAgICAgICAgIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgICAgICBhcHBsaWNhYmxlID0gJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgbm9kZVR5cGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghYXBwbGljYWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuc2V0QmxvY2tUeXBlKGZyb20sIHRvLCBub2RlVHlwZSwgYXR0cnMpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtYXJrQXBwbGllcyhkb2MsIHJhbmdlcywgdHlwZSkge1xuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgdmFyIF9yYW5nZXMkaSA9IHJhbmdlc1tpXSxcbiAgICAgICAgJGZyb20gPSBfcmFuZ2VzJGkuJGZyb20sXG4gICAgICAgICR0byA9IF9yYW5nZXMkaS4kdG87XG4gICAgdmFyIGNhbiA9ICRmcm9tLmRlcHRoID09IDAgPyBkb2MudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKSA6IGZhbHNlO1xuICAgIGRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKGNhbikgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FuID0gbm9kZS5pbmxpbmVDb250ZW50ICYmIG5vZGUudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKTtcbiAgICB9KTtcbiAgICBpZiAoY2FuKSByZXR1cm4ge1xuICAgICAgdjogdHJ1ZVxuICAgIH07XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX3JldCA9IF9sb29wKGkpO1xuXG4gICAgaWYgKF90eXBlb2YoX3JldCkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZU1hcmsobWFya1R5cGUpIHtcbiAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciBfc3RhdGUkc2VsZWN0aW9uMTAgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAgIGVtcHR5ID0gX3N0YXRlJHNlbGVjdGlvbjEwLmVtcHR5LFxuICAgICAgICAkY3Vyc29yID0gX3N0YXRlJHNlbGVjdGlvbjEwLiRjdXJzb3IsXG4gICAgICAgIHJhbmdlcyA9IF9zdGF0ZSRzZWxlY3Rpb24xMC5yYW5nZXM7XG4gICAgaWYgKGVtcHR5ICYmICEkY3Vyc29yIHx8ICFtYXJrQXBwbGllcyhzdGF0ZS5kb2MsIHJhbmdlcywgbWFya1R5cGUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgIGlmIChtYXJrVHlwZS5pc0luU2V0KHN0YXRlLnN0b3JlZE1hcmtzIHx8ICRjdXJzb3IubWFya3MoKSkpIGRpc3BhdGNoKHN0YXRlLnRyLnJlbW92ZVN0b3JlZE1hcmsobWFya1R5cGUpKTtlbHNlIGRpc3BhdGNoKHN0YXRlLnRyLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKGF0dHJzKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGhhcyA9IGZhbHNlLFxuICAgICAgICAgICAgdHIgPSBzdGF0ZS50cjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgIWhhcyAmJiBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9yYW5nZXMkaTIgPSByYW5nZXNbaV0sXG4gICAgICAgICAgICAgICRmcm9tID0gX3JhbmdlcyRpMi4kZnJvbSxcbiAgICAgICAgICAgICAgJHRvID0gX3JhbmdlcyRpMi4kdG87XG4gICAgICAgICAgaGFzID0gc3RhdGUuZG9jLnJhbmdlSGFzTWFyaygkZnJvbS5wb3MsICR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHJhbmdlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIF9yYW5nZXMkX2kgPSByYW5nZXNbX2kyXSxcbiAgICAgICAgICAgICAgXyRmcm9tID0gX3JhbmdlcyRfaS4kZnJvbSxcbiAgICAgICAgICAgICAgXyR0byA9IF9yYW5nZXMkX2kuJHRvO1xuXG4gICAgICAgICAgaWYgKGhhcykge1xuICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhfJGZyb20ucG9zLCBfJHRvLnBvcywgbWFya1R5cGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IF8kZnJvbS5wb3MsXG4gICAgICAgICAgICAgICAgdG8gPSBfJHRvLnBvcyxcbiAgICAgICAgICAgICAgICBzdGFydCA9IF8kZnJvbS5ub2RlQWZ0ZXIsXG4gICAgICAgICAgICAgICAgZW5kID0gXyR0by5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgdmFyIHNwYWNlU3RhcnQgPSBzdGFydCAmJiBzdGFydC5pc1RleHQgPyAvXlxccyovLmV4ZWMoc3RhcnQudGV4dClbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgIHZhciBzcGFjZUVuZCA9IGVuZCAmJiBlbmQuaXNUZXh0ID8gL1xccyokLy5leGVjKGVuZC50ZXh0KVswXS5sZW5ndGggOiAwO1xuXG4gICAgICAgICAgICBpZiAoZnJvbSArIHNwYWNlU3RhcnQgPCB0bykge1xuICAgICAgICAgICAgICBmcm9tICs9IHNwYWNlU3RhcnQ7XG4gICAgICAgICAgICAgIHRvIC09IHNwYWNlRW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgaXNKb2luYWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRyKSB7XG4gICAgaWYgKCF0ci5pc0dlbmVyaWMpIHJldHVybiBkaXNwYXRjaCh0cik7XG4gICAgdmFyIHJhbmdlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmFuZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHJhbmdlc1tqXSA9IG1hcC5tYXAocmFuZ2VzW2pdKTtcbiAgICAgIH1cblxuICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKF9zLCBfZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlcy5wdXNoKGZyb20sIHRvKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBqb2luYWJsZSA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgcmFuZ2VzLmxlbmd0aDsgX2kzICs9IDIpIHtcbiAgICAgIHZhciBmcm9tID0gcmFuZ2VzW19pM10sXG4gICAgICAgICAgdG8gPSByYW5nZXNbX2kzICsgMV07XG4gICAgICB2YXIgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSxcbiAgICAgICAgICBkZXB0aCA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKSxcbiAgICAgICAgICBwYXJlbnQgPSAkZnJvbS5ub2RlKGRlcHRoKTtcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSwgcG9zID0gJGZyb20uYWZ0ZXIoZGVwdGggKyAxKTsgcG9zIDw9IHRvOyArK2luZGV4KSB7XG4gICAgICAgIHZhciBhZnRlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgaWYgKCFhZnRlcikgYnJlYWs7XG5cbiAgICAgICAgaWYgKGluZGV4ICYmIGpvaW5hYmxlLmluZGV4T2YocG9zKSA9PSAtMSkge1xuICAgICAgICAgIHZhciBiZWZvcmUgPSBwYXJlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgICBpZiAoYmVmb3JlLnR5cGUgPT0gYWZ0ZXIudHlwZSAmJiBpc0pvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpKSBqb2luYWJsZS5wdXNoKHBvcyk7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MgKz0gYWZ0ZXIubm9kZVNpemU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgam9pbmFibGUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgX2k0ID0gam9pbmFibGUubGVuZ3RoIC0gMTsgX2k0ID49IDA7IF9pNC0tKSB7XG4gICAgICBpZiAocHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuSm9pbih0ci5kb2MsIGpvaW5hYmxlW19pNF0pKSB0ci5qb2luKGpvaW5hYmxlW19pNF0pO1xuICAgIH1cblxuICAgIGRpc3BhdGNoKHRyKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXV0b0pvaW4oY29tbWFuZCwgaXNKb2luYWJsZSkge1xuICB2YXIgY2FuSm9pbiA9IEFycmF5LmlzQXJyYXkoaXNKb2luYWJsZSkgPyBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBpc0pvaW5hYmxlLmluZGV4T2Yobm9kZS50eXBlLm5hbWUpID4gLTE7XG4gIH0gOiBpc0pvaW5hYmxlO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgIHJldHVybiBjb21tYW5kKHN0YXRlLCBkaXNwYXRjaCAmJiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBjYW5Kb2luKSwgdmlldyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoYWluQ29tbWFuZHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjb21tYW5kcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBjb21tYW5kc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNvbW1hbmRzW2ldKHN0YXRlLCBkaXNwYXRjaCwgdmlldykpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxudmFyIGJhY2tzcGFjZSA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luQmFja3dhcmQsIHNlbGVjdE5vZGVCYWNrd2FyZCk7XG52YXIgZGVsID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5Gb3J3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCk7XG52YXIgcGNCYXNlS2V5bWFwID0ge1xuICBcIkVudGVyXCI6IGNoYWluQ29tbWFuZHMobmV3bGluZUluQ29kZSwgY3JlYXRlUGFyYWdyYXBoTmVhciwgbGlmdEVtcHR5QmxvY2ssIHNwbGl0QmxvY2spLFxuICBcIk1vZC1FbnRlclwiOiBleGl0Q29kZSxcbiAgXCJCYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICBcIk1vZC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gIFwiRGVsZXRlXCI6IGRlbCxcbiAgXCJNb2QtRGVsZXRlXCI6IGRlbCxcbiAgXCJNb2QtYVwiOiBzZWxlY3RBbGxcbn07XG52YXIgbWFjQmFzZUtleW1hcCA9IHtcbiAgXCJDdHJsLWhcIjogcGNCYXNlS2V5bWFwW1wiQmFja3NwYWNlXCJdLFxuICBcIkFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLUJhY2tzcGFjZVwiXSxcbiAgXCJDdHJsLWRcIjogcGNCYXNlS2V5bWFwW1wiRGVsZXRlXCJdLFxuICBcIkN0cmwtQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICBcIkFsdC1EZWxldGVcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgXCJBbHQtZFwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICBcIkN0cmwtYVwiOiBzZWxlY3RUZXh0YmxvY2tTdGFydCxcbiAgXCJDdHJsLWVcIjogc2VsZWN0VGV4dGJsb2NrRW5kXG59O1xuXG5mb3IgKHZhciBrZXkgaW4gcGNCYXNlS2V5bWFwKSB7XG4gIG1hY0Jhc2VLZXltYXBba2V5XSA9IHBjQmFzZUtleW1hcFtrZXldO1xufVxuXG52YXIgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gL01hY3xpUChob25lfFtvYV1kKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIDogdHlwZW9mIG9zICE9IFwidW5kZWZpbmVkXCIgJiYgb3MucGxhdGZvcm0gPyBvcy5wbGF0Zm9ybSgpID09IFwiZGFyd2luXCIgOiBmYWxzZTtcbnZhciBiYXNlS2V5bWFwID0gbWFjID8gbWFjQmFzZUtleW1hcCA6IHBjQmFzZUtleW1hcDtcbmV4cG9ydHMuYXV0b0pvaW4gPSBhdXRvSm9pbjtcbmV4cG9ydHMuYmFzZUtleW1hcCA9IGJhc2VLZXltYXA7XG5leHBvcnRzLmNoYWluQ29tbWFuZHMgPSBjaGFpbkNvbW1hbmRzO1xuZXhwb3J0cy5jcmVhdGVQYXJhZ3JhcGhOZWFyID0gY3JlYXRlUGFyYWdyYXBoTmVhcjtcbmV4cG9ydHMuZGVsZXRlU2VsZWN0aW9uID0gZGVsZXRlU2VsZWN0aW9uO1xuZXhwb3J0cy5leGl0Q29kZSA9IGV4aXRDb2RlO1xuZXhwb3J0cy5qb2luQmFja3dhcmQgPSBqb2luQmFja3dhcmQ7XG5leHBvcnRzLmpvaW5Eb3duID0gam9pbkRvd247XG5leHBvcnRzLmpvaW5Gb3J3YXJkID0gam9pbkZvcndhcmQ7XG5leHBvcnRzLmpvaW5VcCA9IGpvaW5VcDtcbmV4cG9ydHMubGlmdCA9IGxpZnQ7XG5leHBvcnRzLmxpZnRFbXB0eUJsb2NrID0gbGlmdEVtcHR5QmxvY2s7XG5leHBvcnRzLm1hY0Jhc2VLZXltYXAgPSBtYWNCYXNlS2V5bWFwO1xuZXhwb3J0cy5uZXdsaW5lSW5Db2RlID0gbmV3bGluZUluQ29kZTtcbmV4cG9ydHMucGNCYXNlS2V5bWFwID0gcGNCYXNlS2V5bWFwO1xuZXhwb3J0cy5zZWxlY3RBbGwgPSBzZWxlY3RBbGw7XG5leHBvcnRzLnNlbGVjdE5vZGVCYWNrd2FyZCA9IHNlbGVjdE5vZGVCYWNrd2FyZDtcbmV4cG9ydHMuc2VsZWN0Tm9kZUZvcndhcmQgPSBzZWxlY3ROb2RlRm9yd2FyZDtcbmV4cG9ydHMuc2VsZWN0UGFyZW50Tm9kZSA9IHNlbGVjdFBhcmVudE5vZGU7XG5leHBvcnRzLnNlbGVjdFRleHRibG9ja0VuZCA9IHNlbGVjdFRleHRibG9ja0VuZDtcbmV4cG9ydHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQgPSBzZWxlY3RUZXh0YmxvY2tTdGFydDtcbmV4cG9ydHMuc2V0QmxvY2tUeXBlID0gc2V0QmxvY2tUeXBlO1xuZXhwb3J0cy5zcGxpdEJsb2NrID0gc3BsaXRCbG9jaztcbmV4cG9ydHMuc3BsaXRCbG9ja0tlZXBNYXJrcyA9IHNwbGl0QmxvY2tLZWVwTWFya3M7XG5leHBvcnRzLnRvZ2dsZU1hcmsgPSB0b2dnbGVNYXJrO1xuZXhwb3J0cy53cmFwSW4gPSB3cmFwSW47XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBwcm9zZW1pcnJvclN0YXRlID0gcmVxdWlyZSgncHJvc2VtaXJyb3Itc3RhdGUnKTtcblxudmFyIHByb3NlbWlycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItdHJhbnNmb3JtJyk7XG5cbmZ1bmN0aW9uIGRyb3BDdXJzb3IoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgcmV0dXJuIG5ldyBwcm9zZW1pcnJvclN0YXRlLlBsdWdpbih7XG4gICAgdmlldzogZnVuY3Rpb24gdmlldyhlZGl0b3JWaWV3KSB7XG4gICAgICByZXR1cm4gbmV3IERyb3BDdXJzb3JWaWV3KGVkaXRvclZpZXcsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBEcm9wQ3Vyc29yVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRHJvcEN1cnNvclZpZXcoZWRpdG9yVmlldywgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcEN1cnNvclZpZXcpO1xuXG4gICAgdGhpcy5lZGl0b3JWaWV3ID0gZWRpdG9yVmlldztcbiAgICB0aGlzLmN1cnNvclBvcyA9IG51bGw7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLnRpbWVvdXQgPSAtMTtcbiAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCB8fCAxO1xuICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgICB0aGlzW1wiY2xhc3NcIl0gPSBvcHRpb25zW1wiY2xhc3NcIl07XG4gICAgdGhpcy5oYW5kbGVycyA9IFtcImRyYWdvdmVyXCIsIFwiZHJhZ2VuZFwiLCBcImRyb3BcIiwgXCJkcmFnbGVhdmVcIl0ubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuICAgICAgICBfdGhpc1tuYW1lXShlKTtcbiAgICAgIH07XG5cbiAgICAgIGVkaXRvclZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERyb3BDdXJzb3JWaWV3LCBbe1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5oYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICAgICAgaGFuZGxlciA9IF9yZWYuaGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5lZGl0b3JWaWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoZWRpdG9yVmlldywgcHJldlN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5jdXJzb3JQb3MgIT0gbnVsbCAmJiBwcmV2U3RhdGUuZG9jICE9IGVkaXRvclZpZXcuc3RhdGUuZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvclBvcyA+IGVkaXRvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSkgdGhpcy5zZXRDdXJzb3IobnVsbCk7ZWxzZSB0aGlzLnVwZGF0ZU92ZXJsYXkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q3Vyc29yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnNvcihwb3MpIHtcbiAgICAgIGlmIChwb3MgPT0gdGhpcy5jdXJzb3JQb3MpIHJldHVybjtcbiAgICAgIHRoaXMuY3Vyc29yUG9zID0gcG9zO1xuXG4gICAgICBpZiAocG9zID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBkYXRlT3ZlcmxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVPdmVybGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU92ZXJsYXkoKSB7XG4gICAgICB2YXIgJHBvcyA9IHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2MucmVzb2x2ZSh0aGlzLmN1cnNvclBvcyksXG4gICAgICAgICAgcmVjdDtcblxuICAgICAgaWYgKCEkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmUsXG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZUFmdGVyO1xuXG4gICAgICAgIGlmIChiZWZvcmUgfHwgYWZ0ZXIpIHtcbiAgICAgICAgICB2YXIgbm9kZVJlY3QgPSB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcyAtIChiZWZvcmUgPyBiZWZvcmUubm9kZVNpemUgOiAwKSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgdmFyIHRvcCA9IGJlZm9yZSA/IG5vZGVSZWN0LmJvdHRvbSA6IG5vZGVSZWN0LnRvcDtcbiAgICAgICAgICBpZiAoYmVmb3JlICYmIGFmdGVyKSB0b3AgPSAodG9wICsgdGhpcy5lZGl0b3JWaWV3Lm5vZGVET00odGhpcy5jdXJzb3JQb3MpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkgLyAyO1xuICAgICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgICBsZWZ0OiBub2RlUmVjdC5sZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IG5vZGVSZWN0LnJpZ2h0LFxuICAgICAgICAgICAgdG9wOiB0b3AgLSB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgICAgIGJvdHRvbTogdG9wICsgdGhpcy53aWR0aCAvIDJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVjdCkge1xuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5lZGl0b3JWaWV3LmNvb3Jkc0F0UG9zKHRoaXMuY3Vyc29yUG9zKTtcbiAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICBsZWZ0OiBjb29yZHMubGVmdCAtIHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIHJpZ2h0OiBjb29yZHMubGVmdCArIHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIHRvcDogY29vcmRzLnRvcCxcbiAgICAgICAgICBib3R0b206IGNvb3Jkcy5ib3R0b21cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZWRpdG9yVmlldy5kb20ub2Zmc2V0UGFyZW50O1xuXG4gICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgIGlmICh0aGlzW1wiY2xhc3NcIl0pIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSB0aGlzW1wiY2xhc3NcIl07XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHotaW5kZXg6IDUwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgYmFja2dyb3VuZC1jb2xvcjogXCIgKyB0aGlzLmNvbG9yO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50TGVmdCwgcGFyZW50VG9wO1xuXG4gICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT0gZG9jdW1lbnQuYm9keSAmJiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkucG9zaXRpb24gPT0gXCJzdGF0aWNcIikge1xuICAgICAgICBwYXJlbnRMZWZ0ID0gLXBhZ2VYT2Zmc2V0O1xuICAgICAgICBwYXJlbnRUb3AgPSAtcGFnZVlPZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3JlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgcGFyZW50TGVmdCA9IF9yZWN0LmxlZnQgLSBwYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgcGFyZW50VG9wID0gX3JlY3QudG9wIC0gcGFyZW50LnNjcm9sbFRvcDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgLSBwYXJlbnRMZWZ0ICsgXCJweFwiO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IHJlY3QudG9wIC0gcGFyZW50VG9wICsgXCJweFwiO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gcmVjdC5yaWdodCAtIHJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wICsgXCJweFwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY2hlZHVsZVJlbW92YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NoZWR1bGVSZW1vdmFsKHRpbWVvdXQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnNldEN1cnNvcihudWxsKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmFnb3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmFnb3ZlcihldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmVkaXRvclZpZXcuZWRpdGFibGUpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmVkaXRvclZpZXcucG9zQXRDb29yZHMoe1xuICAgICAgICBsZWZ0OiBldmVudC5jbGllbnRYLFxuICAgICAgICB0b3A6IGV2ZW50LmNsaWVudFlcbiAgICAgIH0pO1xuICAgICAgdmFyIG5vZGUgPSBwb3MgJiYgcG9zLmluc2lkZSA+PSAwICYmIHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcy5pbnNpZGUpO1xuICAgICAgdmFyIGRpc2FibGVEcm9wQ3Vyc29yID0gbm9kZSAmJiBub2RlLnR5cGUuc3BlYy5kaXNhYmxlRHJvcEN1cnNvcjtcbiAgICAgIHZhciBkaXNhYmxlZCA9IHR5cGVvZiBkaXNhYmxlRHJvcEN1cnNvciA9PSBcImZ1bmN0aW9uXCIgPyBkaXNhYmxlRHJvcEN1cnNvcih0aGlzLmVkaXRvclZpZXcsIHBvcykgOiBkaXNhYmxlRHJvcEN1cnNvcjtcblxuICAgICAgaWYgKHBvcyAmJiAhZGlzYWJsZWQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHBvcy5wb3M7XG5cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yVmlldy5kcmFnZ2luZyAmJiB0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcuc2xpY2UpIHtcbiAgICAgICAgICB0YXJnZXQgPSBwcm9zZW1pcnJvclRyYW5zZm9ybS5kcm9wUG9pbnQodGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYywgdGFyZ2V0LCB0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcuc2xpY2UpO1xuICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkgcmV0dXJuIHRoaXMuc2V0Q3Vyc29yKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoNTAwMCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYWdlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhZ2VuZCgpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDIwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcm9wKCkge1xuICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoMjApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmFnbGVhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhZ2xlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IHRoaXMuZWRpdG9yVmlldy5kb20gfHwgIXRoaXMuZWRpdG9yVmlldy5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHRoaXMuc2V0Q3Vyc29yKG51bGwpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEcm9wQ3Vyc29yVmlldztcbn0oKTtcblxuZXhwb3J0cy5kcm9wQ3Vyc29yID0gZHJvcEN1cnNvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBwcm9zZW1pcnJvcktleW1hcCA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLWtleW1hcCcpO1xuXG52YXIgcHJvc2VtaXJyb3JIaXN0b3J5ID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItaGlzdG9yeScpO1xuXG52YXIgcHJvc2VtaXJyb3JDb21tYW5kcyA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLWNvbW1hbmRzJyk7XG5cbnZhciBwcm9zZW1pcnJvclN0YXRlID0gcmVxdWlyZSgncHJvc2VtaXJyb3Itc3RhdGUnKTtcblxudmFyIHByb3NlbWlycm9yRHJvcGN1cnNvciA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLWRyb3BjdXJzb3InKTtcblxudmFyIHByb3NlbWlycm9yR2FwY3Vyc29yID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItZ2FwY3Vyc29yJyk7XG5cbnZhciBwcm9zZW1pcnJvck1lbnUgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1tZW51Jyk7XG5cbnZhciBwcm9zZW1pcnJvclNjaGVtYUxpc3QgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1zY2hlbWEtbGlzdCcpO1xuXG52YXIgcHJvc2VtaXJyb3JJbnB1dHJ1bGVzID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItaW5wdXRydWxlcycpO1xuXG52YXIgcHJlZml4ID0gXCJQcm9zZU1pcnJvci1wcm9tcHRcIjtcblxuZnVuY3Rpb24gb3BlblByb21wdChvcHRpb25zKSB7XG4gIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgd3JhcHBlci5jbGFzc05hbWUgPSBwcmVmaXg7XG5cbiAgdmFyIG1vdXNlT3V0c2lkZSA9IGZ1bmN0aW9uIG1vdXNlT3V0c2lkZShlKSB7XG4gICAgaWYgKCF3cmFwcGVyLmNvbnRhaW5zKGUudGFyZ2V0KSkgY2xvc2UoKTtcbiAgfTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VPdXRzaWRlKTtcbiAgfSwgNTApO1xuXG4gIHZhciBjbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG1vdXNlT3V0c2lkZSk7XG4gICAgaWYgKHdyYXBwZXIucGFyZW50Tm9kZSkgd3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHdyYXBwZXIpO1xuICB9O1xuXG4gIHZhciBkb21GaWVsZHMgPSBbXTtcblxuICBmb3IgKHZhciBuYW1lIGluIG9wdGlvbnMuZmllbGRzKSB7XG4gICAgZG9tRmllbGRzLnB1c2gob3B0aW9ucy5maWVsZHNbbmFtZV0ucmVuZGVyKCkpO1xuICB9XG5cbiAgdmFyIHN1Ym1pdEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gIHN1Ym1pdEJ1dHRvbi50eXBlID0gXCJzdWJtaXRcIjtcbiAgc3VibWl0QnV0dG9uLmNsYXNzTmFtZSA9IHByZWZpeCArIFwiLXN1Ym1pdFwiO1xuICBzdWJtaXRCdXR0b24udGV4dENvbnRlbnQgPSBcIk9LXCI7XG4gIHZhciBjYW5jZWxCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICBjYW5jZWxCdXR0b24udHlwZSA9IFwiYnV0dG9uXCI7XG4gIGNhbmNlbEJ1dHRvbi5jbGFzc05hbWUgPSBwcmVmaXggKyBcIi1jYW5jZWxcIjtcbiAgY2FuY2VsQnV0dG9uLnRleHRDb250ZW50ID0gXCJDYW5jZWxcIjtcbiAgY2FuY2VsQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjbG9zZSk7XG4gIHZhciBmb3JtID0gd3JhcHBlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSk7XG4gIGlmIChvcHRpb25zLnRpdGxlKSBmb3JtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoNVwiKSkudGV4dENvbnRlbnQgPSBvcHRpb25zLnRpdGxlO1xuICBkb21GaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICBmb3JtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmFwcGVuZENoaWxkKGZpZWxkKTtcbiAgfSk7XG4gIHZhciBidXR0b25zID0gZm9ybS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgYnV0dG9ucy5jbGFzc05hbWUgPSBwcmVmaXggKyBcIi1idXR0b25zXCI7XG4gIGJ1dHRvbnMuYXBwZW5kQ2hpbGQoc3VibWl0QnV0dG9uKTtcbiAgYnV0dG9ucy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIiBcIikpO1xuICBidXR0b25zLmFwcGVuZENoaWxkKGNhbmNlbEJ1dHRvbik7XG4gIHZhciBib3ggPSB3cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB3cmFwcGVyLnN0eWxlLnRvcCA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBib3guaGVpZ2h0KSAvIDIgKyBcInB4XCI7XG4gIHdyYXBwZXIuc3R5bGUubGVmdCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIGJveC53aWR0aCkgLyAyICsgXCJweFwiO1xuXG4gIHZhciBzdWJtaXQgPSBmdW5jdGlvbiBzdWJtaXQoKSB7XG4gICAgdmFyIHBhcmFtcyA9IGdldFZhbHVlcyhvcHRpb25zLmZpZWxkcywgZG9tRmllbGRzKTtcblxuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgICBvcHRpb25zLmNhbGxiYWNrKHBhcmFtcyk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBzdWJtaXQoKTtcbiAgfSk7XG4gIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09IDI3KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjbG9zZSgpO1xuICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmICEoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5KSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3VibWl0KCk7XG4gICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT0gOSkge1xuICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXdyYXBwZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIGNsb3NlKCk7XG4gICAgICB9LCA1MDApO1xuICAgIH1cbiAgfSk7XG4gIHZhciBpbnB1dCA9IGZvcm0uZWxlbWVudHNbMF07XG4gIGlmIChpbnB1dCkgaW5wdXQuZm9jdXMoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKGZpZWxkcywgZG9tRmllbGRzKSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgaSA9IDA7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBmaWVsZHMpIHtcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbbmFtZV0sXG4gICAgICAgIGRvbSA9IGRvbUZpZWxkc1tpKytdO1xuICAgIHZhciB2YWx1ZSA9IGZpZWxkLnJlYWQoZG9tKSxcbiAgICAgICAgYmFkID0gZmllbGQudmFsaWRhdGUodmFsdWUpO1xuXG4gICAgaWYgKGJhZCkge1xuICAgICAgcmVwb3J0SW52YWxpZChkb20sIGJhZCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXN1bHRbbmFtZV0gPSBmaWVsZC5jbGVhbih2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZXBvcnRJbnZhbGlkKGRvbSwgbWVzc2FnZSkge1xuICB2YXIgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gIHZhciBtc2cgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gIG1zZy5zdHlsZS5sZWZ0ID0gZG9tLm9mZnNldExlZnQgKyBkb20ub2Zmc2V0V2lkdGggKyAyICsgXCJweFwiO1xuICBtc2cuc3R5bGUudG9wID0gZG9tLm9mZnNldFRvcCAtIDUgKyBcInB4XCI7XG4gIG1zZy5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLWludmFsaWRcIjtcbiAgbXNnLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcmVudC5yZW1vdmVDaGlsZChtc2cpO1xuICB9LCAxNTAwKTtcbn1cblxudmFyIEZpZWxkID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGaWVsZChvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpZWxkKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRmllbGQsIFt7XG4gICAga2V5OiBcInJlYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZChkb20pIHtcbiAgICAgIHJldHVybiBkb20udmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZVR5cGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSAmJiB0aGlzLm9wdGlvbnMucmVxdWlyZWQpIHJldHVybiBcIlJlcXVpcmVkIGZpZWxkXCI7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVR5cGUodmFsdWUpIHx8ICh0aGlzLm9wdGlvbnMudmFsaWRhdGUgPyB0aGlzLm9wdGlvbnMudmFsaWRhdGUodmFsdWUpIDogbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNsZWFuID8gdGhpcy5vcHRpb25zLmNsZWFuKHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaWVsZDtcbn0oKTtcblxudmFyIFRleHRGaWVsZCA9IGZ1bmN0aW9uIChfRmllbGQpIHtcbiAgX2luaGVyaXRzKFRleHRGaWVsZCwgX0ZpZWxkKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFRleHRGaWVsZCk7XG5cbiAgZnVuY3Rpb24gVGV4dEZpZWxkKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0RmllbGQpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRleHRGaWVsZCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIGlucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgIGlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5vcHRpb25zLmxhYmVsO1xuICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWUgfHwgXCJcIjtcbiAgICAgIGlucHV0LmF1dG9jb21wbGV0ZSA9IFwib2ZmXCI7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRleHRGaWVsZDtcbn0oRmllbGQpO1xuXG5mdW5jdGlvbiBjYW5JbnNlcnQoc3RhdGUsIG5vZGVUeXBlKSB7XG4gIHZhciAkZnJvbSA9IHN0YXRlLnNlbGVjdGlvbi4kZnJvbTtcblxuICBmb3IgKHZhciBkID0gJGZyb20uZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgdmFyIGluZGV4ID0gJGZyb20uaW5kZXgoZCk7XG4gICAgaWYgKCRmcm9tLm5vZGUoZCkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBub2RlVHlwZSkpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRJbWFnZUl0ZW0obm9kZVR5cGUpIHtcbiAgcmV0dXJuIG5ldyBwcm9zZW1pcnJvck1lbnUuTWVudUl0ZW0oe1xuICAgIHRpdGxlOiBcIkluc2VydCBpbWFnZVwiLFxuICAgIGxhYmVsOiBcIkltYWdlXCIsXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoc3RhdGUpIHtcbiAgICAgIHJldHVybiBjYW5JbnNlcnQoc3RhdGUsIG5vZGVUeXBlKTtcbiAgICB9LFxuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHN0YXRlLCBfLCB2aWV3KSB7XG4gICAgICB2YXIgX3N0YXRlJHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgICBmcm9tID0gX3N0YXRlJHNlbGVjdGlvbi5mcm9tLFxuICAgICAgICAgIHRvID0gX3N0YXRlJHNlbGVjdGlvbi50byxcbiAgICAgICAgICBhdHRycyA9IG51bGw7XG4gICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uICYmIHN0YXRlLnNlbGVjdGlvbi5ub2RlLnR5cGUgPT0gbm9kZVR5cGUpIGF0dHJzID0gc3RhdGUuc2VsZWN0aW9uLm5vZGUuYXR0cnM7XG4gICAgICBvcGVuUHJvbXB0KHtcbiAgICAgICAgdGl0bGU6IFwiSW5zZXJ0IGltYWdlXCIsXG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgIHNyYzogbmV3IFRleHRGaWVsZCh7XG4gICAgICAgICAgICBsYWJlbDogXCJMb2NhdGlvblwiLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogYXR0cnMgJiYgYXR0cnMuc3JjXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGl0bGU6IG5ldyBUZXh0RmllbGQoe1xuICAgICAgICAgICAgbGFiZWw6IFwiVGl0bGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBhdHRycyAmJiBhdHRycy50aXRsZVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGFsdDogbmV3IFRleHRGaWVsZCh7XG4gICAgICAgICAgICBsYWJlbDogXCJEZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgdmFsdWU6IGF0dHJzID8gYXR0cnMuYWx0IDogc3RhdGUuZG9jLnRleHRCZXR3ZWVuKGZyb20sIHRvLCBcIiBcIilcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soYXR0cnMpIHtcbiAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbldpdGgobm9kZVR5cGUuY3JlYXRlQW5kRmlsbChhdHRycykpKTtcbiAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNtZEl0ZW0oY21kLCBvcHRpb25zKSB7XG4gIHZhciBwYXNzZWRPcHRpb25zID0ge1xuICAgIGxhYmVsOiBvcHRpb25zLnRpdGxlLFxuICAgIHJ1bjogY21kXG4gIH07XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgcGFzc2VkT3B0aW9uc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuZW5hYmxlICYmICFvcHRpb25zLnNlbGVjdCkgcGFzc2VkT3B0aW9uc1tvcHRpb25zLmVuYWJsZSA/IFwiZW5hYmxlXCIgOiBcInNlbGVjdFwiXSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBjbWQoc3RhdGUpO1xuICB9O1xuICByZXR1cm4gbmV3IHByb3NlbWlycm9yTWVudS5NZW51SXRlbShwYXNzZWRPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbWFya0FjdGl2ZShzdGF0ZSwgdHlwZSkge1xuICB2YXIgX3N0YXRlJHNlbGVjdGlvbjIgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICBmcm9tID0gX3N0YXRlJHNlbGVjdGlvbjIuZnJvbSxcbiAgICAgICRmcm9tID0gX3N0YXRlJHNlbGVjdGlvbjIuJGZyb20sXG4gICAgICB0byA9IF9zdGF0ZSRzZWxlY3Rpb24yLnRvLFxuICAgICAgZW1wdHkgPSBfc3RhdGUkc2VsZWN0aW9uMi5lbXB0eTtcbiAgaWYgKGVtcHR5KSByZXR1cm4gISF0eXBlLmlzSW5TZXQoc3RhdGUuc3RvcmVkTWFya3MgfHwgJGZyb20ubWFya3MoKSk7ZWxzZSByZXR1cm4gc3RhdGUuZG9jLnJhbmdlSGFzTWFyayhmcm9tLCB0bywgdHlwZSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtJdGVtKG1hcmtUeXBlLCBvcHRpb25zKSB7XG4gIHZhciBwYXNzZWRPcHRpb25zID0ge1xuICAgIGFjdGl2ZTogZnVuY3Rpb24gYWN0aXZlKHN0YXRlKSB7XG4gICAgICByZXR1cm4gbWFya0FjdGl2ZShzdGF0ZSwgbWFya1R5cGUpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICBwYXNzZWRPcHRpb25zW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgfVxuXG4gIHJldHVybiBjbWRJdGVtKHByb3NlbWlycm9yQ29tbWFuZHMudG9nZ2xlTWFyayhtYXJrVHlwZSksIHBhc3NlZE9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBsaW5rSXRlbShtYXJrVHlwZSkge1xuICByZXR1cm4gbmV3IHByb3NlbWlycm9yTWVudS5NZW51SXRlbSh7XG4gICAgdGl0bGU6IFwiQWRkIG9yIHJlbW92ZSBsaW5rXCIsXG4gICAgaWNvbjogcHJvc2VtaXJyb3JNZW51Lmljb25zLmxpbmssXG4gICAgYWN0aXZlOiBmdW5jdGlvbiBhY3RpdmUoc3RhdGUpIHtcbiAgICAgIHJldHVybiBtYXJrQWN0aXZlKHN0YXRlLCBtYXJrVHlwZSk7XG4gICAgfSxcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkge1xuICAgICAgcmV0dXJuICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHk7XG4gICAgfSxcbiAgICBydW46IGZ1bmN0aW9uIHJ1bihzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgIGlmIChtYXJrQWN0aXZlKHN0YXRlLCBtYXJrVHlwZSkpIHtcbiAgICAgICAgcHJvc2VtaXJyb3JDb21tYW5kcy50b2dnbGVNYXJrKG1hcmtUeXBlKShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgb3BlblByb21wdCh7XG4gICAgICAgIHRpdGxlOiBcIkNyZWF0ZSBhIGxpbmtcIixcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgaHJlZjogbmV3IFRleHRGaWVsZCh7XG4gICAgICAgICAgICBsYWJlbDogXCJMaW5rIHRhcmdldFwiLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0aXRsZTogbmV3IFRleHRGaWVsZCh7XG4gICAgICAgICAgICBsYWJlbDogXCJUaXRsZVwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKGF0dHJzKSB7XG4gICAgICAgICAgcHJvc2VtaXJyb3JDb21tYW5kcy50b2dnbGVNYXJrKG1hcmtUeXBlLCBhdHRycykodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCk7XG4gICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cmFwTGlzdEl0ZW0obm9kZVR5cGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNtZEl0ZW0ocHJvc2VtaXJyb3JTY2hlbWFMaXN0LndyYXBJbkxpc3Qobm9kZVR5cGUsIG9wdGlvbnMuYXR0cnMpLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRNZW51SXRlbXMoc2NoZW1hKSB7XG4gIHZhciByID0ge307XG4gIHZhciBtYXJrO1xuICBpZiAobWFyayA9IHNjaGVtYS5tYXJrcy5zdHJvbmcpIHIudG9nZ2xlU3Ryb25nID0gbWFya0l0ZW0obWFyaywge1xuICAgIHRpdGxlOiBcIlRvZ2dsZSBzdHJvbmcgc3R5bGVcIixcbiAgICBpY29uOiBwcm9zZW1pcnJvck1lbnUuaWNvbnMuc3Ryb25nXG4gIH0pO1xuICBpZiAobWFyayA9IHNjaGVtYS5tYXJrcy5lbSkgci50b2dnbGVFbSA9IG1hcmtJdGVtKG1hcmssIHtcbiAgICB0aXRsZTogXCJUb2dnbGUgZW1waGFzaXNcIixcbiAgICBpY29uOiBwcm9zZW1pcnJvck1lbnUuaWNvbnMuZW1cbiAgfSk7XG4gIGlmIChtYXJrID0gc2NoZW1hLm1hcmtzLmNvZGUpIHIudG9nZ2xlQ29kZSA9IG1hcmtJdGVtKG1hcmssIHtcbiAgICB0aXRsZTogXCJUb2dnbGUgY29kZSBmb250XCIsXG4gICAgaWNvbjogcHJvc2VtaXJyb3JNZW51Lmljb25zLmNvZGVcbiAgfSk7XG4gIGlmIChtYXJrID0gc2NoZW1hLm1hcmtzLmxpbmspIHIudG9nZ2xlTGluayA9IGxpbmtJdGVtKG1hcmspO1xuICB2YXIgbm9kZTtcbiAgaWYgKG5vZGUgPSBzY2hlbWEubm9kZXMuaW1hZ2UpIHIuaW5zZXJ0SW1hZ2UgPSBpbnNlcnRJbWFnZUl0ZW0obm9kZSk7XG4gIGlmIChub2RlID0gc2NoZW1hLm5vZGVzLmJ1bGxldF9saXN0KSByLndyYXBCdWxsZXRMaXN0ID0gd3JhcExpc3RJdGVtKG5vZGUsIHtcbiAgICB0aXRsZTogXCJXcmFwIGluIGJ1bGxldCBsaXN0XCIsXG4gICAgaWNvbjogcHJvc2VtaXJyb3JNZW51Lmljb25zLmJ1bGxldExpc3RcbiAgfSk7XG4gIGlmIChub2RlID0gc2NoZW1hLm5vZGVzLm9yZGVyZWRfbGlzdCkgci53cmFwT3JkZXJlZExpc3QgPSB3cmFwTGlzdEl0ZW0obm9kZSwge1xuICAgIHRpdGxlOiBcIldyYXAgaW4gb3JkZXJlZCBsaXN0XCIsXG4gICAgaWNvbjogcHJvc2VtaXJyb3JNZW51Lmljb25zLm9yZGVyZWRMaXN0XG4gIH0pO1xuICBpZiAobm9kZSA9IHNjaGVtYS5ub2Rlcy5ibG9ja3F1b3RlKSByLndyYXBCbG9ja1F1b3RlID0gcHJvc2VtaXJyb3JNZW51LndyYXBJdGVtKG5vZGUsIHtcbiAgICB0aXRsZTogXCJXcmFwIGluIGJsb2NrIHF1b3RlXCIsXG4gICAgaWNvbjogcHJvc2VtaXJyb3JNZW51Lmljb25zLmJsb2NrcXVvdGVcbiAgfSk7XG4gIGlmIChub2RlID0gc2NoZW1hLm5vZGVzLnBhcmFncmFwaCkgci5tYWtlUGFyYWdyYXBoID0gcHJvc2VtaXJyb3JNZW51LmJsb2NrVHlwZUl0ZW0obm9kZSwge1xuICAgIHRpdGxlOiBcIkNoYW5nZSB0byBwYXJhZ3JhcGhcIixcbiAgICBsYWJlbDogXCJQbGFpblwiXG4gIH0pO1xuICBpZiAobm9kZSA9IHNjaGVtYS5ub2Rlcy5jb2RlX2Jsb2NrKSByLm1ha2VDb2RlQmxvY2sgPSBwcm9zZW1pcnJvck1lbnUuYmxvY2tUeXBlSXRlbShub2RlLCB7XG4gICAgdGl0bGU6IFwiQ2hhbmdlIHRvIGNvZGUgYmxvY2tcIixcbiAgICBsYWJlbDogXCJDb2RlXCJcbiAgfSk7XG4gIGlmIChub2RlID0gc2NoZW1hLm5vZGVzLmhlYWRpbmcpIGZvciAodmFyIGkgPSAxOyBpIDw9IDEwOyBpKyspIHtcbiAgICByW1wibWFrZUhlYWRcIiArIGldID0gcHJvc2VtaXJyb3JNZW51LmJsb2NrVHlwZUl0ZW0obm9kZSwge1xuICAgICAgdGl0bGU6IFwiQ2hhbmdlIHRvIGhlYWRpbmcgXCIgKyBpLFxuICAgICAgbGFiZWw6IFwiTGV2ZWwgXCIgKyBpLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgbGV2ZWw6IGlcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChub2RlID0gc2NoZW1hLm5vZGVzLmhvcml6b250YWxfcnVsZSkge1xuICAgIHZhciBociA9IG5vZGU7XG4gICAgci5pbnNlcnRIb3Jpem9udGFsUnVsZSA9IG5ldyBwcm9zZW1pcnJvck1lbnUuTWVudUl0ZW0oe1xuICAgICAgdGl0bGU6IFwiSW5zZXJ0IGhvcml6b250YWwgcnVsZVwiLFxuICAgICAgbGFiZWw6IFwiSG9yaXpvbnRhbCBydWxlXCIsXG4gICAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkge1xuICAgICAgICByZXR1cm4gY2FuSW5zZXJ0KHN0YXRlLCBocik7XG4gICAgICB9LFxuICAgICAgcnVuOiBmdW5jdGlvbiBydW4oc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKGhyLmNyZWF0ZSgpKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY3V0ID0gZnVuY3Rpb24gY3V0KGFycikge1xuICAgIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9KTtcbiAgfTtcblxuICByLmluc2VydE1lbnUgPSBuZXcgcHJvc2VtaXJyb3JNZW51LkRyb3Bkb3duKGN1dChbci5pbnNlcnRJbWFnZSwgci5pbnNlcnRIb3Jpem9udGFsUnVsZV0pLCB7XG4gICAgbGFiZWw6IFwiSW5zZXJ0XCJcbiAgfSk7XG4gIHIudHlwZU1lbnUgPSBuZXcgcHJvc2VtaXJyb3JNZW51LkRyb3Bkb3duKGN1dChbci5tYWtlUGFyYWdyYXBoLCByLm1ha2VDb2RlQmxvY2ssIHIubWFrZUhlYWQxICYmIG5ldyBwcm9zZW1pcnJvck1lbnUuRHJvcGRvd25TdWJtZW51KGN1dChbci5tYWtlSGVhZDEsIHIubWFrZUhlYWQyLCByLm1ha2VIZWFkMywgci5tYWtlSGVhZDQsIHIubWFrZUhlYWQ1LCByLm1ha2VIZWFkNl0pLCB7XG4gICAgbGFiZWw6IFwiSGVhZGluZ1wiXG4gIH0pXSksIHtcbiAgICBsYWJlbDogXCJUeXBlLi4uXCJcbiAgfSk7XG4gIHIuaW5saW5lTWVudSA9IFtjdXQoW3IudG9nZ2xlU3Ryb25nLCByLnRvZ2dsZUVtLCByLnRvZ2dsZUNvZGUsIHIudG9nZ2xlTGlua10pXTtcbiAgci5ibG9ja01lbnUgPSBbY3V0KFtyLndyYXBCdWxsZXRMaXN0LCByLndyYXBPcmRlcmVkTGlzdCwgci53cmFwQmxvY2tRdW90ZSwgcHJvc2VtaXJyb3JNZW51LmpvaW5VcEl0ZW0sIHByb3NlbWlycm9yTWVudS5saWZ0SXRlbSwgcHJvc2VtaXJyb3JNZW51LnNlbGVjdFBhcmVudE5vZGVJdGVtXSldO1xuICByLmZ1bGxNZW51ID0gci5pbmxpbmVNZW51LmNvbmNhdChbW3IuaW5zZXJ0TWVudSwgci50eXBlTWVudV1dLCBbW3Byb3NlbWlycm9yTWVudS51bmRvSXRlbSwgcHJvc2VtaXJyb3JNZW51LnJlZG9JdGVtXV0sIHIuYmxvY2tNZW51KTtcbiAgcmV0dXJuIHI7XG59XG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcblxuZnVuY3Rpb24gYnVpbGRLZXltYXAoc2NoZW1hLCBtYXBLZXlzKSB7XG4gIHZhciBrZXlzID0ge30sXG4gICAgICB0eXBlO1xuXG4gIGZ1bmN0aW9uIGJpbmQoa2V5LCBjbWQpIHtcbiAgICBpZiAobWFwS2V5cykge1xuICAgICAgdmFyIG1hcHBlZCA9IG1hcEtleXNba2V5XTtcbiAgICAgIGlmIChtYXBwZWQgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICBpZiAobWFwcGVkKSBrZXkgPSBtYXBwZWQ7XG4gICAgfVxuXG4gICAga2V5c1trZXldID0gY21kO1xuICB9XG5cbiAgYmluZChcIk1vZC16XCIsIHByb3NlbWlycm9ySGlzdG9yeS51bmRvKTtcbiAgYmluZChcIlNoaWZ0LU1vZC16XCIsIHByb3NlbWlycm9ySGlzdG9yeS5yZWRvKTtcbiAgYmluZChcIkJhY2tzcGFjZVwiLCBwcm9zZW1pcnJvcklucHV0cnVsZXMudW5kb0lucHV0UnVsZSk7XG4gIGlmICghbWFjKSBiaW5kKFwiTW9kLXlcIiwgcHJvc2VtaXJyb3JIaXN0b3J5LnJlZG8pO1xuICBiaW5kKFwiQWx0LUFycm93VXBcIiwgcHJvc2VtaXJyb3JDb21tYW5kcy5qb2luVXApO1xuICBiaW5kKFwiQWx0LUFycm93RG93blwiLCBwcm9zZW1pcnJvckNvbW1hbmRzLmpvaW5Eb3duKTtcbiAgYmluZChcIk1vZC1CcmFja2V0TGVmdFwiLCBwcm9zZW1pcnJvckNvbW1hbmRzLmxpZnQpO1xuICBiaW5kKFwiRXNjYXBlXCIsIHByb3NlbWlycm9yQ29tbWFuZHMuc2VsZWN0UGFyZW50Tm9kZSk7XG5cbiAgaWYgKHR5cGUgPSBzY2hlbWEubWFya3Muc3Ryb25nKSB7XG4gICAgYmluZChcIk1vZC1iXCIsIHByb3NlbWlycm9yQ29tbWFuZHMudG9nZ2xlTWFyayh0eXBlKSk7XG4gICAgYmluZChcIk1vZC1CXCIsIHByb3NlbWlycm9yQ29tbWFuZHMudG9nZ2xlTWFyayh0eXBlKSk7XG4gIH1cblxuICBpZiAodHlwZSA9IHNjaGVtYS5tYXJrcy5lbSkge1xuICAgIGJpbmQoXCJNb2QtaVwiLCBwcm9zZW1pcnJvckNvbW1hbmRzLnRvZ2dsZU1hcmsodHlwZSkpO1xuICAgIGJpbmQoXCJNb2QtSVwiLCBwcm9zZW1pcnJvckNvbW1hbmRzLnRvZ2dsZU1hcmsodHlwZSkpO1xuICB9XG5cbiAgaWYgKHR5cGUgPSBzY2hlbWEubWFya3MuY29kZSkgYmluZChcIk1vZC1gXCIsIHByb3NlbWlycm9yQ29tbWFuZHMudG9nZ2xlTWFyayh0eXBlKSk7XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmJ1bGxldF9saXN0KSBiaW5kKFwiU2hpZnQtQ3RybC04XCIsIHByb3NlbWlycm9yU2NoZW1hTGlzdC53cmFwSW5MaXN0KHR5cGUpKTtcbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMub3JkZXJlZF9saXN0KSBiaW5kKFwiU2hpZnQtQ3RybC05XCIsIHByb3NlbWlycm9yU2NoZW1hTGlzdC53cmFwSW5MaXN0KHR5cGUpKTtcbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuYmxvY2txdW90ZSkgYmluZChcIkN0cmwtPlwiLCBwcm9zZW1pcnJvckNvbW1hbmRzLndyYXBJbih0eXBlKSk7XG5cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuaGFyZF9icmVhaykge1xuICAgIHZhciBiciA9IHR5cGUsXG4gICAgICAgIGNtZCA9IHByb3NlbWlycm9yQ29tbWFuZHMuY2hhaW5Db21tYW5kcyhwcm9zZW1pcnJvckNvbW1hbmRzLmV4aXRDb2RlLCBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKGJyLmNyZWF0ZSgpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGJpbmQoXCJNb2QtRW50ZXJcIiwgY21kKTtcbiAgICBiaW5kKFwiU2hpZnQtRW50ZXJcIiwgY21kKTtcbiAgICBpZiAobWFjKSBiaW5kKFwiQ3RybC1FbnRlclwiLCBjbWQpO1xuICB9XG5cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMubGlzdF9pdGVtKSB7XG4gICAgYmluZChcIkVudGVyXCIsIHByb3NlbWlycm9yU2NoZW1hTGlzdC5zcGxpdExpc3RJdGVtKHR5cGUpKTtcbiAgICBiaW5kKFwiTW9kLVtcIiwgcHJvc2VtaXJyb3JTY2hlbWFMaXN0LmxpZnRMaXN0SXRlbSh0eXBlKSk7XG4gICAgYmluZChcIk1vZC1dXCIsIHByb3NlbWlycm9yU2NoZW1hTGlzdC5zaW5rTGlzdEl0ZW0odHlwZSkpO1xuICB9XG5cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMucGFyYWdyYXBoKSBiaW5kKFwiU2hpZnQtQ3RybC0wXCIsIHByb3NlbWlycm9yQ29tbWFuZHMuc2V0QmxvY2tUeXBlKHR5cGUpKTtcbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuY29kZV9ibG9jaykgYmluZChcIlNoaWZ0LUN0cmwtXFxcXFwiLCBwcm9zZW1pcnJvckNvbW1hbmRzLnNldEJsb2NrVHlwZSh0eXBlKSk7XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmhlYWRpbmcpIGZvciAodmFyIGkgPSAxOyBpIDw9IDY7IGkrKykge1xuICAgIGJpbmQoXCJTaGlmdC1DdHJsLVwiICsgaSwgcHJvc2VtaXJyb3JDb21tYW5kcy5zZXRCbG9ja1R5cGUodHlwZSwge1xuICAgICAgbGV2ZWw6IGlcbiAgICB9KSk7XG4gIH1cblxuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5ob3Jpem9udGFsX3J1bGUpIHtcbiAgICB2YXIgaHIgPSB0eXBlO1xuICAgIGJpbmQoXCJNb2QtX1wiLCBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKGhyLmNyZWF0ZSgpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIGJsb2NrUXVvdGVSdWxlKG5vZGVUeXBlKSB7XG4gIHJldHVybiBwcm9zZW1pcnJvcklucHV0cnVsZXMud3JhcHBpbmdJbnB1dFJ1bGUoL15cXHMqPlxccyQvLCBub2RlVHlwZSk7XG59XG5cbmZ1bmN0aW9uIG9yZGVyZWRMaXN0UnVsZShub2RlVHlwZSkge1xuICByZXR1cm4gcHJvc2VtaXJyb3JJbnB1dHJ1bGVzLndyYXBwaW5nSW5wdXRSdWxlKC9eKFxcZCspXFwuXFxzJC8sIG5vZGVUeXBlLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3JkZXI6ICttYXRjaFsxXVxuICAgIH07XG4gIH0sIGZ1bmN0aW9uIChtYXRjaCwgbm9kZSkge1xuICAgIHJldHVybiBub2RlLmNoaWxkQ291bnQgKyBub2RlLmF0dHJzLm9yZGVyID09ICttYXRjaFsxXTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1bGxldExpc3RSdWxlKG5vZGVUeXBlKSB7XG4gIHJldHVybiBwcm9zZW1pcnJvcklucHV0cnVsZXMud3JhcHBpbmdJbnB1dFJ1bGUoL15cXHMqKFstKypdKVxccyQvLCBub2RlVHlwZSk7XG59XG5cbmZ1bmN0aW9uIGNvZGVCbG9ja1J1bGUobm9kZVR5cGUpIHtcbiAgcmV0dXJuIHByb3NlbWlycm9ySW5wdXRydWxlcy50ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKC9eYGBgJC8sIG5vZGVUeXBlKTtcbn1cblxuZnVuY3Rpb24gaGVhZGluZ1J1bGUobm9kZVR5cGUsIG1heExldmVsKSB7XG4gIHJldHVybiBwcm9zZW1pcnJvcklucHV0cnVsZXMudGV4dGJsb2NrVHlwZUlucHV0UnVsZShuZXcgUmVnRXhwKFwiXigjezEsXCIgKyBtYXhMZXZlbCArIFwifSlcXFxccyRcIiksIG5vZGVUeXBlLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6IG1hdGNoWzFdLmxlbmd0aFxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBidWlsZElucHV0UnVsZXMoc2NoZW1hKSB7XG4gIHZhciBydWxlcyA9IHByb3NlbWlycm9ySW5wdXRydWxlcy5zbWFydFF1b3Rlcy5jb25jYXQocHJvc2VtaXJyb3JJbnB1dHJ1bGVzLmVsbGlwc2lzLCBwcm9zZW1pcnJvcklucHV0cnVsZXMuZW1EYXNoKSxcbiAgICAgIHR5cGU7XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmJsb2NrcXVvdGUpIHJ1bGVzLnB1c2goYmxvY2tRdW90ZVJ1bGUodHlwZSkpO1xuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5vcmRlcmVkX2xpc3QpIHJ1bGVzLnB1c2gob3JkZXJlZExpc3RSdWxlKHR5cGUpKTtcbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuYnVsbGV0X2xpc3QpIHJ1bGVzLnB1c2goYnVsbGV0TGlzdFJ1bGUodHlwZSkpO1xuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5jb2RlX2Jsb2NrKSBydWxlcy5wdXNoKGNvZGVCbG9ja1J1bGUodHlwZSkpO1xuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5oZWFkaW5nKSBydWxlcy5wdXNoKGhlYWRpbmdSdWxlKHR5cGUsIDYpKTtcbiAgcmV0dXJuIHByb3NlbWlycm9ySW5wdXRydWxlcy5pbnB1dFJ1bGVzKHtcbiAgICBydWxlczogcnVsZXNcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGV4YW1wbGVTZXR1cChvcHRpb25zKSB7XG4gIHZhciBwbHVnaW5zID0gW2J1aWxkSW5wdXRSdWxlcyhvcHRpb25zLnNjaGVtYSksIHByb3NlbWlycm9yS2V5bWFwLmtleW1hcChidWlsZEtleW1hcChvcHRpb25zLnNjaGVtYSwgb3B0aW9ucy5tYXBLZXlzKSksIHByb3NlbWlycm9yS2V5bWFwLmtleW1hcChwcm9zZW1pcnJvckNvbW1hbmRzLmJhc2VLZXltYXApLCBwcm9zZW1pcnJvckRyb3BjdXJzb3IuZHJvcEN1cnNvcigpLCBwcm9zZW1pcnJvckdhcGN1cnNvci5nYXBDdXJzb3IoKV07XG4gIGlmIChvcHRpb25zLm1lbnVCYXIgIT09IGZhbHNlKSBwbHVnaW5zLnB1c2gocHJvc2VtaXJyb3JNZW51Lm1lbnVCYXIoe1xuICAgIGZsb2F0aW5nOiBvcHRpb25zLmZsb2F0aW5nTWVudSAhPT0gZmFsc2UsXG4gICAgY29udGVudDogb3B0aW9ucy5tZW51Q29udGVudCB8fCBidWlsZE1lbnVJdGVtcyhvcHRpb25zLnNjaGVtYSkuZnVsbE1lbnVcbiAgfSkpO1xuICBpZiAob3B0aW9ucy5oaXN0b3J5ICE9PSBmYWxzZSkgcGx1Z2lucy5wdXNoKHByb3NlbWlycm9ySGlzdG9yeS5oaXN0b3J5KCkpO1xuICByZXR1cm4gcGx1Z2lucy5jb25jYXQobmV3IHByb3NlbWlycm9yU3RhdGUuUGx1Z2luKHtcbiAgICBwcm9wczoge1xuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBcImNsYXNzXCI6IFwiUHJvc2VNaXJyb3ItZXhhbXBsZS1zZXR1cC1zdHlsZVwiXG4gICAgICB9XG4gICAgfVxuICB9KSk7XG59XG5cbmV4cG9ydHMuYnVpbGRJbnB1dFJ1bGVzID0gYnVpbGRJbnB1dFJ1bGVzO1xuZXhwb3J0cy5idWlsZEtleW1hcCA9IGJ1aWxkS2V5bWFwO1xuZXhwb3J0cy5idWlsZE1lbnVJdGVtcyA9IGJ1aWxkTWVudUl0ZW1zO1xuZXhwb3J0cy5leGFtcGxlU2V0dXAgPSBleGFtcGxlU2V0dXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgcHJvc2VtaXJyb3JLZXltYXAgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1rZXltYXAnKTtcblxudmFyIHByb3NlbWlycm9yU3RhdGUgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1zdGF0ZScpO1xuXG52YXIgcHJvc2VtaXJyb3JNb2RlbCA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLW1vZGVsJyk7XG5cbnZhciBwcm9zZW1pcnJvclZpZXcgPSByZXF1aXJlKCdwcm9zZW1pcnJvci12aWV3Jyk7XG5cbnZhciBHYXBDdXJzb3IgPSBmdW5jdGlvbiAoX3Byb3NlbWlycm9yU3RhdGUkU2VsKSB7XG4gIF9pbmhlcml0cyhHYXBDdXJzb3IsIF9wcm9zZW1pcnJvclN0YXRlJFNlbCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihHYXBDdXJzb3IpO1xuXG4gIGZ1bmN0aW9uIEdhcEN1cnNvcigkcG9zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdhcEN1cnNvcik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJHBvcywgJHBvcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoR2FwQ3Vyc29yLCBbe1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICAgIHJldHVybiBHYXBDdXJzb3IudmFsaWQoJHBvcykgPyBuZXcgR2FwQ3Vyc29yKCRwb3MpIDogcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgICAgcmV0dXJuIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBHYXBDdXJzb3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImdhcGN1cnNvclwiLFxuICAgICAgICBwb3M6IHRoaXMuaGVhZFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm9va21hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9va21hcmsoKSB7XG4gICAgICByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKHRoaXMuYW5jaG9yKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBHYXBDdXJzb3IuZnJvbUpTT05cIik7XG4gICAgICByZXR1cm4gbmV3IEdhcEN1cnNvcihkb2MucmVzb2x2ZShqc29uLnBvcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZCgkcG9zKSB7XG4gICAgICB2YXIgcGFyZW50ID0gJHBvcy5wYXJlbnQ7XG4gICAgICBpZiAocGFyZW50LmlzVGV4dGJsb2NrIHx8ICFjbG9zZWRCZWZvcmUoJHBvcykgfHwgIWNsb3NlZEFmdGVyKCRwb3MpKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSBwYXJlbnQudHlwZS5zcGVjLmFsbG93R2FwQ3Vyc29yO1xuICAgICAgaWYgKG92ZXJyaWRlICE9IG51bGwpIHJldHVybiBvdmVycmlkZTtcbiAgICAgIHZhciBkZWZsdCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgkcG9zLmluZGV4KCkpLmRlZmF1bHRUeXBlO1xuICAgICAgcmV0dXJuIGRlZmx0ICYmIGRlZmx0LmlzVGV4dGJsb2NrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kR2FwQ3Vyc29yRnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kR2FwQ3Vyc29yRnJvbSgkcG9zLCBkaXIpIHtcbiAgICAgIHZhciBtdXN0TW92ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIHNlYXJjaDogZm9yICg7Oykge1xuICAgICAgICBpZiAoIW11c3RNb3ZlICYmIEdhcEN1cnNvci52YWxpZCgkcG9zKSkgcmV0dXJuICRwb3M7XG4gICAgICAgIHZhciBwb3MgPSAkcG9zLnBvcyxcbiAgICAgICAgICAgIG5leHQgPSBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcblxuICAgICAgICAgIGlmIChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDwgcGFyZW50LmNoaWxkQ291bnQgOiAkcG9zLmluZGV4KGQpID4gMCkge1xuICAgICAgICAgICAgbmV4dCA9IHBhcmVudC5jaGlsZChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDogJHBvcy5pbmRleChkKSAtIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChkID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgICAgdmFyICRjdXIgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgICAgaWYgKEdhcEN1cnNvci52YWxpZCgkY3VyKSkgcmV0dXJuICRjdXI7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgdmFyIGluc2lkZSA9IGRpciA+IDAgPyBuZXh0LmZpcnN0Q2hpbGQgOiBuZXh0Lmxhc3RDaGlsZDtcblxuICAgICAgICAgIGlmICghaW5zaWRlKSB7XG4gICAgICAgICAgICBpZiAobmV4dC5pc0F0b20gJiYgIW5leHQuaXNUZXh0ICYmICFwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5leHQpKSB7XG4gICAgICAgICAgICAgICRwb3MgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyArIG5leHQubm9kZVNpemUgKiBkaXIpO1xuICAgICAgICAgICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb250aW51ZSBzZWFyY2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQgPSBpbnNpZGU7XG4gICAgICAgICAgcG9zICs9IGRpcjtcblxuICAgICAgICAgIHZhciBfJGN1ciA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcblxuICAgICAgICAgIGlmIChHYXBDdXJzb3IudmFsaWQoXyRjdXIpKSByZXR1cm4gXyRjdXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR2FwQ3Vyc29yO1xufShwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbik7XG5cbkdhcEN1cnNvci5wcm90b3R5cGUudmlzaWJsZSA9IGZhbHNlO1xuR2FwQ3Vyc29yLmZpbmRGcm9tID0gR2FwQ3Vyc29yLmZpbmRHYXBDdXJzb3JGcm9tO1xucHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24uanNvbklEKFwiZ2FwY3Vyc29yXCIsIEdhcEN1cnNvcik7XG5cbnZhciBHYXBCb29rbWFyayA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2FwQm9va21hcmsocG9zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdhcEJvb2ttYXJrKTtcblxuICAgIHRoaXMucG9zID0gcG9zO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEdhcEJvb2ttYXJrLCBbe1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcpIHtcbiAgICAgIHJldHVybiBuZXcgR2FwQm9va21hcmsobWFwcGluZy5tYXAodGhpcy5wb3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKGRvYykge1xuICAgICAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLnBvcyk7XG4gICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IHByb3NlbWlycm9yU3RhdGUuU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdhcEJvb2ttYXJrO1xufSgpO1xuXG5mdW5jdGlvbiBjbG9zZWRCZWZvcmUoJHBvcykge1xuICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICB2YXIgaW5kZXggPSAkcG9zLmluZGV4KGQpLFxuICAgICAgICBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG5cbiAgICBpZiAoaW5kZXggPT0gMCkge1xuICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpOzsgYmVmb3JlID0gYmVmb3JlLmxhc3RDaGlsZCkge1xuICAgICAgaWYgKGJlZm9yZS5jaGlsZENvdW50ID09IDAgJiYgIWJlZm9yZS5pbmxpbmVDb250ZW50IHx8IGJlZm9yZS5pc0F0b20gfHwgYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGJlZm9yZS5pbmxpbmVDb250ZW50KSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNsb3NlZEFmdGVyKCRwb3MpIHtcbiAgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgdmFyIGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpLFxuICAgICAgICBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG5cbiAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpIHtcbiAgICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZykgcmV0dXJuIHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBhZnRlciA9IHBhcmVudC5jaGlsZChpbmRleCk7OyBhZnRlciA9IGFmdGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGlmIChhZnRlci5jaGlsZENvdW50ID09IDAgJiYgIWFmdGVyLmlubGluZUNvbnRlbnQgfHwgYWZ0ZXIuaXNBdG9tIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGFmdGVyLmlubGluZUNvbnRlbnQpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2FwQ3Vyc29yKCkge1xuICByZXR1cm4gbmV3IHByb3NlbWlycm9yU3RhdGUuUGx1Z2luKHtcbiAgICBwcm9wczoge1xuICAgICAgZGVjb3JhdGlvbnM6IGRyYXdHYXBDdXJzb3IsXG4gICAgICBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuOiBmdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuKF92aWV3LCAkYW5jaG9yLCAkaGVhZCkge1xuICAgICAgICByZXR1cm4gJGFuY2hvci5wb3MgPT0gJGhlYWQucG9zICYmIEdhcEN1cnNvci52YWxpZCgkaGVhZCkgPyBuZXcgR2FwQ3Vyc29yKCRoZWFkKSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2xpY2s6IGhhbmRsZUNsaWNrLFxuICAgICAgaGFuZGxlS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICBiZWZvcmVpbnB1dDogYmVmb3JlaW5wdXRcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG52YXIgaGFuZGxlS2V5RG93biA9IHByb3NlbWlycm9yS2V5bWFwLmtleWRvd25IYW5kbGVyKHtcbiAgXCJBcnJvd0xlZnRcIjogYXJyb3coXCJob3JpelwiLCAtMSksXG4gIFwiQXJyb3dSaWdodFwiOiBhcnJvdyhcImhvcml6XCIsIDEpLFxuICBcIkFycm93VXBcIjogYXJyb3coXCJ2ZXJ0XCIsIC0xKSxcbiAgXCJBcnJvd0Rvd25cIjogYXJyb3coXCJ2ZXJ0XCIsIDEpXG59KTtcblxuZnVuY3Rpb24gYXJyb3coYXhpcywgZGlyKSB7XG4gIHZhciBkaXJTdHIgPSBheGlzID09IFwidmVydFwiID8gZGlyID4gMCA/IFwiZG93blwiIDogXCJ1cFwiIDogZGlyID4gMCA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgIHZhciBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgdmFyICRzdGFydCA9IGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tLFxuICAgICAgICBtdXN0TW92ZSA9IHNlbC5lbXB0eTtcblxuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24pIHtcbiAgICAgIGlmICghdmlldy5lbmRPZlRleHRibG9jayhkaXJTdHIpIHx8ICRzdGFydC5kZXB0aCA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgJHN0YXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUoZGlyID4gMCA/ICRzdGFydC5hZnRlcigpIDogJHN0YXJ0LmJlZm9yZSgpKTtcbiAgICB9XG5cbiAgICB2YXIgJGZvdW5kID0gR2FwQ3Vyc29yLmZpbmRHYXBDdXJzb3JGcm9tKCRzdGFydCwgZGlyLCBtdXN0TW92ZSk7XG4gICAgaWYgKCEkZm91bmQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgR2FwQ3Vyc29yKCRmb3VuZCkpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQ2xpY2sodmlldywgcG9zLCBldmVudCkge1xuICBpZiAoIXZpZXcgfHwgIXZpZXcuZWRpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgdmFyICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gIGlmICghR2FwQ3Vyc29yLnZhbGlkKCRwb3MpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBjbGlja1BvcyA9IHZpZXcucG9zQXRDb29yZHMoe1xuICAgIGxlZnQ6IGV2ZW50LmNsaWVudFgsXG4gICAgdG9wOiBldmVudC5jbGllbnRZXG4gIH0pO1xuICBpZiAoY2xpY2tQb3MgJiYgY2xpY2tQb3MuaW5zaWRlID4gLTEgJiYgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh2aWV3LnN0YXRlLmRvYy5ub2RlQXQoY2xpY2tQb3MuaW5zaWRlKSkpIHJldHVybiBmYWxzZTtcbiAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgR2FwQ3Vyc29yKCRwb3MpKSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBiZWZvcmVpbnB1dCh2aWV3LCBldmVudCkge1xuICBpZiAoZXZlbnQuaW5wdXRUeXBlICE9IFwiaW5zZXJ0Q29tcG9zaXRpb25UZXh0XCIgfHwgISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEdhcEN1cnNvcikpIHJldHVybiBmYWxzZTtcbiAgdmFyICRmcm9tID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gIHZhciBpbnNlcnQgPSAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSkuZmluZFdyYXBwaW5nKHZpZXcuc3RhdGUuc2NoZW1hLm5vZGVzLnRleHQpO1xuICBpZiAoIWluc2VydCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgZnJhZyA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHk7XG5cbiAgZm9yICh2YXIgaSA9IGluc2VydC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGZyYWcgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oaW5zZXJ0W2ldLmNyZWF0ZUFuZEZpbGwobnVsbCwgZnJhZykpO1xuICB9XG5cbiAgdmFyIHRyID0gdmlldy5zdGF0ZS50ci5yZXBsYWNlKCRmcm9tLnBvcywgJGZyb20ucG9zLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShmcmFnLCAwLCAwKSk7XG4gIHRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSkpO1xuICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkcmF3R2FwQ3Vyc29yKHN0YXRlKSB7XG4gIGlmICghKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEdhcEN1cnNvcikpIHJldHVybiBudWxsO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIG5vZGUuY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1nYXBjdXJzb3JcIjtcbiAgcmV0dXJuIHByb3NlbWlycm9yVmlldy5EZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtwcm9zZW1pcnJvclZpZXcuRGVjb3JhdGlvbi53aWRnZXQoc3RhdGUuc2VsZWN0aW9uLmhlYWQsIG5vZGUsIHtcbiAgICBrZXk6IFwiZ2FwY3Vyc29yXCJcbiAgfSldKTtcbn1cblxuZXhwb3J0cy5HYXBDdXJzb3IgPSBHYXBDdXJzb3I7XG5leHBvcnRzLmdhcEN1cnNvciA9IGdhcEN1cnNvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgUm9wZVNlcXVlbmNlID0gcmVxdWlyZSgncm9wZS1zZXF1ZW5jZScpO1xuXG52YXIgcHJvc2VtaXJyb3JUcmFuc2Zvcm0gPSByZXF1aXJlKCdwcm9zZW1pcnJvci10cmFuc2Zvcm0nKTtcblxudmFyIHByb3NlbWlycm9yU3RhdGUgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1zdGF0ZScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3koZSkge1xuICByZXR1cm4gZSAmJiBfdHlwZW9mKGUpID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7XG4gICAgJ2RlZmF1bHQnOiBlXG4gIH07XG59XG5cbnZhciBSb3BlU2VxdWVuY2VfX2RlZmF1bHQgPSBfaW50ZXJvcERlZmF1bHRMZWdhY3koUm9wZVNlcXVlbmNlKTtcblxudmFyIG1heF9lbXB0eV9pdGVtcyA9IDUwMDtcblxudmFyIEJyYW5jaCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnJhbmNoKGl0ZW1zLCBldmVudENvdW50KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyYW5jaCk7XG5cbiAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgdGhpcy5ldmVudENvdW50ID0gZXZlbnRDb3VudDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCcmFuY2gsIFt7XG4gICAga2V5OiBcInBvcEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcEV2ZW50KHN0YXRlLCBwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5ldmVudENvdW50ID09IDApIHJldHVybiBudWxsO1xuICAgICAgdmFyIGVuZCA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKDs7IGVuZC0tKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5pdGVtcy5nZXQoZW5kIC0gMSk7XG5cbiAgICAgICAgaWYgKG5leHQuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgLS1lbmQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlbWFwLCBtYXBGcm9tO1xuXG4gICAgICBpZiAocHJlc2VydmVJdGVtcykge1xuICAgICAgICByZW1hcCA9IHRoaXMucmVtYXBwaW5nKGVuZCwgdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBzdGF0ZS50cjtcbiAgICAgIHZhciBzZWxlY3Rpb24sIHJlbWFpbmluZztcbiAgICAgIHZhciBhZGRBZnRlciA9IFtdLFxuICAgICAgICAgIGFkZEJlZm9yZSA9IFtdO1xuICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgIGlmICghaXRlbS5zdGVwKSB7XG4gICAgICAgICAgaWYgKCFyZW1hcCkge1xuICAgICAgICAgICAgcmVtYXAgPSBfdGhpcy5yZW1hcHBpbmcoZW5kLCBpICsgMSk7XG4gICAgICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgIGFkZEJlZm9yZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1hcCkge1xuICAgICAgICAgIGFkZEJlZm9yZS5wdXNoKG5ldyBJdGVtKGl0ZW0ubWFwKSk7XG4gICAgICAgICAgdmFyIHN0ZXAgPSBpdGVtLnN0ZXAubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKSxcbiAgICAgICAgICAgICAgbWFwO1xuXG4gICAgICAgICAgaWYgKHN0ZXAgJiYgdHJhbnNmb3JtLm1heWJlU3RlcChzdGVwKS5kb2MpIHtcbiAgICAgICAgICAgIG1hcCA9IHRyYW5zZm9ybS5tYXBwaW5nLm1hcHNbdHJhbnNmb3JtLm1hcHBpbmcubWFwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGFkZEFmdGVyLnB1c2gobmV3IEl0ZW0obWFwLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYWRkQWZ0ZXIubGVuZ3RoICsgYWRkQmVmb3JlLmxlbmd0aCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICBpZiAobWFwKSByZW1hcC5hcHBlbmRNYXAobWFwLCBtYXBGcm9tKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFuc2Zvcm0ubWF5YmVTdGVwKGl0ZW0uc3RlcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBzZWxlY3Rpb24gPSByZW1hcCA/IGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSkgOiBpdGVtLnNlbGVjdGlvbjtcbiAgICAgICAgICByZW1haW5pbmcgPSBuZXcgQnJhbmNoKF90aGlzLml0ZW1zLnNsaWNlKDAsIGVuZCkuYXBwZW5kKGFkZEJlZm9yZS5yZXZlcnNlKCkuY29uY2F0KGFkZEFmdGVyKSksIF90aGlzLmV2ZW50Q291bnQgLSAxKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuaXRlbXMubGVuZ3RoLCAwKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbWFpbmluZzogcmVtYWluaW5nLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgc2VsZWN0aW9uOiBzZWxlY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUcmFuc2Zvcm0odHJhbnNmb3JtLCBzZWxlY3Rpb24sIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICB2YXIgbmV3SXRlbXMgPSBbXSxcbiAgICAgICAgICBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgdmFyIG9sZEl0ZW1zID0gdGhpcy5pdGVtcyxcbiAgICAgICAgICBsYXN0SXRlbSA9ICFwcmVzZXJ2ZUl0ZW1zICYmIG9sZEl0ZW1zLmxlbmd0aCA/IG9sZEl0ZW1zLmdldChvbGRJdGVtcy5sZW5ndGggLSAxKSA6IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtLnN0ZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdGVwID0gdHJhbnNmb3JtLnN0ZXBzW2ldLmludmVydCh0cmFuc2Zvcm0uZG9jc1tpXSk7XG4gICAgICAgIHZhciBpdGVtID0gbmV3IEl0ZW0odHJhbnNmb3JtLm1hcHBpbmcubWFwc1tpXSwgc3RlcCwgc2VsZWN0aW9uKSxcbiAgICAgICAgICAgIG1lcmdlZCA9IHZvaWQgMDtcblxuICAgICAgICBpZiAobWVyZ2VkID0gbGFzdEl0ZW0gJiYgbGFzdEl0ZW0ubWVyZ2UoaXRlbSkpIHtcbiAgICAgICAgICBpdGVtID0gbWVyZ2VkO1xuICAgICAgICAgIGlmIChpKSBuZXdJdGVtcy5wb3AoKTtlbHNlIG9sZEl0ZW1zID0gb2xkSXRlbXMuc2xpY2UoMCwgb2xkSXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBldmVudENvdW50Kys7XG4gICAgICAgICAgc2VsZWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcmVzZXJ2ZUl0ZW1zKSBsYXN0SXRlbSA9IGl0ZW07XG4gICAgICB9XG5cbiAgICAgIHZhciBvdmVyZmxvdyA9IGV2ZW50Q291bnQgLSBoaXN0T3B0aW9ucy5kZXB0aDtcblxuICAgICAgaWYgKG92ZXJmbG93ID4gREVQVEhfT1ZFUkZMT1cpIHtcbiAgICAgICAgb2xkSXRlbXMgPSBjdXRPZmZFdmVudHMob2xkSXRlbXMsIG92ZXJmbG93KTtcbiAgICAgICAgZXZlbnRDb3VudCAtPSBvdmVyZmxvdztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBCcmFuY2gob2xkSXRlbXMuYXBwZW5kKG5ld0l0ZW1zKSwgZXZlbnRDb3VudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbWFwcGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1hcHBpbmcoZnJvbSwgdG8pIHtcbiAgICAgIHZhciBtYXBzID0gbmV3IHByb3NlbWlycm9yVHJhbnNmb3JtLk1hcHBpbmcoKTtcbiAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICB2YXIgbWlycm9yUG9zID0gaXRlbS5taXJyb3JPZmZzZXQgIT0gbnVsbCAmJiBpIC0gaXRlbS5taXJyb3JPZmZzZXQgPj0gZnJvbSA/IG1hcHMubWFwcy5sZW5ndGggLSBpdGVtLm1pcnJvck9mZnNldCA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWFwcy5hcHBlbmRNYXAoaXRlbS5tYXAsIG1pcnJvclBvcyk7XG4gICAgICB9LCBmcm9tLCB0byk7XG4gICAgICByZXR1cm4gbWFwcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTWFwc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNYXBzKGFycmF5KSB7XG4gICAgICBpZiAodGhpcy5ldmVudENvdW50ID09IDApIHJldHVybiB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBCcmFuY2godGhpcy5pdGVtcy5hcHBlbmQoYXJyYXkubWFwKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVtKG1hcCk7XG4gICAgICB9KSksIHRoaXMuZXZlbnRDb3VudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlYmFzZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmViYXNlZChyZWJhc2VkVHJhbnNmb3JtLCByZWJhc2VkQ291bnQpIHtcbiAgICAgIGlmICghdGhpcy5ldmVudENvdW50KSByZXR1cm4gdGhpcztcbiAgICAgIHZhciByZWJhc2VkSXRlbXMgPSBbXSxcbiAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDAsIHRoaXMuaXRlbXMubGVuZ3RoIC0gcmViYXNlZENvdW50KTtcbiAgICAgIHZhciBtYXBwaW5nID0gcmViYXNlZFRyYW5zZm9ybS5tYXBwaW5nO1xuICAgICAgdmFyIG5ld1VudGlsID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7XG4gICAgICB2YXIgZXZlbnRDb3VudCA9IHRoaXMuZXZlbnRDb3VudDtcbiAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24pIGV2ZW50Q291bnQtLTtcbiAgICAgIH0sIHN0YXJ0KTtcbiAgICAgIHZhciBpUmViYXNlZCA9IHJlYmFzZWRDb3VudDtcbiAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgcG9zID0gbWFwcGluZy5nZXRNaXJyb3IoLS1pUmViYXNlZCk7XG4gICAgICAgIGlmIChwb3MgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBuZXdVbnRpbCA9IE1hdGgubWluKG5ld1VudGlsLCBwb3MpO1xuICAgICAgICB2YXIgbWFwID0gbWFwcGluZy5tYXBzW3Bvc107XG5cbiAgICAgICAgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgIHZhciBzdGVwID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwc1twb3NdLmludmVydChyZWJhc2VkVHJhbnNmb3JtLmRvY3NbcG9zXSk7XG4gICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChtYXBwaW5nLnNsaWNlKGlSZWJhc2VkICsgMSwgcG9zKSk7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbikgZXZlbnRDb3VudCsrO1xuICAgICAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCwgc3RlcCwgc2VsZWN0aW9uKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmViYXNlZEl0ZW1zLnB1c2gobmV3IEl0ZW0obWFwKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHN0YXJ0KTtcbiAgICAgIHZhciBuZXdNYXBzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSByZWJhc2VkQ291bnQ7IGkgPCBuZXdVbnRpbDsgaSsrKSB7XG4gICAgICAgIG5ld01hcHMucHVzaChuZXcgSXRlbShtYXBwaW5nLm1hcHNbaV0pKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgwLCBzdGFydCkuYXBwZW5kKG5ld01hcHMpLmFwcGVuZChyZWJhc2VkSXRlbXMpO1xuICAgICAgdmFyIGJyYW5jaCA9IG5ldyBCcmFuY2goaXRlbXMsIGV2ZW50Q291bnQpO1xuICAgICAgaWYgKGJyYW5jaC5lbXB0eUl0ZW1Db3VudCgpID4gbWF4X2VtcHR5X2l0ZW1zKSBicmFuY2ggPSBicmFuY2guY29tcHJlc3ModGhpcy5pdGVtcy5sZW5ndGggLSByZWJhc2VkSXRlbXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBicmFuY2g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVtcHR5SXRlbUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtcHR5SXRlbUNvdW50KCkge1xuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0uc3RlcCkgY291bnQrKztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wcmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wcmVzcygpIHtcbiAgICAgIHZhciB1cHRvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgIHZhciByZW1hcCA9IHRoaXMucmVtYXBwaW5nKDAsIHVwdG8pLFxuICAgICAgICAgIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgIHZhciBpdGVtcyA9IFtdLFxuICAgICAgICAgIGV2ZW50cyA9IDA7XG4gICAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgaWYgKGkgPj0gdXB0bykge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKSBldmVudHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLnN0ZXApIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZW0uc3RlcC5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpLFxuICAgICAgICAgICAgICBtYXAgPSBzdGVwICYmIHN0ZXAuZ2V0TWFwKCk7XG4gICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgIGlmIChtYXApIHJlbWFwLmFwcGVuZE1hcChtYXAsIG1hcEZyb20pO1xuXG4gICAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBpdGVtLnNlbGVjdGlvbiAmJiBpdGVtLnNlbGVjdGlvbi5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikgZXZlbnRzKys7XG4gICAgICAgICAgICB2YXIgbmV3SXRlbSA9IG5ldyBJdGVtKG1hcC5pbnZlcnQoKSwgc3RlcCwgc2VsZWN0aW9uKSxcbiAgICAgICAgICAgICAgICBtZXJnZWQsXG4gICAgICAgICAgICAgICAgbGFzdCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobWVyZ2VkID0gaXRlbXMubGVuZ3RoICYmIGl0ZW1zW2xhc3RdLm1lcmdlKG5ld0l0ZW0pKSBpdGVtc1tsYXN0XSA9IG1lcmdlZDtlbHNlIGl0ZW1zLnB1c2gobmV3SXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ubWFwKSB7XG4gICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLml0ZW1zLmxlbmd0aCwgMCk7XG4gICAgICByZXR1cm4gbmV3IEJyYW5jaChSb3BlU2VxdWVuY2VfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZyb20oaXRlbXMucmV2ZXJzZSgpKSwgZXZlbnRzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnJhbmNoO1xufSgpO1xuXG5CcmFuY2guZW1wdHkgPSBuZXcgQnJhbmNoKFJvcGVTZXF1ZW5jZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0uZW1wdHksIDApO1xuXG5mdW5jdGlvbiBjdXRPZmZFdmVudHMoaXRlbXMsIG4pIHtcbiAgdmFyIGN1dFBvaW50O1xuICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgaWYgKGl0ZW0uc2VsZWN0aW9uICYmIG4tLSA9PSAwKSB7XG4gICAgICBjdXRQb2ludCA9IGk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGl0ZW1zLnNsaWNlKGN1dFBvaW50KTtcbn1cblxudmFyIEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEl0ZW0obWFwLCBzdGVwLCBzZWxlY3Rpb24sIG1pcnJvck9mZnNldCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJdGVtKTtcblxuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIHRoaXMuc3RlcCA9IHN0ZXA7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgdGhpcy5taXJyb3JPZmZzZXQgPSBtaXJyb3JPZmZzZXQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSXRlbSwgW3tcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2Uob3RoZXIpIHtcbiAgICAgIGlmICh0aGlzLnN0ZXAgJiYgb3RoZXIuc3RlcCAmJiAhb3RoZXIuc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBzdGVwID0gb3RoZXIuc3RlcC5tZXJnZSh0aGlzLnN0ZXApO1xuICAgICAgICBpZiAoc3RlcCkgcmV0dXJuIG5ldyBJdGVtKHN0ZXAuZ2V0TWFwKCkuaW52ZXJ0KCksIHN0ZXAsIHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSXRlbTtcbn0oKTtcblxudmFyIEhpc3RvcnlTdGF0ZSA9IF9jcmVhdGVDbGFzcyhmdW5jdGlvbiBIaXN0b3J5U3RhdGUoZG9uZSwgdW5kb25lLCBwcmV2UmFuZ2VzLCBwcmV2VGltZSkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGlzdG9yeVN0YXRlKTtcblxuICB0aGlzLmRvbmUgPSBkb25lO1xuICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcbiAgdGhpcy5wcmV2UmFuZ2VzID0gcHJldlJhbmdlcztcbiAgdGhpcy5wcmV2VGltZSA9IHByZXZUaW1lO1xufSk7XG5cbnZhciBERVBUSF9PVkVSRkxPVyA9IDIwO1xuXG5mdW5jdGlvbiBhcHBseVRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCB0ciwgb3B0aW9ucykge1xuICB2YXIgaGlzdG9yeVRyID0gdHIuZ2V0TWV0YShoaXN0b3J5S2V5KSxcbiAgICAgIHJlYmFzZWQ7XG4gIGlmIChoaXN0b3J5VHIpIHJldHVybiBoaXN0b3J5VHIuaGlzdG9yeVN0YXRlO1xuICBpZiAodHIuZ2V0TWV0YShjbG9zZUhpc3RvcnlLZXkpKSBoaXN0b3J5ID0gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUsIGhpc3RvcnkudW5kb25lLCBudWxsLCAwKTtcbiAgdmFyIGFwcGVuZGVkID0gdHIuZ2V0TWV0YShcImFwcGVuZGVkVHJhbnNhY3Rpb25cIik7XG5cbiAgaWYgKHRyLnN0ZXBzLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIGhpc3Rvcnk7XG4gIH0gZWxzZSBpZiAoYXBwZW5kZWQgJiYgYXBwZW5kZWQuZ2V0TWV0YShoaXN0b3J5S2V5KSkge1xuICAgIGlmIChhcHBlbmRlZC5nZXRNZXRhKGhpc3RvcnlLZXkpLnJlZG8pIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgaGlzdG9yeS51bmRvbmUsIHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHNbdHIuc3RlcHMubGVuZ3RoIC0gMV0pLCBoaXN0b3J5LnByZXZUaW1lKTtlbHNlIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUuYWRkVHJhbnNmb3JtKHRyLCB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIG51bGwsIGhpc3RvcnkucHJldlRpbWUpO1xuICB9IGVsc2UgaWYgKHRyLmdldE1ldGEoXCJhZGRUb0hpc3RvcnlcIikgIT09IGZhbHNlICYmICEoYXBwZW5kZWQgJiYgYXBwZW5kZWQuZ2V0TWV0YShcImFkZFRvSGlzdG9yeVwiKSA9PT0gZmFsc2UpKSB7XG4gICAgdmFyIG5ld0dyb3VwID0gaGlzdG9yeS5wcmV2VGltZSA9PSAwIHx8ICFhcHBlbmRlZCAmJiAoaGlzdG9yeS5wcmV2VGltZSA8ICh0ci50aW1lIHx8IDApIC0gb3B0aW9ucy5uZXdHcm91cERlbGF5IHx8ICFpc0FkamFjZW50VG8odHIsIGhpc3RvcnkucHJldlJhbmdlcykpO1xuICAgIHZhciBwcmV2UmFuZ2VzID0gYXBwZW5kZWQgPyBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSA6IHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHNbdHIuc3RlcHMubGVuZ3RoIC0gMV0pO1xuICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIG5ld0dyb3VwID8gc3RhdGUuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCkgOiB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIEJyYW5jaC5lbXB0eSwgcHJldlJhbmdlcywgdHIudGltZSk7XG4gIH0gZWxzZSBpZiAocmViYXNlZCA9IHRyLmdldE1ldGEoXCJyZWJhc2VkXCIpKSB7XG4gICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLnJlYmFzZWQodHIsIHJlYmFzZWQpLCBoaXN0b3J5LnVuZG9uZS5yZWJhc2VkKHRyLCByZWJhc2VkKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRNYXBzKHRyLm1hcHBpbmcubWFwcyksIGhpc3RvcnkudW5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQWRqYWNlbnRUbyh0cmFuc2Zvcm0sIHByZXZSYW5nZXMpIHtcbiAgaWYgKCFwcmV2UmFuZ2VzKSByZXR1cm4gZmFsc2U7XG4gIGlmICghdHJhbnNmb3JtLmRvY0NoYW5nZWQpIHJldHVybiB0cnVlO1xuICB2YXIgYWRqYWNlbnQgPSBmYWxzZTtcbiAgdHJhbnNmb3JtLm1hcHBpbmcubWFwc1swXS5mb3JFYWNoKGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2UmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAoc3RhcnQgPD0gcHJldlJhbmdlc1tpICsgMV0gJiYgZW5kID49IHByZXZSYW5nZXNbaV0pIGFkamFjZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYWRqYWNlbnQ7XG59XG5cbmZ1bmN0aW9uIHJhbmdlc0ZvcihtYXApIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAoX2Zyb20sIF90bywgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbWFwUmFuZ2VzKHJhbmdlcywgbWFwcGluZykge1xuICBpZiAoIXJhbmdlcykgcmV0dXJuIG51bGw7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXAocmFuZ2VzW2ldLCAxKSxcbiAgICAgICAgdG8gPSBtYXBwaW5nLm1hcChyYW5nZXNbaSArIDFdLCAtMSk7XG4gICAgaWYgKGZyb20gPD0gdG8pIHJlc3VsdC5wdXNoKGZyb20sIHRvKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGhpc3RUcmFuc2FjdGlvbihoaXN0b3J5LCBzdGF0ZSwgZGlzcGF0Y2gsIHJlZG8pIHtcbiAgdmFyIHByZXNlcnZlSXRlbXMgPSBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSk7XG4gIHZhciBoaXN0T3B0aW9ucyA9IGhpc3RvcnlLZXkuZ2V0KHN0YXRlKS5zcGVjLmNvbmZpZztcbiAgdmFyIHBvcCA9IChyZWRvID8gaGlzdG9yeS51bmRvbmUgOiBoaXN0b3J5LmRvbmUpLnBvcEV2ZW50KHN0YXRlLCBwcmVzZXJ2ZUl0ZW1zKTtcbiAgaWYgKCFwb3ApIHJldHVybjtcbiAgdmFyIHNlbGVjdGlvbiA9IHBvcC5zZWxlY3Rpb24ucmVzb2x2ZShwb3AudHJhbnNmb3JtLmRvYyk7XG4gIHZhciBhZGRlZCA9IChyZWRvID8gaGlzdG9yeS5kb25lIDogaGlzdG9yeS51bmRvbmUpLmFkZFRyYW5zZm9ybShwb3AudHJhbnNmb3JtLCBzdGF0ZS5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKSwgaGlzdE9wdGlvbnMsIHByZXNlcnZlSXRlbXMpO1xuICB2YXIgbmV3SGlzdCA9IG5ldyBIaXN0b3J5U3RhdGUocmVkbyA/IGFkZGVkIDogcG9wLnJlbWFpbmluZywgcmVkbyA/IHBvcC5yZW1haW5pbmcgOiBhZGRlZCwgbnVsbCwgMCk7XG4gIGRpc3BhdGNoKHBvcC50cmFuc2Zvcm0uc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikuc2V0TWV0YShoaXN0b3J5S2V5LCB7XG4gICAgcmVkbzogcmVkbyxcbiAgICBoaXN0b3J5U3RhdGU6IG5ld0hpc3RcbiAgfSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG59XG5cbnZhciBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gZmFsc2UsXG4gICAgY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgPSBudWxsO1xuXG5mdW5jdGlvbiBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkge1xuICB2YXIgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XG5cbiAgaWYgKGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zICE9IHBsdWdpbnMpIHtcbiAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gZmFsc2U7XG4gICAgY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgPSBwbHVnaW5zO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocGx1Z2luc1tpXS5zcGVjLmhpc3RvcnlQcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgIGNhY2hlZFByZXNlcnZlSXRlbXMgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FjaGVkUHJlc2VydmVJdGVtcztcbn1cblxuZnVuY3Rpb24gY2xvc2VIaXN0b3J5KHRyKSB7XG4gIHJldHVybiB0ci5zZXRNZXRhKGNsb3NlSGlzdG9yeUtleSwgdHJ1ZSk7XG59XG5cbnZhciBoaXN0b3J5S2V5ID0gbmV3IHByb3NlbWlycm9yU3RhdGUuUGx1Z2luS2V5KFwiaGlzdG9yeVwiKTtcbnZhciBjbG9zZUhpc3RvcnlLZXkgPSBuZXcgcHJvc2VtaXJyb3JTdGF0ZS5QbHVnaW5LZXkoXCJjbG9zZUhpc3RvcnlcIik7XG5cbmZ1bmN0aW9uIGhpc3RvcnkoKSB7XG4gIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBjb25maWcgPSB7XG4gICAgZGVwdGg6IGNvbmZpZy5kZXB0aCB8fCAxMDAsXG4gICAgbmV3R3JvdXBEZWxheTogY29uZmlnLm5ld0dyb3VwRGVsYXkgfHwgNTAwXG4gIH07XG4gIHJldHVybiBuZXcgcHJvc2VtaXJyb3JTdGF0ZS5QbHVnaW4oe1xuICAgIGtleTogaGlzdG9yeUtleSxcbiAgICBzdGF0ZToge1xuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoQnJhbmNoLmVtcHR5LCBCcmFuY2guZW1wdHksIG51bGwsIDApO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0ciwgaGlzdCwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIHRyLCBjb25maWcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29uZmlnOiBjb25maWcsXG4gICAgcHJvcHM6IHtcbiAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICBiZWZvcmVpbnB1dDogZnVuY3Rpb24gYmVmb3JlaW5wdXQodmlldywgZSkge1xuICAgICAgICAgIHZhciBpbnB1dFR5cGUgPSBlLmlucHV0VHlwZTtcbiAgICAgICAgICB2YXIgY29tbWFuZCA9IGlucHV0VHlwZSA9PSBcImhpc3RvcnlVbmRvXCIgPyB1bmRvIDogaW5wdXRUeXBlID09IFwiaGlzdG9yeVJlZG9cIiA/IHJlZG8gOiBudWxsO1xuICAgICAgICAgIGlmICghY29tbWFuZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbnZhciB1bmRvID0gZnVuY3Rpb24gdW5kbyhzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgaWYgKCFoaXN0IHx8IGhpc3QuZG9uZS5ldmVudENvdW50ID09IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSBoaXN0VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHJlZG8gPSBmdW5jdGlvbiByZWRvKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICBpZiAoIWhpc3QgfHwgaGlzdC51bmRvbmUuZXZlbnRDb3VudCA9PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkgaGlzdFRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gdW5kb0RlcHRoKHN0YXRlKSB7XG4gIHZhciBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gIHJldHVybiBoaXN0ID8gaGlzdC5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuXG5mdW5jdGlvbiByZWRvRGVwdGgoc3RhdGUpIHtcbiAgdmFyIGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgcmV0dXJuIGhpc3QgPyBoaXN0LnVuZG9uZS5ldmVudENvdW50IDogMDtcbn1cblxuZXhwb3J0cy5jbG9zZUhpc3RvcnkgPSBjbG9zZUhpc3Rvcnk7XG5leHBvcnRzLmhpc3RvcnkgPSBoaXN0b3J5O1xuZXhwb3J0cy5yZWRvID0gcmVkbztcbmV4cG9ydHMucmVkb0RlcHRoID0gcmVkb0RlcHRoO1xuZXhwb3J0cy51bmRvID0gdW5kbztcbmV4cG9ydHMudW5kb0RlcHRoID0gdW5kb0RlcHRoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgcHJvc2VtaXJyb3JTdGF0ZSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXN0YXRlJyk7XG5cbnZhciBwcm9zZW1pcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXRyYW5zZm9ybScpO1xuXG52YXIgSW5wdXRSdWxlID0gX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIElucHV0UnVsZShtYXRjaCwgaGFuZGxlcikge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5wdXRSdWxlKTtcblxuICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgdGhpcy5oYW5kbGVyID0gdHlwZW9mIGhhbmRsZXIgPT0gXCJzdHJpbmdcIiA/IHN0cmluZ0hhbmRsZXIoaGFuZGxlcikgOiBoYW5kbGVyO1xufSk7XG5cbmZ1bmN0aW9uIHN0cmluZ0hhbmRsZXIoc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIG1hdGNoLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGluc2VydCA9IHN0cmluZztcblxuICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgdmFyIG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpO1xuICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgdmFyIGN1dE9mZiA9IHN0YXJ0IC0gZW5kO1xuXG4gICAgICBpZiAoY3V0T2ZmID4gMCkge1xuICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnQ7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS50ci5pbnNlcnRUZXh0KGluc2VydCwgc3RhcnQsIGVuZCk7XG4gIH07XG59XG5cbnZhciBNQVhfTUFUQ0ggPSA1MDA7XG5cbmZ1bmN0aW9uIGlucHV0UnVsZXMoX3JlZikge1xuICB2YXIgcnVsZXMgPSBfcmVmLnJ1bGVzO1xuICB2YXIgcGx1Z2luID0gbmV3IHByb3NlbWlycm9yU3RhdGUuUGx1Z2luKHtcbiAgICBzdGF0ZToge1xuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRyLCBwcmV2KSB7XG4gICAgICAgIHZhciBzdG9yZWQgPSB0ci5nZXRNZXRhKHRoaXMpO1xuICAgICAgICBpZiAoc3RvcmVkKSByZXR1cm4gc3RvcmVkO1xuICAgICAgICByZXR1cm4gdHIuc2VsZWN0aW9uU2V0IHx8IHRyLmRvY0NoYW5nZWQgPyBudWxsIDogcHJldjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVUZXh0SW5wdXQ6IGZ1bmN0aW9uIGhhbmRsZVRleHRJbnB1dCh2aWV3LCBmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICByZXR1cm4gcnVuKHZpZXcsIGZyb20sIHRvLCB0ZXh0LCBydWxlcywgcGx1Z2luKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgY29tcG9zaXRpb25lbmQ6IGZ1bmN0aW9uIGNvbXBvc2l0aW9uZW5kKHZpZXcpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkY3Vyc29yID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGN1cnNvcjtcbiAgICAgICAgICAgIGlmICgkY3Vyc29yKSBydW4odmlldywgJGN1cnNvci5wb3MsICRjdXJzb3IucG9zLCBcIlwiLCBydWxlcywgcGx1Z2luKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaXNJbnB1dFJ1bGVzOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gcGx1Z2luO1xufVxuXG5mdW5jdGlvbiBydW4odmlldywgZnJvbSwgdG8sIHRleHQsIHJ1bGVzLCBwbHVnaW4pIHtcbiAgaWYgKHZpZXcuY29tcG9zaW5nKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzdGF0ZSA9IHZpZXcuc3RhdGUsXG4gICAgICAkZnJvbSA9IHN0YXRlLmRvYy5yZXNvbHZlKGZyb20pO1xuICBpZiAoJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlKSByZXR1cm4gZmFsc2U7XG4gIHZhciB0ZXh0QmVmb3JlID0gJGZyb20ucGFyZW50LnRleHRCZXR3ZWVuKE1hdGgubWF4KDAsICRmcm9tLnBhcmVudE9mZnNldCAtIE1BWF9NQVRDSCksICRmcm9tLnBhcmVudE9mZnNldCwgbnVsbCwgXCJcXHVGRkZDXCIpICsgdGV4dDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hdGNoID0gcnVsZXNbaV0ubWF0Y2guZXhlYyh0ZXh0QmVmb3JlKTtcbiAgICB2YXIgdHIgPSBtYXRjaCAmJiBydWxlc1tpXS5oYW5kbGVyKHN0YXRlLCBtYXRjaCwgZnJvbSAtIChtYXRjaFswXS5sZW5ndGggLSB0ZXh0Lmxlbmd0aCksIHRvKTtcbiAgICBpZiAoIXRyKSBjb250aW51ZTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNldE1ldGEocGx1Z2luLCB7XG4gICAgICB0cmFuc2Zvcm06IHRyLFxuICAgICAgZnJvbTogZnJvbSxcbiAgICAgIHRvOiB0byxcbiAgICAgIHRleHQ6IHRleHRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciB1bmRvSW5wdXRSdWxlID0gZnVuY3Rpb24gdW5kb0lucHV0UnVsZShzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIHBsdWdpbnMgPSBzdGF0ZS5wbHVnaW5zO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW2ldLFxuICAgICAgICB1bmRvYWJsZSA9IHZvaWQgMDtcblxuICAgIGlmIChwbHVnaW4uc3BlYy5pc0lucHV0UnVsZXMgJiYgKHVuZG9hYmxlID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKSkpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB2YXIgdHIgPSBzdGF0ZS50cixcbiAgICAgICAgICAgIHRvVW5kbyA9IHVuZG9hYmxlLnRyYW5zZm9ybTtcblxuICAgICAgICBmb3IgKHZhciBqID0gdG9VbmRvLnN0ZXBzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgdHIuc3RlcCh0b1VuZG8uc3RlcHNbal0uaW52ZXJ0KHRvVW5kby5kb2NzW2pdKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodW5kb2FibGUudGV4dCkge1xuICAgICAgICAgIHZhciBtYXJrcyA9IHRyLmRvYy5yZXNvbHZlKHVuZG9hYmxlLmZyb20pLm1hcmtzKCk7XG4gICAgICAgICAgdHIucmVwbGFjZVdpdGgodW5kb2FibGUuZnJvbSwgdW5kb2FibGUudG8sIHN0YXRlLnNjaGVtYS50ZXh0KHVuZG9hYmxlLnRleHQsIG1hcmtzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJbXCJkZWxldGVcIl0odW5kb2FibGUuZnJvbSwgdW5kb2FibGUudG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgZW1EYXNoID0gbmV3IElucHV0UnVsZSgvLS0kLywgXCLigJRcIik7XG52YXIgZWxsaXBzaXMgPSBuZXcgSW5wdXRSdWxlKC9cXC5cXC5cXC4kLywgXCLigKZcIik7XG52YXIgb3BlbkRvdWJsZVF1b3RlID0gbmV3IElucHV0UnVsZSgvKD86XnxbXFxzXFx7XFxbXFwoXFw8J1wiXFx1MjAxOFxcdTIwMUNdKShcIikkLywgXCLigJxcIik7XG52YXIgY2xvc2VEb3VibGVRdW90ZSA9IG5ldyBJbnB1dFJ1bGUoL1wiJC8sIFwi4oCdXCIpO1xudmFyIG9wZW5TaW5nbGVRdW90ZSA9IG5ldyBJbnB1dFJ1bGUoLyg/Ol58W1xcc1xce1xcW1xcKFxcPCdcIlxcdTIwMThcXHUyMDFDXSkoJykkLywgXCLigJhcIik7XG52YXIgY2xvc2VTaW5nbGVRdW90ZSA9IG5ldyBJbnB1dFJ1bGUoLyckLywgXCLigJlcIik7XG52YXIgc21hcnRRdW90ZXMgPSBbb3BlbkRvdWJsZVF1b3RlLCBjbG9zZURvdWJsZVF1b3RlLCBvcGVuU2luZ2xlUXVvdGUsIGNsb3NlU2luZ2xlUXVvdGVdO1xuXG5mdW5jdGlvbiB3cmFwcGluZ0lucHV0UnVsZShyZWdleHAsIG5vZGVUeXBlKSB7XG4gIHZhciBnZXRBdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgdmFyIGpvaW5QcmVkaWNhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUocmVnZXhwLCBmdW5jdGlvbiAoc3RhdGUsIG1hdGNoLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGdldEF0dHJzKG1hdGNoKSA6IGdldEF0dHJzO1xuICAgIHZhciB0ciA9IHN0YXRlLnRyW1wiZGVsZXRlXCJdKHN0YXJ0LCBlbmQpO1xuICAgIHZhciAkc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShzdGFydCksXG4gICAgICAgIHJhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKSxcbiAgICAgICAgd3JhcHBpbmcgPSByYW5nZSAmJiBwcm9zZW1pcnJvclRyYW5zZm9ybS5maW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgaWYgKCF3cmFwcGluZykgcmV0dXJuIG51bGw7XG4gICAgdHIud3JhcChyYW5nZSwgd3JhcHBpbmcpO1xuICAgIHZhciBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShzdGFydCAtIDEpLm5vZGVCZWZvcmU7XG4gICAgaWYgKGJlZm9yZSAmJiBiZWZvcmUudHlwZSA9PSBub2RlVHlwZSAmJiBwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5Kb2luKHRyLmRvYywgc3RhcnQgLSAxKSAmJiAoIWpvaW5QcmVkaWNhdGUgfHwgam9pblByZWRpY2F0ZShtYXRjaCwgYmVmb3JlKSkpIHRyLmpvaW4oc3RhcnQgLSAxKTtcbiAgICByZXR1cm4gdHI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHJlZ2V4cCwgbm9kZVR5cGUpIHtcbiAgdmFyIGdldEF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICByZXR1cm4gbmV3IElucHV0UnVsZShyZWdleHAsIGZ1bmN0aW9uIChzdGF0ZSwgbWF0Y2gsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgJHN0YXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUoc3RhcnQpO1xuICAgIHZhciBhdHRycyA9IGdldEF0dHJzIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBnZXRBdHRycyhtYXRjaCkgOiBnZXRBdHRycztcbiAgICBpZiAoISRzdGFydC5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkc3RhcnQuaW5kZXgoLTEpLCAkc3RhcnQuaW5kZXhBZnRlcigtMSksIG5vZGVUeXBlKSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHN0YXRlLnRyW1wiZGVsZXRlXCJdKHN0YXJ0LCBlbmQpLnNldEJsb2NrVHlwZShzdGFydCwgc3RhcnQsIG5vZGVUeXBlLCBhdHRycyk7XG4gIH0pO1xufVxuXG5leHBvcnRzLklucHV0UnVsZSA9IElucHV0UnVsZTtcbmV4cG9ydHMuY2xvc2VEb3VibGVRdW90ZSA9IGNsb3NlRG91YmxlUXVvdGU7XG5leHBvcnRzLmNsb3NlU2luZ2xlUXVvdGUgPSBjbG9zZVNpbmdsZVF1b3RlO1xuZXhwb3J0cy5lbGxpcHNpcyA9IGVsbGlwc2lzO1xuZXhwb3J0cy5lbURhc2ggPSBlbURhc2g7XG5leHBvcnRzLmlucHV0UnVsZXMgPSBpbnB1dFJ1bGVzO1xuZXhwb3J0cy5vcGVuRG91YmxlUXVvdGUgPSBvcGVuRG91YmxlUXVvdGU7XG5leHBvcnRzLm9wZW5TaW5nbGVRdW90ZSA9IG9wZW5TaW5nbGVRdW90ZTtcbmV4cG9ydHMuc21hcnRRdW90ZXMgPSBzbWFydFF1b3RlcztcbmV4cG9ydHMudGV4dGJsb2NrVHlwZUlucHV0UnVsZSA9IHRleHRibG9ja1R5cGVJbnB1dFJ1bGU7XG5leHBvcnRzLnVuZG9JbnB1dFJ1bGUgPSB1bmRvSW5wdXRSdWxlO1xuZXhwb3J0cy53cmFwcGluZ0lucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIHczY0tleW5hbWUgPSByZXF1aXJlKCd3M2Mta2V5bmFtZScpO1xuXG52YXIgcHJvc2VtaXJyb3JTdGF0ZSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXN0YXRlJyk7XG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pLFxuICAgICAgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gIGlmIChyZXN1bHQgPT0gXCJTcGFjZVwiKSByZXN1bHQgPSBcIiBcIjtcbiAgdmFyIGFsdCwgY3RybCwgc2hpZnQsIG1ldGE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB2YXIgbW9kID0gcGFydHNbaV07XG4gICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSkgbWV0YSA9IHRydWU7ZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKSBhbHQgPSB0cnVlO2Vsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIGN0cmwgPSB0cnVlO2Vsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKSBzaGlmdCA9IHRydWU7ZWxzZSBpZiAoL15tb2QkL2kudGVzdChtb2QpKSB7XG4gICAgICBpZiAobWFjKSBtZXRhID0gdHJ1ZTtlbHNlIGN0cmwgPSB0cnVlO1xuICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpO1xuICB9XG5cbiAgaWYgKGFsdCkgcmVzdWx0ID0gXCJBbHQtXCIgKyByZXN1bHQ7XG4gIGlmIChjdHJsKSByZXN1bHQgPSBcIkN0cmwtXCIgKyByZXN1bHQ7XG4gIGlmIChtZXRhKSByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7XG4gIGlmIChzaGlmdCkgcmVzdWx0ID0gXCJTaGlmdC1cIiArIHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKG1hcCkge1xuICB2YXIgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBtYXApIHtcbiAgICBjb3B5W25vcm1hbGl6ZUtleU5hbWUocHJvcCldID0gbWFwW3Byb3BdO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIG1vZGlmaWVycyhuYW1lLCBldmVudCwgc2hpZnQpIHtcbiAgaWYgKGV2ZW50LmFsdEtleSkgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTtcbiAgaWYgKGV2ZW50LmN0cmxLZXkpIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICBpZiAoZXZlbnQubWV0YUtleSkgbmFtZSA9IFwiTWV0YS1cIiArIG5hbWU7XG4gIGlmIChzaGlmdCAhPT0gZmFsc2UgJiYgZXZlbnQuc2hpZnRLZXkpIG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTtcbiAgcmV0dXJuIG5hbWU7XG59XG5cbmZ1bmN0aW9uIGtleW1hcChiaW5kaW5ncykge1xuICByZXR1cm4gbmV3IHByb3NlbWlycm9yU3RhdGUuUGx1Z2luKHtcbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlS2V5RG93bjoga2V5ZG93bkhhbmRsZXIoYmluZGluZ3MpXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24ga2V5ZG93bkhhbmRsZXIoYmluZGluZ3MpIHtcbiAgdmFyIG1hcCA9IG5vcm1hbGl6ZShiaW5kaW5ncyk7XG4gIHJldHVybiBmdW5jdGlvbiAodmlldywgZXZlbnQpIHtcbiAgICB2YXIgbmFtZSA9IHczY0tleW5hbWUua2V5TmFtZShldmVudCksXG4gICAgICAgIGlzQ2hhciA9IG5hbWUubGVuZ3RoID09IDEgJiYgbmFtZSAhPSBcIiBcIixcbiAgICAgICAgYmFzZU5hbWU7XG4gICAgdmFyIGRpcmVjdCA9IG1hcFttb2RpZmllcnMobmFtZSwgZXZlbnQsICFpc0NoYXIpXTtcbiAgICBpZiAoZGlyZWN0ICYmIGRpcmVjdCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSkgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAoaXNDaGFyICYmIChldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBuYW1lLmNoYXJDb2RlQXQoMCkgPiAxMjcpICYmIChiYXNlTmFtZSA9IHczY0tleW5hbWUuYmFzZVtldmVudC5rZXlDb2RlXSkgJiYgYmFzZU5hbWUgIT0gbmFtZSkge1xuICAgICAgdmFyIGZyb21Db2RlID0gbWFwW21vZGlmaWVycyhiYXNlTmFtZSwgZXZlbnQsIHRydWUpXTtcbiAgICAgIGlmIChmcm9tQ29kZSAmJiBmcm9tQ29kZSh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSkgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc0NoYXIgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIHZhciB3aXRoU2hpZnQgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCB0cnVlKV07XG4gICAgICBpZiAod2l0aFNoaWZ0ICYmIHdpdGhTaGlmdCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxuXG5leHBvcnRzLmtleWRvd25IYW5kbGVyID0ga2V5ZG93bkhhbmRsZXI7XG5leHBvcnRzLmtleW1hcCA9IGtleW1hcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgY3JlbCA9IHJlcXVpcmUoJ2NyZWx0Jyk7XG5cbnZhciBwcm9zZW1pcnJvckNvbW1hbmRzID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItY29tbWFuZHMnKTtcblxudmFyIHByb3NlbWlycm9ySGlzdG9yeSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLWhpc3RvcnknKTtcblxudmFyIHByb3NlbWlycm9yU3RhdGUgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1zdGF0ZScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3koZSkge1xuICByZXR1cm4gZSAmJiBfdHlwZW9mKGUpID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7XG4gICAgJ2RlZmF1bHQnOiBlXG4gIH07XG59XG5cbnZhciBjcmVsX19kZWZhdWx0ID0gX2ludGVyb3BEZWZhdWx0TGVnYWN5KGNyZWwpO1xuXG52YXIgU1ZHID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xudmFyIFhMSU5LID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XG52YXIgcHJlZml4JDIgPSBcIlByb3NlTWlycm9yLWljb25cIjtcblxuZnVuY3Rpb24gaGFzaFBhdGgocGF0aCkge1xuICB2YXIgaGFzaCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIHBhdGguY2hhckNvZGVBdChpKSB8IDA7XG4gIH1cblxuICByZXR1cm4gaGFzaDtcbn1cblxuZnVuY3Rpb24gZ2V0SWNvbihpY29uKSB7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbm9kZS5jbGFzc05hbWUgPSBwcmVmaXgkMjtcblxuICBpZiAoaWNvbi5wYXRoKSB7XG4gICAgdmFyIHBhdGggPSBpY29uLnBhdGgsXG4gICAgICAgIHdpZHRoID0gaWNvbi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gaWNvbi5oZWlnaHQ7XG4gICAgdmFyIG5hbWUgPSBcInBtLWljb24tXCIgKyBoYXNoUGF0aChwYXRoKS50b1N0cmluZygxNik7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuYW1lKSkgYnVpbGRTVkcobmFtZSwgaWNvbik7XG4gICAgdmFyIHN2ZyA9IG5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWRywgXCJzdmdcIikpO1xuICAgIHN2Zy5zdHlsZS53aWR0aCA9IHdpZHRoIC8gaGVpZ2h0ICsgXCJlbVwiO1xuICAgIHZhciB1c2UgPSBzdmcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWRywgXCJ1c2VcIikpO1xuICAgIHVzZS5zZXRBdHRyaWJ1dGVOUyhYTElOSywgXCJocmVmXCIsIC8oW14jXSopLy5leGVjKGRvY3VtZW50LmxvY2F0aW9uLnRvU3RyaW5nKCkpWzFdICsgXCIjXCIgKyBuYW1lKTtcbiAgfSBlbHNlIGlmIChpY29uLmRvbSkge1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoaWNvbi5kb20uY2xvbmVOb2RlKHRydWUpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGV4dCA9IGljb24udGV4dCxcbiAgICAgICAgY3NzID0gaWNvbi5jc3M7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSkudGV4dENvbnRlbnQgPSB0ZXh0IHx8ICcnO1xuICAgIGlmIChjc3MpIG5vZGUuZmlyc3RDaGlsZC5zdHlsZS5jc3NUZXh0ID0gY3NzO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU1ZHKG5hbWUsIGRhdGEpIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgkMiArIFwiLWNvbGxlY3Rpb25cIik7XG5cbiAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgY29sbGVjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkcsIFwic3ZnXCIpO1xuICAgIGNvbGxlY3Rpb24uaWQgPSBwcmVmaXgkMiArIFwiLWNvbGxlY3Rpb25cIjtcbiAgICBjb2xsZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShjb2xsZWN0aW9uLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgdmFyIHN5bSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkcsIFwic3ltYm9sXCIpO1xuICBzeW0uaWQgPSBuYW1lO1xuICBzeW0uc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBcIjAgMCBcIiArIGRhdGEud2lkdGggKyBcIiBcIiArIGRhdGEuaGVpZ2h0KTtcbiAgdmFyIHBhdGggPSBzeW0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWRywgXCJwYXRoXCIpKTtcbiAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIGRhdGEucGF0aCk7XG4gIGNvbGxlY3Rpb24uYXBwZW5kQ2hpbGQoc3ltKTtcbn1cblxudmFyIHByZWZpeCQxID0gXCJQcm9zZU1pcnJvci1tZW51XCI7XG5cbnZhciBNZW51SXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWVudUl0ZW0oc3BlYykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51SXRlbSk7XG5cbiAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1lbnVJdGVtLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHZpZXcpIHtcbiAgICAgIHZhciBzcGVjID0gdGhpcy5zcGVjO1xuICAgICAgdmFyIGRvbSA9IHNwZWMucmVuZGVyID8gc3BlYy5yZW5kZXIodmlldykgOiBzcGVjLmljb24gPyBnZXRJY29uKHNwZWMuaWNvbikgOiBzcGVjLmxhYmVsID8gY3JlbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oXCJkaXZcIiwgbnVsbCwgdHJhbnNsYXRlKHZpZXcsIHNwZWMubGFiZWwpKSA6IG51bGw7XG4gICAgICBpZiAoIWRvbSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNZW51SXRlbSB3aXRob3V0IGljb24gb3IgbGFiZWwgcHJvcGVydHlcIik7XG5cbiAgICAgIGlmIChzcGVjLnRpdGxlKSB7XG4gICAgICAgIHZhciB0aXRsZSA9IHR5cGVvZiBzcGVjLnRpdGxlID09PSBcImZ1bmN0aW9uXCIgPyBzcGVjLnRpdGxlKHZpZXcuc3RhdGUpIDogc3BlYy50aXRsZTtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIHRyYW5zbGF0ZSh2aWV3LCB0aXRsZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlY1tcImNsYXNzXCJdKSBkb20uY2xhc3NMaXN0LmFkZChzcGVjW1wiY2xhc3NcIl0pO1xuICAgICAgaWYgKHNwZWMuY3NzKSBkb20uc3R5bGUuY3NzVGV4dCArPSBzcGVjLmNzcztcbiAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKCFkb20uY2xhc3NMaXN0LmNvbnRhaW5zKHByZWZpeCQxICsgXCItZGlzYWJsZWRcIikpIHNwZWMucnVuKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcsIGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZShzdGF0ZSkge1xuICAgICAgICBpZiAoc3BlYy5zZWxlY3QpIHtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzcGVjLnNlbGVjdChzdGF0ZSk7XG4gICAgICAgICAgZG9tLnN0eWxlLmRpc3BsYXkgPSBzZWxlY3RlZCA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgICBpZiAoIXNlbGVjdGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHNwZWMuZW5hYmxlKSB7XG4gICAgICAgICAgZW5hYmxlZCA9IHNwZWMuZW5hYmxlKHN0YXRlKSB8fCBmYWxzZTtcbiAgICAgICAgICBzZXRDbGFzcyhkb20sIHByZWZpeCQxICsgXCItZGlzYWJsZWRcIiwgIWVuYWJsZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNwZWMuYWN0aXZlKSB7XG4gICAgICAgICAgdmFyIGFjdGl2ZSA9IGVuYWJsZWQgJiYgc3BlYy5hY3RpdmUoc3RhdGUpIHx8IGZhbHNlO1xuICAgICAgICAgIHNldENsYXNzKGRvbSwgcHJlZml4JDEgKyBcIi1hY3RpdmVcIiwgYWN0aXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb206IGRvbSxcbiAgICAgICAgdXBkYXRlOiB1cGRhdGVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1lbnVJdGVtO1xufSgpO1xuXG5mdW5jdGlvbiB0cmFuc2xhdGUodmlldywgdGV4dCkge1xuICByZXR1cm4gdmlldy5fcHJvcHMudHJhbnNsYXRlID8gdmlldy5fcHJvcHMudHJhbnNsYXRlKHRleHQpIDogdGV4dDtcbn1cblxudmFyIGxhc3RNZW51RXZlbnQgPSB7XG4gIHRpbWU6IDAsXG4gIG5vZGU6IG51bGxcbn07XG5cbmZ1bmN0aW9uIG1hcmtNZW51RXZlbnQoZSkge1xuICBsYXN0TWVudUV2ZW50LnRpbWUgPSBEYXRlLm5vdygpO1xuICBsYXN0TWVudUV2ZW50Lm5vZGUgPSBlLnRhcmdldDtcbn1cblxuZnVuY3Rpb24gaXNNZW51RXZlbnQod3JhcHBlcikge1xuICByZXR1cm4gRGF0ZS5ub3coKSAtIDEwMCA8IGxhc3RNZW51RXZlbnQudGltZSAmJiBsYXN0TWVudUV2ZW50Lm5vZGUgJiYgd3JhcHBlci5jb250YWlucyhsYXN0TWVudUV2ZW50Lm5vZGUpO1xufVxuXG52YXIgRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERyb3Bkb3duKGNvbnRlbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcGRvd24pO1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuY29udGVudCA9IEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERyb3Bkb3duLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHZpZXcpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBjb250ZW50ID0gcmVuZGVyRHJvcGRvd25JdGVtcyh0aGlzLmNvbnRlbnQsIHZpZXcpO1xuICAgICAgdmFyIGxhYmVsID0gY3JlbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oXCJkaXZcIiwge1xuICAgICAgICBcImNsYXNzXCI6IHByZWZpeCQxICsgXCItZHJvcGRvd24gXCIgKyAodGhpcy5vcHRpb25zW1wiY2xhc3NcIl0gfHwgXCJcIiksXG4gICAgICAgIHN0eWxlOiB0aGlzLm9wdGlvbnMuY3NzXG4gICAgICB9LCB0cmFuc2xhdGUodmlldywgdGhpcy5vcHRpb25zLmxhYmVsIHx8IFwiXCIpKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGl0bGUpIGxhYmVsLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIHRyYW5zbGF0ZSh2aWV3LCB0aGlzLm9wdGlvbnMudGl0bGUpKTtcbiAgICAgIHZhciB3cmFwID0gY3JlbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oXCJkaXZcIiwge1xuICAgICAgICBcImNsYXNzXCI6IHByZWZpeCQxICsgXCItZHJvcGRvd24td3JhcFwiXG4gICAgICB9LCBsYWJlbCk7XG4gICAgICB2YXIgb3BlbiA9IG51bGw7XG4gICAgICB2YXIgbGlzdGVuaW5nT25DbG9zZSA9IG51bGw7XG5cbiAgICAgIHZhciBjbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBpZiAob3BlbiAmJiBvcGVuLmNsb3NlKCkpIHtcbiAgICAgICAgICBvcGVuID0gbnVsbDtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBsaXN0ZW5pbmdPbkNsb3NlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG1hcmtNZW51RXZlbnQoZSk7XG5cbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wZW4gPSBfdGhpcy5leHBhbmQod3JhcCwgY29udGVudC5kb20pO1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGxpc3RlbmluZ09uQ2xvc2UgPSBmdW5jdGlvbiBsaXN0ZW5pbmdPbkNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKCFpc01lbnVFdmVudCh3cmFwKSkgY2xvc2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZShzdGF0ZSkge1xuICAgICAgICB2YXIgaW5uZXIgPSBjb250ZW50LnVwZGF0ZShzdGF0ZSk7XG4gICAgICAgIHdyYXAuc3R5bGUuZGlzcGxheSA9IGlubmVyID8gXCJcIiA6IFwibm9uZVwiO1xuICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbTogd3JhcCxcbiAgICAgICAgdXBkYXRlOiB1cGRhdGVcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4cGFuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmQoZG9tLCBpdGVtcykge1xuICAgICAgdmFyIG1lbnVET00gPSBjcmVsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShcImRpdlwiLCB7XG4gICAgICAgIFwiY2xhc3NcIjogcHJlZml4JDEgKyBcIi1kcm9wZG93bi1tZW51IFwiICsgKHRoaXMub3B0aW9uc1tcImNsYXNzXCJdIHx8IFwiXCIpXG4gICAgICB9LCBpdGVtcyk7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIGRvbS5yZW1vdmVDaGlsZChtZW51RE9NKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGRvbS5hcHBlbmRDaGlsZChtZW51RE9NKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsb3NlOiBjbG9zZSxcbiAgICAgICAgbm9kZTogbWVudURPTVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRHJvcGRvd247XG59KCk7XG5cbmZ1bmN0aW9uIHJlbmRlckRyb3Bkb3duSXRlbXMoaXRlbXMsIHZpZXcpIHtcbiAgdmFyIHJlbmRlcmVkID0gW10sXG4gICAgICB1cGRhdGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfaXRlbXMkaSRyZW5kZXIgPSBpdGVtc1tpXS5yZW5kZXIodmlldyksXG4gICAgICAgIGRvbSA9IF9pdGVtcyRpJHJlbmRlci5kb20sXG4gICAgICAgIHVwZGF0ZSA9IF9pdGVtcyRpJHJlbmRlci51cGRhdGU7XG5cbiAgICByZW5kZXJlZC5wdXNoKGNyZWxfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFwiZGl2XCIsIHtcbiAgICAgIFwiY2xhc3NcIjogcHJlZml4JDEgKyBcIi1kcm9wZG93bi1pdGVtXCJcbiAgICB9LCBkb20pKTtcbiAgICB1cGRhdGVzLnB1c2godXBkYXRlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZG9tOiByZW5kZXJlZCxcbiAgICB1cGRhdGU6IGNvbWJpbmVVcGRhdGVzKHVwZGF0ZXMsIHJlbmRlcmVkKVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21iaW5lVXBkYXRlcyh1cGRhdGVzLCBub2Rlcykge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIHNvbWV0aGluZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdXAgPSB1cGRhdGVzW2ldKHN0YXRlKTtcbiAgICAgIG5vZGVzW2ldLnN0eWxlLmRpc3BsYXkgPSB1cCA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICAgIGlmICh1cCkgc29tZXRoaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc29tZXRoaW5nO1xuICB9O1xufVxuXG52YXIgRHJvcGRvd25TdWJtZW51ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEcm9wZG93blN1Ym1lbnUoY29udGVudCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wZG93blN1Ym1lbnUpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbnRlbnQgPSBBcnJheS5pc0FycmF5KGNvbnRlbnQpID8gY29udGVudCA6IFtjb250ZW50XTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEcm9wZG93blN1Ym1lbnUsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIodmlldykge1xuICAgICAgdmFyIGl0ZW1zID0gcmVuZGVyRHJvcGRvd25JdGVtcyh0aGlzLmNvbnRlbnQsIHZpZXcpO1xuICAgICAgdmFyIGxhYmVsID0gY3JlbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oXCJkaXZcIiwge1xuICAgICAgICBcImNsYXNzXCI6IHByZWZpeCQxICsgXCItc3VibWVudS1sYWJlbFwiXG4gICAgICB9LCB0cmFuc2xhdGUodmlldywgdGhpcy5vcHRpb25zLmxhYmVsIHx8IFwiXCIpKTtcbiAgICAgIHZhciB3cmFwID0gY3JlbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oXCJkaXZcIiwge1xuICAgICAgICBcImNsYXNzXCI6IHByZWZpeCQxICsgXCItc3VibWVudS13cmFwXCJcbiAgICAgIH0sIGxhYmVsLCBjcmVsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShcImRpdlwiLCB7XG4gICAgICAgIFwiY2xhc3NcIjogcHJlZml4JDEgKyBcIi1zdWJtZW51XCJcbiAgICAgIH0sIGl0ZW1zLmRvbSkpO1xuICAgICAgdmFyIF9saXN0ZW5pbmdPbkNsb3NlID0gbnVsbDtcbiAgICAgIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBtYXJrTWVudUV2ZW50KGUpO1xuICAgICAgICBzZXRDbGFzcyh3cmFwLCBwcmVmaXgkMSArIFwiLXN1Ym1lbnUtd3JhcC1hY3RpdmVcIiwgZmFsc2UpO1xuICAgICAgICBpZiAoIV9saXN0ZW5pbmdPbkNsb3NlKSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfbGlzdGVuaW5nT25DbG9zZSA9IGZ1bmN0aW9uIGxpc3RlbmluZ09uQ2xvc2UoKSB7XG4gICAgICAgICAgaWYgKCFpc01lbnVFdmVudCh3cmFwKSkge1xuICAgICAgICAgICAgd3JhcC5jbGFzc0xpc3QucmVtb3ZlKHByZWZpeCQxICsgXCItc3VibWVudS13cmFwLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF9saXN0ZW5pbmdPbkNsb3NlKTtcbiAgICAgICAgICAgIF9saXN0ZW5pbmdPbkNsb3NlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZShzdGF0ZSkge1xuICAgICAgICB2YXIgaW5uZXIgPSBpdGVtcy51cGRhdGUoc3RhdGUpO1xuICAgICAgICB3cmFwLnN0eWxlLmRpc3BsYXkgPSBpbm5lciA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb206IHdyYXAsXG4gICAgICAgIHVwZGF0ZTogdXBkYXRlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEcm9wZG93blN1Ym1lbnU7XG59KCk7XG5cbmZ1bmN0aW9uIHJlbmRlckdyb3VwZWQodmlldywgY29udGVudCkge1xuICB2YXIgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgdXBkYXRlcyA9IFtdLFxuICAgICAgc2VwYXJhdG9ycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtcyA9IGNvbnRlbnRbaV0sXG4gICAgICAgIGxvY2FsVXBkYXRlcyA9IFtdLFxuICAgICAgICBsb2NhbE5vZGVzID0gW107XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgX2l0ZW1zJGokcmVuZGVyID0gaXRlbXNbal0ucmVuZGVyKHZpZXcpLFxuICAgICAgICAgIGRvbSA9IF9pdGVtcyRqJHJlbmRlci5kb20sXG4gICAgICAgICAgX3VwZGF0ZSA9IF9pdGVtcyRqJHJlbmRlci51cGRhdGU7XG5cbiAgICAgIHZhciBzcGFuID0gY3JlbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oXCJzcGFuXCIsIHtcbiAgICAgICAgXCJjbGFzc1wiOiBwcmVmaXgkMSArIFwiaXRlbVwiXG4gICAgICB9LCBkb20pO1xuICAgICAgcmVzdWx0LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgbG9jYWxOb2Rlcy5wdXNoKHNwYW4pO1xuICAgICAgbG9jYWxVcGRhdGVzLnB1c2goX3VwZGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGxvY2FsVXBkYXRlcy5sZW5ndGgpIHtcbiAgICAgIHVwZGF0ZXMucHVzaChjb21iaW5lVXBkYXRlcyhsb2NhbFVwZGF0ZXMsIGxvY2FsTm9kZXMpKTtcbiAgICAgIGlmIChpIDwgY29udGVudC5sZW5ndGggLSAxKSBzZXBhcmF0b3JzLnB1c2gocmVzdWx0LmFwcGVuZENoaWxkKHNlcGFyYXRvcigpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKHN0YXRlKSB7XG4gICAgdmFyIHNvbWV0aGluZyA9IGZhbHNlLFxuICAgICAgICBuZWVkU2VwID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdXBkYXRlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBoYXNDb250ZW50ID0gdXBkYXRlc1tfaV0oc3RhdGUpO1xuXG4gICAgICBpZiAoX2kpIHNlcGFyYXRvcnNbX2kgLSAxXS5zdHlsZS5kaXNwbGF5ID0gbmVlZFNlcCAmJiBoYXNDb250ZW50ID8gXCJcIiA6IFwibm9uZVwiO1xuICAgICAgbmVlZFNlcCA9IGhhc0NvbnRlbnQ7XG4gICAgICBpZiAoaGFzQ29udGVudCkgc29tZXRoaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc29tZXRoaW5nO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkb206IHJlc3VsdCxcbiAgICB1cGRhdGU6IHVwZGF0ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBzZXBhcmF0b3IoKSB7XG4gIHJldHVybiBjcmVsX19kZWZhdWx0W1wiZGVmYXVsdFwiXShcInNwYW5cIiwge1xuICAgIFwiY2xhc3NcIjogcHJlZml4JDEgKyBcInNlcGFyYXRvclwiXG4gIH0pO1xufVxuXG52YXIgaWNvbnMgPSB7XG4gIGpvaW46IHtcbiAgICB3aWR0aDogODAwLFxuICAgIGhlaWdodDogOTAwLFxuICAgIHBhdGg6IFwiTTAgNzVoODAwdjEyNWgtODAweiBNMCA4MjVoODAwdi0xMjVoLTgwMHogTTI1MCA0MDBoMTAwdi0xMDBoMTAwdjEwMGgxMDB2MTAwaC0xMDB2MTAwaC0xMDB2LTEwMGgtMTAwelwiXG4gIH0sXG4gIGxpZnQ6IHtcbiAgICB3aWR0aDogMTAyNCxcbiAgICBoZWlnaHQ6IDEwMjQsXG4gICAgcGF0aDogXCJNMjE5IDMxMHYzMjlxMCA3LTUgMTJ0LTEyIDVxLTggMC0xMy01bC0xNjQtMTY0cS01LTUtNS0xM3Q1LTEzbDE2NC0xNjRxNS01IDEzLTUgNyAwIDEyIDV0NSAxMnpNMTAyNCA3NDl2MTA5cTAgNy01IDEydC0xMiA1aC05ODdxLTcgMC0xMi01dC01LTEydi0xMDlxMC03IDUtMTJ0MTItNWg5ODdxNyAwIDEyIDV0NSAxMnpNMTAyNCA1MzB2MTA5cTAgNy01IDEydC0xMiA1aC02MjFxLTcgMC0xMi01dC01LTEydi0xMDlxMC03IDUtMTJ0MTItNWg2MjFxNyAwIDEyIDV0NSAxMnpNMTAyNCAzMTB2MTA5cTAgNy01IDEydC0xMiA1aC02MjFxLTcgMC0xMi01dC01LTEydi0xMDlxMC03IDUtMTJ0MTItNWg2MjFxNyAwIDEyIDV0NSAxMnpNMTAyNCA5MXYxMDlxMCA3LTUgMTJ0LTEyIDVoLTk4N3EtNyAwLTEyLTV0LTUtMTJ2LTEwOXEwLTcgNS0xMnQxMi01aDk4N3E3IDAgMTIgNXQ1IDEyelwiXG4gIH0sXG4gIHNlbGVjdFBhcmVudE5vZGU6IHtcbiAgICB0ZXh0OiBcIlxcdTJCMUFcIixcbiAgICBjc3M6IFwiZm9udC13ZWlnaHQ6IGJvbGRcIlxuICB9LFxuICB1bmRvOiB7XG4gICAgd2lkdGg6IDEwMjQsXG4gICAgaGVpZ2h0OiAxMDI0LFxuICAgIHBhdGg6IFwiTTc2MSAxMDI0YzExMy0yMDYgMTMyLTUyMC0zMTMtNTA5djI1M2wtMzg0LTM4NCAzODQtMzg0djI0OGM1MzQtMTMgNTk0IDQ3MiAzMTMgNzc1elwiXG4gIH0sXG4gIHJlZG86IHtcbiAgICB3aWR0aDogMTAyNCxcbiAgICBoZWlnaHQ6IDEwMjQsXG4gICAgcGF0aDogXCJNNTc2IDI0OHYtMjQ4bDM4NCAzODQtMzg0IDM4NHYtMjUzYy00NDYtMTAtNDI3IDMwMy0zMTMgNTA5LTI4MC0zMDMtMjIxLTc4OSAzMTMtNzc1elwiXG4gIH0sXG4gIHN0cm9uZzoge1xuICAgIHdpZHRoOiA4MDUsXG4gICAgaGVpZ2h0OiAxMDI0LFxuICAgIHBhdGg6IFwiTTMxNyA4NjlxNDIgMTggODAgMTggMjE0IDAgMjE0LTE5MSAwLTY1LTIzLTEwMi0xNS0yNS0zNS00MnQtMzgtMjYtNDYtMTQtNDgtNi01NC0xcS00MSAwLTU3IDUgMCAzMC0wIDkwdC0wIDkwcTAgNC0wIDM4dC0wIDU1IDIgNDcgNiAzOHpNMzA5IDQ0MnEyNCA0IDYyIDQgNDYgMCA4MS03dDYyLTI1IDQyLTUxIDE0LTgxcTAtNDAtMTYtNzB0LTQ1LTQ2LTYxLTI0LTcwLThxLTI4IDAtNzQgNyAwIDI4IDIgODZ0MiA4NnEwIDE1LTAgNDV0LTAgNDVxMCAyNiAwIDM5ek0wIDk1MGwxLTUzcTgtMiA0OC05dDYwLTE1cTQtNiA3LTE1dDQtMTkgMy0xOCAxLTIxIDAtMTl2LTM3cTAtNTYxLTEyLTU4NS0yLTQtMTItOHQtMjUtNi0yOC00LTI3LTItMTctMWwtMi00N3E1Ni0xIDE5NC02dDIxMy01cTEzIDAgMzkgMHQzOCAwcTQwIDAgNzggN3Q3MyAyNCA2MSA0MCA0MiA1OSAxNiA3OHEwIDI5LTkgNTR0LTIyIDQxLTM2IDMyLTQxIDI1LTQ4IDIycTg4IDIwIDE0NiA3NnQ1OCAxNDFxMCA1Ny0yMCAxMDJ0LTUzIDc0LTc4IDQ4LTkzIDI3LTEwMCA4cS0yNSAwLTc1LTF0LTc1LTFxLTYwIDAtMTc1IDZ0LTEzMiA2elwiXG4gIH0sXG4gIGVtOiB7XG4gICAgd2lkdGg6IDU4NSxcbiAgICBoZWlnaHQ6IDEwMjQsXG4gICAgcGF0aDogXCJNMCA5NDlsOS00OHEzLTEgNDYtMTJ0NjMtMjFxMTYtMjAgMjMtNTcgMC00IDM1LTE2NXQ2NS0zMTAgMjktMTY5di0xNHEtMTMtNy0zMS0xMHQtMzktNC0zMy0zbDEwLTU4cTE4IDEgNjggM3Q4NSA0IDY4IDFxMjcgMCA1Ni0xdDY5LTQgNTYtM3EtMiAyMi0xMCA1MC0xNyA1LTU4IDE2dC02MiAxOXEtNCAxMC04IDI0dC01IDIyLTQgMjYtMyAyNHEtMTUgODQtNTAgMjM5dC00NCAyMDNxLTEgNS03IDMzdC0xMSA1MS05IDQ3LTMgMzJsMCAxMHE5IDIgMTA1IDE3LTEgMjUtOSA1Ni02IDAtMTggMHQtMTggMHEtMTYgMC00OS01dC00OS01cS03OC0xLTExNy0xLTI5IDAtODEgNXQtNjkgNnpcIlxuICB9LFxuICBjb2RlOiB7XG4gICAgd2lkdGg6IDg5NixcbiAgICBoZWlnaHQ6IDEwMjQsXG4gICAgcGF0aDogXCJNNjA4IDE5MmwtOTYgOTYgMjI0IDIyNC0yMjQgMjI0IDk2IDk2IDI4OC0zMjAtMjg4LTMyMHpNMjg4IDE5MmwtMjg4IDMyMCAyODggMzIwIDk2LTk2LTIyNC0yMjQgMjI0LTIyNC05Ni05NnpcIlxuICB9LFxuICBsaW5rOiB7XG4gICAgd2lkdGg6IDk1MSxcbiAgICBoZWlnaHQ6IDEwMjQsXG4gICAgcGF0aDogXCJNODMyIDY5NHEwLTIyLTE2LTM4bC0xMTgtMTE4cS0xNi0xNi0zOC0xNi0yNCAwLTQxIDE4IDEgMSAxMCAxMHQxMiAxMiA4IDEwIDcgMTQgMiAxNXEwIDIyLTE2IDM4dC0zOCAxNnEtOCAwLTE1LTJ0LTE0LTctMTAtOC0xMi0xMi0xMC0xMHEtMTggMTctMTggNDEgMCAyMiAxNiAzOGwxMTcgMTE4cTE1IDE1IDM4IDE1IDIyIDAgMzgtMTRsODQtODNxMTYtMTYgMTYtMzh6TTQzMCAyOTJxMC0yMi0xNi0zOGwtMTE3LTExOHEtMTYtMTYtMzgtMTYtMjIgMC0zOCAxNWwtODQgODNxLTE2IDE2LTE2IDM4IDAgMjIgMTYgMzhsMTE4IDExOHExNSAxNSAzOCAxNSAyNCAwIDQxLTE3LTEtMS0xMC0xMHQtMTItMTItOC0xMC03LTE0LTItMTVxMC0yMiAxNi0zOHQzOC0xNnE4IDAgMTUgMnQxNCA3IDEwIDggMTIgMTIgMTAgMTBxMTgtMTcgMTgtNDF6TTk0MSA2OTRxMCA2OC00OCAxMTZsLTg0IDgzcS00NyA0Ny0xMTYgNDctNjkgMC0xMTYtNDhsLTExNy0xMThxLTQ3LTQ3LTQ3LTExNiAwLTcwIDUwLTExOWwtNTAtNTBxLTQ5IDUwLTExOCA1MC02OCAwLTExNi00OGwtMTE4LTExOHEtNDgtNDgtNDgtMTE2dDQ4LTExNmw4NC04M3E0Ny00NyAxMTYtNDcgNjkgMCAxMTYgNDhsMTE3IDExOHE0NyA0NyA0NyAxMTYgMCA3MC01MCAxMTlsNTAgNTBxNDktNTAgMTE4LTUwIDY4IDAgMTE2IDQ4bDExOCAxMThxNDggNDggNDggMTE2elwiXG4gIH0sXG4gIGJ1bGxldExpc3Q6IHtcbiAgICB3aWR0aDogNzY4LFxuICAgIGhlaWdodDogODk2LFxuICAgIHBhdGg6IFwiTTAgNTEyaDEyOHYtMTI4aC0xMjh2MTI4ek0wIDI1NmgxMjh2LTEyOGgtMTI4djEyOHpNMCA3NjhoMTI4di0xMjhoLTEyOHYxMjh6TTI1NiA1MTJoNTEydi0xMjhoLTUxMnYxMjh6TTI1NiAyNTZoNTEydi0xMjhoLTUxMnYxMjh6TTI1NiA3NjhoNTEydi0xMjhoLTUxMnYxMjh6XCJcbiAgfSxcbiAgb3JkZXJlZExpc3Q6IHtcbiAgICB3aWR0aDogNzY4LFxuICAgIGhlaWdodDogODk2LFxuICAgIHBhdGg6IFwiTTMyMCA1MTJoNDQ4di0xMjhoLTQ0OHYxMjh6TTMyMCA3NjhoNDQ4di0xMjhoLTQ0OHYxMjh6TTMyMCAxMjh2MTI4aDQ0OHYtMTI4aC00NDh6TTc5IDM4NGg3OHYtMjU2aC0zNmwtODUgMjN2NTBsNDMtMnYxODV6TTE4OSA1OTBjMC0zNi0xMi03OC05Ni03OC0zMyAwLTY0IDYtODMgMTZsMSA2NmMyMS0xMCA0Mi0xNSA2Ny0xNXMzMiAxMSAzMiAyOGMwIDI2LTMwIDU4LTExMCAxMTJ2NTBoMTkydi02N2wtOTEgMmM0OS0zMCA4Ny02NiA4Ny0xMTNsMS0xelwiXG4gIH0sXG4gIGJsb2NrcXVvdGU6IHtcbiAgICB3aWR0aDogNjQwLFxuICAgIGhlaWdodDogODk2LFxuICAgIHBhdGg6IFwiTTAgNDQ4djI1NmgyNTZ2LTI1NmgtMTI4YzAgMCAwLTEyOCAxMjgtMTI4di0xMjhjMCAwLTI1NiAwLTI1NiAyNTZ6TTY0MCAzMjB2LTEyOGMwIDAtMjU2IDAtMjU2IDI1NnYyNTZoMjU2di0yNTZoLTEyOGMwIDAgMC0xMjggMTI4LTEyOHpcIlxuICB9XG59O1xudmFyIGpvaW5VcEl0ZW0gPSBuZXcgTWVudUl0ZW0oe1xuICB0aXRsZTogXCJKb2luIHdpdGggYWJvdmUgYmxvY2tcIixcbiAgcnVuOiBwcm9zZW1pcnJvckNvbW1hbmRzLmpvaW5VcCxcbiAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3Qoc3RhdGUpIHtcbiAgICByZXR1cm4gcHJvc2VtaXJyb3JDb21tYW5kcy5qb2luVXAoc3RhdGUpO1xuICB9LFxuICBpY29uOiBpY29ucy5qb2luXG59KTtcbnZhciBsaWZ0SXRlbSA9IG5ldyBNZW51SXRlbSh7XG4gIHRpdGxlOiBcIkxpZnQgb3V0IG9mIGVuY2xvc2luZyBibG9ja1wiLFxuICBydW46IHByb3NlbWlycm9yQ29tbWFuZHMubGlmdCxcbiAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3Qoc3RhdGUpIHtcbiAgICByZXR1cm4gcHJvc2VtaXJyb3JDb21tYW5kcy5saWZ0KHN0YXRlKTtcbiAgfSxcbiAgaWNvbjogaWNvbnMubGlmdFxufSk7XG52YXIgc2VsZWN0UGFyZW50Tm9kZUl0ZW0gPSBuZXcgTWVudUl0ZW0oe1xuICB0aXRsZTogXCJTZWxlY3QgcGFyZW50IG5vZGVcIixcbiAgcnVuOiBwcm9zZW1pcnJvckNvbW1hbmRzLnNlbGVjdFBhcmVudE5vZGUsXG4gIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KHN0YXRlKSB7XG4gICAgcmV0dXJuIHByb3NlbWlycm9yQ29tbWFuZHMuc2VsZWN0UGFyZW50Tm9kZShzdGF0ZSk7XG4gIH0sXG4gIGljb246IGljb25zLnNlbGVjdFBhcmVudE5vZGVcbn0pO1xudmFyIHVuZG9JdGVtID0gbmV3IE1lbnVJdGVtKHtcbiAgdGl0bGU6IFwiVW5kbyBsYXN0IGNoYW5nZVwiLFxuICBydW46IHByb3NlbWlycm9ySGlzdG9yeS51bmRvLFxuICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkge1xuICAgIHJldHVybiBwcm9zZW1pcnJvckhpc3RvcnkudW5kbyhzdGF0ZSk7XG4gIH0sXG4gIGljb246IGljb25zLnVuZG9cbn0pO1xudmFyIHJlZG9JdGVtID0gbmV3IE1lbnVJdGVtKHtcbiAgdGl0bGU6IFwiUmVkbyBsYXN0IHVuZG9uZSBjaGFuZ2VcIixcbiAgcnVuOiBwcm9zZW1pcnJvckhpc3RvcnkucmVkbyxcbiAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoc3RhdGUpIHtcbiAgICByZXR1cm4gcHJvc2VtaXJyb3JIaXN0b3J5LnJlZG8oc3RhdGUpO1xuICB9LFxuICBpY29uOiBpY29ucy5yZWRvXG59KTtcblxuZnVuY3Rpb24gd3JhcEl0ZW0obm9kZVR5cGUsIG9wdGlvbnMpIHtcbiAgdmFyIHBhc3NlZE9wdGlvbnMgPSB7XG4gICAgcnVuOiBmdW5jdGlvbiBydW4oc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICByZXR1cm4gcHJvc2VtaXJyb3JDb21tYW5kcy53cmFwSW4obm9kZVR5cGUsIG9wdGlvbnMuYXR0cnMpKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgfSxcbiAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChzdGF0ZSkge1xuICAgICAgcmV0dXJuIHByb3NlbWlycm9yQ29tbWFuZHMud3JhcEluKG5vZGVUeXBlLCBvcHRpb25zLmF0dHJzKShzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgIHBhc3NlZE9wdGlvbnNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBNZW51SXRlbShwYXNzZWRPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gYmxvY2tUeXBlSXRlbShub2RlVHlwZSwgb3B0aW9ucykge1xuICB2YXIgY29tbWFuZCA9IHByb3NlbWlycm9yQ29tbWFuZHMuc2V0QmxvY2tUeXBlKG5vZGVUeXBlLCBvcHRpb25zLmF0dHJzKTtcbiAgdmFyIHBhc3NlZE9wdGlvbnMgPSB7XG4gICAgcnVuOiBjb21tYW5kLFxuICAgIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKHN0YXRlKSB7XG4gICAgICByZXR1cm4gY29tbWFuZChzdGF0ZSk7XG4gICAgfSxcbiAgICBhY3RpdmU6IGZ1bmN0aW9uIGFjdGl2ZShzdGF0ZSkge1xuICAgICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uLiRmcm9tLFxuICAgICAgICAgIHRvID0gX3N0YXRlJHNlbGVjdGlvbi50byxcbiAgICAgICAgICBub2RlID0gX3N0YXRlJHNlbGVjdGlvbi5ub2RlO1xuICAgICAgaWYgKG5vZGUpIHJldHVybiBub2RlLmhhc01hcmt1cChub2RlVHlwZSwgb3B0aW9ucy5hdHRycyk7XG4gICAgICByZXR1cm4gdG8gPD0gJGZyb20uZW5kKCkgJiYgJGZyb20ucGFyZW50Lmhhc01hcmt1cChub2RlVHlwZSwgb3B0aW9ucy5hdHRycyk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgIHBhc3NlZE9wdGlvbnNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBNZW51SXRlbShwYXNzZWRPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gc2V0Q2xhc3MoZG9tLCBjbHMsIG9uKSB7XG4gIGlmIChvbikgZG9tLmNsYXNzTGlzdC5hZGQoY2xzKTtlbHNlIGRvbS5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG59XG5cbnZhciBwcmVmaXggPSBcIlByb3NlTWlycm9yLW1lbnViYXJcIjtcblxuZnVuY3Rpb24gaXNJT1MoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgdmFyIGFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgcmV0dXJuICEvRWRnZVxcL1xcZC8udGVzdChhZ2VudCkgJiYgL0FwcGxlV2ViS2l0Ly50ZXN0KGFnZW50KSAmJiAvTW9iaWxlXFwvXFx3Ky8udGVzdChhZ2VudCk7XG59XG5cbmZ1bmN0aW9uIG1lbnVCYXIob3B0aW9ucykge1xuICByZXR1cm4gbmV3IHByb3NlbWlycm9yU3RhdGUuUGx1Z2luKHtcbiAgICB2aWV3OiBmdW5jdGlvbiB2aWV3KGVkaXRvclZpZXcpIHtcbiAgICAgIHJldHVybiBuZXcgTWVudUJhclZpZXcoZWRpdG9yVmlldywgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIE1lbnVCYXJWaWV3ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNZW51QmFyVmlldyhlZGl0b3JWaWV3LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudUJhclZpZXcpO1xuXG4gICAgdGhpcy5lZGl0b3JWaWV3ID0gZWRpdG9yVmlldztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3BhY2VyID0gbnVsbDtcbiAgICB0aGlzLm1heEhlaWdodCA9IDA7XG4gICAgdGhpcy53aWR0aEZvck1heEhlaWdodCA9IDA7XG4gICAgdGhpcy5mbG9hdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc2Nyb2xsSGFuZGxlciA9IG51bGw7XG4gICAgdGhpcy53cmFwcGVyID0gY3JlbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oXCJkaXZcIiwge1xuICAgICAgXCJjbGFzc1wiOiBwcmVmaXggKyBcIi13cmFwcGVyXCJcbiAgICB9KTtcbiAgICB0aGlzLm1lbnUgPSB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQoY3JlbF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oXCJkaXZcIiwge1xuICAgICAgXCJjbGFzc1wiOiBwcmVmaXhcbiAgICB9KSk7XG4gICAgdGhpcy5tZW51LmNsYXNzTmFtZSA9IHByZWZpeDtcbiAgICBpZiAoZWRpdG9yVmlldy5kb20ucGFyZW50Tm9kZSkgZWRpdG9yVmlldy5kb20ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy53cmFwcGVyLCBlZGl0b3JWaWV3LmRvbSk7XG4gICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGVkaXRvclZpZXcuZG9tKTtcblxuICAgIHZhciBfcmVuZGVyR3JvdXBlZCA9IHJlbmRlckdyb3VwZWQodGhpcy5lZGl0b3JWaWV3LCB0aGlzLm9wdGlvbnMuY29udGVudCksXG4gICAgICAgIGRvbSA9IF9yZW5kZXJHcm91cGVkLmRvbSxcbiAgICAgICAgdXBkYXRlID0gX3JlbmRlckdyb3VwZWQudXBkYXRlO1xuXG4gICAgdGhpcy5jb250ZW50VXBkYXRlID0gdXBkYXRlO1xuICAgIHRoaXMubWVudS5hcHBlbmRDaGlsZChkb20pO1xuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICBpZiAob3B0aW9ucy5mbG9hdGluZyAmJiAhaXNJT1MoKSkge1xuICAgICAgdGhpcy51cGRhdGVGbG9hdCgpO1xuICAgICAgdmFyIHBvdGVudGlhbFNjcm9sbGVycyA9IGdldEFsbFdyYXBwaW5nKHRoaXMud3JhcHBlcik7XG5cbiAgICAgIHRoaXMuc2Nyb2xsSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciByb290ID0gX3RoaXMyLmVkaXRvclZpZXcucm9vdDtcbiAgICAgICAgaWYgKCEocm9vdC5ib2R5IHx8IHJvb3QpLmNvbnRhaW5zKF90aGlzMi53cmFwcGVyKSkgcG90ZW50aWFsU2Nyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgX3RoaXMyLnNjcm9sbEhhbmRsZXIpO1xuICAgICAgICB9KTtlbHNlIF90aGlzMi51cGRhdGVGbG9hdChlLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPyBlLnRhcmdldCA6IHVuZGVmaW5lZCk7XG4gICAgICB9O1xuXG4gICAgICBwb3RlbnRpYWxTY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF90aGlzMi5zY3JvbGxIYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNZW51QmFyVmlldywgW3tcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuY29udGVudFVwZGF0ZSh0aGlzLmVkaXRvclZpZXcuc3RhdGUpO1xuXG4gICAgICBpZiAodGhpcy5mbG9hdGluZykge1xuICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbEN1cnNvcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMubWVudS5vZmZzZXRXaWR0aCAhPSB0aGlzLndpZHRoRm9yTWF4SGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy53aWR0aEZvck1heEhlaWdodCA9IHRoaXMubWVudS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICB0aGlzLm1heEhlaWdodCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tZW51Lm9mZnNldEhlaWdodCA+IHRoaXMubWF4SGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5tYXhIZWlnaHQgPSB0aGlzLm1lbnUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIHRoaXMubWVudS5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLm1heEhlaWdodCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTY3JvbGxDdXJzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2Nyb2xsQ3Vyc29yKCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yVmlldy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCFzZWxlY3Rpb24uZm9jdXNOb2RlKSByZXR1cm47XG4gICAgICB2YXIgcmVjdHMgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgdmFyIHNlbFJlY3QgPSByZWN0c1tzZWxlY3Rpb25Jc0ludmVydGVkKHNlbGVjdGlvbikgPyAwIDogcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoIXNlbFJlY3QpIHJldHVybjtcbiAgICAgIHZhciBtZW51UmVjdCA9IHRoaXMubWVudS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKHNlbFJlY3QudG9wIDwgbWVudVJlY3QuYm90dG9tICYmIHNlbFJlY3QuYm90dG9tID4gbWVudVJlY3QudG9wKSB7XG4gICAgICAgIHZhciBzY3JvbGxhYmxlID0gZmluZFdyYXBwaW5nU2Nyb2xsYWJsZSh0aGlzLndyYXBwZXIpO1xuICAgICAgICBpZiAoc2Nyb2xsYWJsZSkgc2Nyb2xsYWJsZS5zY3JvbGxUb3AgLT0gbWVudVJlY3QuYm90dG9tIC0gc2VsUmVjdC50b3A7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUZsb2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUZsb2F0KHNjcm9sbEFuY2VzdG9yKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy53cmFwcGVyLFxuICAgICAgICAgIGVkaXRvclJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgdG9wID0gc2Nyb2xsQW5jZXN0b3IgPyBNYXRoLm1heCgwLCBzY3JvbGxBbmNlc3Rvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIDogMDtcblxuICAgICAgaWYgKHRoaXMuZmxvYXRpbmcpIHtcbiAgICAgICAgaWYgKGVkaXRvclJlY3QudG9wID49IHRvcCB8fCBlZGl0b3JSZWN0LmJvdHRvbSA8IHRoaXMubWVudS5vZmZzZXRIZWlnaHQgKyAxMCkge1xuICAgICAgICAgIHRoaXMuZmxvYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLm1lbnUuc3R5bGUucG9zaXRpb24gPSB0aGlzLm1lbnUuc3R5bGUubGVmdCA9IHRoaXMubWVudS5zdHlsZS50b3AgPSB0aGlzLm1lbnUuc3R5bGUud2lkdGggPSBcIlwiO1xuICAgICAgICAgIHRoaXMubWVudS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgICB0aGlzLnNwYWNlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc3BhY2VyKTtcbiAgICAgICAgICB0aGlzLnNwYWNlciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGJvcmRlciA9IChwYXJlbnQub2Zmc2V0V2lkdGggLSBwYXJlbnQuY2xpZW50V2lkdGgpIC8gMjtcbiAgICAgICAgICB0aGlzLm1lbnUuc3R5bGUubGVmdCA9IGVkaXRvclJlY3QubGVmdCArIGJvcmRlciArIFwicHhcIjtcbiAgICAgICAgICB0aGlzLm1lbnUuc3R5bGUuZGlzcGxheSA9IGVkaXRvclJlY3QudG9wID4gd2luZG93LmlubmVySGVpZ2h0ID8gXCJub25lXCIgOiBcIlwiO1xuICAgICAgICAgIGlmIChzY3JvbGxBbmNlc3RvcikgdGhpcy5tZW51LnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVkaXRvclJlY3QudG9wIDwgdG9wICYmIGVkaXRvclJlY3QuYm90dG9tID49IHRoaXMubWVudS5vZmZzZXRIZWlnaHQgKyAxMCkge1xuICAgICAgICAgIHRoaXMuZmxvYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHZhciBtZW51UmVjdCA9IHRoaXMubWVudS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB0aGlzLm1lbnUuc3R5bGUubGVmdCA9IG1lbnVSZWN0LmxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgdGhpcy5tZW51LnN0eWxlLndpZHRoID0gbWVudVJlY3Qud2lkdGggKyBcInB4XCI7XG4gICAgICAgICAgaWYgKHNjcm9sbEFuY2VzdG9yKSB0aGlzLm1lbnUuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICAgIHRoaXMubWVudS5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICAgICAgICB0aGlzLnNwYWNlciA9IGNyZWxfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFwiZGl2XCIsIHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogcHJlZml4ICsgXCItc3BhY2VyXCIsXG4gICAgICAgICAgICBzdHlsZTogXCJoZWlnaHQ6IFwiLmNvbmNhdChtZW51UmVjdC5oZWlnaHQsIFwicHhcIilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuc3BhY2VyLCB0aGlzLm1lbnUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLndyYXBwZXIucGFyZW50Tm9kZSkgdGhpcy53cmFwcGVyLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRoaXMuZWRpdG9yVmlldy5kb20sIHRoaXMud3JhcHBlcik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1lbnVCYXJWaWV3O1xufSgpO1xuXG5mdW5jdGlvbiBzZWxlY3Rpb25Jc0ludmVydGVkKHNlbGVjdGlvbikge1xuICBpZiAoc2VsZWN0aW9uLmFuY2hvck5vZGUgPT0gc2VsZWN0aW9uLmZvY3VzTm9kZSkgcmV0dXJuIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gIHJldHVybiBzZWxlY3Rpb24uYW5jaG9yTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihzZWxlY3Rpb24uZm9jdXNOb2RlKSA9PSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbn1cblxuZnVuY3Rpb24gZmluZFdyYXBwaW5nU2Nyb2xsYWJsZShub2RlKSB7XG4gIGZvciAodmFyIGN1ciA9IG5vZGUucGFyZW50Tm9kZTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgIGlmIChjdXIuc2Nyb2xsSGVpZ2h0ID4gY3VyLmNsaWVudEhlaWdodCkgcmV0dXJuIGN1cjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbGxXcmFwcGluZyhub2RlKSB7XG4gIHZhciByZXMgPSBbd2luZG93XTtcblxuICBmb3IgKHZhciBjdXIgPSBub2RlLnBhcmVudE5vZGU7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICByZXMucHVzaChjdXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0cy5Ecm9wZG93biA9IERyb3Bkb3duO1xuZXhwb3J0cy5Ecm9wZG93blN1Ym1lbnUgPSBEcm9wZG93blN1Ym1lbnU7XG5leHBvcnRzLk1lbnVJdGVtID0gTWVudUl0ZW07XG5leHBvcnRzLmJsb2NrVHlwZUl0ZW0gPSBibG9ja1R5cGVJdGVtO1xuZXhwb3J0cy5pY29ucyA9IGljb25zO1xuZXhwb3J0cy5qb2luVXBJdGVtID0gam9pblVwSXRlbTtcbmV4cG9ydHMubGlmdEl0ZW0gPSBsaWZ0SXRlbTtcbmV4cG9ydHMubWVudUJhciA9IG1lbnVCYXI7XG5leHBvcnRzLnJlZG9JdGVtID0gcmVkb0l0ZW07XG5leHBvcnRzLnJlbmRlckdyb3VwZWQgPSByZW5kZXJHcm91cGVkO1xuZXhwb3J0cy5zZWxlY3RQYXJlbnROb2RlSXRlbSA9IHNlbGVjdFBhcmVudE5vZGVJdGVtO1xuZXhwb3J0cy51bmRvSXRlbSA9IHVuZG9JdGVtO1xuZXhwb3J0cy53cmFwSXRlbSA9IHdyYXBJdGVtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfZ2V0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBPcmRlcmVkTWFwID0gcmVxdWlyZSgnb3JkZXJlZG1hcCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3koZSkge1xuICByZXR1cm4gZSAmJiBfdHlwZW9mKGUpID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7XG4gICAgJ2RlZmF1bHQnOiBlXG4gIH07XG59XG5cbnZhciBPcmRlcmVkTWFwX19kZWZhdWx0ID0gX2ludGVyb3BEZWZhdWx0TGVnYWN5KE9yZGVyZWRNYXApO1xuXG5mdW5jdGlvbiBfZmluZERpZmZTdGFydChhLCBiLCBwb3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7OyBpKyspIHtcbiAgICBpZiAoaSA9PSBhLmNoaWxkQ291bnQgfHwgaSA9PSBiLmNoaWxkQ291bnQpIHJldHVybiBhLmNoaWxkQ291bnQgPT0gYi5jaGlsZENvdW50ID8gbnVsbCA6IHBvcztcbiAgICB2YXIgY2hpbGRBID0gYS5jaGlsZChpKSxcbiAgICAgICAgY2hpbGRCID0gYi5jaGlsZChpKTtcblxuICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKSByZXR1cm4gcG9zO1xuXG4gICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBjaGlsZEEudGV4dFtqXSA9PSBjaGlsZEIudGV4dFtqXTsgaisrKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cblxuICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgIHZhciBpbm5lciA9IF9maW5kRGlmZlN0YXJ0KGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zICsgMSk7XG5cbiAgICAgIGlmIChpbm5lciAhPSBudWxsKSByZXR1cm4gaW5uZXI7XG4gICAgfVxuXG4gICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZmluZERpZmZFbmQoYSwgYiwgcG9zQSwgcG9zQikge1xuICBmb3IgKHZhciBpQSA9IGEuY2hpbGRDb3VudCwgaUIgPSBiLmNoaWxkQ291bnQ7Oykge1xuICAgIGlmIChpQSA9PSAwIHx8IGlCID09IDApIHJldHVybiBpQSA9PSBpQiA/IG51bGwgOiB7XG4gICAgICBhOiBwb3NBLFxuICAgICAgYjogcG9zQlxuICAgIH07XG4gICAgdmFyIGNoaWxkQSA9IGEuY2hpbGQoLS1pQSksXG4gICAgICAgIGNoaWxkQiA9IGIuY2hpbGQoLS1pQiksXG4gICAgICAgIHNpemUgPSBjaGlsZEEubm9kZVNpemU7XG5cbiAgICBpZiAoY2hpbGRBID09IGNoaWxkQikge1xuICAgICAgcG9zQSAtPSBzaXplO1xuICAgICAgcG9zQiAtPSBzaXplO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKSByZXR1cm4ge1xuICAgICAgYTogcG9zQSxcbiAgICAgIGI6IHBvc0JcbiAgICB9O1xuXG4gICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgIHZhciBzYW1lID0gMCxcbiAgICAgICAgICBtaW5TaXplID0gTWF0aC5taW4oY2hpbGRBLnRleHQubGVuZ3RoLCBjaGlsZEIudGV4dC5sZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoc2FtZSA8IG1pblNpemUgJiYgY2hpbGRBLnRleHRbY2hpbGRBLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdID09IGNoaWxkQi50ZXh0W2NoaWxkQi50ZXh0Lmxlbmd0aCAtIHNhbWUgLSAxXSkge1xuICAgICAgICBzYW1lKys7XG4gICAgICAgIHBvc0EtLTtcbiAgICAgICAgcG9zQi0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhOiBwb3NBLFxuICAgICAgICBiOiBwb3NCXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgIHZhciBpbm5lciA9IF9maW5kRGlmZkVuZChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvc0EgLSAxLCBwb3NCIC0gMSk7XG5cbiAgICAgIGlmIChpbm5lcikgcmV0dXJuIGlubmVyO1xuICAgIH1cblxuICAgIHBvc0EgLT0gc2l6ZTtcbiAgICBwb3NCIC09IHNpemU7XG4gIH1cbn1cblxudmFyIEZyYWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGcmFnbWVudChjb250ZW50LCBzaXplKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZyYWdtZW50KTtcblxuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgdGhpcy5zaXplID0gc2l6ZSB8fCAwO1xuICAgIGlmIChzaXplID09IG51bGwpIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zaXplICs9IGNvbnRlbnRbaV0ubm9kZVNpemU7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZyYWdtZW50LCBbe1xuICAgIGtleTogXCJub2Rlc0JldHdlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmKSB7XG4gICAgICB2YXIgbm9kZVN0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgdmFyIHBhcmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sXG4gICAgICAgICAgICBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcblxuICAgICAgICBpZiAoZW5kID4gZnJvbSAmJiBmKGNoaWxkLCBub2RlU3RhcnQgKyBwb3MsIHBhcmVudCB8fCBudWxsLCBpKSAhPT0gZmFsc2UgJiYgY2hpbGQuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgICAgICBjaGlsZC5ub2Rlc0JldHdlZW4oTWF0aC5tYXgoMCwgZnJvbSAtIHN0YXJ0KSwgTWF0aC5taW4oY2hpbGQuY29udGVudC5zaXplLCB0byAtIHN0YXJ0KSwgZiwgbm9kZVN0YXJ0ICsgc3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXNjZW5kYW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNjZW5kYW50cyhmKSB7XG4gICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLnNpemUsIGYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0QmV0d2VlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gICAgICB2YXIgdGV4dCA9IFwiXCIsXG4gICAgICAgICAgc2VwYXJhdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgICAgIHRleHQgKz0gbm9kZS50ZXh0LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKTtcbiAgICAgICAgICBzZXBhcmF0ZWQgPSAhYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5pc0xlYWYpIHtcbiAgICAgICAgICBpZiAobGVhZlRleHQpIHtcbiAgICAgICAgICAgIHRleHQgKz0gdHlwZW9mIGxlYWZUZXh0ID09PSBcImZ1bmN0aW9uXCIgPyBsZWFmVGV4dChub2RlKSA6IGxlYWZUZXh0O1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50eXBlLnNwZWMubGVhZlRleHQpIHtcbiAgICAgICAgICAgIHRleHQgKz0gbm9kZS50eXBlLnNwZWMubGVhZlRleHQobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VwYXJhdGVkID0gIWJsb2NrU2VwYXJhdG9yO1xuICAgICAgICB9IGVsc2UgaWYgKCFzZXBhcmF0ZWQgJiYgbm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgICBzZXBhcmF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKG90aGVyKSB7XG4gICAgICBpZiAoIW90aGVyLnNpemUpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCF0aGlzLnNpemUpIHJldHVybiBvdGhlcjtcbiAgICAgIHZhciBsYXN0ID0gdGhpcy5sYXN0Q2hpbGQsXG4gICAgICAgICAgZmlyc3QgPSBvdGhlci5maXJzdENoaWxkLFxuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKSxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgaWYgKGxhc3QuaXNUZXh0ICYmIGxhc3Quc2FtZU1hcmt1cChmaXJzdCkpIHtcbiAgICAgICAgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID0gbGFzdC53aXRoVGV4dChsYXN0LnRleHQgKyBmaXJzdC50ZXh0KTtcbiAgICAgICAgaSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgb3RoZXIuY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb250ZW50LnB1c2gob3RoZXIuY29udGVudFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCwgdGhpcy5zaXplICsgb3RoZXIuc2l6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXQoZnJvbSkge1xuICAgICAgdmFyIHRvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNpemU7XG4gICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuc2l6ZSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2l6ZSA9IDA7XG4gICAgICBpZiAodG8gPiBmcm9tKSBmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sXG4gICAgICAgICAgICBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcblxuICAgICAgICBpZiAoZW5kID4gZnJvbSkge1xuICAgICAgICAgIGlmIChwb3MgPCBmcm9tIHx8IGVuZCA+IHRvKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KSBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgTWF0aC5taW4oY2hpbGQudGV4dC5sZW5ndGgsIHRvIC0gcG9zKSk7ZWxzZSBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zIC0gMSksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBwb3MgLSAxKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgIHNpemUgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHJlc3VsdCwgc2l6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1dEJ5SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3V0QnlJbmRleChmcm9tLCB0bykge1xuICAgICAgaWYgKGZyb20gPT0gdG8pIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5jb250ZW50Lmxlbmd0aCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5zbGljZShmcm9tLCB0bykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZUNoaWxkKGluZGV4LCBub2RlKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICBpZiAoY3VycmVudCA9PSBub2RlKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBjb3B5ID0gdGhpcy5jb250ZW50LnNsaWNlKCk7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUgLSBjdXJyZW50Lm5vZGVTaXplO1xuICAgICAgY29weVtpbmRleF0gPSBub2RlO1xuICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb3B5LCBzaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVG9TdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb1N0YXJ0KG5vZGUpIHtcbiAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoW25vZGVdLmNvbmNhdCh0aGlzLmNvbnRlbnQpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVG9FbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVG9FbmQobm9kZSkge1xuICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuY29uY2F0KG5vZGUpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoICE9IG90aGVyLmNvbnRlbnQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50W2ldLmVxKG90aGVyLmNvbnRlbnRbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdENoaWxkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFswXSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhc3RDaGlsZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRDb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoaWxkKGluZGV4KSB7XG4gICAgICB2YXIgZm91bmQgPSB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICAgICAgaWYgKCFmb3VuZCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBcIiArIGluZGV4ICsgXCIgb3V0IG9mIHJhbmdlIGZvciBcIiArIHRoaXMpO1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXliZUNoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heWJlQ2hpbGQoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbaW5kZXhdIHx8IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChmKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcCA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jb250ZW50W2ldO1xuICAgICAgICBmKGNoaWxkLCBwLCBpKTtcbiAgICAgICAgcCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZERpZmZTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kRGlmZlN0YXJ0KG90aGVyKSB7XG4gICAgICB2YXIgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgcmV0dXJuIF9maW5kRGlmZlN0YXJ0KHRoaXMsIG90aGVyLCBwb3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kRGlmZkVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kRGlmZkVuZChvdGhlcikge1xuICAgICAgdmFyIHBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zaXplO1xuICAgICAgdmFyIG90aGVyUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBvdGhlci5zaXplO1xuICAgICAgcmV0dXJuIF9maW5kRGlmZkVuZCh0aGlzLCBvdGhlciwgcG9zLCBvdGhlclBvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kSW5kZXgocG9zKSB7XG4gICAgICB2YXIgcm91bmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IC0xO1xuICAgICAgaWYgKHBvcyA9PSAwKSByZXR1cm4gcmV0SW5kZXgoMCwgcG9zKTtcbiAgICAgIGlmIChwb3MgPT0gdGhpcy5zaXplKSByZXR1cm4gcmV0SW5kZXgodGhpcy5jb250ZW50Lmxlbmd0aCwgcG9zKTtcbiAgICAgIGlmIChwb3MgPiB0aGlzLnNpemUgfHwgcG9zIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQb3NpdGlvbiBcIi5jb25jYXQocG9zLCBcIiBvdXRzaWRlIG9mIGZyYWdtZW50IChcIikuY29uY2F0KHRoaXMsIFwiKVwiKSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBjdXJQb3MgPSAwOzsgaSsrKSB7XG4gICAgICAgIHZhciBjdXIgPSB0aGlzLmNoaWxkKGkpLFxuICAgICAgICAgICAgZW5kID0gY3VyUG9zICsgY3VyLm5vZGVTaXplO1xuXG4gICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgaWYgKGVuZCA9PSBwb3MgfHwgcm91bmQgPiAwKSByZXR1cm4gcmV0SW5kZXgoaSArIDEsIGVuZCk7XG4gICAgICAgICAgcmV0dXJuIHJldEluZGV4KGksIGN1clBvcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJQb3MgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiPFwiICsgdGhpcy50b1N0cmluZ0lubmVyKCkgKyBcIj5cIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdJbm5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZ0lubmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5qb2luKFwiLCBcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudC5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG4udG9KU09OKCk7XG4gICAgICB9KSA6IG51bGw7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oc2NoZW1hLCB2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBGcmFnbWVudC5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodmFsdWUubWFwKHNjaGVtYS5ub2RlRnJvbUpTT04pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21BcnJheShhcnJheSkge1xuICAgICAgaWYgKCFhcnJheS5sZW5ndGgpIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgIHZhciBqb2luZWQsXG4gICAgICAgICAgc2l6ZSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBhcnJheVtpXTtcbiAgICAgICAgc2l6ZSArPSBub2RlLm5vZGVTaXplO1xuXG4gICAgICAgIGlmIChpICYmIG5vZGUuaXNUZXh0ICYmIGFycmF5W2kgLSAxXS5zYW1lTWFya3VwKG5vZGUpKSB7XG4gICAgICAgICAgaWYgKCFqb2luZWQpIGpvaW5lZCA9IGFycmF5LnNsaWNlKDAsIGkpO1xuICAgICAgICAgIGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0gPSBub2RlLndpdGhUZXh0KGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0udGV4dCArIG5vZGUudGV4dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoam9pbmVkKSB7XG4gICAgICAgICAgam9pbmVkLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChqb2luZWQgfHwgYXJyYXksIHNpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20obm9kZXMpIHtcbiAgICAgIGlmICghbm9kZXMpIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgIGlmIChub2RlcyBpbnN0YW5jZW9mIEZyYWdtZW50KSByZXR1cm4gbm9kZXM7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHJldHVybiB0aGlzLmZyb21BcnJheShub2Rlcyk7XG4gICAgICBpZiAobm9kZXMuYXR0cnMpIHJldHVybiBuZXcgRnJhZ21lbnQoW25vZGVzXSwgbm9kZXMubm9kZVNpemUpO1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgXCIgKyBub2RlcyArIFwiIHRvIGEgRnJhZ21lbnRcIiArIChub2Rlcy5ub2Rlc0JldHdlZW4gPyBcIiAobG9va3MgbGlrZSBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBwcm9zZW1pcnJvci1tb2RlbCB3ZXJlIGxvYWRlZClcIiA6IFwiXCIpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRnJhZ21lbnQ7XG59KCk7XG5cbkZyYWdtZW50LmVtcHR5ID0gbmV3IEZyYWdtZW50KFtdLCAwKTtcbnZhciBmb3VuZCA9IHtcbiAgaW5kZXg6IDAsXG4gIG9mZnNldDogMFxufTtcblxuZnVuY3Rpb24gcmV0SW5kZXgoaW5kZXgsIG9mZnNldCkge1xuICBmb3VuZC5pbmRleCA9IGluZGV4O1xuICBmb3VuZC5vZmZzZXQgPSBvZmZzZXQ7XG4gIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZURlZXAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gIGlmICghKGEgJiYgX3R5cGVvZihhKSA9PSBcIm9iamVjdFwiKSB8fCAhKGIgJiYgX3R5cGVvZihiKSA9PSBcIm9iamVjdFwiKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgYXJyYXkgPSBBcnJheS5pc0FycmF5KGEpO1xuICBpZiAoQXJyYXkuaXNBcnJheShiKSAhPSBhcnJheSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChhcnJheSkge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVEZWVwKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIHAgaW4gYSkge1xuICAgICAgaWYgKCEocCBpbiBiKSB8fCAhY29tcGFyZURlZXAoYVtwXSwgYltwXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfcCBpbiBiKSB7XG4gICAgICBpZiAoIShfcCBpbiBhKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgTWFyayA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFyayh0eXBlLCBhdHRycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXJrKTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hcmssIFt7XG4gICAga2V5OiBcImFkZFRvU2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRvU2V0KHNldCkge1xuICAgICAgdmFyIGNvcHksXG4gICAgICAgICAgcGxhY2VkID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHNldFtpXTtcbiAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKSByZXR1cm4gc2V0O1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUuZXhjbHVkZXMob3RoZXIudHlwZSkpIHtcbiAgICAgICAgICBpZiAoIWNvcHkpIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoZXIudHlwZS5leGNsdWRlcyh0aGlzLnR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXBsYWNlZCAmJiBvdGhlci50eXBlLnJhbmsgPiB0aGlzLnR5cGUucmFuaykge1xuICAgICAgICAgICAgaWYgKCFjb3B5KSBjb3B5ID0gc2V0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29weSkgY29weS5wdXNoKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvcHkpIGNvcHkgPSBzZXQuc2xpY2UoKTtcbiAgICAgIGlmICghcGxhY2VkKSBjb3B5LnB1c2godGhpcyk7XG4gICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRnJvbVNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSkgcmV0dXJuIHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW5TZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJblNldChzZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmVxKHNldFtpXSkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLnR5cGUgPT0gb3RoZXIudHlwZSAmJiBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBvdGhlci5hdHRycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUubmFtZVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgXyBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKCFqc29uKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE1hcmsuZnJvbUpTT05cIik7XG4gICAgICB2YXIgdHlwZSA9IHNjaGVtYS5tYXJrc1tqc29uLnR5cGVdO1xuICAgICAgaWYgKCF0eXBlKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIG1hcmsgdHlwZSBcIi5jb25jYXQoanNvbi50eXBlLCBcIiBpbiB0aGlzIHNjaGVtYVwiKSk7XG4gICAgICByZXR1cm4gdHlwZS5jcmVhdGUoanNvbi5hdHRycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhbWVTZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FtZVNldChhLCBiKSB7XG4gICAgICBpZiAoYSA9PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFhW2ldLmVxKGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb20obWFya3MpIHtcbiAgICAgIGlmICghbWFya3MgfHwgQXJyYXkuaXNBcnJheShtYXJrcykgJiYgbWFya3MubGVuZ3RoID09IDApIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICBpZiAobWFya3MgaW5zdGFuY2VvZiBNYXJrKSByZXR1cm4gW21hcmtzXTtcbiAgICAgIHZhciBjb3B5ID0gbWFya3Muc2xpY2UoKTtcbiAgICAgIGNvcHkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS50eXBlLnJhbmsgLSBiLnR5cGUucmFuaztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcms7XG59KCk7XG5cbk1hcmsubm9uZSA9IFtdO1xuXG52YXIgUmVwbGFjZUVycm9yID0gZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoUmVwbGFjZUVycm9yLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUmVwbGFjZUVycm9yKTtcblxuICBmdW5jdGlvbiBSZXBsYWNlRXJyb3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlcGxhY2VFcnJvcik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFJlcGxhY2VFcnJvcik7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxudmFyIFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpY2UpO1xuXG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB0aGlzLm9wZW5FbmQgPSBvcGVuRW5kO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNsaWNlLCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50LnNpemUgLSB0aGlzLm9wZW5TdGFydCAtIHRoaXMub3BlbkVuZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0QXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QXQocG9zLCBmcmFnbWVudCkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBpbnNlcnRJbnRvKHRoaXMuY29udGVudCwgcG9zICsgdGhpcy5vcGVuU3RhcnQsIGZyYWdtZW50KTtcbiAgICAgIHJldHVybiBjb250ZW50ICYmIG5ldyBTbGljZShjb250ZW50LCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQmV0d2VlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVCZXR3ZWVuKGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gbmV3IFNsaWNlKHJlbW92ZVJhbmdlKHRoaXMuY29udGVudCwgZnJvbSArIHRoaXMub3BlblN0YXJ0LCB0byArIHRoaXMub3BlblN0YXJ0KSwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpICYmIHRoaXMub3BlblN0YXJ0ID09IG90aGVyLm9wZW5TdGFydCAmJiB0aGlzLm9wZW5FbmQgPT0gb3RoZXIub3BlbkVuZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50ICsgXCIoXCIgKyB0aGlzLm9wZW5TdGFydCArIFwiLFwiICsgdGhpcy5vcGVuRW5kICsgXCIpXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudC5zaXplKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBqc29uID0ge1xuICAgICAgICBjb250ZW50OiB0aGlzLmNvbnRlbnQudG9KU09OKClcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPiAwKSBqc29uLm9wZW5TdGFydCA9IHRoaXMub3BlblN0YXJ0O1xuICAgICAgaWYgKHRoaXMub3BlbkVuZCA+IDApIGpzb24ub3BlbkVuZCA9IHRoaXMub3BlbkVuZDtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKCFqc29uKSByZXR1cm4gU2xpY2UuZW1wdHk7XG4gICAgICB2YXIgb3BlblN0YXJ0ID0ganNvbi5vcGVuU3RhcnQgfHwgMCxcbiAgICAgICAgICBvcGVuRW5kID0ganNvbi5vcGVuRW5kIHx8IDA7XG4gICAgICBpZiAodHlwZW9mIG9wZW5TdGFydCAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBvcGVuRW5kICE9IFwibnVtYmVyXCIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU2xpY2UuZnJvbUpTT05cIik7XG4gICAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF4T3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXhPcGVuKGZyYWdtZW50KSB7XG4gICAgICB2YXIgb3Blbklzb2xhdGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciBvcGVuU3RhcnQgPSAwLFxuICAgICAgICAgIG9wZW5FbmQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBuID0gZnJhZ21lbnQuZmlyc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9uID0gZnJhZ21lbnQubGFzdENoaWxkOyBfbiAmJiAhX24uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFfbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgX24gPSBfbi5sYXN0Q2hpbGQpIHtcbiAgICAgICAgb3BlbkVuZCsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFNsaWNlKGZyYWdtZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTbGljZTtcbn0oKTtcblxuU2xpY2UuZW1wdHkgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZW1wdHksIDAsIDApO1xuXG5mdW5jdGlvbiByZW1vdmVSYW5nZShjb250ZW50LCBmcm9tLCB0bykge1xuICB2YXIgX2NvbnRlbnQkZmluZEluZGV4ID0gY29udGVudC5maW5kSW5kZXgoZnJvbSksXG4gICAgICBpbmRleCA9IF9jb250ZW50JGZpbmRJbmRleC5pbmRleCxcbiAgICAgIG9mZnNldCA9IF9jb250ZW50JGZpbmRJbmRleC5vZmZzZXQsXG4gICAgICBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG5cbiAgdmFyIF9jb250ZW50JGZpbmRJbmRleDIgPSBjb250ZW50LmZpbmRJbmRleCh0byksXG4gICAgICBpbmRleFRvID0gX2NvbnRlbnQkZmluZEluZGV4Mi5pbmRleCxcbiAgICAgIG9mZnNldFRvID0gX2NvbnRlbnQkZmluZEluZGV4Mi5vZmZzZXQ7XG5cbiAgaWYgKG9mZnNldCA9PSBmcm9tIHx8IGNoaWxkLmlzVGV4dCkge1xuICAgIGlmIChvZmZzZXRUbyAhPSB0byAmJiAhY29udGVudC5jaGlsZChpbmRleFRvKS5pc1RleHQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGZyb20pLmFwcGVuZChjb250ZW50LmN1dCh0bykpO1xuICB9XG5cbiAgaWYgKGluZGV4ICE9IGluZGV4VG8pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gIHJldHVybiBjb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgY2hpbGQuY29weShyZW1vdmVSYW5nZShjaGlsZC5jb250ZW50LCBmcm9tIC0gb2Zmc2V0IC0gMSwgdG8gLSBvZmZzZXQgLSAxKSkpO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRJbnRvKGNvbnRlbnQsIGRpc3QsIGluc2VydCwgcGFyZW50KSB7XG4gIHZhciBfY29udGVudCRmaW5kSW5kZXgzID0gY29udGVudC5maW5kSW5kZXgoZGlzdCksXG4gICAgICBpbmRleCA9IF9jb250ZW50JGZpbmRJbmRleDMuaW5kZXgsXG4gICAgICBvZmZzZXQgPSBfY29udGVudCRmaW5kSW5kZXgzLm9mZnNldCxcbiAgICAgIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcblxuICBpZiAob2Zmc2V0ID09IGRpc3QgfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4LCBpbnNlcnQpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZGlzdCkuYXBwZW5kKGluc2VydCkuYXBwZW5kKGNvbnRlbnQuY3V0KGRpc3QpKTtcbiAgfVxuXG4gIHZhciBpbm5lciA9IGluc2VydEludG8oY2hpbGQuY29udGVudCwgZGlzdCAtIG9mZnNldCAtIDEsIGluc2VydCk7XG4gIHJldHVybiBpbm5lciAmJiBjb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgY2hpbGQuY29weShpbm5lcikpO1xufVxuXG5mdW5jdGlvbiBfcmVwbGFjZSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICBpZiAoc2xpY2Uub3BlblN0YXJ0ID4gJGZyb20uZGVwdGgpIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbnNlcnRlZCBjb250ZW50IGRlZXBlciB0aGFuIGluc2VydGlvbiBwb3NpdGlvblwiKTtcbiAgaWYgKCRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0ICE9ICR0by5kZXB0aCAtIHNsaWNlLm9wZW5FbmQpIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbmNvbnNpc3RlbnQgb3BlbiBkZXB0aHNcIik7XG4gIHJldHVybiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIDApO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoKSB7XG4gIHZhciBpbmRleCA9ICRmcm9tLmluZGV4KGRlcHRoKSxcbiAgICAgIG5vZGUgPSAkZnJvbS5ub2RlKGRlcHRoKTtcblxuICBpZiAoaW5kZXggPT0gJHRvLmluZGV4KGRlcHRoKSAmJiBkZXB0aCA8ICRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgdmFyIGlubmVyID0gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCArIDEpO1xuICAgIHJldHVybiBub2RlLmNvcHkobm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgaW5uZXIpKTtcbiAgfSBlbHNlIGlmICghc2xpY2UuY29udGVudC5zaXplKSB7XG4gICAgcmV0dXJuIGNsb3NlKG5vZGUsIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpKTtcbiAgfSBlbHNlIGlmICghc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLmRlcHRoID09IGRlcHRoICYmICR0by5kZXB0aCA9PSBkZXB0aCkge1xuICAgIHZhciBwYXJlbnQgPSAkZnJvbS5wYXJlbnQsXG4gICAgICAgIGNvbnRlbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICByZXR1cm4gY2xvc2UocGFyZW50LCBjb250ZW50LmN1dCgwLCAkZnJvbS5wYXJlbnRPZmZzZXQpLmFwcGVuZChzbGljZS5jb250ZW50KS5hcHBlbmQoY29udGVudC5jdXQoJHRvLnBhcmVudE9mZnNldCkpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3ByZXBhcmVTbGljZUZvclJlcGxhID0gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGZyb20pLFxuICAgICAgICBzdGFydCA9IF9wcmVwYXJlU2xpY2VGb3JSZXBsYS5zdGFydCxcbiAgICAgICAgZW5kID0gX3ByZXBhcmVTbGljZUZvclJlcGxhLmVuZDtcblxuICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVGhyZWVXYXkoJGZyb20sIHN0YXJ0LCBlbmQsICR0bywgZGVwdGgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0pvaW4obWFpbiwgc3ViKSB7XG4gIGlmICghc3ViLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobWFpbi50eXBlKSkgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkNhbm5vdCBqb2luIFwiICsgc3ViLnR5cGUubmFtZSArIFwiIG9udG8gXCIgKyBtYWluLnR5cGUubmFtZSk7XG59XG5cbmZ1bmN0aW9uIGpvaW5hYmxlKCRiZWZvcmUsICRhZnRlciwgZGVwdGgpIHtcbiAgdmFyIG5vZGUgPSAkYmVmb3JlLm5vZGUoZGVwdGgpO1xuICBjaGVja0pvaW4obm9kZSwgJGFmdGVyLm5vZGUoZGVwdGgpKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGFkZE5vZGUoY2hpbGQsIHRhcmdldCkge1xuICB2YXIgbGFzdCA9IHRhcmdldC5sZW5ndGggLSAxO1xuICBpZiAobGFzdCA+PSAwICYmIGNoaWxkLmlzVGV4dCAmJiBjaGlsZC5zYW1lTWFya3VwKHRhcmdldFtsYXN0XSkpIHRhcmdldFtsYXN0XSA9IGNoaWxkLndpdGhUZXh0KHRhcmdldFtsYXN0XS50ZXh0ICsgY2hpbGQudGV4dCk7ZWxzZSB0YXJnZXQucHVzaChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFkZFJhbmdlKCRzdGFydCwgJGVuZCwgZGVwdGgsIHRhcmdldCkge1xuICB2YXIgbm9kZSA9ICgkZW5kIHx8ICRzdGFydCkubm9kZShkZXB0aCk7XG4gIHZhciBzdGFydEluZGV4ID0gMCxcbiAgICAgIGVuZEluZGV4ID0gJGVuZCA/ICRlbmQuaW5kZXgoZGVwdGgpIDogbm9kZS5jaGlsZENvdW50O1xuXG4gIGlmICgkc3RhcnQpIHtcbiAgICBzdGFydEluZGV4ID0gJHN0YXJ0LmluZGV4KGRlcHRoKTtcblxuICAgIGlmICgkc3RhcnQuZGVwdGggPiBkZXB0aCkge1xuICAgICAgc3RhcnRJbmRleCsrO1xuICAgIH0gZWxzZSBpZiAoJHN0YXJ0LnRleHRPZmZzZXQpIHtcbiAgICAgIGFkZE5vZGUoJHN0YXJ0Lm5vZGVBZnRlciwgdGFyZ2V0KTtcbiAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICBhZGROb2RlKG5vZGUuY2hpbGQoaSksIHRhcmdldCk7XG4gIH1cblxuICBpZiAoJGVuZCAmJiAkZW5kLmRlcHRoID09IGRlcHRoICYmICRlbmQudGV4dE9mZnNldCkgYWRkTm9kZSgkZW5kLm5vZGVCZWZvcmUsIHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGNsb3NlKG5vZGUsIGNvbnRlbnQpIHtcbiAgaWYgKCFub2RlLnR5cGUudmFsaWRDb250ZW50KGNvbnRlbnQpKSB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIFwiICsgbm9kZS50eXBlLm5hbWUpO1xuICByZXR1cm4gbm9kZS5jb3B5KGNvbnRlbnQpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCkge1xuICB2YXIgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpO1xuICB2YXIgb3BlbkVuZCA9ICR0by5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRlbmQsICR0bywgZGVwdGggKyAxKTtcbiAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcblxuICBpZiAob3BlblN0YXJ0ICYmIG9wZW5FbmQgJiYgJHN0YXJ0LmluZGV4KGRlcHRoKSA9PSAkZW5kLmluZGV4KGRlcHRoKSkge1xuICAgIGNoZWNrSm9pbihvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wZW5TdGFydCkgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUd29XYXkoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIGFkZFJhbmdlKCRzdGFydCwgJGVuZCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmIChvcGVuRW5kKSBhZGROb2RlKGNsb3NlKG9wZW5FbmQsIHJlcGxhY2VUd29XYXkoJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gIH1cblxuICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkge1xuICB2YXIgY29udGVudCA9IFtdO1xuICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuXG4gIGlmICgkZnJvbS5kZXB0aCA+IGRlcHRoKSB7XG4gICAgdmFyIHR5cGUgPSBqb2luYWJsZSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpO1xuICAgIGFkZE5vZGUoY2xvc2UodHlwZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gIH1cblxuICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGFsb25nKSB7XG4gIHZhciBleHRyYSA9ICRhbG9uZy5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCxcbiAgICAgIHBhcmVudCA9ICRhbG9uZy5ub2RlKGV4dHJhKTtcbiAgdmFyIG5vZGUgPSBwYXJlbnQuY29weShzbGljZS5jb250ZW50KTtcblxuICBmb3IgKHZhciBpID0gZXh0cmEgLSAxOyBpID49IDA7IGktLSkge1xuICAgIG5vZGUgPSAkYWxvbmcubm9kZShpKS5jb3B5KEZyYWdtZW50LmZyb20obm9kZSkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogbm9kZS5yZXNvbHZlTm9DYWNoZShzbGljZS5vcGVuU3RhcnQgKyBleHRyYSksXG4gICAgZW5kOiBub2RlLnJlc29sdmVOb0NhY2hlKG5vZGUuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCAtIGV4dHJhKVxuICB9O1xufVxuXG52YXIgUmVzb2x2ZWRQb3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlc29sdmVkUG9zKHBvcywgcGF0aCwgcGFyZW50T2Zmc2V0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc29sdmVkUG9zKTtcblxuICAgIHRoaXMucG9zID0gcG9zO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5wYXJlbnRPZmZzZXQgPSBwYXJlbnRPZmZzZXQ7XG4gICAgdGhpcy5kZXB0aCA9IHBhdGgubGVuZ3RoIC8gMyAtIDE7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVzb2x2ZWRQb3MsIFt7XG4gICAga2V5OiBcInJlc29sdmVEZXB0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlRGVwdGgodmFsKSB7XG4gICAgICBpZiAodmFsID09IG51bGwpIHJldHVybiB0aGlzLmRlcHRoO1xuICAgICAgaWYgKHZhbCA8IDApIHJldHVybiB0aGlzLmRlcHRoICsgdmFsO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyZW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKHRoaXMuZGVwdGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb2NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUoMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZShkZXB0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXgoZGVwdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogMyArIDFdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmRleEFmdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4QWZ0ZXIoZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXgoZGVwdGgpICsgKGRlcHRoID09IHRoaXMuZGVwdGggJiYgIXRoaXMudGV4dE9mZnNldCA/IDAgOiAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgcmV0dXJuIGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZChkZXB0aCkge1xuICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydChkZXB0aCkgKyB0aGlzLm5vZGUoZGVwdGgpLmNvbnRlbnQuc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZShkZXB0aCkge1xuICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICBpZiAoIWRlcHRoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIHBvc2l0aW9uIGJlZm9yZSB0aGUgdG9wLWxldmVsIG5vZGVcIik7XG4gICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWZ0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWZ0ZXIoZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgaWYgKCFkZXB0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBhZnRlciB0aGUgdG9wLWxldmVsIG5vZGVcIik7XG4gICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIHRoaXMucGF0aFtkZXB0aCAqIDNdLm5vZGVTaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0T2Zmc2V0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2RlQWZ0ZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaW5kZXgpO1xuICAgICAgcmV0dXJuIGRPZmYgPyBwYXJlbnQuY2hpbGQoaW5kZXgpLmN1dChkT2ZmKSA6IGNoaWxkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2RlQmVmb3JlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgdmFyIGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoZE9mZikgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkKGluZGV4KS5jdXQoMCwgZE9mZik7XG4gICAgICByZXR1cm4gaW5kZXggPT0gMCA/IG51bGwgOiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3NBdEluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc0F0SW5kZXgoaW5kZXgsIGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5wYXRoW2RlcHRoICogM10sXG4gICAgICAgICAgcG9zID0gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgcG9zICs9IG5vZGUuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtzKCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleCgpO1xuICAgICAgaWYgKHBhcmVudC5jb250ZW50LnNpemUgPT0gMCkgcmV0dXJuIE1hcmsubm9uZTtcbiAgICAgIGlmICh0aGlzLnRleHRPZmZzZXQpIHJldHVybiBwYXJlbnQuY2hpbGQoaW5kZXgpLm1hcmtzO1xuICAgICAgdmFyIG1haW4gPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCAtIDEpLFxuICAgICAgICAgIG90aGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuXG4gICAgICBpZiAoIW1haW4pIHtcbiAgICAgICAgdmFyIHRtcCA9IG1haW47XG4gICAgICAgIG1haW4gPSBvdGhlcjtcbiAgICAgICAgb3RoZXIgPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXJrcyA9IG1haW4ubWFya3M7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghb3RoZXIgfHwgIW1hcmtzW2ldLmlzSW5TZXQob3RoZXIubWFya3MpKSkgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtzQWNyb3NzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtzQWNyb3NzKCRlbmQpIHtcbiAgICAgIHZhciBhZnRlciA9IHRoaXMucGFyZW50Lm1heWJlQ2hpbGQodGhpcy5pbmRleCgpKTtcbiAgICAgIGlmICghYWZ0ZXIgfHwgIWFmdGVyLmlzSW5saW5lKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBtYXJrcyA9IGFmdGVyLm1hcmtzLFxuICAgICAgICAgIG5leHQgPSAkZW5kLnBhcmVudC5tYXliZUNoaWxkKCRlbmQuaW5kZXgoKSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghbmV4dCB8fCAhbWFya3NbaV0uaXNJblNldChuZXh0Lm1hcmtzKSkpIG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGFyZWREZXB0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGFyZWREZXB0aChwb3MpIHtcbiAgICAgIGZvciAodmFyIGRlcHRoID0gdGhpcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aC0tKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0KGRlcHRoKSA8PSBwb3MgJiYgdGhpcy5lbmQoZGVwdGgpID49IHBvcykgcmV0dXJuIGRlcHRoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmxvY2tSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBibG9ja1JhbmdlKCkge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzO1xuICAgICAgdmFyIHByZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChvdGhlci5wb3MgPCB0aGlzLnBvcykgcmV0dXJuIG90aGVyLmJsb2NrUmFuZ2UodGhpcyk7XG5cbiAgICAgIGZvciAodmFyIGQgPSB0aGlzLmRlcHRoIC0gKHRoaXMucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdGhpcy5wb3MgPT0gb3RoZXIucG9zID8gMSA6IDApOyBkID49IDA7IGQtLSkge1xuICAgICAgICBpZiAob3RoZXIucG9zIDw9IHRoaXMuZW5kKGQpICYmICghcHJlZCB8fCBwcmVkKHRoaXMubm9kZShkKSkpKSByZXR1cm4gbmV3IE5vZGVSYW5nZSh0aGlzLCBvdGhlciwgZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzYW1lUGFyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhbWVQYXJlbnQob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGFyZW50T2Zmc2V0ID09IG90aGVyLnBvcyAtIG90aGVyLnBhcmVudE9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heChvdGhlcikge1xuICAgICAgcmV0dXJuIG90aGVyLnBvcyA+IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIucG9zIDwgdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHN0ciA9IFwiXCI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHRoaXMuZGVwdGg7IGkrKykge1xuICAgICAgICBzdHIgKz0gKHN0ciA/IFwiL1wiIDogXCJcIikgKyB0aGlzLm5vZGUoaSkudHlwZS5uYW1lICsgXCJfXCIgKyB0aGlzLmluZGV4KGkgLSAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ciArIFwiOlwiICsgdGhpcy5wYXJlbnRPZmZzZXQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKGRvYywgcG9zKSB7XG4gICAgICBpZiAoIShwb3MgPj0gMCAmJiBwb3MgPD0gZG9jLmNvbnRlbnQuc2l6ZSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUG9zaXRpb24gXCIgKyBwb3MgKyBcIiBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgdmFyIHN0YXJ0ID0gMCxcbiAgICAgICAgICBwYXJlbnRPZmZzZXQgPSBwb3M7XG5cbiAgICAgIGZvciAodmFyIG5vZGUgPSBkb2M7Oykge1xuICAgICAgICB2YXIgX25vZGUkY29udGVudCRmaW5kSW5kID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwYXJlbnRPZmZzZXQpLFxuICAgICAgICAgICAgaW5kZXggPSBfbm9kZSRjb250ZW50JGZpbmRJbmQuaW5kZXgsXG4gICAgICAgICAgICBvZmZzZXQgPSBfbm9kZSRjb250ZW50JGZpbmRJbmQub2Zmc2V0O1xuXG4gICAgICAgIHZhciByZW0gPSBwYXJlbnRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgICAgIHBhdGgucHVzaChub2RlLCBpbmRleCwgc3RhcnQgKyBvZmZzZXQpO1xuICAgICAgICBpZiAoIXJlbSkgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkKGluZGV4KTtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSBicmVhaztcbiAgICAgICAgcGFyZW50T2Zmc2V0ID0gcmVtIC0gMTtcbiAgICAgICAgc3RhcnQgKz0gb2Zmc2V0ICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFBvcyhwb3MsIHBhdGgsIHBhcmVudE9mZnNldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVDYWNoZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZUNhY2hlZChkb2MsIHBvcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlQ2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHJlc29sdmVDYWNoZVtpXTtcbiAgICAgICAgaWYgKGNhY2hlZC5wb3MgPT0gcG9zICYmIGNhY2hlZC5kb2MgPT0gZG9jKSByZXR1cm4gY2FjaGVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUNhY2hlW3Jlc29sdmVDYWNoZVBvc10gPSBSZXNvbHZlZFBvcy5yZXNvbHZlKGRvYywgcG9zKTtcbiAgICAgIHJlc29sdmVDYWNoZVBvcyA9IChyZXNvbHZlQ2FjaGVQb3MgKyAxKSAlIHJlc29sdmVDYWNoZVNpemU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXNvbHZlZFBvcztcbn0oKTtcblxudmFyIHJlc29sdmVDYWNoZSA9IFtdLFxuICAgIHJlc29sdmVDYWNoZVBvcyA9IDAsXG4gICAgcmVzb2x2ZUNhY2hlU2l6ZSA9IDEyO1xuXG52YXIgTm9kZVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlUmFuZ2UoJGZyb20sICR0bywgZGVwdGgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZVJhbmdlKTtcblxuICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICB0aGlzLiR0byA9ICR0bztcbiAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm9kZVJhbmdlLCBbe1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGZyb20uYmVmb3JlKHRoaXMuZGVwdGggKyAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kdG8uYWZ0ZXIodGhpcy5kZXB0aCArIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJlbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRmcm9tLm5vZGUodGhpcy5kZXB0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0SW5kZXhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRmcm9tLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRJbmRleFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHRvLmluZGV4QWZ0ZXIodGhpcy5kZXB0aCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVSYW5nZTtcbn0oKTtcblxudmFyIGVtcHR5QXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG52YXIgTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9kZSh0eXBlLCBhdHRycywgY29udGVudCkge1xuICAgIHZhciBtYXJrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogTWFyay5ub25lO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGUpO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQgfHwgRnJhZ21lbnQuZW1wdHk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm9kZSwgW3tcbiAgICBrZXk6IFwibm9kZVNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzTGVhZiA/IDEgOiAyICsgdGhpcy5jb250ZW50LnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoaWxkQ291bnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGRDb3VudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hpbGQoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXliZUNoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heWJlQ2hpbGQoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChmKSB7XG4gICAgICB0aGlzLmNvbnRlbnQuZm9yRWFjaChmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZXNCZXR3ZWVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZikge1xuICAgICAgdmFyIHN0YXJ0UG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgdGhpcy5jb250ZW50Lm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgc3RhcnRQb3MsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXNjZW5kYW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNjZW5kYW50cyhmKSB7XG4gICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgZik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRDb250ZW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0xlYWYgJiYgdGhpcy50eXBlLnNwZWMubGVhZlRleHQgPyB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dCh0aGlzKSA6IHRoaXMudGV4dEJldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIFwiXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0QmV0d2VlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50LnRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdENoaWxkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhc3RDaGlsZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2FtZU1hcmt1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYW1lTWFya3VwKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNNYXJrdXAob3RoZXIudHlwZSwgb3RoZXIuYXR0cnMsIG90aGVyLm1hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzTWFya3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc01hcmt1cCh0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZSAmJiBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBhdHRycyB8fCB0eXBlLmRlZmF1bHRBdHRycyB8fCBlbXB0eUF0dHJzKSAmJiBNYXJrLnNhbWVTZXQodGhpcy5tYXJrcywgbWFya3MgfHwgTWFyay5ub25lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KCkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICBpZiAoY29udGVudCA9PSB0aGlzLmNvbnRlbnQpIHJldHVybiB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFyayhtYXJrcykge1xuICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0aGlzLmNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1dChmcm9tKSB7XG4gICAgICB2YXIgdG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuY29udGVudC5zaXplO1xuICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQuc2l6ZSkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5jb3B5KHRoaXMuY29udGVudC5jdXQoZnJvbSwgdG8pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2xpY2UoZnJvbSkge1xuICAgICAgdmFyIHRvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmNvbnRlbnQuc2l6ZTtcbiAgICAgIHZhciBpbmNsdWRlUGFyZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICBpZiAoZnJvbSA9PSB0bykgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgdmFyICRmcm9tID0gdGhpcy5yZXNvbHZlKGZyb20pLFxuICAgICAgICAgICR0byA9IHRoaXMucmVzb2x2ZSh0byk7XG4gICAgICB2YXIgZGVwdGggPSBpbmNsdWRlUGFyZW50cyA/IDAgOiAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgICB2YXIgc3RhcnQgPSAkZnJvbS5zdGFydChkZXB0aCksXG4gICAgICAgICAgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgdmFyIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQuY3V0KCRmcm9tLnBvcyAtIHN0YXJ0LCAkdG8ucG9zIC0gc3RhcnQpO1xuICAgICAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCAkZnJvbS5kZXB0aCAtIGRlcHRoLCAkdG8uZGVwdGggLSBkZXB0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZShmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgIHJldHVybiBfcmVwbGFjZSh0aGlzLnJlc29sdmUoZnJvbSksIHRoaXMucmVzb2x2ZSh0byksIHNsaWNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZUF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vZGVBdChwb3MpIHtcbiAgICAgIGZvciAodmFyIG5vZGUgPSB0aGlzOzspIHtcbiAgICAgICAgdmFyIF9ub2RlJGNvbnRlbnQkZmluZEluZDIgPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBvcyksXG4gICAgICAgICAgICBpbmRleCA9IF9ub2RlJGNvbnRlbnQkZmluZEluZDIuaW5kZXgsXG4gICAgICAgICAgICBvZmZzZXQgPSBfbm9kZSRjb250ZW50JGZpbmRJbmQyLm9mZnNldDtcblxuICAgICAgICBub2RlID0gbm9kZS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG9mZnNldCA9PSBwb3MgfHwgbm9kZS5pc1RleHQpIHJldHVybiBub2RlO1xuICAgICAgICBwb3MgLT0gb2Zmc2V0ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRBZnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGlsZEFmdGVyKHBvcykge1xuICAgICAgdmFyIF90aGlzJGNvbnRlbnQkZmluZEluZCA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKSxcbiAgICAgICAgICBpbmRleCA9IF90aGlzJGNvbnRlbnQkZmluZEluZC5pbmRleCxcbiAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRjb250ZW50JGZpbmRJbmQub2Zmc2V0O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiB0aGlzLmNvbnRlbnQubWF5YmVDaGlsZChpbmRleCksXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoaWxkQmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoaWxkQmVmb3JlKHBvcykge1xuICAgICAgaWYgKHBvcyA9PSAwKSByZXR1cm4ge1xuICAgICAgICBub2RlOiBudWxsLFxuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9O1xuXG4gICAgICB2YXIgX3RoaXMkY29udGVudCRmaW5kSW5kMiA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKSxcbiAgICAgICAgICBpbmRleCA9IF90aGlzJGNvbnRlbnQkZmluZEluZDIuaW5kZXgsXG4gICAgICAgICAgb2Zmc2V0ID0gX3RoaXMkY29udGVudCRmaW5kSW5kMi5vZmZzZXQ7XG5cbiAgICAgIGlmIChvZmZzZXQgPCBwb3MpIHJldHVybiB7XG4gICAgICAgIG5vZGU6IHRoaXMuY29udGVudC5jaGlsZChpbmRleCksXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgIH07XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuY29udGVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgaW5kZXg6IGluZGV4IC0gMSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlLm5vZGVTaXplXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUocG9zKSB7XG4gICAgICByZXR1cm4gUmVzb2x2ZWRQb3MucmVzb2x2ZUNhY2hlZCh0aGlzLCBwb3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlTm9DYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlTm9DYWNoZShwb3MpIHtcbiAgICAgIHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlKHRoaXMsIHBvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhbmdlSGFzTWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYW5nZUhhc01hcmsoZnJvbSwgdG8sIHR5cGUpIHtcbiAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgaWYgKHRvID4gZnJvbSkgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICh0eXBlLmlzSW5TZXQobm9kZS5tYXJrcykpIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICFmb3VuZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0Jsb2NrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLmlzQmxvY2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVGV4dGJsb2NrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLmlzVGV4dGJsb2NrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmxpbmVDb250ZW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW5saW5lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLmlzSW5saW5lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1RleHRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaXNUZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0xlYWZcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaXNMZWFmO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0F0b21cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaXNBdG9tO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKSByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgIHZhciBuYW1lID0gdGhpcy50eXBlLm5hbWU7XG4gICAgICBpZiAodGhpcy5jb250ZW50LnNpemUpIG5hbWUgKz0gXCIoXCIgKyB0aGlzLmNvbnRlbnQudG9TdHJpbmdJbm5lcigpICsgXCIpXCI7XG4gICAgICByZXR1cm4gd3JhcE1hcmtzKHRoaXMubWFya3MsIG5hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb250ZW50TWF0Y2hBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250ZW50TWF0Y2hBdChpbmRleCkge1xuICAgICAgdmFyIG1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgMCwgaW5kZXgpO1xuICAgICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIGNvbnRlbnRNYXRjaEF0IG9uIGEgbm9kZSB3aXRoIGludmFsaWQgY29udGVudFwiKTtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuUmVwbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5SZXBsYWNlKGZyb20sIHRvKSB7XG4gICAgICB2YXIgcmVwbGFjZW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IEZyYWdtZW50LmVtcHR5O1xuICAgICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogcmVwbGFjZW1lbnQuY2hpbGRDb3VudDtcbiAgICAgIHZhciBvbmUgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoRnJhZ21lbnQocmVwbGFjZW1lbnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgdmFyIHR3byA9IG9uZSAmJiBvbmUubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIHRvKTtcbiAgICAgIGlmICghdHdvIHx8ICF0d28udmFsaWRFbmQpIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUuYWxsb3dzTWFya3MocmVwbGFjZW1lbnQuY2hpbGQoaSkubWFya3MpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5SZXBsYWNlV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5SZXBsYWNlV2l0aChmcm9tLCB0bywgdHlwZSwgbWFya3MpIHtcbiAgICAgIGlmIChtYXJrcyAmJiAhdGhpcy50eXBlLmFsbG93c01hcmtzKG1hcmtzKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5jb250ZW50TWF0Y2hBdChmcm9tKS5tYXRjaFR5cGUodHlwZSk7XG4gICAgICB2YXIgZW5kID0gc3RhcnQgJiYgc3RhcnQubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIHRvKTtcbiAgICAgIHJldHVybiBlbmQgPyBlbmQudmFsaWRFbmQgOiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuQXBwZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkFwcGVuZChvdGhlcikge1xuICAgICAgaWYgKG90aGVyLmNvbnRlbnQuc2l6ZSkgcmV0dXJuIHRoaXMuY2FuUmVwbGFjZSh0aGlzLmNoaWxkQ291bnQsIHRoaXMuY2hpbGRDb3VudCwgb3RoZXIuY29udGVudCk7ZWxzZSByZXR1cm4gdGhpcy50eXBlLmNvbXBhdGlibGVDb250ZW50KG90aGVyLnR5cGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGVja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVjaygpIHtcbiAgICAgIGlmICghdGhpcy50eXBlLnZhbGlkQ29udGVudCh0aGlzLmNvbnRlbnQpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY29udGVudCBmb3Igbm9kZSBcIi5jb25jYXQodGhpcy50eXBlLm5hbWUsIFwiOiBcIikuY29uY2F0KHRoaXMuY29udGVudC50b1N0cmluZygpLnNsaWNlKDAsIDUwKSkpO1xuICAgICAgdmFyIGNvcHkgPSBNYXJrLm5vbmU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb3B5ID0gdGhpcy5tYXJrc1tpXS5hZGRUb1NldChjb3B5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFNYXJrLnNhbWVTZXQoY29weSwgdGhpcy5tYXJrcykpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb2xsZWN0aW9uIG9mIG1hcmtzIGZvciBub2RlIFwiLmNvbmNhdCh0aGlzLnR5cGUubmFtZSwgXCI6IFwiKS5jb25jYXQodGhpcy5tYXJrcy5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIG0udHlwZS5uYW1lO1xuICAgICAgfSkpKTtcbiAgICAgIHRoaXMuY29udGVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmNoZWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHZhciBvYmogPSB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZS5uYW1lXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSkgb2JqLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQudG9KU09OKCk7XG4gICAgICBpZiAodGhpcy5tYXJrcy5sZW5ndGgpIG9iai5tYXJrcyA9IHRoaXMubWFya3MubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuLnRvSlNPTigpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKCFqc29uKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICB2YXIgbWFya3MgPSBudWxsO1xuXG4gICAgICBpZiAoanNvbi5tYXJrcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbi5tYXJrcykpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtYXJrIGRhdGEgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICAgIG1hcmtzID0ganNvbi5tYXJrcy5tYXAoc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICB9XG5cbiAgICAgIGlmIChqc29uLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnRleHQgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRleHQgbm9kZSBpbiBKU09OXCIpO1xuICAgICAgICByZXR1cm4gc2NoZW1hLnRleHQoanNvbi50ZXh0LCBtYXJrcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZW50ID0gRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpO1xuICAgICAgcmV0dXJuIHNjaGVtYS5ub2RlVHlwZShqc29uLnR5cGUpLmNyZWF0ZShqc29uLmF0dHJzLCBjb250ZW50LCBtYXJrcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGU7XG59KCk7XG5cbk5vZGUucHJvdG90eXBlLnRleHQgPSB1bmRlZmluZWQ7XG5cbnZhciBUZXh0Tm9kZSA9IGZ1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHMoVGV4dE5vZGUsIF9Ob2RlKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihUZXh0Tm9kZSk7XG5cbiAgZnVuY3Rpb24gVGV4dE5vZGUodHlwZSwgYXR0cnMsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHROb2RlKTtcblxuICAgIF90aGlzID0gX3N1cGVyMi5jYWxsKHRoaXMsIHR5cGUsIGF0dHJzLCBudWxsLCBtYXJrcyk7XG4gICAgaWYgKCFjb250ZW50KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdCBhbGxvd2VkXCIpO1xuICAgIF90aGlzLnRleHQgPSBjb250ZW50O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUZXh0Tm9kZSwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZykgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICByZXR1cm4gd3JhcE1hcmtzKHRoaXMubWFya3MsIEpTT04uc3RyaW5naWZ5KHRoaXMudGV4dCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0Q29udGVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dEJldHdlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dEJldHdlZW4oZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2RlU2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFyayhtYXJrcykge1xuICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy50ZXh0LCBtYXJrcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhUZXh0KHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09IHRoaXMudGV4dCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGV4dCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXQoKSB7XG4gICAgICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy50ZXh0Lmxlbmd0aCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy53aXRoVGV4dCh0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMudGV4dCA9PSBvdGhlci50ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIGJhc2UgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihUZXh0Tm9kZS5wcm90b3R5cGUpLCBcInRvSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBiYXNlLnRleHQgPSB0aGlzLnRleHQ7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dE5vZGU7XG59KE5vZGUpO1xuXG5mdW5jdGlvbiB3cmFwTWFya3MobWFya3MsIHN0cikge1xuICBmb3IgKHZhciBpID0gbWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBzdHIgPSBtYXJrc1tpXS50eXBlLm5hbWUgKyBcIihcIiArIHN0ciArIFwiKVwiO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIENvbnRlbnRNYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29udGVudE1hdGNoKHZhbGlkRW5kKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRlbnRNYXRjaCk7XG5cbiAgICB0aGlzLnZhbGlkRW5kID0gdmFsaWRFbmQ7XG4gICAgdGhpcy5uZXh0ID0gW107XG4gICAgdGhpcy53cmFwQ2FjaGUgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb250ZW50TWF0Y2gsIFt7XG4gICAga2V5OiBcIm1hdGNoVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaFR5cGUodHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dFtpXS50eXBlID09IHR5cGUpIHJldHVybiB0aGlzLm5leHRbaV0ubmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoRnJhZ21lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hGcmFnbWVudChmcmFnKSB7XG4gICAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmcmFnLmNoaWxkQ291bnQ7XG4gICAgICB2YXIgY3VyID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBjdXIgJiYgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGN1ciA9IGN1ci5tYXRjaFR5cGUoZnJhZy5jaGlsZChpKS50eXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5saW5lQ29udGVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGggJiYgdGhpcy5uZXh0WzBdLnR5cGUuaXNJbmxpbmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRUeXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMubmV4dFtpXS50eXBlO1xuICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpIHJldHVybiB0eXBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGF0aWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXRpYmxlKG90aGVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG90aGVyLm5leHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gb3RoZXIubmV4dFtqXS50eXBlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbGxCZWZvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbEJlZm9yZShhZnRlcikge1xuICAgICAgdmFyIHRvRW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgdmFyIHNlZW4gPSBbdGhpc107XG5cbiAgICAgIGZ1bmN0aW9uIHNlYXJjaChtYXRjaCwgdHlwZXMpIHtcbiAgICAgICAgdmFyIGZpbmlzaGVkID0gbWF0Y2gubWF0Y2hGcmFnbWVudChhZnRlciwgc3RhcnRJbmRleCk7XG4gICAgICAgIGlmIChmaW5pc2hlZCAmJiAoIXRvRW5kIHx8IGZpbmlzaGVkLnZhbGlkRW5kKSkgcmV0dXJuIEZyYWdtZW50LmZyb20odHlwZXMubWFwKGZ1bmN0aW9uICh0cCkge1xuICAgICAgICAgIHJldHVybiB0cC5jcmVhdGVBbmRGaWxsKCk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX21hdGNoJG5leHQkaSA9IG1hdGNoLm5leHRbaV0sXG4gICAgICAgICAgICAgIHR5cGUgPSBfbWF0Y2gkbmV4dCRpLnR5cGUsXG4gICAgICAgICAgICAgIG5leHQgPSBfbWF0Y2gkbmV4dCRpLm5leHQ7XG5cbiAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgJiYgc2Vlbi5pbmRleE9mKG5leHQpID09IC0xKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2gobmV4dCk7XG5cbiAgICAgICAgICAgIHZhciBfZm91bmQgPSBzZWFyY2gobmV4dCwgdHlwZXMuY29uY2F0KHR5cGUpKTtcblxuICAgICAgICAgICAgaWYgKF9mb3VuZCkgcmV0dXJuIF9mb3VuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlYXJjaCh0aGlzLCBbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRXcmFwcGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud3JhcENhY2hlLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBDYWNoZVtpXSA9PSB0YXJnZXQpIHJldHVybiB0aGlzLndyYXBDYWNoZVtpICsgMV07XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wdXRlZCA9IHRoaXMuY29tcHV0ZVdyYXBwaW5nKHRhcmdldCk7XG4gICAgICB0aGlzLndyYXBDYWNoZS5wdXNoKHRhcmdldCwgY29tcHV0ZWQpO1xuICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wdXRlV3JhcHBpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZVdyYXBwaW5nKHRhcmdldCkge1xuICAgICAgdmFyIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgIGFjdGl2ZSA9IFt7XG4gICAgICAgIG1hdGNoOiB0aGlzLFxuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICB2aWE6IG51bGxcbiAgICAgIH1dO1xuXG4gICAgICB3aGlsZSAoYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGFjdGl2ZS5zaGlmdCgpLFxuICAgICAgICAgICAgbWF0Y2ggPSBjdXJyZW50Lm1hdGNoO1xuXG4gICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUodGFyZ2V0KSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIG9iaiA9IGN1cnJlbnQ7IG9iai50eXBlOyBvYmogPSBvYmoudmlhKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChvYmoudHlwZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXZlcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX21hdGNoJG5leHQkaTIgPSBtYXRjaC5uZXh0W2ldLFxuICAgICAgICAgICAgICB0eXBlID0gX21hdGNoJG5leHQkaTIudHlwZSxcbiAgICAgICAgICAgICAgbmV4dCA9IF9tYXRjaCRuZXh0JGkyLm5leHQ7XG5cbiAgICAgICAgICBpZiAoIXR5cGUuaXNMZWFmICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSAmJiAhKHR5cGUubmFtZSBpbiBzZWVuKSAmJiAoIWN1cnJlbnQudHlwZSB8fCBuZXh0LnZhbGlkRW5kKSkge1xuICAgICAgICAgICAgYWN0aXZlLnB1c2goe1xuICAgICAgICAgICAgICBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2gsXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIHZpYTogY3VycmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWVuW3R5cGUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWRnZUNvdW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0Lmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlZGdlKG4pIHtcbiAgICAgIGlmIChuID49IHRoaXMubmV4dC5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUncyBubyBcIi5jb25jYXQobiwgXCJ0aCBlZGdlIGluIHRoaXMgY29udGVudCBtYXRjaFwiKSk7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0W25dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBzZWVuID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIHNjYW4obSkge1xuICAgICAgICBzZWVuLnB1c2gobSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG0ubmV4dFtpXS5uZXh0KSA9PSAtMSkgc2NhbihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2Nhbih0aGlzKTtcbiAgICAgIHJldHVybiBzZWVuLm1hcChmdW5jdGlvbiAobSwgaSkge1xuICAgICAgICB2YXIgb3V0ID0gaSArIChtLnZhbGlkRW5kID8gXCIqXCIgOiBcIiBcIikgKyBcIiBcIjtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbS5uZXh0Lmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIG91dCArPSAoX2kgPyBcIiwgXCIgOiBcIlwiKSArIG0ubmV4dFtfaV0udHlwZS5uYW1lICsgXCItPlwiICsgc2Vlbi5pbmRleE9mKG0ubmV4dFtfaV0ubmV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgdmFyIHN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcyk7XG4gICAgICBpZiAoc3RyZWFtLm5leHQgPT0gbnVsbCkgcmV0dXJuIENvbnRlbnRNYXRjaC5lbXB0eTtcbiAgICAgIHZhciBleHByID0gcGFyc2VFeHByKHN0cmVhbSk7XG4gICAgICBpZiAoc3RyZWFtLm5leHQpIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRyYWlsaW5nIHRleHRcIik7XG4gICAgICB2YXIgbWF0Y2ggPSBkZmEobmZhKGV4cHIpKTtcbiAgICAgIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSk7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbnRlbnRNYXRjaDtcbn0oKTtcblxuQ29udGVudE1hdGNoLmVtcHR5ID0gbmV3IENvbnRlbnRNYXRjaCh0cnVlKTtcblxudmFyIFRva2VuU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb2tlblN0cmVhbSk7XG5cbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLm5vZGVUeXBlcyA9IG5vZGVUeXBlcztcbiAgICB0aGlzLmlubGluZSA9IG51bGw7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMudG9rZW5zID0gc3RyaW5nLnNwbGl0KC9cXHMqKD89XFxifFxcV3wkKS8pO1xuICAgIGlmICh0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXSA9PSBcIlwiKSB0aGlzLnRva2Vucy5wb3AoKTtcbiAgICBpZiAodGhpcy50b2tlbnNbMF0gPT0gXCJcIikgdGhpcy50b2tlbnMuc2hpZnQoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUb2tlblN0cmVhbSwgW3tcbiAgICBrZXk6IFwibmV4dFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhdCh0b2spIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHQgPT0gdG9rICYmICh0aGlzLnBvcysrIHx8IHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcnJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyKHN0cikge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN0ciArIFwiIChpbiBjb250ZW50IGV4cHJlc3Npb24gJ1wiICsgdGhpcy5zdHJpbmcgKyBcIicpXCIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUb2tlblN0cmVhbTtcbn0oKTtcblxuZnVuY3Rpb24gcGFyc2VFeHByKHN0cmVhbSkge1xuICB2YXIgZXhwcnMgPSBbXTtcblxuICBkbyB7XG4gICAgZXhwcnMucHVzaChwYXJzZUV4cHJTZXEoc3RyZWFtKSk7XG4gIH0gd2hpbGUgKHN0cmVhbS5lYXQoXCJ8XCIpKTtcblxuICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHtcbiAgICB0eXBlOiBcImNob2ljZVwiLFxuICAgIGV4cHJzOiBleHByc1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUV4cHJTZXEoc3RyZWFtKSB7XG4gIHZhciBleHBycyA9IFtdO1xuXG4gIGRvIHtcbiAgICBleHBycy5wdXNoKHBhcnNlRXhwclN1YnNjcmlwdChzdHJlYW0pKTtcbiAgfSB3aGlsZSAoc3RyZWFtLm5leHQgJiYgc3RyZWFtLm5leHQgIT0gXCIpXCIgJiYgc3RyZWFtLm5leHQgIT0gXCJ8XCIpO1xuXG4gIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDoge1xuICAgIHR5cGU6IFwic2VxXCIsXG4gICAgZXhwcnM6IGV4cHJzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXhwclN1YnNjcmlwdChzdHJlYW0pIHtcbiAgdmFyIGV4cHIgPSBwYXJzZUV4cHJBdG9tKHN0cmVhbSk7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiK1wiKSkgZXhwciA9IHtcbiAgICAgIHR5cGU6IFwicGx1c1wiLFxuICAgICAgZXhwcjogZXhwclxuICAgIH07ZWxzZSBpZiAoc3RyZWFtLmVhdChcIipcIikpIGV4cHIgPSB7XG4gICAgICB0eXBlOiBcInN0YXJcIixcbiAgICAgIGV4cHI6IGV4cHJcbiAgICB9O2Vsc2UgaWYgKHN0cmVhbS5lYXQoXCI/XCIpKSBleHByID0ge1xuICAgICAgdHlwZTogXCJvcHRcIixcbiAgICAgIGV4cHI6IGV4cHJcbiAgICB9O2Vsc2UgaWYgKHN0cmVhbS5lYXQoXCJ7XCIpKSBleHByID0gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKTtlbHNlIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGV4cHI7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTnVtKHN0cmVhbSkge1xuICBpZiAoL1xcRC8udGVzdChzdHJlYW0ubmV4dCkpIHN0cmVhbS5lcnIoXCJFeHBlY3RlZCBudW1iZXIsIGdvdCAnXCIgKyBzdHJlYW0ubmV4dCArIFwiJ1wiKTtcbiAgdmFyIHJlc3VsdCA9IE51bWJlcihzdHJlYW0ubmV4dCk7XG4gIHN0cmVhbS5wb3MrKztcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKSB7XG4gIHZhciBtaW4gPSBwYXJzZU51bShzdHJlYW0pLFxuICAgICAgbWF4ID0gbWluO1xuXG4gIGlmIChzdHJlYW0uZWF0KFwiLFwiKSkge1xuICAgIGlmIChzdHJlYW0ubmV4dCAhPSBcIn1cIikgbWF4ID0gcGFyc2VOdW0oc3RyZWFtKTtlbHNlIG1heCA9IC0xO1xuICB9XG5cbiAgaWYgKCFzdHJlYW0uZWF0KFwifVwiKSkgc3RyZWFtLmVycihcIlVuY2xvc2VkIGJyYWNlZCByYW5nZVwiKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXgsXG4gICAgZXhwcjogZXhwclxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTmFtZShzdHJlYW0sIG5hbWUpIHtcbiAgdmFyIHR5cGVzID0gc3RyZWFtLm5vZGVUeXBlcyxcbiAgICAgIHR5cGUgPSB0eXBlc1tuYW1lXTtcbiAgaWYgKHR5cGUpIHJldHVybiBbdHlwZV07XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciB0eXBlTmFtZSBpbiB0eXBlcykge1xuICAgIHZhciBfdHlwZSA9IHR5cGVzW3R5cGVOYW1lXTtcbiAgICBpZiAoX3R5cGUuZ3JvdXBzLmluZGV4T2YobmFtZSkgPiAtMSkgcmVzdWx0LnB1c2goX3R5cGUpO1xuICB9XG5cbiAgaWYgKHJlc3VsdC5sZW5ndGggPT0gMCkgc3RyZWFtLmVycihcIk5vIG5vZGUgdHlwZSBvciBncm91cCAnXCIgKyBuYW1lICsgXCInIGZvdW5kXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUV4cHJBdG9tKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtLmVhdChcIihcIikpIHtcbiAgICB2YXIgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgIGlmICghc3RyZWFtLmVhdChcIilcIikpIHN0cmVhbS5lcnIoXCJNaXNzaW5nIGNsb3NpbmcgcGFyZW5cIik7XG4gICAgcmV0dXJuIGV4cHI7XG4gIH0gZWxzZSBpZiAoIS9cXFcvLnRlc3Qoc3RyZWFtLm5leHQpKSB7XG4gICAgdmFyIGV4cHJzID0gcmVzb2x2ZU5hbWUoc3RyZWFtLCBzdHJlYW0ubmV4dCkubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBpZiAoc3RyZWFtLmlubGluZSA9PSBudWxsKSBzdHJlYW0uaW5saW5lID0gdHlwZS5pc0lubGluZTtlbHNlIGlmIChzdHJlYW0uaW5saW5lICE9IHR5cGUuaXNJbmxpbmUpIHN0cmVhbS5lcnIoXCJNaXhpbmcgaW5saW5lIGFuZCBibG9jayBjb250ZW50XCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJuYW1lXCIsXG4gICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHN0cmVhbS5wb3MrKztcbiAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHtcbiAgICAgIHR5cGU6IFwiY2hvaWNlXCIsXG4gICAgICBleHByczogZXhwcnNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5mYShleHByKSB7XG4gIHZhciBuZmEgPSBbW11dO1xuICBjb25uZWN0KGNvbXBpbGUoZXhwciwgMCksIG5vZGUoKSk7XG4gIHJldHVybiBuZmE7XG5cbiAgZnVuY3Rpb24gbm9kZSgpIHtcbiAgICByZXR1cm4gbmZhLnB1c2goW10pIC0gMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVkZ2UoZnJvbSwgdG8sIHRlcm0pIHtcbiAgICB2YXIgZWRnZSA9IHtcbiAgICAgIHRlcm06IHRlcm0sXG4gICAgICB0bzogdG9cbiAgICB9O1xuICAgIG5mYVtmcm9tXS5wdXNoKGVkZ2UpO1xuICAgIHJldHVybiBlZGdlO1xuICB9XG5cbiAgZnVuY3Rpb24gY29ubmVjdChlZGdlcywgdG8pIHtcbiAgICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS50byA9IHRvO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZShleHByLCBmcm9tKSB7XG4gICAgaWYgKGV4cHIudHlwZSA9PSBcImNob2ljZVwiKSB7XG4gICAgICByZXR1cm4gZXhwci5leHBycy5yZWR1Y2UoZnVuY3Rpb24gKG91dCwgZXhwcikge1xuICAgICAgICByZXR1cm4gb3V0LmNvbmNhdChjb21waWxlKGV4cHIsIGZyb20pKTtcbiAgICAgIH0sIFtdKTtcbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInNlcVwiKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDs7IGkrKykge1xuICAgICAgICB2YXIgbmV4dCA9IGNvbXBpbGUoZXhwci5leHByc1tpXSwgZnJvbSk7XG4gICAgICAgIGlmIChpID09IGV4cHIuZXhwcnMubGVuZ3RoIC0gMSkgcmV0dXJuIG5leHQ7XG4gICAgICAgIGNvbm5lY3QobmV4dCwgZnJvbSA9IG5vZGUoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJzdGFyXCIpIHtcbiAgICAgIHZhciBsb29wID0gbm9kZSgpO1xuICAgICAgZWRnZShmcm9tLCBsb29wKTtcbiAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJwbHVzXCIpIHtcbiAgICAgIHZhciBfbG9vcCA9IG5vZGUoKTtcblxuICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSksIF9sb29wKTtcbiAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIF9sb29wKSwgX2xvb3ApO1xuICAgICAgcmV0dXJuIFtlZGdlKF9sb29wKV07XG4gICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJvcHRcIikge1xuICAgICAgcmV0dXJuIFtlZGdlKGZyb20pXS5jb25jYXQoY29tcGlsZShleHByLmV4cHIsIGZyb20pKTtcbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInJhbmdlXCIpIHtcbiAgICAgIHZhciBjdXIgPSBmcm9tO1xuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBleHByLm1pbjsgX2kyKyspIHtcbiAgICAgICAgdmFyIF9uZXh0ID0gbm9kZSgpO1xuXG4gICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIF9uZXh0KTtcbiAgICAgICAgY3VyID0gX25leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChleHByLm1heCA9PSAtMSkge1xuICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBjdXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX2kzID0gZXhwci5taW47IF9pMyA8IGV4cHIubWF4OyBfaTMrKykge1xuICAgICAgICAgIHZhciBfbmV4dDIgPSBub2RlKCk7XG5cbiAgICAgICAgICBlZGdlKGN1ciwgX25leHQyKTtcbiAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBfbmV4dDIpO1xuICAgICAgICAgIGN1ciA9IF9uZXh0MjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2VkZ2UoY3VyKV07XG4gICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJuYW1lXCIpIHtcbiAgICAgIHJldHVybiBbZWRnZShmcm9tLCB1bmRlZmluZWQsIGV4cHIudmFsdWUpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBleHByIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNtcChhLCBiKSB7XG4gIHJldHVybiBiIC0gYTtcbn1cblxuZnVuY3Rpb24gbnVsbEZyb20obmZhLCBub2RlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgc2Nhbihub2RlKTtcbiAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCk7XG5cbiAgZnVuY3Rpb24gc2Nhbihub2RlKSB7XG4gICAgdmFyIGVkZ2VzID0gbmZhW25vZGVdO1xuICAgIGlmIChlZGdlcy5sZW5ndGggPT0gMSAmJiAhZWRnZXNbMF0udGVybSkgcmV0dXJuIHNjYW4oZWRnZXNbMF0udG8pO1xuICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9lZGdlcyRpID0gZWRnZXNbaV0sXG4gICAgICAgICAgdGVybSA9IF9lZGdlcyRpLnRlcm0sXG4gICAgICAgICAgdG8gPSBfZWRnZXMkaS50bztcbiAgICAgIGlmICghdGVybSAmJiByZXN1bHQuaW5kZXhPZih0bykgPT0gLTEpIHNjYW4odG8pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZmEobmZhKSB7XG4gIHZhciBsYWJlbGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIGV4cGxvcmUobnVsbEZyb20obmZhLCAwKSk7XG5cbiAgZnVuY3Rpb24gZXhwbG9yZShzdGF0ZXMpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIG5mYVtub2RlXS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciB0ZXJtID0gX3JlZi50ZXJtLFxuICAgICAgICAgICAgdG8gPSBfcmVmLnRvO1xuICAgICAgICBpZiAoIXRlcm0pIHJldHVybjtcbiAgICAgICAgdmFyIHNldDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChvdXRbaV1bMF0gPT0gdGVybSkgc2V0ID0gb3V0W2ldWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVsbEZyb20obmZhLCB0bykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmICghc2V0KSBvdXQucHVzaChbdGVybSwgc2V0ID0gW11dKTtcbiAgICAgICAgICBpZiAoc2V0LmluZGV4T2Yobm9kZSkgPT0gLTEpIHNldC5wdXNoKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBzdGF0ZSA9IGxhYmVsZWRbc3RhdGVzLmpvaW4oXCIsXCIpXSA9IG5ldyBDb250ZW50TWF0Y2goc3RhdGVzLmluZGV4T2YobmZhLmxlbmd0aCAtIDEpID4gLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfc3RhdGVzID0gb3V0W2ldWzFdLnNvcnQoY21wKTtcblxuICAgICAgc3RhdGUubmV4dC5wdXNoKHtcbiAgICAgICAgdHlwZTogb3V0W2ldWzBdLFxuICAgICAgICBuZXh0OiBsYWJlbGVkW19zdGF0ZXMuam9pbihcIixcIildIHx8IGV4cGxvcmUoX3N0YXRlcylcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ZvckRlYWRFbmRzKG1hdGNoLCBzdHJlYW0pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdvcmsgPSBbbWF0Y2hdOyBpIDwgd29yay5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGF0ZSA9IHdvcmtbaV0sXG4gICAgICAgIGRlYWQgPSAhc3RhdGUudmFsaWRFbmQsXG4gICAgICAgIG5vZGVzID0gW107XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0YXRlLm5leHQubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBfc3RhdGUkbmV4dCRqID0gc3RhdGUubmV4dFtqXSxcbiAgICAgICAgICB0eXBlID0gX3N0YXRlJG5leHQkai50eXBlLFxuICAgICAgICAgIG5leHQgPSBfc3RhdGUkbmV4dCRqLm5leHQ7XG4gICAgICBub2Rlcy5wdXNoKHR5cGUubmFtZSk7XG4gICAgICBpZiAoZGVhZCAmJiAhKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSkgZGVhZCA9IGZhbHNlO1xuICAgICAgaWYgKHdvcmsuaW5kZXhPZihuZXh0KSA9PSAtMSkgd29yay5wdXNoKG5leHQpO1xuICAgIH1cblxuICAgIGlmIChkZWFkKSBzdHJlYW0uZXJyKFwiT25seSBub24tZ2VuZXJhdGFibGUgbm9kZXMgKFwiICsgbm9kZXMuam9pbihcIiwgXCIpICsgXCIpIGluIGEgcmVxdWlyZWQgcG9zaXRpb24gKHNlZSBodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL2d1aWRlLyNnZW5lcmF0YWJsZSlcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdEF0dHJzKGF0dHJzKSB7XG4gIHZhciBkZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIgYXR0ck5hbWUgaW4gYXR0cnMpIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICBpZiAoIWF0dHIuaGFzRGVmYXVsdCkgcmV0dXJuIG51bGw7XG4gICAgZGVmYXVsdHNbYXR0ck5hbWVdID0gYXR0cltcImRlZmF1bHRcIl07XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdHM7XG59XG5cbmZ1bmN0aW9uIF9jb21wdXRlQXR0cnMoYXR0cnMsIHZhbHVlKSB7XG4gIHZhciBidWlsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBhdHRycykge1xuICAgIHZhciBnaXZlbiA9IHZhbHVlICYmIHZhbHVlW25hbWVdO1xuXG4gICAgaWYgKGdpdmVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cnNbbmFtZV07XG4gICAgICBpZiAoYXR0ci5oYXNEZWZhdWx0KSBnaXZlbiA9IGF0dHJbXCJkZWZhdWx0XCJdO2Vsc2UgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyB2YWx1ZSBzdXBwbGllZCBmb3IgYXR0cmlidXRlIFwiICsgbmFtZSk7XG4gICAgfVxuXG4gICAgYnVpbHRbbmFtZV0gPSBnaXZlbjtcbiAgfVxuXG4gIHJldHVybiBidWlsdDtcbn1cblxuZnVuY3Rpb24gaW5pdEF0dHJzKGF0dHJzKSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoYXR0cnMpIGZvciAodmFyIG5hbWUgaW4gYXR0cnMpIHtcbiAgICByZXN1bHRbbmFtZV0gPSBuZXcgQXR0cmlidXRlKGF0dHJzW25hbWVdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgTm9kZVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vZGVUeXBlKG5hbWUsIHNjaGVtYSwgc3BlYykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlVHlwZSk7XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgdGhpcy5tYXJrU2V0ID0gbnVsbDtcbiAgICB0aGlzLmdyb3VwcyA9IHNwZWMuZ3JvdXAgPyBzcGVjLmdyb3VwLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMoc3BlYy5hdHRycyk7XG4gICAgdGhpcy5kZWZhdWx0QXR0cnMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgdGhpcy5jb250ZW50TWF0Y2ggPSBudWxsO1xuICAgIHRoaXMuaW5saW5lQ29udGVudCA9IG51bGw7XG4gICAgdGhpcy5pc0Jsb2NrID0gIShzcGVjLmlubGluZSB8fCBuYW1lID09IFwidGV4dFwiKTtcbiAgICB0aGlzLmlzVGV4dCA9IG5hbWUgPT0gXCJ0ZXh0XCI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm9kZVR5cGUsIFt7XG4gICAga2V5OiBcImlzSW5saW5lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaXNCbG9jaztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNUZXh0YmxvY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzQmxvY2sgJiYgdGhpcy5pbmxpbmVDb250ZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0xlYWZcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRNYXRjaCA9PSBDb250ZW50TWF0Y2guZW1wdHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQXRvbVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNMZWFmIHx8ICEhdGhpcy5zcGVjLmF0b207XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndoaXRlc3BhY2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwZWMud2hpdGVzcGFjZSB8fCAodGhpcy5zcGVjLmNvZGUgPyBcInByZVwiIDogXCJub3JtYWxcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1JlcXVpcmVkQXR0cnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUmVxdWlyZWRBdHRycygpIHtcbiAgICAgIGZvciAodmFyIG4gaW4gdGhpcy5hdHRycykge1xuICAgICAgICBpZiAodGhpcy5hdHRyc1tuXS5pc1JlcXVpcmVkKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXRpYmxlQ29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXRpYmxlQ29udGVudChvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb250ZW50TWF0Y2guY29tcGF0aWJsZShvdGhlci5jb250ZW50TWF0Y2gpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wdXRlQXR0cnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZUF0dHJzKGF0dHJzKSB7XG4gICAgICBpZiAoIWF0dHJzICYmIHRoaXMuZGVmYXVsdEF0dHJzKSByZXR1cm4gdGhpcy5kZWZhdWx0QXR0cnM7ZWxzZSByZXR1cm4gX2NvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy5pc1RleHQpIHRocm93IG5ldyBFcnJvcihcIk5vZGVUeXBlLmNyZWF0ZSBjYW4ndCBjb25zdHJ1Y3QgdGV4dCBub2Rlc1wiKTtcbiAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIEZyYWdtZW50LmZyb20oY29udGVudCksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVDaGVja2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNoZWNrZWQoKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbShjb250ZW50KTtcbiAgICAgIGlmICghdGhpcy52YWxpZENvbnRlbnQoY29udGVudCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIFwiICsgdGhpcy5uYW1lKTtcbiAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIGNvbnRlbnQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVBbmRGaWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUFuZEZpbGwoKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICBhdHRycyA9IHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKTtcbiAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuXG4gICAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSB0aGlzLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGNvbnRlbnQpO1xuICAgICAgICBpZiAoIWJlZm9yZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnRlbnQgPSBiZWZvcmUuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlZCA9IHRoaXMuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICB2YXIgYWZ0ZXIgPSBtYXRjaGVkICYmIG1hdGNoZWQuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICBpZiAoIWFmdGVyKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBhdHRycywgY29udGVudC5hcHBlbmQoYWZ0ZXIpLCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkQ29udGVudChjb250ZW50KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQudmFsaWRFbmQpIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya3MoY29udGVudC5jaGlsZChpKS5tYXJrcykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFsbG93c01hcmtUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXJrU2V0ID09IG51bGwgfHwgdGhpcy5tYXJrU2V0LmluZGV4T2YobWFya1R5cGUpID4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFsbG93c01hcmtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFsbG93c01hcmtzKG1hcmtzKSB7XG4gICAgICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWxsb3dlZE1hcmtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFsbG93ZWRNYXJrcyhtYXJrcykge1xuICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKSByZXR1cm4gbWFya3M7XG4gICAgICB2YXIgY29weTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpIHtcbiAgICAgICAgICBpZiAoIWNvcHkpIGNvcHkgPSBtYXJrcy5zbGljZSgwLCBpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb3B5KSB7XG4gICAgICAgICAgY29weS5wdXNoKG1hcmtzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gIWNvcHkgPyBtYXJrcyA6IGNvcHkubGVuZ3RoID8gY29weSA6IE1hcmsubm9uZTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjb21waWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUobm9kZXMsIHNjaGVtYSkge1xuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbbmFtZV0gPSBuZXcgTm9kZVR5cGUobmFtZSwgc2NoZW1hLCBzcGVjKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHRvcFR5cGUgPSBzY2hlbWEuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCI7XG4gICAgICBpZiAoIXJlc3VsdFt0b3BUeXBlXSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTY2hlbWEgaXMgbWlzc2luZyBpdHMgdG9wIG5vZGUgdHlwZSAoJ1wiICsgdG9wVHlwZSArIFwiJylcIik7XG4gICAgICBpZiAoIXJlc3VsdC50ZXh0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV2ZXJ5IHNjaGVtYSBuZWVkcyBhICd0ZXh0JyB0eXBlXCIpO1xuXG4gICAgICBmb3IgKHZhciBfIGluIHJlc3VsdC50ZXh0LmF0dHJzKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHRleHQgbm9kZSB0eXBlIHNob3VsZCBub3QgaGF2ZSBhdHRyaWJ1dGVzXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb2RlVHlwZTtcbn0oKTtcblxudmFyIEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXR0cmlidXRlKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXR0cmlidXRlKTtcblxuICAgIHRoaXMuaGFzRGVmYXVsdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcImRlZmF1bHRcIik7XG4gICAgdGhpc1tcImRlZmF1bHRcIl0gPSBvcHRpb25zW1wiZGVmYXVsdFwiXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBdHRyaWJ1dGUsIFt7XG4gICAga2V5OiBcImlzUmVxdWlyZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5oYXNEZWZhdWx0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBdHRyaWJ1dGU7XG59KCk7XG5cbnZhciBNYXJrVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFya1R5cGUobmFtZSwgcmFuaywgc2NoZW1hLCBzcGVjKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmtUeXBlKTtcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMoc3BlYy5hdHRycyk7XG4gICAgdGhpcy5leGNsdWRlZCA9IG51bGw7XG4gICAgdmFyIGRlZmF1bHRzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICAgIHRoaXMuaW5zdGFuY2UgPSBkZWZhdWx0cyA/IG5ldyBNYXJrKHRoaXMsIGRlZmF1bHRzKSA6IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFya1R5cGUsIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICBpZiAoIWF0dHJzICYmIHRoaXMuaW5zdGFuY2UpIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgICAgcmV0dXJuIG5ldyBNYXJrKHRoaXMsIF9jb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRnJvbVNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNldFtpXS50eXBlID09IHRoaXMpIHtcbiAgICAgICAgICBzZXQgPSBzZXQuc2xpY2UoMCwgaSkuY29uY2F0KHNldC5zbGljZShpICsgMSkpO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0luU2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW5TZXQoc2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcykgcmV0dXJuIHNldFtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhjbHVkZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhjbHVkZXMob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmV4Y2x1ZGVkLmluZGV4T2Yob3RoZXIpID4gLTE7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY29tcGlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21waWxlKG1hcmtzLCBzY2hlbWEpIHtcbiAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgIHJhbmsgPSAwO1xuICAgICAgbWFya3MuZm9yRWFjaChmdW5jdGlvbiAobmFtZSwgc3BlYykge1xuICAgICAgICByZXR1cm4gcmVzdWx0W25hbWVdID0gbmV3IE1hcmtUeXBlKG5hbWUsIHJhbmsrKywgc2NoZW1hLCBzcGVjKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFya1R5cGU7XG59KCk7XG5cbnZhciBTY2hlbWEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNjaGVtYShzcGVjKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNjaGVtYSk7XG5cbiAgICB0aGlzLmNhY2hlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zcGVjID0ge1xuICAgICAgbm9kZXM6IE9yZGVyZWRNYXBfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZyb20oc3BlYy5ub2RlcyksXG4gICAgICBtYXJrczogT3JkZXJlZE1hcF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnJvbShzcGVjLm1hcmtzIHx8IHt9KSxcbiAgICAgIHRvcE5vZGU6IHNwZWMudG9wTm9kZVxuICAgIH07XG4gICAgdGhpcy5ub2RlcyA9IE5vZGVUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm5vZGVzLCB0aGlzKTtcbiAgICB0aGlzLm1hcmtzID0gTWFya1R5cGUuY29tcGlsZSh0aGlzLnNwZWMubWFya3MsIHRoaXMpO1xuICAgIHZhciBjb250ZW50RXhwckNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgaWYgKHByb3AgaW4gdGhpcy5tYXJrcykgdGhyb3cgbmV3IFJhbmdlRXJyb3IocHJvcCArIFwiIGNhbiBub3QgYmUgYm90aCBhIG5vZGUgYW5kIGEgbWFya1wiKTtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5ub2Rlc1twcm9wXSxcbiAgICAgICAgICBjb250ZW50RXhwciA9IHR5cGUuc3BlYy5jb250ZW50IHx8IFwiXCIsXG4gICAgICAgICAgbWFya0V4cHIgPSB0eXBlLnNwZWMubWFya3M7XG4gICAgICB0eXBlLmNvbnRlbnRNYXRjaCA9IGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdIHx8IChjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSA9IENvbnRlbnRNYXRjaC5wYXJzZShjb250ZW50RXhwciwgdGhpcy5ub2RlcykpO1xuICAgICAgdHlwZS5pbmxpbmVDb250ZW50ID0gdHlwZS5jb250ZW50TWF0Y2guaW5saW5lQ29udGVudDtcbiAgICAgIHR5cGUubWFya1NldCA9IG1hcmtFeHByID09IFwiX1wiID8gbnVsbCA6IG1hcmtFeHByID8gZ2F0aGVyTWFya3ModGhpcywgbWFya0V4cHIuc3BsaXQoXCIgXCIpKSA6IG1hcmtFeHByID09IFwiXCIgfHwgIXR5cGUuaW5saW5lQ29udGVudCA/IFtdIDogbnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfcHJvcCBpbiB0aGlzLm1hcmtzKSB7XG4gICAgICB2YXIgX3R5cGUyID0gdGhpcy5tYXJrc1tfcHJvcF0sXG4gICAgICAgICAgZXhjbCA9IF90eXBlMi5zcGVjLmV4Y2x1ZGVzO1xuICAgICAgX3R5cGUyLmV4Y2x1ZGVkID0gZXhjbCA9PSBudWxsID8gW190eXBlMl0gOiBleGNsID09IFwiXCIgPyBbXSA6IGdhdGhlck1hcmtzKHRoaXMsIGV4Y2wuc3BsaXQoXCIgXCIpKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vZGVGcm9tSlNPTiA9IHRoaXMubm9kZUZyb21KU09OLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXJrRnJvbUpTT04gPSB0aGlzLm1hcmtGcm9tSlNPTi5iaW5kKHRoaXMpO1xuICAgIHRoaXMudG9wTm9kZVR5cGUgPSB0aGlzLm5vZGVzW3RoaXMuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCJdO1xuICAgIHRoaXMuY2FjaGVkLndyYXBwaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2NoZW1hLCBbe1xuICAgIGtleTogXCJub2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vZGUodHlwZSkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIGNvbnRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBtYXJrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpIHR5cGUgPSB0aGlzLm5vZGVUeXBlKHR5cGUpO2Vsc2UgaWYgKCEodHlwZSBpbnN0YW5jZW9mIE5vZGVUeXBlKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG5vZGUgdHlwZTogXCIgKyB0eXBlKTtlbHNlIGlmICh0eXBlLnNjaGVtYSAhPSB0aGlzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBmcm9tIGRpZmZlcmVudCBzY2hlbWEgdXNlZCAoXCIgKyB0eXBlLm5hbWUgKyBcIilcIik7XG4gICAgICByZXR1cm4gdHlwZS5jcmVhdGVDaGVja2VkKGF0dHJzLCBjb250ZW50LCBtYXJrcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dChfdGV4dCwgbWFya3MpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5ub2Rlcy50ZXh0O1xuICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0eXBlLCB0eXBlLmRlZmF1bHRBdHRycywgX3RleHQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmsodHlwZSwgYXR0cnMpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKSB0eXBlID0gdGhpcy5tYXJrc1t0eXBlXTtcbiAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShhdHRycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vZGVGcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub2RlRnJvbUpTT04oanNvbikge1xuICAgICAgcmV0dXJuIE5vZGUuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtGcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrRnJvbUpTT04oanNvbikge1xuICAgICAgcmV0dXJuIE1hcmsuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vZGVUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vZGVUeXBlKG5hbWUpIHtcbiAgICAgIHZhciBmb3VuZCA9IHRoaXMubm9kZXNbbmFtZV07XG4gICAgICBpZiAoIWZvdW5kKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIiArIG5hbWUpO1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY2hlbWE7XG59KCk7XG5cbmZ1bmN0aW9uIGdhdGhlck1hcmtzKHNjaGVtYSwgbWFya3MpIHtcbiAgdmFyIGZvdW5kID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gbWFya3NbaV0sXG4gICAgICAgIG1hcmsgPSBzY2hlbWEubWFya3NbbmFtZV0sXG4gICAgICAgIG9rID0gbWFyaztcblxuICAgIGlmIChtYXJrKSB7XG4gICAgICBmb3VuZC5wdXNoKG1hcmspO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHNjaGVtYS5tYXJrcykge1xuICAgICAgICB2YXIgX21hcmsgPSBzY2hlbWEubWFya3NbcHJvcF07XG4gICAgICAgIGlmIChuYW1lID09IFwiX1wiIHx8IF9tYXJrLnNwZWMuZ3JvdXAgJiYgX21hcmsuc3BlYy5ncm91cC5zcGxpdChcIiBcIikuaW5kZXhPZihuYW1lKSA+IC0xKSBmb3VuZC5wdXNoKG9rID0gX21hcmspO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghb2spIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVua25vd24gbWFyayB0eXBlOiAnXCIgKyBtYXJrc1tpXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiBmb3VuZDtcbn1cblxudmFyIERPTVBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRE9NUGFyc2VyKHNjaGVtYSwgcnVsZXMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBET01QYXJzZXIpO1xuXG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgIHRoaXMudGFncyA9IFtdO1xuICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgcnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKHJ1bGUudGFnKSBfdGhpczIudGFncy5wdXNoKHJ1bGUpO2Vsc2UgaWYgKHJ1bGUuc3R5bGUpIF90aGlzMi5zdHlsZXMucHVzaChydWxlKTtcbiAgICB9KTtcbiAgICB0aGlzLm5vcm1hbGl6ZUxpc3RzID0gIXRoaXMudGFncy5zb21lKGZ1bmN0aW9uIChyKSB7XG4gICAgICBpZiAoIS9eKHVsfG9sKVxcYi8udGVzdChyLnRhZykgfHwgIXIubm9kZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIG5vZGUgPSBzY2hlbWEubm9kZXNbci5ub2RlXTtcbiAgICAgIHJldHVybiBub2RlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUobm9kZSk7XG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRE9NUGFyc2VyLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShkb20pIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICBjb250ZXh0LmFkZEFsbChkb20sIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgICByZXR1cm4gY29udGV4dC5maW5pc2goKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VTbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVNsaWNlKGRvbSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIHRydWUpO1xuICAgICAgY29udGV4dC5hZGRBbGwoZG9tLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgcmV0dXJuIFNsaWNlLm1heE9wZW4oY29udGV4dC5maW5pc2goKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoVGFnKGRvbSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSBhZnRlciA/IHRoaXMudGFncy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBydWxlID0gdGhpcy50YWdzW2ldO1xuXG4gICAgICAgIGlmIChtYXRjaGVzKGRvbSwgcnVsZS50YWcpICYmIChydWxlLm5hbWVzcGFjZSA9PT0gdW5kZWZpbmVkIHx8IGRvbS5uYW1lc3BhY2VVUkkgPT0gcnVsZS5uYW1lc3BhY2UpICYmICghcnVsZS5jb250ZXh0IHx8IGNvbnRleHQubWF0Y2hlc0NvbnRleHQocnVsZS5jb250ZXh0KSkpIHtcbiAgICAgICAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnMoZG9tKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoU3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hTdHlsZShwcm9wLCB2YWx1ZSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSBhZnRlciA/IHRoaXMuc3R5bGVzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcnVsZSA9IHRoaXMuc3R5bGVzW2ldLFxuICAgICAgICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuICAgICAgICBpZiAoc3R5bGUuaW5kZXhPZihwcm9wKSAhPSAwIHx8IHJ1bGUuY29udGV4dCAmJiAhY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpIHx8IHN0eWxlLmxlbmd0aCA+IHByb3AubGVuZ3RoICYmIChzdHlsZS5jaGFyQ29kZUF0KHByb3AubGVuZ3RoKSAhPSA2MSB8fCBzdHlsZS5zbGljZShwcm9wLmxlbmd0aCArIDEpICE9IHZhbHVlKSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwic2NoZW1hUnVsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NoZW1hUnVsZXMoc2NoZW1hKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGluc2VydChydWxlKSB7XG4gICAgICAgIHZhciBwcmlvcml0eSA9IHJ1bGUucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogcnVsZS5wcmlvcml0eSxcbiAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgIGZvciAoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSByZXN1bHRbaV0sXG4gICAgICAgICAgICAgIG5leHRQcmlvcml0eSA9IG5leHQucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogbmV4dC5wcmlvcml0eTtcbiAgICAgICAgICBpZiAobmV4dFByaW9yaXR5IDwgcHJpb3JpdHkpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnNwbGljZShpLCAwLCBydWxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihuYW1lKSB7XG4gICAgICAgIHZhciBydWxlcyA9IHNjaGVtYS5tYXJrc1tuYW1lXS5zcGVjLnBhcnNlRE9NO1xuICAgICAgICBpZiAocnVsZXMpIHJ1bGVzLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgIHJ1bGUubWFyayA9IG5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgX2xvb3AyKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2xvb3AzID0gZnVuY3Rpb24gX2xvb3AzKF9uYW1lKSB7XG4gICAgICAgIHZhciBydWxlcyA9IHNjaGVtYS5ub2Rlc1tfbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgaWYgKHJ1bGVzKSBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgICAgICBydWxlLm5vZGUgPSBfbmFtZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfbmFtZSBpbiBzY2hlbWEubm9kZXMpIHtcbiAgICAgICAgX2xvb3AzKF9uYW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVNjaGVtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyIHx8IChzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciA9IG5ldyBET01QYXJzZXIoc2NoZW1hLCBET01QYXJzZXIuc2NoZW1hUnVsZXMoc2NoZW1hKSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBET01QYXJzZXI7XG59KCk7XG5cbnZhciBibG9ja1RhZ3MgPSB7XG4gIGFkZHJlc3M6IHRydWUsXG4gIGFydGljbGU6IHRydWUsXG4gIGFzaWRlOiB0cnVlLFxuICBibG9ja3F1b3RlOiB0cnVlLFxuICBjYW52YXM6IHRydWUsXG4gIGRkOiB0cnVlLFxuICBkaXY6IHRydWUsXG4gIGRsOiB0cnVlLFxuICBmaWVsZHNldDogdHJ1ZSxcbiAgZmlnY2FwdGlvbjogdHJ1ZSxcbiAgZmlndXJlOiB0cnVlLFxuICBmb290ZXI6IHRydWUsXG4gIGZvcm06IHRydWUsXG4gIGgxOiB0cnVlLFxuICBoMjogdHJ1ZSxcbiAgaDM6IHRydWUsXG4gIGg0OiB0cnVlLFxuICBoNTogdHJ1ZSxcbiAgaDY6IHRydWUsXG4gIGhlYWRlcjogdHJ1ZSxcbiAgaGdyb3VwOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgbGk6IHRydWUsXG4gIG5vc2NyaXB0OiB0cnVlLFxuICBvbDogdHJ1ZSxcbiAgb3V0cHV0OiB0cnVlLFxuICBwOiB0cnVlLFxuICBwcmU6IHRydWUsXG4gIHNlY3Rpb246IHRydWUsXG4gIHRhYmxlOiB0cnVlLFxuICB0Zm9vdDogdHJ1ZSxcbiAgdWw6IHRydWVcbn07XG52YXIgaWdub3JlVGFncyA9IHtcbiAgaGVhZDogdHJ1ZSxcbiAgbm9zY3JpcHQ6IHRydWUsXG4gIG9iamVjdDogdHJ1ZSxcbiAgc2NyaXB0OiB0cnVlLFxuICBzdHlsZTogdHJ1ZSxcbiAgdGl0bGU6IHRydWVcbn07XG52YXIgbGlzdFRhZ3MgPSB7XG4gIG9sOiB0cnVlLFxuICB1bDogdHJ1ZVxufTtcbnZhciBPUFRfUFJFU0VSVkVfV1MgPSAxLFxuICAgIE9QVF9QUkVTRVJWRV9XU19GVUxMID0gMixcbiAgICBPUFRfT1BFTl9MRUZUID0gNDtcblxuZnVuY3Rpb24gd3NPcHRpb25zRm9yKHR5cGUsIHByZXNlcnZlV2hpdGVzcGFjZSwgYmFzZSkge1xuICBpZiAocHJlc2VydmVXaGl0ZXNwYWNlICE9IG51bGwpIHJldHVybiAocHJlc2VydmVXaGl0ZXNwYWNlID8gT1BUX1BSRVNFUlZFX1dTIDogMCkgfCAocHJlc2VydmVXaGl0ZXNwYWNlID09PSBcImZ1bGxcIiA/IE9QVF9QUkVTRVJWRV9XU19GVUxMIDogMCk7XG4gIHJldHVybiB0eXBlICYmIHR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiID8gT1BUX1BSRVNFUlZFX1dTIHwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiBiYXNlICYgfk9QVF9PUEVOX0xFRlQ7XG59XG5cbnZhciBOb2RlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9kZUNvbnRleHQodHlwZSwgYXR0cnMsIG1hcmtzLCBwZW5kaW5nTWFya3MsIHNvbGlkLCBtYXRjaCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlQ29udGV4dCk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgdGhpcy5wZW5kaW5nTWFya3MgPSBwZW5kaW5nTWFya3M7XG4gICAgdGhpcy5zb2xpZCA9IHNvbGlkO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgdGhpcy5hY3RpdmVNYXJrcyA9IE1hcmsubm9uZTtcbiAgICB0aGlzLnN0YXNoTWFya3MgPSBbXTtcbiAgICB0aGlzLm1hdGNoID0gbWF0Y2ggfHwgKG9wdGlvbnMgJiBPUFRfT1BFTl9MRUZUID8gbnVsbCA6IHR5cGUuY29udGVudE1hdGNoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb2RlQ29udGV4dCwgW3tcbiAgICBrZXk6IFwiZmluZFdyYXBwaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRXcmFwcGluZyhub2RlKSB7XG4gICAgICBpZiAoIXRoaXMubWF0Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIGZpbGwgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShub2RlKSk7XG5cbiAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZpbGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gsXG4gICAgICAgICAgICAgIHdyYXA7XG5cbiAgICAgICAgICBpZiAod3JhcCA9IHN0YXJ0LmZpbmRXcmFwcGluZyhub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gc3RhcnQ7XG4gICAgICAgICAgICByZXR1cm4gd3JhcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm1hdGNoLmZpbmRXcmFwcGluZyhub2RlLnR5cGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5pc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluaXNoKG9wZW5FbmQpIHtcbiAgICAgIGlmICghKHRoaXMub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHtcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgbTtcblxuICAgICAgICBpZiAobGFzdCAmJiBsYXN0LmlzVGV4dCAmJiAobSA9IC9bIFxcdFxcclxcblxcdTAwMGNdKyQvLmV4ZWMobGFzdC50ZXh0KSkpIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGxhc3Q7XG4gICAgICAgICAgaWYgKGxhc3QudGV4dC5sZW5ndGggPT0gbVswXS5sZW5ndGgpIHRoaXMuY29udGVudC5wb3AoKTtlbHNlIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gPSB0ZXh0LndpdGhUZXh0KHRleHQudGV4dC5zbGljZSgwLCB0ZXh0LnRleHQubGVuZ3RoIC0gbVswXS5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29udGVudCA9IEZyYWdtZW50LmZyb20odGhpcy5jb250ZW50KTtcbiAgICAgIGlmICghb3BlbkVuZCAmJiB0aGlzLm1hdGNoKSBjb250ZW50ID0gY29udGVudC5hcHBlbmQodGhpcy5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgICByZXR1cm4gdGhpcy50eXBlID8gdGhpcy50eXBlLmNyZWF0ZSh0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKSA6IGNvbnRlbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvcEZyb21TdGFzaE1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9wRnJvbVN0YXNoTWFyayhtYXJrKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5zdGFzaE1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChtYXJrLmVxKHRoaXMuc3Rhc2hNYXJrc1tpXSkpIHJldHVybiB0aGlzLnN0YXNoTWFya3Muc3BsaWNlKGksIDEpWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVBlbmRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlQZW5kaW5nKG5leHRUeXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcGVuZGluZyA9IHRoaXMucGVuZGluZ01hcmtzOyBpIDwgcGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWFyayA9IHBlbmRpbmdbaV07XG5cbiAgICAgICAgaWYgKCh0aGlzLnR5cGUgPyB0aGlzLnR5cGUuYWxsb3dzTWFya1R5cGUobWFyay50eXBlKSA6IG1hcmtNYXlBcHBseShtYXJrLnR5cGUsIG5leHRUeXBlKSkgJiYgIW1hcmsuaXNJblNldCh0aGlzLmFjdGl2ZU1hcmtzKSkge1xuICAgICAgICAgIHRoaXMuYWN0aXZlTWFya3MgPSBtYXJrLmFkZFRvU2V0KHRoaXMuYWN0aXZlTWFya3MpO1xuICAgICAgICAgIHRoaXMucGVuZGluZ01hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KHRoaXMucGVuZGluZ01hcmtzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmxpbmVDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlubGluZUNvbnRleHQobm9kZSkge1xuICAgICAgaWYgKHRoaXMudHlwZSkgcmV0dXJuIHRoaXMudHlwZS5pbmxpbmVDb250ZW50O1xuICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpIHJldHVybiB0aGlzLmNvbnRlbnRbMF0uaXNJbmxpbmU7XG4gICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlICYmICFibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb2RlQ29udGV4dDtcbn0oKTtcblxudmFyIFBhcnNlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFyc2VDb250ZXh0KHBhcnNlciwgb3B0aW9ucywgaXNPcGVuKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnNlQ29udGV4dCk7XG5cbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaXNPcGVuID0gaXNPcGVuO1xuICAgIHRoaXMub3BlbiA9IDA7XG4gICAgdmFyIHRvcE5vZGUgPSBvcHRpb25zLnRvcE5vZGUsXG4gICAgICAgIHRvcENvbnRleHQ7XG4gICAgdmFyIHRvcE9wdGlvbnMgPSB3c09wdGlvbnNGb3IobnVsbCwgb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsIDApIHwgKGlzT3BlbiA/IE9QVF9PUEVOX0xFRlQgOiAwKTtcbiAgICBpZiAodG9wTm9kZSkgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dCh0b3BOb2RlLnR5cGUsIHRvcE5vZGUuYXR0cnMsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBvcHRpb25zLnRvcE1hdGNoIHx8IHRvcE5vZGUudHlwZS5jb250ZW50TWF0Y2gsIHRvcE9wdGlvbnMpO2Vsc2UgaWYgKGlzT3BlbikgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dChudWxsLCBudWxsLCBNYXJrLm5vbmUsIE1hcmsubm9uZSwgdHJ1ZSwgbnVsbCwgdG9wT3B0aW9ucyk7ZWxzZSB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHBhcnNlci5zY2hlbWEudG9wTm9kZVR5cGUsIG51bGwsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICB0aGlzLm5vZGVzID0gW3RvcENvbnRleHRdO1xuICAgIHRoaXMuZmluZCA9IG9wdGlvbnMuZmluZFBvc2l0aW9ucztcbiAgICB0aGlzLm5lZWRzQmxvY2sgPSBmYWxzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQYXJzZUNvbnRleHQsIFt7XG4gICAga2V5OiBcInRvcFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXNbdGhpcy5vcGVuXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZERPTShkb20pIHtcbiAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMykge1xuICAgICAgICB0aGlzLmFkZFRleHROb2RlKGRvbSk7XG4gICAgICB9IGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGRvbS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICAgICAgdmFyIG1hcmtzID0gc3R5bGUgPyB0aGlzLnJlYWRTdHlsZXMocGFyc2VTdHlsZXMoc3R5bGUpKSA6IG51bGwsXG4gICAgICAgICAgICB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgaWYgKG1hcmtzICE9IG51bGwpIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNYXJrKG1hcmtzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tKTtcbiAgICAgICAgaWYgKG1hcmtzICE9IG51bGwpIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG1hcmtzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVBlbmRpbmdNYXJrKG1hcmtzW19pNF0sIHRvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVGV4dE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVGV4dE5vZGUoZG9tKSB7XG4gICAgICB2YXIgdmFsdWUgPSBkb20ubm9kZVZhbHVlO1xuICAgICAgdmFyIHRvcCA9IHRoaXMudG9wO1xuXG4gICAgICBpZiAodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCB8fCB0b3AuaW5saW5lQ29udGV4dChkb20pIHx8IC9bXiBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCEodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bIFxcdFxcclxcblxcdTAwMGNdKy9nLCBcIiBcIik7XG5cbiAgICAgICAgICBpZiAoL15bIFxcdFxcclxcblxcdTAwMGNdLy50ZXN0KHZhbHVlKSAmJiB0aGlzLm9wZW4gPT0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUJlZm9yZSA9IHRvcC5jb250ZW50W3RvcC5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIGRvbU5vZGVCZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKCFub2RlQmVmb3JlIHx8IGRvbU5vZGVCZWZvcmUgJiYgZG9tTm9kZUJlZm9yZS5ub2RlTmFtZSA9PSAnQlInIHx8IG5vZGVCZWZvcmUuaXNUZXh0ICYmIC9bIFxcdFxcclxcblxcdTAwMGNdJC8udGVzdChub2RlQmVmb3JlLnRleHQpKSB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTX0ZVTEwpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCBcIiBcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB0aGlzLmluc2VydE5vZGUodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQodmFsdWUpKTtcbiAgICAgICAgdGhpcy5maW5kSW5UZXh0KGRvbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFbGVtZW50KGRvbSwgbWF0Y2hBZnRlcikge1xuICAgICAgdmFyIG5hbWUgPSBkb20ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBydWxlSUQ7XG4gICAgICBpZiAobGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgdGhpcy5wYXJzZXIubm9ybWFsaXplTGlzdHMpIG5vcm1hbGl6ZUxpc3QoZG9tKTtcbiAgICAgIHZhciBydWxlID0gdGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZSAmJiB0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlKGRvbSkgfHwgKHJ1bGVJRCA9IHRoaXMucGFyc2VyLm1hdGNoVGFnKGRvbSwgdGhpcywgbWF0Y2hBZnRlcikpO1xuXG4gICAgICBpZiAocnVsZSA/IHJ1bGUuaWdub3JlIDogaWdub3JlVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgdGhpcy5pZ25vcmVGYWxsYmFjayhkb20pO1xuICAgICAgfSBlbHNlIGlmICghcnVsZSB8fCBydWxlLnNraXAgfHwgcnVsZS5jbG9zZVBhcmVudCkge1xuICAgICAgICBpZiAocnVsZSAmJiBydWxlLmNsb3NlUGFyZW50KSB0aGlzLm9wZW4gPSBNYXRoLm1heCgwLCB0aGlzLm9wZW4gLSAxKTtlbHNlIGlmIChydWxlICYmIHJ1bGUuc2tpcC5ub2RlVHlwZSkgZG9tID0gcnVsZS5za2lwO1xuICAgICAgICB2YXIgc3luYyxcbiAgICAgICAgICAgIHRvcCA9IHRoaXMudG9wLFxuICAgICAgICAgICAgb2xkTmVlZHNCbG9jayA9IHRoaXMubmVlZHNCbG9jaztcblxuICAgICAgICBpZiAoYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgc3luYyA9IHRydWU7XG4gICAgICAgICAgaWYgKCF0b3AudHlwZSkgdGhpcy5uZWVkc0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkQWxsKGRvbSk7XG4gICAgICAgIGlmIChzeW5jKSB0aGlzLnN5bmModG9wKTtcbiAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gb2xkTmVlZHNCbG9jaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSA/IHJ1bGVJRCA6IHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlYWZGYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWFmRmFsbGJhY2soZG9tKSB7XG4gICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiB0aGlzLnRvcC50eXBlICYmIHRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudCkgdGhpcy5hZGRUZXh0Tm9kZShkb20ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlnbm9yZUZhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlnbm9yZUZhbGxiYWNrKGRvbSkge1xuICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgKCF0aGlzLnRvcC50eXBlIHx8ICF0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpKSB0aGlzLmZpbmRQbGFjZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dChcIi1cIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWFkU3R5bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRTdHlsZXMoc3R5bGVzKSB7XG4gICAgICB2YXIgbWFya3MgPSBNYXJrLm5vbmU7XG5cbiAgICAgIHN0eWxlOiBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBmb3IgKHZhciBhZnRlciA9IHVuZGVmaW5lZDs7KSB7XG4gICAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLnBhcnNlci5tYXRjaFN0eWxlKHN0eWxlc1tpXSwgc3R5bGVzW2kgKyAxXSwgdGhpcywgYWZ0ZXIpO1xuICAgICAgICAgIGlmICghcnVsZSkgY29udGludWUgc3R5bGU7XG4gICAgICAgICAgaWYgKHJ1bGUuaWdub3JlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBtYXJrcyA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdLmNyZWF0ZShydWxlLmF0dHJzKS5hZGRUb1NldChtYXJrcyk7XG4gICAgICAgICAgaWYgKHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSkgYWZ0ZXIgPSBydWxlO2Vsc2UgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFbGVtZW50QnlSdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVsZW1lbnRCeVJ1bGUoZG9tLCBydWxlLCBjb250aW51ZUFmdGVyKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHN5bmMsIG5vZGVUeXBlLCBtYXJrO1xuXG4gICAgICBpZiAocnVsZS5ub2RlKSB7XG4gICAgICAgIG5vZGVUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW3J1bGUubm9kZV07XG5cbiAgICAgICAgaWYgKCFub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgICBzeW5jID0gdGhpcy5lbnRlcihub2RlVHlwZSwgcnVsZS5hdHRycyB8fCBudWxsLCBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaW5zZXJ0Tm9kZShub2RlVHlwZS5jcmVhdGUocnVsZS5hdHRycykpKSB7XG4gICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1hcmtUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya107XG4gICAgICAgIG1hcmsgPSBtYXJrVHlwZS5jcmVhdGUocnVsZS5hdHRycyk7XG4gICAgICAgIHRoaXMuYWRkUGVuZGluZ01hcmsobWFyayk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydEluID0gdGhpcy50b3A7XG5cbiAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50KGRvbSwgY29udGludWVBZnRlcik7XG4gICAgICB9IGVsc2UgaWYgKHJ1bGUuZ2V0Q29udGVudCkge1xuICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgcnVsZS5nZXRDb250ZW50KGRvbSwgdGhpcy5wYXJzZXIuc2NoZW1hKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb250ZW50RE9NID0gZG9tO1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJzdHJpbmdcIikgY29udGVudERPTSA9IGRvbS5xdWVyeVNlbGVjdG9yKHJ1bGUuY29udGVudEVsZW1lbnQpO2Vsc2UgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwiZnVuY3Rpb25cIikgY29udGVudERPTSA9IHJ1bGUuY29udGVudEVsZW1lbnQoZG9tKTtlbHNlIGlmIChydWxlLmNvbnRlbnRFbGVtZW50KSBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkQWxsKGNvbnRlbnRET00pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3luYyAmJiB0aGlzLnN5bmMoc3RhcnRJbikpIHRoaXMub3Blbi0tO1xuICAgICAgaWYgKG1hcmspIHRoaXMucmVtb3ZlUGVuZGluZ01hcmsobWFyaywgc3RhcnRJbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBbGwocGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuXG4gICAgICBmb3IgKHZhciBkb20gPSBzdGFydEluZGV4ID8gcGFyZW50LmNoaWxkTm9kZXNbc3RhcnRJbmRleF0gOiBwYXJlbnQuZmlyc3RDaGlsZCwgZW5kID0gZW5kSW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnQuY2hpbGROb2Rlc1tlbmRJbmRleF07IGRvbSAhPSBlbmQ7IGRvbSA9IGRvbS5uZXh0U2libGluZywgKytpbmRleCkge1xuICAgICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgICAgICB0aGlzLmFkZERPTShkb20pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kUGxhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFBsYWNlKG5vZGUpIHtcbiAgICAgIHZhciByb3V0ZSwgc3luYztcblxuICAgICAgZm9yICh2YXIgZGVwdGggPSB0aGlzLm9wZW47IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgdmFyIGN4ID0gdGhpcy5ub2Rlc1tkZXB0aF07XG5cbiAgICAgICAgdmFyIF9mb3VuZDIgPSBjeC5maW5kV3JhcHBpbmcobm9kZSk7XG5cbiAgICAgICAgaWYgKF9mb3VuZDIgJiYgKCFyb3V0ZSB8fCByb3V0ZS5sZW5ndGggPiBfZm91bmQyLmxlbmd0aCkpIHtcbiAgICAgICAgICByb3V0ZSA9IF9mb3VuZDI7XG4gICAgICAgICAgc3luYyA9IGN4O1xuICAgICAgICAgIGlmICghX2ZvdW5kMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN4LnNvbGlkKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb3V0ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy5zeW5jKHN5bmMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZW50ZXJJbm5lcihyb3V0ZVtpXSwgbnVsbCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnROb2RlKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmlzSW5saW5lICYmIHRoaXMubmVlZHNCbG9jayAmJiAhdGhpcy50b3AudHlwZSkge1xuICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLnRleHRibG9ja0Zyb21Db250ZXh0KCk7XG4gICAgICAgIGlmIChibG9jaykgdGhpcy5lbnRlcklubmVyKGJsb2NrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmluZFBsYWNlKG5vZGUpKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICB2YXIgdG9wID0gdGhpcy50b3A7XG4gICAgICAgIHRvcC5hcHBseVBlbmRpbmcobm9kZS50eXBlKTtcbiAgICAgICAgaWYgKHRvcC5tYXRjaCkgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZShub2RlLnR5cGUpO1xuICAgICAgICB2YXIgbWFya3MgPSB0b3AuYWN0aXZlTWFya3M7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLm1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCF0b3AudHlwZSB8fCB0b3AudHlwZS5hbGxvd3NNYXJrVHlwZShub2RlLm1hcmtzW2ldLnR5cGUpKSBtYXJrcyA9IG5vZGUubWFya3NbaV0uYWRkVG9TZXQobWFya3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9wLmNvbnRlbnQucHVzaChub2RlLm1hcmsobWFya3MpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW50ZXIodHlwZSwgYXR0cnMsIHByZXNlcnZlV1MpIHtcbiAgICAgIHZhciBvayA9IHRoaXMuZmluZFBsYWNlKHR5cGUuY3JlYXRlKGF0dHJzKSk7XG4gICAgICBpZiAob2spIHRoaXMuZW50ZXJJbm5lcih0eXBlLCBhdHRycywgdHJ1ZSwgcHJlc2VydmVXUyk7XG4gICAgICByZXR1cm4gb2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVudGVySW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW50ZXJJbm5lcih0eXBlKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICB2YXIgc29saWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIHByZXNlcnZlV1MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgdmFyIHRvcCA9IHRoaXMudG9wO1xuICAgICAgdG9wLmFwcGx5UGVuZGluZyh0eXBlKTtcbiAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaCAmJiB0b3AubWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXUywgdG9wLm9wdGlvbnMpO1xuICAgICAgaWYgKHRvcC5vcHRpb25zICYgT1BUX09QRU5fTEVGVCAmJiB0b3AuY29udGVudC5sZW5ndGggPT0gMCkgb3B0aW9ucyB8PSBPUFRfT1BFTl9MRUZUO1xuICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBOb2RlQ29udGV4dCh0eXBlLCBhdHRycywgdG9wLmFjdGl2ZU1hcmtzLCB0b3AucGVuZGluZ01hcmtzLCBzb2xpZCwgbnVsbCwgb3B0aW9ucykpO1xuICAgICAgdGhpcy5vcGVuKys7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlRXh0cmFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VFeHRyYSgpIHtcbiAgICAgIHZhciBvcGVuRW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIHZhciBpID0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxO1xuXG4gICAgICBpZiAoaSA+IHRoaXMub3Blbikge1xuICAgICAgICBmb3IgKDsgaSA+IHRoaXMub3BlbjsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5ub2Rlc1tpIC0gMV0uY29udGVudC5wdXNoKHRoaXMubm9kZXNbaV0uZmluaXNoKG9wZW5FbmQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubm9kZXMubGVuZ3RoID0gdGhpcy5vcGVuICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluaXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgIHRoaXMub3BlbiA9IDA7XG4gICAgICB0aGlzLmNsb3NlRXh0cmEodGhpcy5pc09wZW4pO1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF0uZmluaXNoKHRoaXMuaXNPcGVuIHx8IHRoaXMub3B0aW9ucy50b3BPcGVuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3luY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW5jKHRvKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSA9PSB0bykge1xuICAgICAgICAgIHRoaXMub3BlbiA9IGk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXJyZW50UG9zXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgIHZhciBwb3MgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGVudCA9IHRoaXMubm9kZXNbaV0uY29udGVudDtcblxuICAgICAgICBmb3IgKHZhciBqID0gY29udGVudC5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHBvcyArPSBjb250ZW50W2pdLm5vZGVTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkpIHBvcysrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQXRQb2ludChwYXJlbnQsIG9mZnNldCkge1xuICAgICAgaWYgKHRoaXMuZmluZCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHBhcmVudCAmJiB0aGlzLmZpbmRbaV0ub2Zmc2V0ID09IG9mZnNldCkgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEluc2lkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kSW5zaWRlKHBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuZmluZCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKSB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQXJvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRBcm91bmQocGFyZW50LCBjb250ZW50LCBiZWZvcmUpIHtcbiAgICAgIGlmIChwYXJlbnQgIT0gY29udGVudCAmJiB0aGlzLmZpbmQpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSkge1xuICAgICAgICAgIHZhciBwb3MgPSBjb250ZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuZmluZFtpXS5ub2RlKTtcbiAgICAgICAgICBpZiAocG9zICYgKGJlZm9yZSA/IDIgOiA0KSkgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kSW5UZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRJblRleHQodGV4dE5vZGUpIHtcbiAgICAgIGlmICh0aGlzLmZpbmQpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSB0ZXh0Tm9kZSkgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcyAtICh0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gdGhpcy5maW5kW2ldLm9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoZXNDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoZXNDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAoY29udGV4dC5pbmRleE9mKFwifFwiKSA+IC0xKSByZXR1cm4gY29udGV4dC5zcGxpdCgvXFxzKlxcfFxccyovKS5zb21lKHRoaXMubWF0Y2hlc0NvbnRleHQsIHRoaXMpO1xuICAgICAgdmFyIHBhcnRzID0gY29udGV4dC5zcGxpdChcIi9cIik7XG4gICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gICAgICB2YXIgdXNlUm9vdCA9ICF0aGlzLmlzT3BlbiAmJiAoIW9wdGlvbiB8fCBvcHRpb24ucGFyZW50LnR5cGUgPT0gdGhpcy5ub2Rlc1swXS50eXBlKTtcbiAgICAgIHZhciBtaW5EZXB0aCA9IC0ob3B0aW9uID8gb3B0aW9uLmRlcHRoICsgMSA6IDApICsgKHVzZVJvb3QgPyAwIDogMSk7XG5cbiAgICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKGksIGRlcHRoKSB7XG4gICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgICBpZiAocGFydCA9PSBcIlwiKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBwYXJ0cy5sZW5ndGggLSAxIHx8IGkgPT0gMCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGZvciAoOyBkZXB0aCA+PSBtaW5EZXB0aDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgICBpZiAobWF0Y2goaSAtIDEsIGRlcHRoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBkZXB0aCA+IDAgfHwgZGVwdGggPT0gMCAmJiB1c2VSb290ID8gX3RoaXM0Lm5vZGVzW2RlcHRoXS50eXBlIDogb3B0aW9uICYmIGRlcHRoID49IG1pbkRlcHRoID8gb3B0aW9uLm5vZGUoZGVwdGggLSBtaW5EZXB0aCkudHlwZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5uYW1lICE9IHBhcnQgJiYgbmV4dC5ncm91cHMuaW5kZXhPZihwYXJ0KSA9PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBtYXRjaChwYXJ0cy5sZW5ndGggLSAxLCB0aGlzLm9wZW4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0YmxvY2tGcm9tQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0YmxvY2tGcm9tQ29udGV4dCgpIHtcbiAgICAgIHZhciAkY29udGV4dCA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgaWYgKCRjb250ZXh0KSBmb3IgKHZhciBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIHZhciBkZWZsdCA9ICRjb250ZXh0Lm5vZGUoZCkuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXhBZnRlcihkKSkuZGVmYXVsdFR5cGU7XG4gICAgICAgIGlmIChkZWZsdCAmJiBkZWZsdC5pc1RleHRibG9jayAmJiBkZWZsdC5kZWZhdWx0QXR0cnMpIHJldHVybiBkZWZsdDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXMpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXNbbmFtZV07XG4gICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmIHR5cGUuZGVmYXVsdEF0dHJzKSByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUGVuZGluZ01hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUGVuZGluZ01hcmsobWFyaykge1xuICAgICAgdmFyIGZvdW5kID0gZmluZFNhbWVNYXJrSW5TZXQobWFyaywgdGhpcy50b3AucGVuZGluZ01hcmtzKTtcbiAgICAgIGlmIChmb3VuZCkgdGhpcy50b3Auc3Rhc2hNYXJrcy5wdXNoKGZvdW5kKTtcbiAgICAgIHRoaXMudG9wLnBlbmRpbmdNYXJrcyA9IG1hcmsuYWRkVG9TZXQodGhpcy50b3AucGVuZGluZ01hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlUGVuZGluZ01hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlUGVuZGluZ01hcmsobWFyaywgdXB0bykge1xuICAgICAgZm9yICh2YXIgZGVwdGggPSB0aGlzLm9wZW47IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5ub2Rlc1tkZXB0aF07XG5cbiAgICAgICAgdmFyIF9mb3VuZDMgPSBsZXZlbC5wZW5kaW5nTWFya3MubGFzdEluZGV4T2YobWFyayk7XG5cbiAgICAgICAgaWYgKF9mb3VuZDMgPiAtMSkge1xuICAgICAgICAgIGxldmVsLnBlbmRpbmdNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldChsZXZlbC5wZW5kaW5nTWFya3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldmVsLmFjdGl2ZU1hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KGxldmVsLmFjdGl2ZU1hcmtzKTtcbiAgICAgICAgICB2YXIgc3Rhc2hNYXJrID0gbGV2ZWwucG9wRnJvbVN0YXNoTWFyayhtYXJrKTtcbiAgICAgICAgICBpZiAoc3Rhc2hNYXJrICYmIGxldmVsLnR5cGUgJiYgbGV2ZWwudHlwZS5hbGxvd3NNYXJrVHlwZShzdGFzaE1hcmsudHlwZSkpIGxldmVsLmFjdGl2ZU1hcmtzID0gc3Rhc2hNYXJrLmFkZFRvU2V0KGxldmVsLmFjdGl2ZU1hcmtzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXZlbCA9PSB1cHRvKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFyc2VDb250ZXh0O1xufSgpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVMaXN0KGRvbSkge1xuICBmb3IgKHZhciBjaGlsZCA9IGRvbS5maXJzdENoaWxkLCBwcmV2SXRlbSA9IG51bGw7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgdmFyIG5hbWUgPSBjaGlsZC5ub2RlVHlwZSA9PSAxID8gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cbiAgICBpZiAobmFtZSAmJiBsaXN0VGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBwcmV2SXRlbSkge1xuICAgICAgcHJldkl0ZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgY2hpbGQgPSBwcmV2SXRlbTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJsaVwiKSB7XG4gICAgICBwcmV2SXRlbSA9IGNoaWxkO1xuICAgIH0gZWxzZSBpZiAobmFtZSkge1xuICAgICAgcHJldkl0ZW0gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzKGRvbSwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIChkb20ubWF0Y2hlcyB8fCBkb20ubXNNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBkb20ubW96TWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGRvbSwgc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0eWxlcyhzdHlsZSkge1xuICB2YXIgcmUgPSAvXFxzKihbXFx3LV0rKVxccyo6XFxzKihbXjtdKykvZyxcbiAgICAgIG0sXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAobSA9IHJlLmV4ZWMoc3R5bGUpKSB7XG4gICAgcmVzdWx0LnB1c2gobVsxXSwgbVsyXS50cmltKCkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY29weShvYmopIHtcbiAgdmFyIGNvcHkgPSB7fTtcblxuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gIH1cblxuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gbWFya01heUFwcGx5KG1hcmtUeXBlLCBub2RlVHlwZSkge1xuICB2YXIgbm9kZXMgPSBub2RlVHlwZS5zY2hlbWEubm9kZXM7XG5cbiAgdmFyIF9sb29wNCA9IGZ1bmN0aW9uIF9sb29wNChuYW1lKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVzW25hbWVdO1xuICAgIGlmICghcGFyZW50LmFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSkgcmV0dXJuIFwiY29udGludWVcIjtcblxuICAgIHZhciBzZWVuID0gW10sXG4gICAgICAgIHNjYW4gPSBmdW5jdGlvbiBzY2FuKG1hdGNoKSB7XG4gICAgICBzZWVuLnB1c2gobWF0Y2gpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBfbWF0Y2gkZWRnZSA9IG1hdGNoLmVkZ2UoaSksXG4gICAgICAgICAgICB0eXBlID0gX21hdGNoJGVkZ2UudHlwZSxcbiAgICAgICAgICAgIG5leHQgPSBfbWF0Y2gkZWRnZS5uZXh0O1xuXG4gICAgICAgIGlmICh0eXBlID09IG5vZGVUeXBlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihuZXh0KSA8IDAgJiYgc2NhbihuZXh0KSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzY2FuKHBhcmVudC5jb250ZW50TWF0Y2gpKSByZXR1cm4ge1xuICAgICAgdjogdHJ1ZVxuICAgIH07XG4gIH07XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBub2Rlcykge1xuICAgIHZhciBfcmV0ID0gX2xvb3A0KG5hbWUpO1xuXG4gICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgaWYgKF90eXBlb2YoX3JldCkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFNhbWVNYXJrSW5TZXQobWFyaywgc2V0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1hcmsuZXEoc2V0W2ldKSkgcmV0dXJuIHNldFtpXTtcbiAgfVxufVxuXG52YXIgRE9NU2VyaWFsaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRE9NU2VyaWFsaXplcihub2RlcywgbWFya3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRE9NU2VyaWFsaXplcik7XG5cbiAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERPTVNlcmlhbGl6ZXIsIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZUZyYWdtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIHRhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCF0YXJnZXQpIHRhcmdldCA9IGRvYyhvcHRpb25zKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICB2YXIgdG9wID0gdGFyZ2V0LFxuICAgICAgICAgIGFjdGl2ZSA9IFtdO1xuICAgICAgZnJhZ21lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCB8fCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBrZWVwID0gMCxcbiAgICAgICAgICAgICAgcmVuZGVyZWQgPSAwO1xuXG4gICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoICYmIHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gbm9kZS5tYXJrc1tyZW5kZXJlZF07XG5cbiAgICAgICAgICAgIGlmICghX3RoaXM1Lm1hcmtzW25leHQudHlwZS5uYW1lXSkge1xuICAgICAgICAgICAgICByZW5kZXJlZCsrO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFuZXh0LmVxKGFjdGl2ZVtrZWVwXVswXSkgfHwgbmV4dC50eXBlLnNwZWMuc3Bhbm5pbmcgPT09IGZhbHNlKSBicmVhaztcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b3AgPSBhY3RpdmUucG9wKClbMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBhZGQgPSBub2RlLm1hcmtzW3JlbmRlcmVkKytdO1xuXG4gICAgICAgICAgICB2YXIgbWFya0RPTSA9IF90aGlzNS5zZXJpYWxpemVNYXJrKGFkZCwgbm9kZS5pc0lubGluZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmIChtYXJrRE9NKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKFthZGQsIHRvcF0pO1xuICAgICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQobWFya0RPTS5kb20pO1xuICAgICAgICAgICAgICB0b3AgPSBtYXJrRE9NLmNvbnRlbnRET00gfHwgbWFya0RPTS5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdG9wLmFwcGVuZENoaWxkKF90aGlzNS5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVOb2RlSW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfRE9NU2VyaWFsaXplciRyZW5kZXIgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0aGlzLm5vZGVzW25vZGUudHlwZS5uYW1lXShub2RlKSksXG4gICAgICAgICAgZG9tID0gX0RPTVNlcmlhbGl6ZXIkcmVuZGVyLmRvbSxcbiAgICAgICAgICBjb250ZW50RE9NID0gX0RPTVNlcmlhbGl6ZXIkcmVuZGVyLmNvbnRlbnRET007XG5cbiAgICAgIGlmIChjb250ZW50RE9NKSB7XG4gICAgICAgIGlmIChub2RlLmlzTGVhZikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbm90IGFsbG93ZWQgaW4gYSBsZWFmIG5vZGUgc3BlY1wiKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVGcmFnbWVudChub2RlLmNvbnRlbnQsIG9wdGlvbnMsIGNvbnRlbnRET00pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGUobm9kZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGRvbSA9IHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gbm9kZS5tYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgd3JhcCA9IHRoaXMuc2VyaWFsaXplTWFyayhub2RlLm1hcmtzW2ldLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAod3JhcCkge1xuICAgICAgICAgICh3cmFwLmNvbnRlbnRET00gfHwgd3JhcC5kb20pLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgZG9tID0gd3JhcC5kb207XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplTWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemVNYXJrKG1hcmssIGlubGluZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIHRvRE9NID0gdGhpcy5tYXJrc1ttYXJrLnR5cGUubmFtZV07XG4gICAgICByZXR1cm4gdG9ET00gJiYgRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdG9ET00obWFyaywgaW5saW5lKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicmVuZGVyU3BlY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlKSB7XG4gICAgICB2YXIgeG1sTlMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHN0cnVjdHVyZSA9PSBcInN0cmluZ1wiKSByZXR1cm4ge1xuICAgICAgICBkb206IGRvYy5jcmVhdGVUZXh0Tm9kZShzdHJ1Y3R1cmUpXG4gICAgICB9O1xuICAgICAgaWYgKHN0cnVjdHVyZS5ub2RlVHlwZSAhPSBudWxsKSByZXR1cm4ge1xuICAgICAgICBkb206IHN0cnVjdHVyZVxuICAgICAgfTtcbiAgICAgIGlmIChzdHJ1Y3R1cmUuZG9tICYmIHN0cnVjdHVyZS5kb20ubm9kZVR5cGUgIT0gbnVsbCkgcmV0dXJuIHN0cnVjdHVyZTtcbiAgICAgIHZhciB0YWdOYW1lID0gc3RydWN0dXJlWzBdLFxuICAgICAgICAgIHNwYWNlID0gdGFnTmFtZS5pbmRleE9mKFwiIFwiKTtcblxuICAgICAgaWYgKHNwYWNlID4gMCkge1xuICAgICAgICB4bWxOUyA9IHRhZ05hbWUuc2xpY2UoMCwgc3BhY2UpO1xuICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zbGljZShzcGFjZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGVudERPTTtcbiAgICAgIHZhciBkb20gPSB4bWxOUyA/IGRvYy5jcmVhdGVFbGVtZW50TlMoeG1sTlMsIHRhZ05hbWUpIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICB2YXIgYXR0cnMgPSBzdHJ1Y3R1cmVbMV0sXG4gICAgICAgICAgc3RhcnQgPSAxO1xuXG4gICAgICBpZiAoYXR0cnMgJiYgX3R5cGVvZihhdHRycykgPT0gXCJvYmplY3RcIiAmJiBhdHRycy5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuICAgICAgICBzdGFydCA9IDI7XG5cbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBhdHRycykge1xuICAgICAgICAgIGlmIChhdHRyc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX3NwYWNlID0gbmFtZS5pbmRleE9mKFwiIFwiKTtcblxuICAgICAgICAgICAgaWYgKF9zcGFjZSA+IDApIGRvbS5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNsaWNlKDAsIF9zcGFjZSksIG5hbWUuc2xpY2UoX3NwYWNlICsgMSksIGF0dHJzW25hbWVdKTtlbHNlIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzdHJ1Y3R1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gc3RydWN0dXJlW2ldO1xuXG4gICAgICAgIGlmIChjaGlsZCA9PT0gMCkge1xuICAgICAgICAgIGlmIChpIDwgc3RydWN0dXJlLmxlbmd0aCAtIDEgfHwgaSA+IHN0YXJ0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBtdXN0IGJlIHRoZSBvbmx5IGNoaWxkIG9mIGl0cyBwYXJlbnQgbm9kZVwiKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9tOiBkb20sXG4gICAgICAgICAgICBjb250ZW50RE9NOiBkb21cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfRE9NU2VyaWFsaXplciRyZW5kZXIyID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvYywgY2hpbGQsIHhtbE5TKSxcbiAgICAgICAgICAgICAgaW5uZXIgPSBfRE9NU2VyaWFsaXplciRyZW5kZXIyLmRvbSxcbiAgICAgICAgICAgICAgaW5uZXJDb250ZW50ID0gX0RPTVNlcmlhbGl6ZXIkcmVuZGVyMi5jb250ZW50RE9NO1xuXG4gICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGlubmVyKTtcblxuICAgICAgICAgIGlmIChpbm5lckNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50RE9NKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11bHRpcGxlIGNvbnRlbnQgaG9sZXNcIik7XG4gICAgICAgICAgICBjb250ZW50RE9NID0gaW5uZXJDb250ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb206IGRvbSxcbiAgICAgICAgY29udGVudERPTTogY29udGVudERPTVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVNjaGVtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tU2VyaWFsaXplciB8fCAoc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyID0gbmV3IERPTVNlcmlhbGl6ZXIodGhpcy5ub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSwgdGhpcy5tYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2Rlc0Zyb21TY2hlbWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZXNGcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdhdGhlclRvRE9NKHNjaGVtYS5ub2Rlcyk7XG4gICAgICBpZiAoIXJlc3VsdC50ZXh0KSByZXN1bHQudGV4dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnRleHQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya3NGcm9tU2NoZW1hXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgIHJldHVybiBnYXRoZXJUb0RPTShzY2hlbWEubWFya3MpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBET01TZXJpYWxpemVyO1xufSgpO1xuXG5mdW5jdGlvbiBnYXRoZXJUb0RPTShvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG4gICAgdmFyIHRvRE9NID0gb2JqW25hbWVdLnNwZWMudG9ET007XG4gICAgaWYgKHRvRE9NKSByZXN1bHRbbmFtZV0gPSB0b0RPTTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGRvYyhvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudDtcbn1cblxuZXhwb3J0cy5Db250ZW50TWF0Y2ggPSBDb250ZW50TWF0Y2g7XG5leHBvcnRzLkRPTVBhcnNlciA9IERPTVBhcnNlcjtcbmV4cG9ydHMuRE9NU2VyaWFsaXplciA9IERPTVNlcmlhbGl6ZXI7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLk1hcmsgPSBNYXJrO1xuZXhwb3J0cy5NYXJrVHlwZSA9IE1hcmtUeXBlO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbmV4cG9ydHMuTm9kZVJhbmdlID0gTm9kZVJhbmdlO1xuZXhwb3J0cy5Ob2RlVHlwZSA9IE5vZGVUeXBlO1xuZXhwb3J0cy5SZXBsYWNlRXJyb3IgPSBSZXBsYWNlRXJyb3I7XG5leHBvcnRzLlJlc29sdmVkUG9zID0gUmVzb2x2ZWRQb3M7XG5leHBvcnRzLlNjaGVtYSA9IFNjaGVtYTtcbmV4cG9ydHMuU2xpY2UgPSBTbGljZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBwcm9zZW1pcnJvck1vZGVsID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItbW9kZWwnKTtcblxudmFyIHBET00gPSBbXCJwXCIsIDBdLFxuICAgIGJsb2NrcXVvdGVET00gPSBbXCJibG9ja3F1b3RlXCIsIDBdLFxuICAgIGhyRE9NID0gW1wiaHJcIl0sXG4gICAgcHJlRE9NID0gW1wicHJlXCIsIFtcImNvZGVcIiwgMF1dLFxuICAgIGJyRE9NID0gW1wiYnJcIl07XG52YXIgbm9kZXMgPSB7XG4gIGRvYzoge1xuICAgIGNvbnRlbnQ6IFwiYmxvY2srXCJcbiAgfSxcbiAgcGFyYWdyYXBoOiB7XG4gICAgY29udGVudDogXCJpbmxpbmUqXCIsXG4gICAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgICBwYXJzZURPTTogW3tcbiAgICAgIHRhZzogXCJwXCJcbiAgICB9XSxcbiAgICB0b0RPTTogZnVuY3Rpb24gdG9ET00oKSB7XG4gICAgICByZXR1cm4gcERPTTtcbiAgICB9XG4gIH0sXG4gIGJsb2NrcXVvdGU6IHtcbiAgICBjb250ZW50OiBcImJsb2NrK1wiLFxuICAgIGdyb3VwOiBcImJsb2NrXCIsXG4gICAgZGVmaW5pbmc6IHRydWUsXG4gICAgcGFyc2VET006IFt7XG4gICAgICB0YWc6IFwiYmxvY2txdW90ZVwiXG4gICAgfV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkge1xuICAgICAgcmV0dXJuIGJsb2NrcXVvdGVET007XG4gICAgfVxuICB9LFxuICBob3Jpem9udGFsX3J1bGU6IHtcbiAgICBncm91cDogXCJibG9ja1wiLFxuICAgIHBhcnNlRE9NOiBbe1xuICAgICAgdGFnOiBcImhyXCJcbiAgICB9XSxcbiAgICB0b0RPTTogZnVuY3Rpb24gdG9ET00oKSB7XG4gICAgICByZXR1cm4gaHJET007XG4gICAgfVxuICB9LFxuICBoZWFkaW5nOiB7XG4gICAgYXR0cnM6IHtcbiAgICAgIGxldmVsOiB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiAxXG4gICAgICB9XG4gICAgfSxcbiAgICBjb250ZW50OiBcImlubGluZSpcIixcbiAgICBncm91cDogXCJibG9ja1wiLFxuICAgIGRlZmluaW5nOiB0cnVlLFxuICAgIHBhcnNlRE9NOiBbe1xuICAgICAgdGFnOiBcImgxXCIsXG4gICAgICBhdHRyczoge1xuICAgICAgICBsZXZlbDogMVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJoMlwiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgbGV2ZWw6IDJcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB0YWc6IFwiaDNcIixcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIGxldmVsOiAzXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgdGFnOiBcImg0XCIsXG4gICAgICBhdHRyczoge1xuICAgICAgICBsZXZlbDogNFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJoNVwiLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgbGV2ZWw6IDVcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB0YWc6IFwiaDZcIixcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIGxldmVsOiA2XG4gICAgICB9XG4gICAgfV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKG5vZGUpIHtcbiAgICAgIHJldHVybiBbXCJoXCIgKyBub2RlLmF0dHJzLmxldmVsLCAwXTtcbiAgICB9XG4gIH0sXG4gIGNvZGVfYmxvY2s6IHtcbiAgICBjb250ZW50OiBcInRleHQqXCIsXG4gICAgbWFya3M6IFwiXCIsXG4gICAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgICBjb2RlOiB0cnVlLFxuICAgIGRlZmluaW5nOiB0cnVlLFxuICAgIHBhcnNlRE9NOiBbe1xuICAgICAgdGFnOiBcInByZVwiLFxuICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiBcImZ1bGxcIlxuICAgIH1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHtcbiAgICAgIHJldHVybiBwcmVET007XG4gICAgfVxuICB9LFxuICB0ZXh0OiB7XG4gICAgZ3JvdXA6IFwiaW5saW5lXCJcbiAgfSxcbiAgaW1hZ2U6IHtcbiAgICBpbmxpbmU6IHRydWUsXG4gICAgYXR0cnM6IHtcbiAgICAgIHNyYzoge30sXG4gICAgICBhbHQ6IHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IG51bGxcbiAgICAgIH0sXG4gICAgICB0aXRsZToge1xuICAgICAgICBcImRlZmF1bHRcIjogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgZ3JvdXA6IFwiaW5saW5lXCIsXG4gICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgIHBhcnNlRE9NOiBbe1xuICAgICAgdGFnOiBcImltZ1tzcmNdXCIsXG4gICAgICBnZXRBdHRyczogZnVuY3Rpb24gZ2V0QXR0cnMoZG9tKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3JjOiBkb20uZ2V0QXR0cmlidXRlKFwic3JjXCIpLFxuICAgICAgICAgIHRpdGxlOiBkb20uZ2V0QXR0cmlidXRlKFwidGl0bGVcIiksXG4gICAgICAgICAgYWx0OiBkb20uZ2V0QXR0cmlidXRlKFwiYWx0XCIpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKG5vZGUpIHtcbiAgICAgIHZhciBfbm9kZSRhdHRycyA9IG5vZGUuYXR0cnMsXG4gICAgICAgICAgc3JjID0gX25vZGUkYXR0cnMuc3JjLFxuICAgICAgICAgIGFsdCA9IF9ub2RlJGF0dHJzLmFsdCxcbiAgICAgICAgICB0aXRsZSA9IF9ub2RlJGF0dHJzLnRpdGxlO1xuICAgICAgcmV0dXJuIFtcImltZ1wiLCB7XG4gICAgICAgIHNyYzogc3JjLFxuICAgICAgICBhbHQ6IGFsdCxcbiAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICB9XTtcbiAgICB9XG4gIH0sXG4gIGhhcmRfYnJlYWs6IHtcbiAgICBpbmxpbmU6IHRydWUsXG4gICAgZ3JvdXA6IFwiaW5saW5lXCIsXG4gICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgcGFyc2VET006IFt7XG4gICAgICB0YWc6IFwiYnJcIlxuICAgIH1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHtcbiAgICAgIHJldHVybiBickRPTTtcbiAgICB9XG4gIH1cbn07XG52YXIgZW1ET00gPSBbXCJlbVwiLCAwXSxcbiAgICBzdHJvbmdET00gPSBbXCJzdHJvbmdcIiwgMF0sXG4gICAgY29kZURPTSA9IFtcImNvZGVcIiwgMF07XG52YXIgbWFya3MgPSB7XG4gIGxpbms6IHtcbiAgICBhdHRyczoge1xuICAgICAgaHJlZjoge30sXG4gICAgICB0aXRsZToge1xuICAgICAgICBcImRlZmF1bHRcIjogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICBwYXJzZURPTTogW3tcbiAgICAgIHRhZzogXCJhW2hyZWZdXCIsXG4gICAgICBnZXRBdHRyczogZnVuY3Rpb24gZ2V0QXR0cnMoZG9tKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogZG9tLmdldEF0dHJpYnV0ZShcImhyZWZcIiksXG4gICAgICAgICAgdGl0bGU6IGRvbS5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTShub2RlKSB7XG4gICAgICB2YXIgX25vZGUkYXR0cnMyID0gbm9kZS5hdHRycyxcbiAgICAgICAgICBocmVmID0gX25vZGUkYXR0cnMyLmhyZWYsXG4gICAgICAgICAgdGl0bGUgPSBfbm9kZSRhdHRyczIudGl0bGU7XG4gICAgICByZXR1cm4gW1wiYVwiLCB7XG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgfSwgMF07XG4gICAgfVxuICB9LFxuICBlbToge1xuICAgIHBhcnNlRE9NOiBbe1xuICAgICAgdGFnOiBcImlcIlxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJlbVwiXG4gICAgfSwge1xuICAgICAgc3R5bGU6IFwiZm9udC1zdHlsZT1pdGFsaWNcIlxuICAgIH1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHtcbiAgICAgIHJldHVybiBlbURPTTtcbiAgICB9XG4gIH0sXG4gIHN0cm9uZzoge1xuICAgIHBhcnNlRE9NOiBbe1xuICAgICAgdGFnOiBcInN0cm9uZ1wiXG4gICAgfSwge1xuICAgICAgdGFnOiBcImJcIixcbiAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiBnZXRBdHRycyhub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnN0eWxlLmZvbnRXZWlnaHQgIT0gXCJub3JtYWxcIiAmJiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHN0eWxlOiBcImZvbnQtd2VpZ2h0XCIsXG4gICAgICBnZXRBdHRyczogZnVuY3Rpb24gZ2V0QXR0cnModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIC9eKGJvbGQoZXIpP3xbNS05XVxcZHsyLH0pJC8udGVzdCh2YWx1ZSkgJiYgbnVsbDtcbiAgICAgIH1cbiAgICB9XSxcbiAgICB0b0RPTTogZnVuY3Rpb24gdG9ET00oKSB7XG4gICAgICByZXR1cm4gc3Ryb25nRE9NO1xuICAgIH1cbiAgfSxcbiAgY29kZToge1xuICAgIHBhcnNlRE9NOiBbe1xuICAgICAgdGFnOiBcImNvZGVcIlxuICAgIH1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHtcbiAgICAgIHJldHVybiBjb2RlRE9NO1xuICAgIH1cbiAgfVxufTtcbnZhciBzY2hlbWEgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TY2hlbWEoe1xuICBub2Rlczogbm9kZXMsXG4gIG1hcmtzOiBtYXJrc1xufSk7XG5leHBvcnRzLm1hcmtzID0gbWFya3M7XG5leHBvcnRzLm5vZGVzID0gbm9kZXM7XG5leHBvcnRzLnNjaGVtYSA9IHNjaGVtYTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBwcm9zZW1pcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXRyYW5zZm9ybScpO1xuXG52YXIgcHJvc2VtaXJyb3JNb2RlbCA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLW1vZGVsJyk7XG5cbnZhciBwcm9zZW1pcnJvclN0YXRlID0gcmVxdWlyZSgncHJvc2VtaXJyb3Itc3RhdGUnKTtcblxudmFyIG9sRE9NID0gW1wib2xcIiwgMF0sXG4gICAgdWxET00gPSBbXCJ1bFwiLCAwXSxcbiAgICBsaURPTSA9IFtcImxpXCIsIDBdO1xudmFyIG9yZGVyZWRMaXN0ID0ge1xuICBhdHRyczoge1xuICAgIG9yZGVyOiB7XG4gICAgICBcImRlZmF1bHRcIjogMVxuICAgIH1cbiAgfSxcbiAgcGFyc2VET006IFt7XG4gICAgdGFnOiBcIm9sXCIsXG4gICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIGdldEF0dHJzKGRvbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JkZXI6IGRvbS5oYXNBdHRyaWJ1dGUoXCJzdGFydFwiKSA/ICtkb20uZ2V0QXR0cmlidXRlKFwic3RhcnRcIikgOiAxXG4gICAgICB9O1xuICAgIH1cbiAgfV0sXG4gIHRvRE9NOiBmdW5jdGlvbiB0b0RPTShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuYXR0cnMub3JkZXIgPT0gMSA/IG9sRE9NIDogW1wib2xcIiwge1xuICAgICAgc3RhcnQ6IG5vZGUuYXR0cnMub3JkZXJcbiAgICB9LCAwXTtcbiAgfVxufTtcbnZhciBidWxsZXRMaXN0ID0ge1xuICBwYXJzZURPTTogW3tcbiAgICB0YWc6IFwidWxcIlxuICB9XSxcbiAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkge1xuICAgIHJldHVybiB1bERPTTtcbiAgfVxufTtcbnZhciBsaXN0SXRlbSA9IHtcbiAgcGFyc2VET006IFt7XG4gICAgdGFnOiBcImxpXCJcbiAgfV0sXG4gIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHtcbiAgICByZXR1cm4gbGlET007XG4gIH0sXG4gIGRlZmluaW5nOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBhZGQob2JqLCBwcm9wcykge1xuICB2YXIgY29weSA9IHt9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgY29weVtwcm9wXSA9IG9ialtwcm9wXTtcbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wIGluIHByb3BzKSB7XG4gICAgY29weVtfcHJvcF0gPSBwcm9wc1tfcHJvcF07XG4gIH1cblxuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gYWRkTGlzdE5vZGVzKG5vZGVzLCBpdGVtQ29udGVudCwgbGlzdEdyb3VwKSB7XG4gIHJldHVybiBub2Rlcy5hcHBlbmQoe1xuICAgIG9yZGVyZWRfbGlzdDogYWRkKG9yZGVyZWRMaXN0LCB7XG4gICAgICBjb250ZW50OiBcImxpc3RfaXRlbStcIixcbiAgICAgIGdyb3VwOiBsaXN0R3JvdXBcbiAgICB9KSxcbiAgICBidWxsZXRfbGlzdDogYWRkKGJ1bGxldExpc3QsIHtcbiAgICAgIGNvbnRlbnQ6IFwibGlzdF9pdGVtK1wiLFxuICAgICAgZ3JvdXA6IGxpc3RHcm91cFxuICAgIH0pLFxuICAgIGxpc3RfaXRlbTogYWRkKGxpc3RJdGVtLCB7XG4gICAgICBjb250ZW50OiBpdGVtQ29udGVudFxuICAgIH0pXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cmFwSW5MaXN0KGxpc3RUeXBlKSB7XG4gIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgX3N0YXRlJHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uLiRmcm9tLFxuICAgICAgICAkdG8gPSBfc3RhdGUkc2VsZWN0aW9uLiR0bztcbiAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksXG4gICAgICAgIGRvSm9pbiA9IGZhbHNlLFxuICAgICAgICBvdXRlclJhbmdlID0gcmFuZ2U7XG4gICAgaWYgKCFyYW5nZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHJhbmdlLmRlcHRoID49IDIgJiYgJGZyb20ubm9kZShyYW5nZS5kZXB0aCAtIDEpLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobGlzdFR5cGUpICYmIHJhbmdlLnN0YXJ0SW5kZXggPT0gMCkge1xuICAgICAgaWYgKCRmcm9tLmluZGV4KHJhbmdlLmRlcHRoIC0gMSkgPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyICRpbnNlcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShyYW5nZS5zdGFydCAtIDIpO1xuICAgICAgb3V0ZXJSYW5nZSA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLk5vZGVSYW5nZSgkaW5zZXJ0LCAkaW5zZXJ0LCByYW5nZS5kZXB0aCk7XG4gICAgICBpZiAocmFuZ2UuZW5kSW5kZXggPCByYW5nZS5wYXJlbnQuY2hpbGRDb3VudCkgcmFuZ2UgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5Ob2RlUmFuZ2UoJGZyb20sIHN0YXRlLmRvYy5yZXNvbHZlKCR0by5lbmQocmFuZ2UuZGVwdGgpKSwgcmFuZ2UuZGVwdGgpO1xuICAgICAgZG9Kb2luID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgd3JhcCA9IHByb3NlbWlycm9yVHJhbnNmb3JtLmZpbmRXcmFwcGluZyhvdXRlclJhbmdlLCBsaXN0VHlwZSwgYXR0cnMsIHJhbmdlKTtcbiAgICBpZiAoIXdyYXApIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKGRvV3JhcEluTGlzdChzdGF0ZS50ciwgcmFuZ2UsIHdyYXAsIGRvSm9pbiwgbGlzdFR5cGUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkb1dyYXBJbkxpc3QodHIsIHJhbmdlLCB3cmFwcGVycywgam9pbkJlZm9yZSwgbGlzdFR5cGUpIHtcbiAgdmFyIGNvbnRlbnQgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5O1xuXG4gIGZvciAodmFyIGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnRlbnQgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgfVxuXG4gIHRyLnN0ZXAobmV3IHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VBcm91bmRTdGVwKHJhbmdlLnN0YXJ0IC0gKGpvaW5CZWZvcmUgPyAyIDogMCksIHJhbmdlLmVuZCwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xuICB2YXIgZm91bmQgPSAwO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCB3cmFwcGVycy5sZW5ndGg7IF9pKyspIHtcbiAgICBpZiAod3JhcHBlcnNbX2ldLnR5cGUgPT0gbGlzdFR5cGUpIGZvdW5kID0gX2kgKyAxO1xuICB9XG5cbiAgdmFyIHNwbGl0RGVwdGggPSB3cmFwcGVycy5sZW5ndGggLSBmb3VuZDtcbiAgdmFyIHNwbGl0UG9zID0gcmFuZ2Uuc3RhcnQgKyB3cmFwcGVycy5sZW5ndGggLSAoam9pbkJlZm9yZSA/IDIgOiAwKSxcbiAgICAgIHBhcmVudCA9IHJhbmdlLnBhcmVudDtcblxuICBmb3IgKHZhciBfaTIgPSByYW5nZS5zdGFydEluZGV4LCBlID0gcmFuZ2UuZW5kSW5kZXgsIGZpcnN0ID0gdHJ1ZTsgX2kyIDwgZTsgX2kyKyssIGZpcnN0ID0gZmFsc2UpIHtcbiAgICBpZiAoIWZpcnN0ICYmIHByb3NlbWlycm9yVHJhbnNmb3JtLmNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHNwbGl0RGVwdGgpKSB7XG4gICAgICB0ci5zcGxpdChzcGxpdFBvcywgc3BsaXREZXB0aCk7XG4gICAgICBzcGxpdFBvcyArPSAyICogc3BsaXREZXB0aDtcbiAgICB9XG5cbiAgICBzcGxpdFBvcyArPSBwYXJlbnQuY2hpbGQoX2kyKS5ub2RlU2l6ZTtcbiAgfVxuXG4gIHJldHVybiB0cjtcbn1cblxuZnVuY3Rpb24gc3BsaXRMaXN0SXRlbShpdGVtVHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciBfc3RhdGUkc2VsZWN0aW9uMiA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uMi4kZnJvbSxcbiAgICAgICAgJHRvID0gX3N0YXRlJHNlbGVjdGlvbjIuJHRvLFxuICAgICAgICBub2RlID0gX3N0YXRlJHNlbGVjdGlvbjIubm9kZTtcbiAgICBpZiAobm9kZSAmJiBub2RlLmlzQmxvY2sgfHwgJGZyb20uZGVwdGggPCAyIHx8ICEkZnJvbS5zYW1lUGFyZW50KCR0bykpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPSBpdGVtVHlwZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09ICRmcm9tLmluZGV4QWZ0ZXIoLTEpKSB7XG4gICAgICBpZiAoJGZyb20uZGVwdGggPT0gMyB8fCAkZnJvbS5ub2RlKC0zKS50eXBlICE9IGl0ZW1UeXBlIHx8ICRmcm9tLmluZGV4KC0yKSAhPSAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50IC0gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHdyYXAgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5O1xuICAgICAgICB2YXIgZGVwdGhCZWZvcmUgPSAkZnJvbS5pbmRleCgtMSkgPyAxIDogJGZyb20uaW5kZXgoLTIpID8gMiA6IDM7XG5cbiAgICAgICAgZm9yICh2YXIgZCA9ICRmcm9tLmRlcHRoIC0gZGVwdGhCZWZvcmU7IGQgPj0gJGZyb20uZGVwdGggLSAzOyBkLS0pIHtcbiAgICAgICAgICB3cmFwID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weSh3cmFwKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDEgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogMztcbiAgICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGVBbmRGaWxsKCkpKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpO1xuXG4gICAgICAgIHZhciBfdHIgPSBzdGF0ZS50ci5yZXBsYWNlKHN0YXJ0LCAkZnJvbS5hZnRlcigtZGVwdGhBZnRlciksIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpO1xuXG4gICAgICAgIHZhciBzZWwgPSAtMTtcblxuICAgICAgICBfdHIuZG9jLm5vZGVzQmV0d2VlbihzdGFydCwgX3RyLmRvYy5jb250ZW50LnNpemUsIGZ1bmN0aW9uIChub2RlLCBwb3MpIHtcbiAgICAgICAgICBpZiAoc2VsID4gLTEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAobm9kZS5pc1RleHRibG9jayAmJiBub2RlLmNvbnRlbnQuc2l6ZSA9PSAwKSBzZWwgPSBwb3MgKyAxO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsID4gLTEpIF90ci5zZXRTZWxlY3Rpb24ocHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24ubmVhcihfdHIuZG9jLnJlc29sdmUoc2VsKSkpO1xuICAgICAgICBkaXNwYXRjaChfdHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBuZXh0VHlwZSA9ICR0by5wb3MgPT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGw7XG4gICAgdmFyIHRyID0gc3RhdGUudHJbXCJkZWxldGVcIl0oJGZyb20ucG9zLCAkdG8ucG9zKTtcbiAgICB2YXIgdHlwZXMgPSBuZXh0VHlwZSA/IFtudWxsLCB7XG4gICAgICB0eXBlOiBuZXh0VHlwZVxuICAgIH1dIDogdW5kZWZpbmVkO1xuICAgIGlmICghcHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuU3BsaXQodHIuZG9jLCAkZnJvbS5wb3MsIDIsIHR5cGVzKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2godHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGxpZnRMaXN0SXRlbShpdGVtVHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciBfc3RhdGUkc2VsZWN0aW9uMyA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uMy4kZnJvbSxcbiAgICAgICAgJHRvID0gX3N0YXRlJHNlbGVjdGlvbjMuJHRvO1xuICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGU7XG4gICAgfSk7XG4gICAgaWYgKCFyYW5nZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghZGlzcGF0Y2gpIHJldHVybiB0cnVlO1xuICAgIGlmICgkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZSA9PSBpdGVtVHlwZSkgcmV0dXJuIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSk7ZWxzZSByZXR1cm4gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbGlmdFRvT3V0ZXJMaXN0KHN0YXRlLCBkaXNwYXRjaCwgaXRlbVR5cGUsIHJhbmdlKSB7XG4gIHZhciB0ciA9IHN0YXRlLnRyLFxuICAgICAgZW5kID0gcmFuZ2UuZW5kLFxuICAgICAgZW5kT2ZMaXN0ID0gcmFuZ2UuJHRvLmVuZChyYW5nZS5kZXB0aCk7XG5cbiAgaWYgKGVuZCA8IGVuZE9mTGlzdCkge1xuICAgIHRyLnN0ZXAobmV3IHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VBcm91bmRTdGVwKGVuZCAtIDEsIGVuZE9mTGlzdCwgZW5kLCBlbmRPZkxpc3QsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGUobnVsbCwgcmFuZ2UucGFyZW50LmNvcHkoKSkpLCAxLCAwKSwgMSwgdHJ1ZSkpO1xuICAgIHJhbmdlID0gbmV3IHByb3NlbWlycm9yTW9kZWwuTm9kZVJhbmdlKHRyLmRvYy5yZXNvbHZlKHJhbmdlLiRmcm9tLnBvcyksIHRyLmRvYy5yZXNvbHZlKGVuZE9mTGlzdCksIHJhbmdlLmRlcHRoKTtcbiAgfVxuXG4gIGRpc3BhdGNoKHRyLmxpZnQocmFuZ2UsIHByb3NlbWlycm9yVHJhbnNmb3JtLmxpZnRUYXJnZXQocmFuZ2UpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGxpZnRPdXRPZkxpc3Qoc3RhdGUsIGRpc3BhdGNoLCByYW5nZSkge1xuICB2YXIgdHIgPSBzdGF0ZS50cixcbiAgICAgIGxpc3QgPSByYW5nZS5wYXJlbnQ7XG5cbiAgZm9yICh2YXIgcG9zID0gcmFuZ2UuZW5kLCBpID0gcmFuZ2UuZW5kSW5kZXggLSAxLCBlID0gcmFuZ2Uuc3RhcnRJbmRleDsgaSA+IGU7IGktLSkge1xuICAgIHBvcyAtPSBsaXN0LmNoaWxkKGkpLm5vZGVTaXplO1xuICAgIHRyW1wiZGVsZXRlXCJdKHBvcyAtIDEsIHBvcyArIDEpO1xuICB9XG5cbiAgdmFyICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0KSxcbiAgICAgIGl0ZW0gPSAkc3RhcnQubm9kZUFmdGVyO1xuICBpZiAodHIubWFwcGluZy5tYXAocmFuZ2UuZW5kKSAhPSByYW5nZS5zdGFydCArICRzdGFydC5ub2RlQWZ0ZXIubm9kZVNpemUpIHJldHVybiBmYWxzZTtcbiAgdmFyIGF0U3RhcnQgPSByYW5nZS5zdGFydEluZGV4ID09IDAsXG4gICAgICBhdEVuZCA9IHJhbmdlLmVuZEluZGV4ID09IGxpc3QuY2hpbGRDb3VudDtcbiAgdmFyIHBhcmVudCA9ICRzdGFydC5ub2RlKC0xKSxcbiAgICAgIGluZGV4QmVmb3JlID0gJHN0YXJ0LmluZGV4KC0xKTtcbiAgaWYgKCFwYXJlbnQuY2FuUmVwbGFjZShpbmRleEJlZm9yZSArIChhdFN0YXJ0ID8gMCA6IDEpLCBpbmRleEJlZm9yZSArIDEsIGl0ZW0uY29udGVudC5hcHBlbmQoYXRFbmQgPyBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5IDogcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGxpc3QpKSkpIHJldHVybiBmYWxzZTtcbiAgdmFyIHN0YXJ0ID0gJHN0YXJ0LnBvcyxcbiAgICAgIGVuZCA9IHN0YXJ0ICsgaXRlbS5ub2RlU2l6ZTtcbiAgdHIuc3RlcChuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQgLSAoYXRTdGFydCA/IDEgOiAwKSwgZW5kICsgKGF0RW5kID8gMSA6IDApLCBzdGFydCArIDEsIGVuZCAtIDEsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKChhdFN0YXJ0ID8gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eSA6IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eSkpKS5hcHBlbmQoYXRFbmQgPyBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5IDogcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGxpc3QuY29weShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5KSkpLCBhdFN0YXJ0ID8gMCA6IDEsIGF0RW5kID8gMCA6IDEpLCBhdFN0YXJ0ID8gMCA6IDEpKTtcbiAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzaW5rTGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgX3N0YXRlJHNlbGVjdGlvbjQgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAgICRmcm9tID0gX3N0YXRlJHNlbGVjdGlvbjQuJGZyb20sXG4gICAgICAgICR0byA9IF9zdGF0ZSRzZWxlY3Rpb240LiR0bztcbiAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmNoaWxkQ291bnQgPiAwICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09IGl0ZW1UeXBlO1xuICAgIH0pO1xuICAgIGlmICghcmFuZ2UpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXg7XG4gICAgaWYgKHN0YXJ0SW5kZXggPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBwYXJlbnQgPSByYW5nZS5wYXJlbnQsXG4gICAgICAgIG5vZGVCZWZvcmUgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpO1xuICAgIGlmIChub2RlQmVmb3JlLnR5cGUgIT0gaXRlbVR5cGUpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgdmFyIG5lc3RlZEJlZm9yZSA9IG5vZGVCZWZvcmUubGFzdENoaWxkICYmIG5vZGVCZWZvcmUubGFzdENoaWxkLnR5cGUgPT0gcGFyZW50LnR5cGU7XG4gICAgICB2YXIgaW5uZXIgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20obmVzdGVkQmVmb3JlID8gaXRlbVR5cGUuY3JlYXRlKCkgOiBudWxsKTtcbiAgICAgIHZhciBzbGljZSA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGUobnVsbCwgcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKHBhcmVudC50eXBlLmNyZWF0ZShudWxsLCBpbm5lcikpKSksIG5lc3RlZEJlZm9yZSA/IDMgOiAxLCAwKTtcbiAgICAgIHZhciBiZWZvcmUgPSByYW5nZS5zdGFydCxcbiAgICAgICAgICBhZnRlciA9IHJhbmdlLmVuZDtcbiAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnN0ZXAobmV3IHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VBcm91bmRTdGVwKGJlZm9yZSAtIChuZXN0ZWRCZWZvcmUgPyAzIDogMSksIGFmdGVyLCBiZWZvcmUsIGFmdGVyLCBzbGljZSwgMSwgdHJ1ZSkpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG5leHBvcnRzLmFkZExpc3ROb2RlcyA9IGFkZExpc3ROb2RlcztcbmV4cG9ydHMuYnVsbGV0TGlzdCA9IGJ1bGxldExpc3Q7XG5leHBvcnRzLmxpZnRMaXN0SXRlbSA9IGxpZnRMaXN0SXRlbTtcbmV4cG9ydHMubGlzdEl0ZW0gPSBsaXN0SXRlbTtcbmV4cG9ydHMub3JkZXJlZExpc3QgPSBvcmRlcmVkTGlzdDtcbmV4cG9ydHMuc2lua0xpc3RJdGVtID0gc2lua0xpc3RJdGVtO1xuZXhwb3J0cy5zcGxpdExpc3RJdGVtID0gc3BsaXRMaXN0SXRlbTtcbmV4cG9ydHMud3JhcEluTGlzdCA9IHdyYXBJbkxpc3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgcHJvc2VtaXJyb3JNb2RlbCA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLW1vZGVsJyk7XG5cbnZhciBwcm9zZW1pcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXRyYW5zZm9ybScpO1xuXG52YXIgY2xhc3Nlc0J5SWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG52YXIgU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZWxlY3Rpb24oJGFuY2hvciwgJGhlYWQsIHJhbmdlcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWxlY3Rpb24pO1xuXG4gICAgdGhpcy4kYW5jaG9yID0gJGFuY2hvcjtcbiAgICB0aGlzLiRoZWFkID0gJGhlYWQ7XG4gICAgdGhpcy5yYW5nZXMgPSByYW5nZXMgfHwgW25ldyBTZWxlY3Rpb25SYW5nZSgkYW5jaG9yLm1pbigkaGVhZCksICRhbmNob3IubWF4KCRoZWFkKSldO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNlbGVjdGlvbiwgW3tcbiAgICBrZXk6IFwiYW5jaG9yXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kYW5jaG9yLnBvcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGVhZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGhlYWQucG9zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZnJvbS5wb3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kdG8ucG9zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCIkZnJvbVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzWzBdLiRmcm9tO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCIkdG9cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS4kdG87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVtcHR5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyYW5nZXNbaV0uJGZyb20ucG9zICE9IHJhbmdlc1tpXS4kdG8ucG9zKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZnJvbS5kb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKHRyKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGNvbnRlbnQuY29udGVudC5sYXN0Q2hpbGQsXG4gICAgICAgICAgbGFzdFBhcmVudCA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5vcGVuRW5kOyBpKyspIHtcbiAgICAgICAgbGFzdFBhcmVudCA9IGxhc3ROb2RlO1xuICAgICAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLmxhc3RDaGlsZDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCByYW5nZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfcmFuZ2VzJF9pID0gcmFuZ2VzW19pXSxcbiAgICAgICAgICAgICRmcm9tID0gX3JhbmdlcyRfaS4kZnJvbSxcbiAgICAgICAgICAgICR0byA9IF9yYW5nZXMkX2kuJHRvLFxuICAgICAgICAgICAgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgIHRyLnJlcGxhY2VSYW5nZShtYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCBtYXBwaW5nLm1hcCgkdG8ucG9zKSwgX2kgPyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5IDogY29udGVudCk7XG4gICAgICAgIGlmIChfaSA9PSAwKSBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgbWFwRnJvbSwgKGxhc3ROb2RlID8gbGFzdE5vZGUuaXNJbmxpbmUgOiBsYXN0UGFyZW50ICYmIGxhc3RQYXJlbnQuaXNUZXh0YmxvY2spID8gLTEgOiAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVdpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVdpdGgodHIsIG5vZGUpIHtcbiAgICAgIHZhciBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX3JhbmdlcyRpID0gcmFuZ2VzW2ldLFxuICAgICAgICAgICAgJGZyb20gPSBfcmFuZ2VzJGkuJGZyb20sXG4gICAgICAgICAgICAkdG8gPSBfcmFuZ2VzJGkuJHRvLFxuICAgICAgICAgICAgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXAoJGZyb20ucG9zKSxcbiAgICAgICAgICAgIHRvID0gbWFwcGluZy5tYXAoJHRvLnBvcyk7XG5cbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICB0ci5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHIucmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSk7XG4gICAgICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIG1hcEZyb20sIG5vZGUuaXNJbmxpbmUgPyAtMSA6IDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvb2ttYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvb2ttYXJrKCkge1xuICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbih0aGlzLiRhbmNob3IsIHRoaXMuJGhlYWQpLmdldEJvb2ttYXJrKCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZmluZEZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEZyb20oJHBvcywgZGlyKSB7XG4gICAgICB2YXIgdGV4dE9ubHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIGlubmVyID0gJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCA/IG5ldyBUZXh0U2VsZWN0aW9uKCRwb3MpIDogZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5wYXJlbnQsICRwb3MucG9zLCAkcG9zLmluZGV4KCksIGRpciwgdGV4dE9ubHkpO1xuICAgICAgaWYgKGlubmVyKSByZXR1cm4gaW5uZXI7XG5cbiAgICAgIGZvciAodmFyIGRlcHRoID0gJHBvcy5kZXB0aCAtIDE7IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgdmFyIGZvdW5kID0gZGlyIDwgMCA/IGZpbmRTZWxlY3Rpb25JbigkcG9zLm5vZGUoMCksICRwb3Mubm9kZShkZXB0aCksICRwb3MuYmVmb3JlKGRlcHRoICsgMSksICRwb3MuaW5kZXgoZGVwdGgpLCBkaXIsIHRleHRPbmx5KSA6IGZpbmRTZWxlY3Rpb25JbigkcG9zLm5vZGUoMCksICRwb3Mubm9kZShkZXB0aCksICRwb3MuYWZ0ZXIoZGVwdGggKyAxKSwgJHBvcy5pbmRleChkZXB0aCkgKyAxLCBkaXIsIHRleHRPbmx5KTtcbiAgICAgICAgaWYgKGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lYXIoJHBvcykge1xuICAgICAgdmFyIGJpYXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICByZXR1cm4gdGhpcy5maW5kRnJvbSgkcG9zLCBiaWFzKSB8fCB0aGlzLmZpbmRGcm9tKCRwb3MsIC1iaWFzKSB8fCBuZXcgQWxsU2VsZWN0aW9uKCRwb3Mubm9kZSgwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF0U3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXRTdGFydChkb2MpIHtcbiAgICAgIHJldHVybiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBkb2MsIDAsIDAsIDEpIHx8IG5ldyBBbGxTZWxlY3Rpb24oZG9jKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXRFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXRFbmQoZG9jKSB7XG4gICAgICByZXR1cm4gZmluZFNlbGVjdGlvbkluKGRvYywgZG9jLCBkb2MuY29udGVudC5zaXplLCBkb2MuY2hpbGRDb3VudCwgLTEpIHx8IG5ldyBBbGxTZWxlY3Rpb24oZG9jKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICBpZiAoIWpzb24gfHwgIWpzb24udHlwZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTZWxlY3Rpb24uZnJvbUpTT05cIik7XG4gICAgICB2YXIgY2xzID0gY2xhc3Nlc0J5SWRbanNvbi50eXBlXTtcbiAgICAgIGlmICghY2xzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHNlbGVjdGlvbiB0eXBlIFwiLmNvbmNhdChqc29uLnR5cGUsIFwiIGRlZmluZWRcIikpO1xuICAgICAgcmV0dXJuIGNscy5mcm9tSlNPTihkb2MsIGpzb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqc29uSURcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ganNvbklEKGlkLCBzZWxlY3Rpb25DbGFzcykge1xuICAgICAgaWYgKGlkIGluIGNsYXNzZXNCeUlkKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cGxpY2F0ZSB1c2Ugb2Ygc2VsZWN0aW9uIEpTT04gSUQgXCIgKyBpZCk7XG4gICAgICBjbGFzc2VzQnlJZFtpZF0gPSBzZWxlY3Rpb25DbGFzcztcbiAgICAgIHNlbGVjdGlvbkNsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgIHJldHVybiBzZWxlY3Rpb25DbGFzcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2VsZWN0aW9uO1xufSgpO1xuXG5TZWxlY3Rpb24ucHJvdG90eXBlLnZpc2libGUgPSB0cnVlO1xuXG52YXIgU2VsZWN0aW9uUmFuZ2UgPSBfY3JlYXRlQ2xhc3MoZnVuY3Rpb24gU2VsZWN0aW9uUmFuZ2UoJGZyb20sICR0bykge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uUmFuZ2UpO1xuXG4gIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgdGhpcy4kdG8gPSAkdG87XG59KTtcblxudmFyIHdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjaGVja1RleHRTZWxlY3Rpb24oJHBvcykge1xuICBpZiAoIXdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiAmJiAhJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgIHdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiA9IHRydWU7XG4gICAgY29uc29sZVtcIndhcm5cIl0oXCJUZXh0U2VsZWN0aW9uIGVuZHBvaW50IG5vdCBwb2ludGluZyBpbnRvIGEgbm9kZSB3aXRoIGlubGluZSBjb250ZW50IChcIiArICRwb3MucGFyZW50LnR5cGUubmFtZSArIFwiKVwiKTtcbiAgfVxufVxuXG52YXIgVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChfU2VsZWN0aW9uKSB7XG4gIF9pbmhlcml0cyhUZXh0U2VsZWN0aW9uLCBfU2VsZWN0aW9uKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFRleHRTZWxlY3Rpb24pO1xuXG4gIGZ1bmN0aW9uIFRleHRTZWxlY3Rpb24oJGFuY2hvcikge1xuICAgIHZhciAkaGVhZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJGFuY2hvcjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0U2VsZWN0aW9uKTtcblxuICAgIGNoZWNrVGV4dFNlbGVjdGlvbigkYW5jaG9yKTtcbiAgICBjaGVja1RleHRTZWxlY3Rpb24oJGhlYWQpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAkYW5jaG9yLCAkaGVhZCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV4dFNlbGVjdGlvbiwgW3tcbiAgICBrZXk6IFwiJGN1cnNvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGFuY2hvci5wb3MgPT0gdGhpcy4kaGVhZC5wb3MgPyB0aGlzLiRoZWFkIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChkb2MsIG1hcHBpbmcpIHtcbiAgICAgIHZhciAkaGVhZCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgaWYgKCEkaGVhZC5wYXJlbnQuaW5saW5lQ29udGVudCkgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkKTtcbiAgICAgIHZhciAkYW5jaG9yID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5hbmNob3IpKTtcbiAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLnBhcmVudC5pbmxpbmVDb250ZW50ID8gJGFuY2hvciA6ICRoZWFkLCAkaGVhZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZSh0cikge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHk7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFRleHRTZWxlY3Rpb24ucHJvdG90eXBlKSwgXCJyZXBsYWNlXCIsIHRoaXMpLmNhbGwodGhpcywgdHIsIGNvbnRlbnQpO1xuXG4gICAgICBpZiAoY29udGVudCA9PSBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5KSB7XG4gICAgICAgIHZhciBtYXJrcyA9IHRoaXMuJGZyb20ubWFya3NBY3Jvc3ModGhpcy4kdG8pO1xuICAgICAgICBpZiAobWFya3MpIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgb3RoZXIuYW5jaG9yID09IHRoaXMuYW5jaG9yICYmIG90aGVyLmhlYWQgPT0gdGhpcy5oZWFkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb29rbWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb29rbWFyaygpIHtcbiAgICAgIHJldHVybiBuZXcgVGV4dEJvb2ttYXJrKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgIGFuY2hvcjogdGhpcy5hbmNob3IsXG4gICAgICAgIGhlYWQ6IHRoaXMuaGVhZFxuICAgICAgfTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgIGlmICh0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5oZWFkICE9IFwibnVtYmVyXCIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgVGV4dFNlbGVjdGlvbi5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbihkb2MucmVzb2x2ZShqc29uLmFuY2hvciksIGRvYy5yZXNvbHZlKGpzb24uaGVhZCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKGRvYywgYW5jaG9yKSB7XG4gICAgICB2YXIgaGVhZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYW5jaG9yO1xuICAgICAgdmFyICRhbmNob3IgPSBkb2MucmVzb2x2ZShhbmNob3IpO1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCRhbmNob3IsIGhlYWQgPT0gYW5jaG9yID8gJGFuY2hvciA6IGRvYy5yZXNvbHZlKGhlYWQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmV0d2VlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZXR3ZWVuKCRhbmNob3IsICRoZWFkLCBiaWFzKSB7XG4gICAgICB2YXIgZFBvcyA9ICRhbmNob3IucG9zIC0gJGhlYWQucG9zO1xuICAgICAgaWYgKCFiaWFzIHx8IGRQb3MpIGJpYXMgPSBkUG9zID49IDAgPyAxIDogLTE7XG5cbiAgICAgIGlmICghJGhlYWQucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gU2VsZWN0aW9uLmZpbmRGcm9tKCRoZWFkLCBiaWFzLCB0cnVlKSB8fCBTZWxlY3Rpb24uZmluZEZyb20oJGhlYWQsIC1iaWFzLCB0cnVlKTtcbiAgICAgICAgaWYgKGZvdW5kKSAkaGVhZCA9IGZvdW5kLiRoZWFkO2Vsc2UgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkLCBiaWFzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEkYW5jaG9yLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGlmIChkUG9zID09IDApIHtcbiAgICAgICAgICAkYW5jaG9yID0gJGhlYWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGFuY2hvciA9IChTZWxlY3Rpb24uZmluZEZyb20oJGFuY2hvciwgLWJpYXMsIHRydWUpIHx8IFNlbGVjdGlvbi5maW5kRnJvbSgkYW5jaG9yLCBiaWFzLCB0cnVlKSkuJGFuY2hvcjtcbiAgICAgICAgICBpZiAoJGFuY2hvci5wb3MgPCAkaGVhZC5wb3MgIT0gZFBvcyA8IDApICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oJGFuY2hvciwgJGhlYWQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXh0U2VsZWN0aW9uO1xufShTZWxlY3Rpb24pO1xuXG5TZWxlY3Rpb24uanNvbklEKFwidGV4dFwiLCBUZXh0U2VsZWN0aW9uKTtcblxudmFyIFRleHRCb29rbWFyayA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGV4dEJvb2ttYXJrKGFuY2hvciwgaGVhZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0Qm9va21hcmspO1xuXG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUZXh0Qm9va21hcmssIFt7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAobWFwcGluZykge1xuICAgICAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsobWFwcGluZy5tYXAodGhpcy5hbmNob3IpLCBtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKGRvYykge1xuICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbihkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIGRvYy5yZXNvbHZlKHRoaXMuaGVhZCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXh0Qm9va21hcms7XG59KCk7XG5cbnZhciBOb2RlU2VsZWN0aW9uID0gZnVuY3Rpb24gKF9TZWxlY3Rpb24yKSB7XG4gIF9pbmhlcml0cyhOb2RlU2VsZWN0aW9uLCBfU2VsZWN0aW9uMik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoTm9kZVNlbGVjdGlvbik7XG5cbiAgZnVuY3Rpb24gTm9kZVNlbGVjdGlvbigkcG9zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVTZWxlY3Rpb24pO1xuXG4gICAgdmFyIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICB2YXIgJGVuZCA9ICRwb3Mubm9kZSgwKS5yZXNvbHZlKCRwb3MucG9zICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgX3RoaXMgPSBfc3VwZXIyLmNhbGwodGhpcywgJHBvcywgJGVuZCk7XG4gICAgX3RoaXMubm9kZSA9IG5vZGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE5vZGVTZWxlY3Rpb24sIFt7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICB2YXIgX21hcHBpbmckbWFwUmVzdWx0ID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5hbmNob3IpLFxuICAgICAgICAgIGRlbGV0ZWQgPSBfbWFwcGluZyRtYXBSZXN1bHQuZGVsZXRlZCxcbiAgICAgICAgICBwb3MgPSBfbWFwcGluZyRtYXBSZXN1bHQucG9zO1xuXG4gICAgICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICBpZiAoZGVsZXRlZCkgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKHRoaXMubm9kZSksIDAsIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3I7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5vZGVcIixcbiAgICAgICAgYW5jaG9yOiB0aGlzLmFuY2hvclxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm9va21hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9va21hcmsoKSB7XG4gICAgICByZXR1cm4gbmV3IE5vZGVCb29rbWFyayh0aGlzLmFuY2hvcik7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICBpZiAodHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTm9kZVNlbGVjdGlvbi5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbihkb2MucmVzb2x2ZShqc29uLmFuY2hvcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKGRvYywgZnJvbSkge1xuICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGZyb20pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTZWxlY3RhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2VsZWN0YWJsZShub2RlKSB7XG4gICAgICByZXR1cm4gIW5vZGUuaXNUZXh0ICYmIG5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb2RlU2VsZWN0aW9uO1xufShTZWxlY3Rpb24pO1xuXG5Ob2RlU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5TZWxlY3Rpb24uanNvbklEKFwibm9kZVwiLCBOb2RlU2VsZWN0aW9uKTtcblxudmFyIE5vZGVCb29rbWFyayA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9kZUJvb2ttYXJrKGFuY2hvcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlQm9va21hcmspO1xuXG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm9kZUJvb2ttYXJrLCBbe1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcpIHtcbiAgICAgIHZhciBfbWFwcGluZyRtYXBSZXN1bHQyID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5hbmNob3IpLFxuICAgICAgICAgIGRlbGV0ZWQgPSBfbWFwcGluZyRtYXBSZXN1bHQyLmRlbGV0ZWQsXG4gICAgICAgICAgcG9zID0gX21hcHBpbmckbWFwUmVzdWx0Mi5wb3M7XG5cbiAgICAgIHJldHVybiBkZWxldGVkID8gbmV3IFRleHRCb29rbWFyayhwb3MsIHBvcykgOiBuZXcgTm9kZUJvb2ttYXJrKHBvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZShkb2MpIHtcbiAgICAgIHZhciAkcG9zID0gZG9jLnJlc29sdmUodGhpcy5hbmNob3IpLFxuICAgICAgICAgIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgIGlmIChub2RlICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyk7XG4gICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVCb29rbWFyaztcbn0oKTtcblxudmFyIEFsbFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChfU2VsZWN0aW9uMykge1xuICBfaW5oZXJpdHMoQWxsU2VsZWN0aW9uLCBfU2VsZWN0aW9uMyk7XG5cbiAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoQWxsU2VsZWN0aW9uKTtcblxuICBmdW5jdGlvbiBBbGxTZWxlY3Rpb24oZG9jKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFsbFNlbGVjdGlvbik7XG5cbiAgICByZXR1cm4gX3N1cGVyMy5jYWxsKHRoaXMsIGRvYy5yZXNvbHZlKDApLCBkb2MucmVzb2x2ZShkb2MuY29udGVudC5zaXplKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQWxsU2VsZWN0aW9uLCBbe1xuICAgIGtleTogXCJyZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UodHIpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5O1xuXG4gICAgICBpZiAoY29udGVudCA9PSBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5KSB7XG4gICAgICAgIHRyW1wiZGVsZXRlXCJdKDAsIHRyLmRvYy5jb250ZW50LnNpemUpO1xuICAgICAgICB2YXIgc2VsID0gU2VsZWN0aW9uLmF0U3RhcnQodHIuZG9jKTtcbiAgICAgICAgaWYgKCFzZWwuZXEodHIuc2VsZWN0aW9uKSkgdHIuc2V0U2VsZWN0aW9uKHNlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihBbGxTZWxlY3Rpb24ucHJvdG90eXBlKSwgXCJyZXBsYWNlXCIsIHRoaXMpLmNhbGwodGhpcywgdHIsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhbGxcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChkb2MpIHtcbiAgICAgIHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvb2ttYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvb2ttYXJrKCkge1xuICAgICAgcmV0dXJuIEFsbEJvb2ttYXJrO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGRvYykge1xuICAgICAgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWxsU2VsZWN0aW9uO1xufShTZWxlY3Rpb24pO1xuXG5TZWxlY3Rpb24uanNvbklEKFwiYWxsXCIsIEFsbFNlbGVjdGlvbik7XG52YXIgQWxsQm9va21hcmsgPSB7XG4gIG1hcDogZnVuY3Rpb24gbWFwKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKGRvYykge1xuICAgIHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZpbmRTZWxlY3Rpb25Jbihkb2MsIG5vZGUsIHBvcywgaW5kZXgsIGRpcikge1xuICB2YXIgdGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogZmFsc2U7XG4gIGlmIChub2RlLmlubGluZUNvbnRlbnQpIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyk7XG5cbiAgZm9yICh2YXIgaSA9IGluZGV4IC0gKGRpciA+IDAgPyAwIDogMSk7IGRpciA+IDAgPyBpIDwgbm9kZS5jaGlsZENvdW50IDogaSA+PSAwOyBpICs9IGRpcikge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQoaSk7XG5cbiAgICBpZiAoIWNoaWxkLmlzQXRvbSkge1xuICAgICAgdmFyIGlubmVyID0gZmluZFNlbGVjdGlvbkluKGRvYywgY2hpbGQsIHBvcyArIGRpciwgZGlyIDwgMCA/IGNoaWxkLmNoaWxkQ291bnQgOiAwLCBkaXIsIHRleHQpO1xuICAgICAgaWYgKGlubmVyKSByZXR1cm4gaW5uZXI7XG4gICAgfSBlbHNlIGlmICghdGV4dCAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShjaGlsZCkpIHtcbiAgICAgIHJldHVybiBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyAtIChkaXIgPCAwID8gY2hpbGQubm9kZVNpemUgOiAwKSk7XG4gICAgfVxuXG4gICAgcG9zICs9IGNoaWxkLm5vZGVTaXplICogZGlyO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xuICB2YXIgbGFzdCA9IHRyLnN0ZXBzLmxlbmd0aCAtIDE7XG4gIGlmIChsYXN0IDwgc3RhcnRMZW4pIHJldHVybjtcbiAgdmFyIHN0ZXAgPSB0ci5zdGVwc1tsYXN0XTtcbiAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VTdGVwIHx8IHN0ZXAgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclRyYW5zZm9ybS5SZXBsYWNlQXJvdW5kU3RlcCkpIHJldHVybjtcbiAgdmFyIG1hcCA9IHRyLm1hcHBpbmcubWFwc1tsYXN0XSxcbiAgICAgIGVuZDtcbiAgbWFwLmZvckVhY2goZnVuY3Rpb24gKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykge1xuICAgIGlmIChlbmQgPT0gbnVsbCkgZW5kID0gbmV3VG87XG4gIH0pO1xuICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoZW5kKSwgYmlhcykpO1xufVxuXG52YXIgVVBEQVRFRF9TRUwgPSAxLFxuICAgIFVQREFURURfTUFSS1MgPSAyLFxuICAgIFVQREFURURfU0NST0xMID0gNDtcblxudmFyIFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKF9wcm9zZW1pcnJvclRyYW5zZm9ybSkge1xuICBfaW5oZXJpdHMoVHJhbnNhY3Rpb24sIF9wcm9zZW1pcnJvclRyYW5zZm9ybSk7XG5cbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoVHJhbnNhY3Rpb24pO1xuXG4gIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2FjdGlvbik7XG5cbiAgICBfdGhpczIgPSBfc3VwZXI0LmNhbGwodGhpcywgc3RhdGUuZG9jKTtcbiAgICBfdGhpczIuY3VyU2VsZWN0aW9uRm9yID0gMDtcbiAgICBfdGhpczIudXBkYXRlZCA9IDA7XG4gICAgX3RoaXMyLm1ldGEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIF90aGlzMi50aW1lID0gRGF0ZS5ub3coKTtcbiAgICBfdGhpczIuY3VyU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIF90aGlzMi5zdG9yZWRNYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVHJhbnNhY3Rpb24sIFt7XG4gICAga2V5OiBcInNlbGVjdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuY3VyU2VsZWN0aW9uRm9yIDwgdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSB0aGlzLmN1clNlbGVjdGlvbi5tYXAodGhpcy5kb2MsIHRoaXMubWFwcGluZy5zbGljZSh0aGlzLmN1clNlbGVjdGlvbkZvcikpO1xuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IHRoaXMuc3RlcHMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jdXJTZWxlY3Rpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLmRvYyAhPSB0aGlzLmRvYykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTZWxlY3Rpb24gcGFzc2VkIHRvIHNldFNlbGVjdGlvbiBtdXN0IHBvaW50IGF0IHRoZSBjdXJyZW50IGRvY3VtZW50XCIpO1xuICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IHRoaXMuc3RlcHMubGVuZ3RoO1xuICAgICAgdGhpcy51cGRhdGVkID0gKHRoaXMudXBkYXRlZCB8IFVQREFURURfU0VMKSAmIH5VUERBVEVEX01BUktTO1xuICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0aW9uU2V0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfU0VMKSA+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFN0b3JlZE1hcmtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0b3JlZE1hcmtzKG1hcmtzKSB7XG4gICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbWFya3M7XG4gICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9NQVJLUztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbnN1cmVNYXJrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmVNYXJrcyhtYXJrcykge1xuICAgICAgaWYgKCFwcm9zZW1pcnJvck1vZGVsLk1hcmsuc2FtZVNldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCksIG1hcmtzKSkgdGhpcy5zZXRTdG9yZWRNYXJrcyhtYXJrcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU3RvcmVkTWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTdG9yZWRNYXJrKG1hcmspIHtcbiAgICAgIHJldHVybiB0aGlzLmVuc3VyZU1hcmtzKG1hcmsuYWRkVG9TZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVN0b3JlZE1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlU3RvcmVkTWFyayhtYXJrKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnN1cmVNYXJrcyhtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0b3JlZE1hcmtzU2V0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfTUFSS1MpID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoVHJhbnNhY3Rpb24ucHJvdG90eXBlKSwgXCJhZGRTdGVwXCIsIHRoaXMpLmNhbGwodGhpcywgc3RlcCwgZG9jKTtcblxuICAgICAgdGhpcy51cGRhdGVkID0gdGhpcy51cGRhdGVkICYgflVQREFURURfTUFSS1M7XG4gICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUaW1lKHRpbWUpIHtcbiAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlU2VsZWN0aW9uKHNsaWNlKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5yZXBsYWNlKHRoaXMsIHNsaWNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlU2VsZWN0aW9uV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlU2VsZWN0aW9uV2l0aChub2RlKSB7XG4gICAgICB2YXIgaW5oZXJpdE1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgaWYgKGluaGVyaXRNYXJrcykgbm9kZSA9IG5vZGUubWFyayh0aGlzLnN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uZW1wdHkgPyBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSA6IHNlbGVjdGlvbi4kZnJvbS5tYXJrc0Fjcm9zcyhzZWxlY3Rpb24uJHRvKSB8fCBwcm9zZW1pcnJvck1vZGVsLk1hcmsubm9uZSkpO1xuICAgICAgc2VsZWN0aW9uLnJlcGxhY2VXaXRoKHRoaXMsIG5vZGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVTZWxlY3Rpb24oKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5yZXBsYWNlKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0VGV4dCh0ZXh0LCBmcm9tLCB0bykge1xuICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuZG9jLnR5cGUuc2NoZW1hO1xuXG4gICAgICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgICAgIGlmICghdGV4dCkgcmV0dXJuIHRoaXMuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNjaGVtYS50ZXh0KHRleHQpLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0byA9PSBudWxsKSB0byA9IGZyb207XG4gICAgICAgIHRvID0gdG8gPT0gbnVsbCA/IGZyb20gOiB0bztcbiAgICAgICAgaWYgKCF0ZXh0KSByZXR1cm4gdGhpcy5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgICAgIHZhciBtYXJrcyA9IHRoaXMuc3RvcmVkTWFya3M7XG5cbiAgICAgICAgaWYgKCFtYXJrcykge1xuICAgICAgICAgIHZhciAkZnJvbSA9IHRoaXMuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgICAgICAgbWFya3MgPSB0byA9PSBmcm9tID8gJGZyb20ubWFya3MoKSA6ICRmcm9tLm1hcmtzQWNyb3NzKHRoaXMuZG9jLnJlc29sdmUodG8pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgc2NoZW1hLnRleHQodGV4dCwgbWFya3MpKTtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5lbXB0eSkgdGhpcy5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodGhpcy5zZWxlY3Rpb24uJHRvKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRNZXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1ldGEoa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWV0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZXRhKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMubWV0YVt0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgPyBrZXkgOiBrZXkua2V5XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNHZW5lcmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBmb3IgKHZhciBfIGluIHRoaXMubWV0YSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY3JvbGxJbnRvVmlld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldygpIHtcbiAgICAgIHRoaXMudXBkYXRlZCB8PSBVUERBVEVEX1NDUk9MTDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY3JvbGxlZEludG9WaWV3XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfU0NST0xMKSA+IDA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYW5zYWN0aW9uO1xufShwcm9zZW1pcnJvclRyYW5zZm9ybS5UcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBiaW5kKGYsIHNlbGYpIHtcbiAgcmV0dXJuICFzZWxmIHx8ICFmID8gZiA6IGYuYmluZChzZWxmKTtcbn1cblxudmFyIEZpZWxkRGVzYyA9IF9jcmVhdGVDbGFzcyhmdW5jdGlvbiBGaWVsZERlc2MobmFtZSwgZGVzYywgc2VsZikge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmllbGREZXNjKTtcblxuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmluaXQgPSBiaW5kKGRlc2MuaW5pdCwgc2VsZik7XG4gIHRoaXMuYXBwbHkgPSBiaW5kKGRlc2MuYXBwbHksIHNlbGYpO1xufSk7XG5cbnZhciBiYXNlRmllbGRzID0gW25ldyBGaWVsZERlc2MoXCJkb2NcIiwge1xuICBpbml0OiBmdW5jdGlvbiBpbml0KGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcuZG9jIHx8IGNvbmZpZy5zY2hlbWEudG9wTm9kZVR5cGUuY3JlYXRlQW5kRmlsbCgpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodHIpIHtcbiAgICByZXR1cm4gdHIuZG9jO1xuICB9XG59KSwgbmV3IEZpZWxkRGVzYyhcInNlbGVjdGlvblwiLCB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQoY29uZmlnLCBpbnN0YW5jZSkge1xuICAgIHJldHVybiBjb25maWcuc2VsZWN0aW9uIHx8IFNlbGVjdGlvbi5hdFN0YXJ0KGluc3RhbmNlLmRvYyk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0cikge1xuICAgIHJldHVybiB0ci5zZWxlY3Rpb247XG4gIH1cbn0pLCBuZXcgRmllbGREZXNjKFwic3RvcmVkTWFya3NcIiwge1xuICBpbml0OiBmdW5jdGlvbiBpbml0KGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcuc3RvcmVkTWFya3MgfHwgbnVsbDtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRyLCBfbWFya3MsIF9vbGQsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yID8gdHIuc3RvcmVkTWFya3MgOiBudWxsO1xuICB9XG59KSwgbmV3IEZpZWxkRGVzYyhcInNjcm9sbFRvU2VsZWN0aW9uXCIsIHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRyLCBwcmV2KSB7XG4gICAgcmV0dXJuIHRyLnNjcm9sbGVkSW50b1ZpZXcgPyBwcmV2ICsgMSA6IHByZXY7XG4gIH1cbn0pXTtcblxudmFyIENvbmZpZ3VyYXRpb24gPSBfY3JlYXRlQ2xhc3MoZnVuY3Rpb24gQ29uZmlndXJhdGlvbihzY2hlbWEsIHBsdWdpbnMpIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmZpZ3VyYXRpb24pO1xuXG4gIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgdGhpcy5wbHVnaW5zQnlLZXkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLmZpZWxkcyA9IGJhc2VGaWVsZHMuc2xpY2UoKTtcbiAgaWYgKHBsdWdpbnMpIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgaWYgKF90aGlzMy5wbHVnaW5zQnlLZXlbcGx1Z2luLmtleV0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQWRkaW5nIGRpZmZlcmVudCBpbnN0YW5jZXMgb2YgYSBrZXllZCBwbHVnaW4gKFwiICsgcGx1Z2luLmtleSArIFwiKVwiKTtcblxuICAgIF90aGlzMy5wbHVnaW5zLnB1c2gocGx1Z2luKTtcblxuICAgIF90aGlzMy5wbHVnaW5zQnlLZXlbcGx1Z2luLmtleV0gPSBwbHVnaW47XG4gICAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlKSBfdGhpczMuZmllbGRzLnB1c2gobmV3IEZpZWxkRGVzYyhwbHVnaW4ua2V5LCBwbHVnaW4uc3BlYy5zdGF0ZSwgcGx1Z2luKSk7XG4gIH0pO1xufSk7XG5cbnZhciBFZGl0b3JTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRWRpdG9yU3RhdGUoY29uZmlnKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkaXRvclN0YXRlKTtcblxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVkaXRvclN0YXRlLCBbe1xuICAgIGtleTogXCJzY2hlbWFcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5zY2hlbWE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBsdWdpbnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5wbHVnaW5zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSh0cikge1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUcmFuc2FjdGlvbih0cikuc3RhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbHRlclRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlclRyYW5zYWN0aW9uKHRyKSB7XG4gICAgICB2YXIgaWdub3JlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAtMTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpICE9IGlnbm9yZSkge1xuICAgICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiAmJiAhcGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24uY2FsbChwbHVnaW4sIHRyLCB0aGlzKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5VHJhbnNhY3Rpb24ocm9vdFRyKSB7XG4gICAgICBpZiAoIXRoaXMuZmlsdGVyVHJhbnNhY3Rpb24ocm9vdFRyKSkgcmV0dXJuIHtcbiAgICAgICAgc3RhdGU6IHRoaXMsXG4gICAgICAgIHRyYW5zYWN0aW9uczogW11cbiAgICAgIH07XG4gICAgICB2YXIgdHJzID0gW3Jvb3RUcl0sXG4gICAgICAgICAgbmV3U3RhdGUgPSB0aGlzLmFwcGx5SW5uZXIocm9vdFRyKSxcbiAgICAgICAgICBzZWVuID0gbnVsbDtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICB2YXIgaGF2ZU5ldyA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuXG4gICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHNlZW4gPyBzZWVuW2ldLm4gOiAwLFxuICAgICAgICAgICAgICAgIG9sZFN0YXRlID0gc2VlbiA/IHNlZW5baV0uc3RhdGUgOiB0aGlzO1xuICAgICAgICAgICAgdmFyIHRyID0gbiA8IHRycy5sZW5ndGggJiYgcGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24uY2FsbChwbHVnaW4sIG4gPyB0cnMuc2xpY2UobikgOiB0cnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG5cbiAgICAgICAgICAgIGlmICh0ciAmJiBuZXdTdGF0ZS5maWx0ZXJUcmFuc2FjdGlvbih0ciwgaSkpIHtcbiAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImFwcGVuZGVkVHJhbnNhY3Rpb25cIiwgcm9vdFRyKTtcblxuICAgICAgICAgICAgICBpZiAoIXNlZW4pIHtcbiAgICAgICAgICAgICAgICBzZWVuID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChqIDwgaSA/IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICBuOiB0cnMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbjogMFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdHJzLnB1c2godHIpO1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLmFwcGx5SW5uZXIodHIpO1xuICAgICAgICAgICAgICBoYXZlTmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlZW4pIHNlZW5baV0gPSB7XG4gICAgICAgICAgICAgIHN0YXRlOiBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgbjogdHJzLmxlbmd0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhdmVOZXcpIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgIHRyYW5zYWN0aW9uczogdHJzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5SW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlJbm5lcih0cikge1xuICAgICAgaWYgKCF0ci5iZWZvcmUuZXEodGhpcy5kb2MpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGEgbWlzbWF0Y2hlZCB0cmFuc2FjdGlvblwiKTtcbiAgICAgIHZhciBuZXdJbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSh0aGlzLmNvbmZpZyksXG4gICAgICAgICAgZmllbGRzID0gdGhpcy5jb25maWcuZmllbGRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgIG5ld0luc3RhbmNlW2ZpZWxkLm5hbWVdID0gZmllbGQuYXBwbHkodHIsIHRoaXNbZmllbGQubmFtZV0sIHRoaXMsIG5ld0luc3RhbmNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0luc3RhbmNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0clwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbih0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVjb25maWd1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICB2YXIgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKHRoaXMuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gICAgICB2YXIgZmllbGRzID0gJGNvbmZpZy5maWVsZHMsXG4gICAgICAgICAgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gZmllbGRzW2ldLm5hbWU7XG4gICAgICAgIGluc3RhbmNlW25hbWVdID0gdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHRoaXNbbmFtZV0gOiBmaWVsZHNbaV0uaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKHBsdWdpbkZpZWxkcykge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgZG9jOiB0aGlzLmRvYy50b0pTT04oKSxcbiAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnN0b3JlZE1hcmtzKSByZXN1bHQuc3RvcmVkTWFya3MgPSB0aGlzLnN0b3JlZE1hcmtzLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gbS50b0pTT04oKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHBsdWdpbkZpZWxkcyAmJiBfdHlwZW9mKHBsdWdpbkZpZWxkcykgPT0gJ29iamVjdCcpIGZvciAodmFyIHByb3AgaW4gcGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGlmIChwcm9wID09IFwiZG9jXCIgfHwgcHJvcCA9PSBcInNlbGVjdGlvblwiKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBKU09OIGZpZWxkcyBgZG9jYCBhbmQgYHNlbGVjdGlvbmAgYXJlIHJlc2VydmVkXCIpO1xuICAgICAgICB2YXIgcGx1Z2luID0gcGx1Z2luRmllbGRzW3Byb3BdLFxuICAgICAgICAgICAgc3RhdGUgPSBwbHVnaW4uc3BlYy5zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvSlNPTikgcmVzdWx0W3Byb3BdID0gc3RhdGUudG9KU09OLmNhbGwocGx1Z2luLCB0aGlzW3BsdWdpbi5rZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShjb25maWcpIHtcbiAgICAgIHZhciAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLmRvYyA/IGNvbmZpZy5kb2MudHlwZS5zY2hlbWEgOiBjb25maWcuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJGNvbmZpZy5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5zdGFuY2VbJGNvbmZpZy5maWVsZHNbaV0ubmFtZV0gPSAkY29uZmlnLmZpZWxkc1tpXS5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGNvbmZpZywganNvbiwgcGx1Z2luRmllbGRzKSB7XG4gICAgICBpZiAoIWpzb24pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRWRpdG9yU3RhdGUuZnJvbUpTT05cIik7XG4gICAgICBpZiAoIWNvbmZpZy5zY2hlbWEpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVxdWlyZWQgY29uZmlnIGZpZWxkICdzY2hlbWEnIG1pc3NpbmdcIik7XG4gICAgICB2YXIgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICRjb25maWcuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGlmIChmaWVsZC5uYW1lID09IFwiZG9jXCIpIHtcbiAgICAgICAgICBpbnN0YW5jZS5kb2MgPSBwcm9zZW1pcnJvck1vZGVsLk5vZGUuZnJvbUpTT04oY29uZmlnLnNjaGVtYSwganNvbi5kb2MpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLm5hbWUgPT0gXCJzZWxlY3Rpb25cIikge1xuICAgICAgICAgIGluc3RhbmNlLnNlbGVjdGlvbiA9IFNlbGVjdGlvbi5mcm9tSlNPTihpbnN0YW5jZS5kb2MsIGpzb24uc2VsZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5uYW1lID09IFwic3RvcmVkTWFya3NcIikge1xuICAgICAgICAgIGlmIChqc29uLnN0b3JlZE1hcmtzKSBpbnN0YW5jZS5zdG9yZWRNYXJrcyA9IGpzb24uc3RvcmVkTWFya3MubWFwKGNvbmZpZy5zY2hlbWEubWFya0Zyb21KU09OKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocGx1Z2luRmllbGRzKSBmb3IgKHZhciBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgdmFyIHBsdWdpbiA9IHBsdWdpbkZpZWxkc1twcm9wXSxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHBsdWdpbi5zcGVjLnN0YXRlO1xuXG4gICAgICAgICAgICBpZiAocGx1Z2luLmtleSA9PSBmaWVsZC5uYW1lICYmIHN0YXRlICYmIHN0YXRlLmZyb21KU09OICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqc29uLCBwcm9wKSkge1xuICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IHN0YXRlLmZyb21KU09OLmNhbGwocGx1Z2luLCBjb25maWcsIGpzb25bcHJvcF0sIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IGZpZWxkLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFZGl0b3JTdGF0ZTtcbn0oKTtcblxuZnVuY3Rpb24gYmluZFByb3BzKG9iaiwgc2VsZiwgdGFyZ2V0KSB7XG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgdmFyIHZhbCA9IG9ialtwcm9wXTtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHZhbCA9IHZhbC5iaW5kKHNlbGYpO2Vsc2UgaWYgKHByb3AgPT0gXCJoYW5kbGVET01FdmVudHNcIikgdmFsID0gYmluZFByb3BzKHZhbCwgc2VsZiwge30pO1xuICAgIHRhcmdldFtwcm9wXSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsdWdpbihzcGVjKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsdWdpbik7XG5cbiAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIHRoaXMucHJvcHMgPSB7fTtcbiAgICBpZiAoc3BlYy5wcm9wcykgYmluZFByb3BzKHNwZWMucHJvcHMsIHRoaXMsIHRoaXMucHJvcHMpO1xuICAgIHRoaXMua2V5ID0gc3BlYy5rZXkgPyBzcGVjLmtleS5rZXkgOiBjcmVhdGVLZXkoXCJwbHVnaW5cIik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGx1Z2luLCBbe1xuICAgIGtleTogXCJnZXRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlW3RoaXMua2V5XTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGx1Z2luO1xufSgpO1xuXG52YXIga2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShuYW1lKSB7XG4gIGlmIChuYW1lIGluIGtleXMpIHJldHVybiBuYW1lICsgXCIkXCIgKyArK2tleXNbbmFtZV07XG4gIGtleXNbbmFtZV0gPSAwO1xuICByZXR1cm4gbmFtZSArIFwiJFwiO1xufVxuXG52YXIgUGx1Z2luS2V5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbHVnaW5LZXkoKSB7XG4gICAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwia2V5XCI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGx1Z2luS2V5KTtcblxuICAgIHRoaXMua2V5ID0gY3JlYXRlS2V5KG5hbWUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBsdWdpbktleSwgW3tcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5wbHVnaW5zQnlLZXlbdGhpcy5rZXldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlW3RoaXMua2V5XTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGx1Z2luS2V5O1xufSgpO1xuXG5leHBvcnRzLkFsbFNlbGVjdGlvbiA9IEFsbFNlbGVjdGlvbjtcbmV4cG9ydHMuRWRpdG9yU3RhdGUgPSBFZGl0b3JTdGF0ZTtcbmV4cG9ydHMuTm9kZVNlbGVjdGlvbiA9IE5vZGVTZWxlY3Rpb247XG5leHBvcnRzLlBsdWdpbiA9IFBsdWdpbjtcbmV4cG9ydHMuUGx1Z2luS2V5ID0gUGx1Z2luS2V5O1xuZXhwb3J0cy5TZWxlY3Rpb24gPSBTZWxlY3Rpb247XG5leHBvcnRzLlNlbGVjdGlvblJhbmdlID0gU2VsZWN0aW9uUmFuZ2U7XG5leHBvcnRzLlRleHRTZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uO1xuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBwcm9zZW1pcnJvck1vZGVsID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItbW9kZWwnKTtcblxudmFyIGxvd2VyMTYgPSAweGZmZmY7XG52YXIgZmFjdG9yMTYgPSBNYXRoLnBvdygyLCAxNik7XG5cbmZ1bmN0aW9uIG1ha2VSZWNvdmVyKGluZGV4LCBvZmZzZXQpIHtcbiAgcmV0dXJuIGluZGV4ICsgb2Zmc2V0ICogZmFjdG9yMTY7XG59XG5cbmZ1bmN0aW9uIHJlY292ZXJJbmRleCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiBsb3dlcjE2O1xufVxuXG5mdW5jdGlvbiByZWNvdmVyT2Zmc2V0KHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgLSAodmFsdWUgJiBsb3dlcjE2KSkgLyBmYWN0b3IxNjtcbn1cblxudmFyIERFTF9CRUZPUkUgPSAxLFxuICAgIERFTF9BRlRFUiA9IDIsXG4gICAgREVMX0FDUk9TUyA9IDQsXG4gICAgREVMX1NJREUgPSA4O1xuXG52YXIgTWFwUmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXBSZXN1bHQocG9zLCBkZWxJbmZvLCByZWNvdmVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcFJlc3VsdCk7XG5cbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB0aGlzLmRlbEluZm8gPSBkZWxJbmZvO1xuICAgIHRoaXMucmVjb3ZlciA9IHJlY292ZXI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFwUmVzdWx0LCBbe1xuICAgIGtleTogXCJkZWxldGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIERFTF9TSURFKSA+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZWRCZWZvcmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9CRUZPUkUgfCBERUxfQUNST1NTKSkgPiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVkQWZ0ZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9BRlRFUiB8IERFTF9BQ1JPU1MpKSA+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZWRBY3Jvc3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX0FDUk9TUykgPiAwO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXBSZXN1bHQ7XG59KCk7XG5cbnZhciBTdGVwTWFwID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdGVwTWFwKHJhbmdlcykge1xuICAgIHZhciBpbnZlcnRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RlcE1hcCk7XG5cbiAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICB0aGlzLmludmVydGVkID0gaW52ZXJ0ZWQ7XG4gICAgaWYgKCFyYW5nZXMubGVuZ3RoICYmIFN0ZXBNYXAuZW1wdHkpIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0ZXBNYXAsIFt7XG4gICAga2V5OiBcInJlY292ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3Zlcih2YWx1ZSkge1xuICAgICAgdmFyIGRpZmYgPSAwLFxuICAgICAgICAgIGluZGV4ID0gcmVjb3ZlckluZGV4KHZhbHVlKTtcbiAgICAgIGlmICghdGhpcy5pbnZlcnRlZCkgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgIGRpZmYgKz0gdGhpcy5yYW5nZXNbaSAqIDMgKyAyXSAtIHRoaXMucmFuZ2VzW2kgKiAzICsgMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZXNbaW5kZXggKiAzXSArIGRpZmYgKyByZWNvdmVyT2Zmc2V0KHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwUmVzdWx0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcFJlc3VsdChwb3MpIHtcbiAgICAgIHZhciBhc3NvYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKHBvcykge1xuICAgICAgdmFyIGFzc29jID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX21hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFwKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICAgICAgdmFyIGRpZmYgPSAwLFxuICAgICAgICAgIG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLFxuICAgICAgICAgIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMucmFuZ2VzW2ldIC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCk7XG4gICAgICAgIGlmIChzdGFydCA+IHBvcykgYnJlYWs7XG4gICAgICAgIHZhciBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSxcbiAgICAgICAgICAgIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdLFxuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuXG4gICAgICAgIGlmIChwb3MgPD0gZW5kKSB7XG4gICAgICAgICAgdmFyIHNpZGUgPSAhb2xkU2l6ZSA/IGFzc29jIDogcG9zID09IHN0YXJ0ID8gLTEgOiBwb3MgPT0gZW5kID8gMSA6IGFzc29jO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBzdGFydCArIGRpZmYgKyAoc2lkZSA8IDAgPyAwIDogbmV3U2l6ZSk7XG4gICAgICAgICAgaWYgKHNpbXBsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB2YXIgcmVjb3ZlciA9IHBvcyA9PSAoYXNzb2MgPCAwID8gc3RhcnQgOiBlbmQpID8gbnVsbCA6IG1ha2VSZWNvdmVyKGkgLyAzLCBwb3MgLSBzdGFydCk7XG4gICAgICAgICAgdmFyIGRlbCA9IHBvcyA9PSBzdGFydCA/IERFTF9BRlRFUiA6IHBvcyA9PSBlbmQgPyBERUxfQkVGT1JFIDogREVMX0FDUk9TUztcbiAgICAgICAgICBpZiAoYXNzb2MgPCAwID8gcG9zICE9IHN0YXJ0IDogcG9zICE9IGVuZCkgZGVsIHw9IERFTF9TSURFO1xuICAgICAgICAgIHJldHVybiBuZXcgTWFwUmVzdWx0KHJlc3VsdCwgZGVsLCByZWNvdmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpZmYgKz0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaW1wbGUgPyBwb3MgKyBkaWZmIDogbmV3IE1hcFJlc3VsdChwb3MgKyBkaWZmLCAwLCBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG91Y2hlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b3VjaGVzKHBvcywgcmVjb3Zlcikge1xuICAgICAgdmFyIGRpZmYgPSAwLFxuICAgICAgICAgIGluZGV4ID0gcmVjb3ZlckluZGV4KHJlY292ZXIpO1xuICAgICAgdmFyIG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLFxuICAgICAgICAgIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMucmFuZ2VzW2ldIC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCk7XG4gICAgICAgIGlmIChzdGFydCA+IHBvcykgYnJlYWs7XG4gICAgICAgIHZhciBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSxcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICAgICAgaWYgKHBvcyA8PSBlbmQgJiYgaSA9PSBpbmRleCAqIDMpIHJldHVybiB0cnVlO1xuICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0gLSBvbGRTaXplO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChmKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsXG4gICAgICAgICAgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBkaWZmID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMucmFuZ2VzW2ldLFxuICAgICAgICAgICAgb2xkU3RhcnQgPSBzdGFydCAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApLFxuICAgICAgICAgICAgbmV3U3RhcnQgPSBzdGFydCArICh0aGlzLmludmVydGVkID8gMCA6IGRpZmYpO1xuICAgICAgICB2YXIgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sXG4gICAgICAgICAgICBuZXdTaXplID0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XTtcbiAgICAgICAgZihvbGRTdGFydCwgb2xkU3RhcnQgKyBvbGRTaXplLCBuZXdTdGFydCwgbmV3U3RhcnQgKyBuZXdTaXplKTtcbiAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW52ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmVydCgpIHtcbiAgICAgIHJldHVybiBuZXcgU3RlcE1hcCh0aGlzLnJhbmdlcywgIXRoaXMuaW52ZXJ0ZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAodGhpcy5pbnZlcnRlZCA/IFwiLVwiIDogXCJcIikgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnJhbmdlcyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwib2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZnNldChuKSB7XG4gICAgICByZXR1cm4gbiA9PSAwID8gU3RlcE1hcC5lbXB0eSA6IG5ldyBTdGVwTWFwKG4gPCAwID8gWzAsIC1uLCAwXSA6IFswLCAwLCBuXSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0ZXBNYXA7XG59KCk7XG5cblN0ZXBNYXAuZW1wdHkgPSBuZXcgU3RlcE1hcChbXSk7XG5cbnZhciBNYXBwaW5nID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXBwaW5nKCkge1xuICAgIHZhciBtYXBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICB2YXIgbWlycm9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgdmFyIHRvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBtYXBzLmxlbmd0aDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXBwaW5nKTtcblxuICAgIHRoaXMubWFwcyA9IG1hcHM7XG4gICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICB0aGlzLnRvID0gdG87XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFwcGluZywgW3tcbiAgICBrZXk6IFwic2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2xpY2UoKSB7XG4gICAgICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5tYXBzLmxlbmd0aDtcbiAgICAgIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLm1hcHMsIHRoaXMubWlycm9yLCBmcm9tLCB0byk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weSgpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLm1hcHMuc2xpY2UoKSwgdGhpcy5taXJyb3IgJiYgdGhpcy5taXJyb3Iuc2xpY2UoKSwgdGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZE1hcChtYXAsIG1pcnJvcnMpIHtcbiAgICAgIHRoaXMudG8gPSB0aGlzLm1hcHMucHVzaChtYXApO1xuICAgICAgaWYgKG1pcnJvcnMgIT0gbnVsbCkgdGhpcy5zZXRNaXJyb3IodGhpcy5tYXBzLmxlbmd0aCAtIDEsIG1pcnJvcnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRNYXBwaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZE1hcHBpbmcobWFwcGluZykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHN0YXJ0U2l6ZSA9IHRoaXMubWFwcy5sZW5ndGg7IGkgPCBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG1pcnIgPSBtYXBwaW5nLmdldE1pcnJvcihpKTtcbiAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLCBtaXJyICE9IG51bGwgJiYgbWlyciA8IGkgPyBzdGFydFNpemUgKyBtaXJyIDogdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWlycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1pcnJvcihuKSB7XG4gICAgICBpZiAodGhpcy5taXJyb3IpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5taXJyb3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yW2ldID09IG4pIHJldHVybiB0aGlzLm1pcnJvcltpICsgKGkgJSAyID8gLTEgOiAxKV07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE1pcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNaXJyb3IobiwgbSkge1xuICAgICAgaWYgKCF0aGlzLm1pcnJvcikgdGhpcy5taXJyb3IgPSBbXTtcbiAgICAgIHRoaXMubWlycm9yLnB1c2gobiwgbSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZE1hcHBpbmdJbnZlcnRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRNYXBwaW5nSW52ZXJ0ZWQobWFwcGluZykge1xuICAgICAgZm9yICh2YXIgaSA9IG1hcHBpbmcubWFwcy5sZW5ndGggLSAxLCB0b3RhbFNpemUgPSB0aGlzLm1hcHMubGVuZ3RoICsgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1pcnIgPSBtYXBwaW5nLmdldE1pcnJvcihpKTtcbiAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLmludmVydCgpLCBtaXJyICE9IG51bGwgJiYgbWlyciA+IGkgPyB0b3RhbFNpemUgLSBtaXJyIC0gMSA6IHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgICB2YXIgaW52ZXJzZSA9IG5ldyBNYXBwaW5nKCk7XG4gICAgICBpbnZlcnNlLmFwcGVuZE1hcHBpbmdJbnZlcnRlZCh0aGlzKTtcbiAgICAgIHJldHVybiBpbnZlcnNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKHBvcykge1xuICAgICAgdmFyIGFzc29jID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgaWYgKHRoaXMubWlycm9yKSByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpO1xuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKSB7XG4gICAgICAgIHBvcyA9IHRoaXMubWFwc1tpXS5tYXAocG9zLCBhc3NvYyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFJlc3VsdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBSZXN1bHQocG9zKSB7XG4gICAgICB2YXIgYXNzb2MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX21hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFwKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICAgICAgdmFyIGRlbEluZm8gPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcHNbaV0sXG4gICAgICAgICAgICByZXN1bHQgPSBtYXAubWFwUmVzdWx0KHBvcywgYXNzb2MpO1xuXG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlciAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGNvcnIgPSB0aGlzLmdldE1pcnJvcihpKTtcblxuICAgICAgICAgIGlmIChjb3JyICE9IG51bGwgJiYgY29yciA+IGkgJiYgY29yciA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgIGkgPSBjb3JyO1xuICAgICAgICAgICAgcG9zID0gdGhpcy5tYXBzW2NvcnJdLnJlY292ZXIocmVzdWx0LnJlY292ZXIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsSW5mbyB8PSByZXN1bHQuZGVsSW5mbztcbiAgICAgICAgcG9zID0gcmVzdWx0LnBvcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyA6IG5ldyBNYXBSZXN1bHQocG9zLCBkZWxJbmZvLCBudWxsKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFwcGluZztcbn0oKTtcblxudmFyIHN0ZXBzQnlJRCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbnZhciBTdGVwID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdGVwKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGVwKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdGVwLCBbe1xuICAgIGtleTogXCJnZXRNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFwKCkge1xuICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKG90aGVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgIGlmICghanNvbiB8fCAhanNvbi5zdGVwVHlwZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTdGVwLmZyb21KU09OXCIpO1xuICAgICAgdmFyIHR5cGUgPSBzdGVwc0J5SURbanNvbi5zdGVwVHlwZV07XG4gICAgICBpZiAoIXR5cGUpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gc3RlcCB0eXBlIFwiLmNvbmNhdChqc29uLnN0ZXBUeXBlLCBcIiBkZWZpbmVkXCIpKTtcbiAgICAgIHJldHVybiB0eXBlLmZyb21KU09OKHNjaGVtYSwganNvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpzb25JRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqc29uSUQoaWQsIHN0ZXBDbGFzcykge1xuICAgICAgaWYgKGlkIGluIHN0ZXBzQnlJRCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXBsaWNhdGUgdXNlIG9mIHN0ZXAgSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgIHN0ZXBzQnlJRFtpZF0gPSBzdGVwQ2xhc3M7XG4gICAgICBzdGVwQ2xhc3MucHJvdG90eXBlLmpzb25JRCA9IGlkO1xuICAgICAgcmV0dXJuIHN0ZXBDbGFzcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RlcDtcbn0oKTtcblxudmFyIFN0ZXBSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0ZXBSZXN1bHQoZG9jLCBmYWlsZWQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RlcFJlc3VsdCk7XG5cbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLmZhaWxlZCA9IGZhaWxlZDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdGVwUmVzdWx0LCBudWxsLCBbe1xuICAgIGtleTogXCJva1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvayhkb2MpIHtcbiAgICAgIHJldHVybiBuZXcgU3RlcFJlc3VsdChkb2MsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmYWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KG51bGwsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tUmVwbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUmVwbGFjZShkb2MsIGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQub2soZG9jLnJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JNb2RlbC5SZXBsYWNlRXJyb3IpIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoZS5tZXNzYWdlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RlcFJlc3VsdDtcbn0oKTtcblxuZnVuY3Rpb24gbWFwRnJhZ21lbnQoZnJhZ21lbnQsIGYsIHBhcmVudCkge1xuICB2YXIgbWFwcGVkID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBmcmFnbWVudC5jaGlsZChpKTtcbiAgICBpZiAoY2hpbGQuY29udGVudC5zaXplKSBjaGlsZCA9IGNoaWxkLmNvcHkobWFwRnJhZ21lbnQoY2hpbGQuY29udGVudCwgZiwgY2hpbGQpKTtcbiAgICBpZiAoY2hpbGQuaXNJbmxpbmUpIGNoaWxkID0gZihjaGlsZCwgcGFyZW50LCBpKTtcbiAgICBtYXBwZWQucHVzaChjaGlsZCk7XG4gIH1cblxuICByZXR1cm4gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tQXJyYXkobWFwcGVkKTtcbn1cblxudmFyIEFkZE1hcmtTdGVwID0gZnVuY3Rpb24gKF9TdGVwKSB7XG4gIF9pbmhlcml0cyhBZGRNYXJrU3RlcCwgX1N0ZXApO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWRkTWFya1N0ZXApO1xuXG4gIGZ1bmN0aW9uIEFkZE1hcmtTdGVwKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFkZE1hcmtTdGVwKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMuZnJvbSA9IGZyb207XG4gICAgX3RoaXMudG8gPSB0bztcbiAgICBfdGhpcy5tYXJrID0gbWFyaztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQWRkTWFya1N0ZXAsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGRvYykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBvbGRTbGljZSA9IGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLFxuICAgICAgICAgICRmcm9tID0gZG9jLnJlc29sdmUodGhpcy5mcm9tKTtcbiAgICAgIHZhciBwYXJlbnQgPSAkZnJvbS5ub2RlKCRmcm9tLnNoYXJlZERlcHRoKHRoaXMudG8pKTtcbiAgICAgIHZhciBzbGljZSA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKG1hcEZyYWdtZW50KG9sZFNsaWNlLmNvbnRlbnQsIGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKCFub2RlLmlzQXRvbSB8fCAhcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUoX3RoaXMyLm1hcmsudHlwZSkpIHJldHVybiBub2RlO1xuICAgICAgICByZXR1cm4gbm9kZS5tYXJrKF90aGlzMi5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICAgIH0sIHBhcmVudCksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAobWFwcGluZykge1xuICAgICAgdmFyIGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLFxuICAgICAgICAgIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgaWYgKGZyb20uZGVsZXRlZCAmJiB0by5kZWxldGVkIHx8IGZyb20ucG9zID49IHRvLnBvcykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKGZyb20ucG9zLCB0by5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBBZGRNYXJrU3RlcCAmJiBvdGhlci5tYXJrLmVxKHRoaXMubWFyaykgJiYgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSkgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0ZXBUeXBlOiBcImFkZE1hcmtcIixcbiAgICAgICAgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgIHRvOiB0aGlzLnRvXG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEFkZE1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFkZE1hcmtTdGVwO1xufShTdGVwKTtcblxuU3RlcC5qc29uSUQoXCJhZGRNYXJrXCIsIEFkZE1hcmtTdGVwKTtcblxudmFyIFJlbW92ZU1hcmtTdGVwID0gZnVuY3Rpb24gKF9TdGVwMikge1xuICBfaW5oZXJpdHMoUmVtb3ZlTWFya1N0ZXAsIF9TdGVwMik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoUmVtb3ZlTWFya1N0ZXApO1xuXG4gIGZ1bmN0aW9uIFJlbW92ZU1hcmtTdGVwKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW1vdmVNYXJrU3RlcCk7XG5cbiAgICBfdGhpczMgPSBfc3VwZXIyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMzLmZyb20gPSBmcm9tO1xuICAgIF90aGlzMy50byA9IHRvO1xuICAgIF90aGlzMy5tYXJrID0gbWFyaztcbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlbW92ZU1hcmtTdGVwLCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShkb2MpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICAgIHZhciBzbGljZSA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKG1hcEZyYWdtZW50KG9sZFNsaWNlLmNvbnRlbnQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLm1hcmsoX3RoaXM0Lm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICB9LCBkb2MpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHNsaWNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW52ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmVydCgpIHtcbiAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcpIHtcbiAgICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSxcbiAgICAgICAgICB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZShvdGhlcikge1xuICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgUmVtb3ZlTWFya1N0ZXAgJiYgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmIHRoaXMuZnJvbSA8PSBvdGhlci50byAmJiB0aGlzLnRvID49IG90aGVyLmZyb20pIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGVwVHlwZTogXCJyZW1vdmVNYXJrXCIsXG4gICAgICAgIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICB0bzogdGhpcy50b1xuICAgICAgfTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZW1vdmVNYXJrU3RlcDtcbn0oU3RlcCk7XG5cblN0ZXAuanNvbklEKFwicmVtb3ZlTWFya1wiLCBSZW1vdmVNYXJrU3RlcCk7XG5cbnZhciBSZXBsYWNlU3RlcCA9IGZ1bmN0aW9uIChfU3RlcDMpIHtcbiAgX2luaGVyaXRzKFJlcGxhY2VTdGVwLCBfU3RlcDMpO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKFJlcGxhY2VTdGVwKTtcblxuICBmdW5jdGlvbiBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UpIHtcbiAgICB2YXIgX3RoaXM1O1xuXG4gICAgdmFyIHN0cnVjdHVyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVwbGFjZVN0ZXApO1xuXG4gICAgX3RoaXM1ID0gX3N1cGVyMy5jYWxsKHRoaXMpO1xuICAgIF90aGlzNS5mcm9tID0gZnJvbTtcbiAgICBfdGhpczUudG8gPSB0bztcbiAgICBfdGhpczUuc2xpY2UgPSBzbGljZTtcbiAgICBfdGhpczUuc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIHJldHVybiBfdGhpczU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVwbGFjZVN0ZXAsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGRvYykge1xuICAgICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvKSkgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSByZXBsYWNlIHdvdWxkIG92ZXJ3cml0ZSBjb250ZW50XCIpO1xuICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMuc2xpY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFwKCkge1xuICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMudG8gLSB0aGlzLmZyb20sIHRoaXMuc2xpY2Uuc2l6ZV0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KGRvYykge1xuICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSwgZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcpIHtcbiAgICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSxcbiAgICAgICAgICB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgIGlmIChmcm9tLmRlbGV0ZWRBY3Jvc3MgJiYgdG8uZGVsZXRlZEFjcm9zcykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20ucG9zLCBNYXRoLm1heChmcm9tLnBvcywgdG8ucG9zKSwgdGhpcy5zbGljZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKG90aGVyKSB7XG4gICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwKSB8fCBvdGhlci5zdHJ1Y3R1cmUgfHwgdGhpcy5zdHJ1Y3R1cmUpIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAodGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplID09IG90aGVyLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlbkVuZCAmJiAhb3RoZXIuc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgIHZhciBzbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkgOiBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZSh0aGlzLnNsaWNlLmNvbnRlbnQuYXBwZW5kKG90aGVyLnNsaWNlLmNvbnRlbnQpLCB0aGlzLnNsaWNlLm9wZW5TdGFydCwgb3RoZXIuc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLnRvICsgKG90aGVyLnRvIC0gb3RoZXIuZnJvbSksIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyLnRvID09IHRoaXMuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuU3RhcnQgJiYgIW90aGVyLnNsaWNlLm9wZW5FbmQpIHtcbiAgICAgICAgdmFyIF9zbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkgOiBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShvdGhlci5zbGljZS5jb250ZW50LmFwcGVuZCh0aGlzLnNsaWNlLmNvbnRlbnQpLCBvdGhlci5zbGljZS5vcGVuU3RhcnQsIHRoaXMuc2xpY2Uub3BlbkVuZCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChvdGhlci5mcm9tLCB0aGlzLnRvLCBfc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIGpzb24gPSB7XG4gICAgICAgIHN0ZXBUeXBlOiBcInJlcGxhY2VcIixcbiAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICB0bzogdGhpcy50b1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnNsaWNlLnNpemUpIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgaWYgKHRoaXMuc3RydWN0dXJlKSBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXBsYWNlU3RlcDtcbn0oU3RlcCk7XG5cblN0ZXAuanNvbklEKFwicmVwbGFjZVwiLCBSZXBsYWNlU3RlcCk7XG5cbnZhciBSZXBsYWNlQXJvdW5kU3RlcCA9IGZ1bmN0aW9uIChfU3RlcDQpIHtcbiAgX2luaGVyaXRzKFJlcGxhY2VBcm91bmRTdGVwLCBfU3RlcDQpO1xuXG4gIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKFJlcGxhY2VBcm91bmRTdGVwKTtcblxuICBmdW5jdGlvbiBSZXBsYWNlQXJvdW5kU3RlcChmcm9tLCB0bywgZ2FwRnJvbSwgZ2FwVG8sIHNsaWNlLCBpbnNlcnQpIHtcbiAgICB2YXIgX3RoaXM2O1xuXG4gICAgdmFyIHN0cnVjdHVyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogZmFsc2U7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVwbGFjZUFyb3VuZFN0ZXApO1xuXG4gICAgX3RoaXM2ID0gX3N1cGVyNC5jYWxsKHRoaXMpO1xuICAgIF90aGlzNi5mcm9tID0gZnJvbTtcbiAgICBfdGhpczYudG8gPSB0bztcbiAgICBfdGhpczYuZ2FwRnJvbSA9IGdhcEZyb207XG4gICAgX3RoaXM2LmdhcFRvID0gZ2FwVG87XG4gICAgX3RoaXM2LnNsaWNlID0gc2xpY2U7XG4gICAgX3RoaXM2Lmluc2VydCA9IGluc2VydDtcbiAgICBfdGhpczYuc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIHJldHVybiBfdGhpczY7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVwbGFjZUFyb3VuZFN0ZXAsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGRvYykge1xuICAgICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIChjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZnJvbSwgdGhpcy5nYXBGcm9tKSB8fCBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZ2FwVG8sIHRoaXMudG8pKSkgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSBnYXAtcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgIHZhciBnYXAgPSBkb2Muc2xpY2UodGhpcy5nYXBGcm9tLCB0aGlzLmdhcFRvKTtcbiAgICAgIGlmIChnYXAub3BlblN0YXJ0IHx8IGdhcC5vcGVuRW5kKSByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiR2FwIGlzIG5vdCBhIGZsYXQgcmFuZ2VcIik7XG4gICAgICB2YXIgaW5zZXJ0ZWQgPSB0aGlzLnNsaWNlLmluc2VydEF0KHRoaXMuaW5zZXJ0LCBnYXAuY29udGVudCk7XG4gICAgICBpZiAoIWluc2VydGVkKSByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiQ29udGVudCBkb2VzIG5vdCBmaXQgaW4gZ2FwXCIpO1xuICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIGluc2VydGVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcCgpIHtcbiAgICAgIHJldHVybiBuZXcgU3RlcE1hcChbdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuaW5zZXJ0LCB0aGlzLmdhcFRvLCB0aGlzLnRvIC0gdGhpcy5nYXBUbywgdGhpcy5zbGljZS5zaXplIC0gdGhpcy5pbnNlcnRdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW52ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmVydChkb2MpIHtcbiAgICAgIHZhciBnYXAgPSB0aGlzLmdhcFRvIC0gdGhpcy5nYXBGcm9tO1xuICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSArIGdhcCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQsIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0ICsgZ2FwLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKS5yZW1vdmVCZXR3ZWVuKHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5nYXBUbyAtIHRoaXMuZnJvbSksIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcpIHtcbiAgICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSxcbiAgICAgICAgICB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgIHZhciBnYXBGcm9tID0gbWFwcGluZy5tYXAodGhpcy5nYXBGcm9tLCAtMSksXG4gICAgICAgICAgZ2FwVG8gPSBtYXBwaW5nLm1hcCh0aGlzLmdhcFRvLCAxKTtcbiAgICAgIGlmIChmcm9tLmRlbGV0ZWRBY3Jvc3MgJiYgdG8uZGVsZXRlZEFjcm9zcyB8fCBnYXBGcm9tIDwgZnJvbS5wb3MgfHwgZ2FwVG8gPiB0by5wb3MpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChmcm9tLnBvcywgdG8ucG9zLCBnYXBGcm9tLCBnYXBUbywgdGhpcy5zbGljZSwgdGhpcy5pbnNlcnQsIHRoaXMuc3RydWN0dXJlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHZhciBqc29uID0ge1xuICAgICAgICBzdGVwVHlwZTogXCJyZXBsYWNlQXJvdW5kXCIsXG4gICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgIGdhcEZyb206IHRoaXMuZ2FwRnJvbSxcbiAgICAgICAgZ2FwVG86IHRoaXMuZ2FwVG8sXG4gICAgICAgIGluc2VydDogdGhpcy5pbnNlcnRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5zbGljZS5zaXplKSBqc29uLnNsaWNlID0gdGhpcy5zbGljZS50b0pTT04oKTtcbiAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSkganNvbi5zdHJ1Y3R1cmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uZ2FwRnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmdhcFRvICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaW5zZXJ0ICE9IFwibnVtYmVyXCIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVwbGFjZUFyb3VuZFN0ZXAuZnJvbUpTT05cIik7XG4gICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGpzb24uZnJvbSwganNvbi50bywganNvbi5nYXBGcm9tLCBqc29uLmdhcFRvLCBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksIGpzb24uaW5zZXJ0LCAhIWpzb24uc3RydWN0dXJlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVwbGFjZUFyb3VuZFN0ZXA7XG59KFN0ZXApO1xuXG5TdGVwLmpzb25JRChcInJlcGxhY2VBcm91bmRcIiwgUmVwbGFjZUFyb3VuZFN0ZXApO1xuXG5mdW5jdGlvbiBjb250ZW50QmV0d2Vlbihkb2MsIGZyb20sIHRvKSB7XG4gIHZhciAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20pLFxuICAgICAgZGlzdCA9IHRvIC0gZnJvbSxcbiAgICAgIGRlcHRoID0gJGZyb20uZGVwdGg7XG5cbiAgd2hpbGUgKGRpc3QgPiAwICYmIGRlcHRoID4gMCAmJiAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSA9PSAkZnJvbS5ub2RlKGRlcHRoKS5jaGlsZENvdW50KSB7XG4gICAgZGVwdGgtLTtcbiAgICBkaXN0LS07XG4gIH1cblxuICBpZiAoZGlzdCA+IDApIHtcbiAgICB2YXIgbmV4dCA9ICRmcm9tLm5vZGUoZGVwdGgpLm1heWJlQ2hpbGQoJGZyb20uaW5kZXhBZnRlcihkZXB0aCkpO1xuXG4gICAgd2hpbGUgKGRpc3QgPiAwKSB7XG4gICAgICBpZiAoIW5leHQgfHwgbmV4dC5pc0xlYWYpIHJldHVybiB0cnVlO1xuICAgICAgbmV4dCA9IG5leHQuZmlyc3RDaGlsZDtcbiAgICAgIGRpc3QtLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9hZGRNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICB2YXIgcmVtb3ZlZCA9IFtdLFxuICAgICAgYWRkZWQgPSBbXTtcbiAgdmFyIHJlbW92aW5nLCBhZGRpbmc7XG4gIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGZ1bmN0aW9uIChub2RlLCBwb3MsIHBhcmVudCkge1xuICAgIGlmICghbm9kZS5pc0lubGluZSkgcmV0dXJuO1xuICAgIHZhciBtYXJrcyA9IG5vZGUubWFya3M7XG5cbiAgICBpZiAoIW1hcmsuaXNJblNldChtYXJrcykgJiYgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobWFyay50eXBlKSkge1xuICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSxcbiAgICAgICAgICBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICB2YXIgbmV3U2V0ID0gbWFyay5hZGRUb1NldChtYXJrcyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFtYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpIHtcbiAgICAgICAgICBpZiAocmVtb3ZpbmcgJiYgcmVtb3ZpbmcudG8gPT0gc3RhcnQgJiYgcmVtb3ZpbmcubWFyay5lcShtYXJrc1tpXSkpIHJlbW92aW5nLnRvID0gZW5kO2Vsc2UgcmVtb3ZlZC5wdXNoKHJlbW92aW5nID0gbmV3IFJlbW92ZU1hcmtTdGVwKHN0YXJ0LCBlbmQsIG1hcmtzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFkZGluZyAmJiBhZGRpbmcudG8gPT0gc3RhcnQpIGFkZGluZy50byA9IGVuZDtlbHNlIGFkZGVkLnB1c2goYWRkaW5nID0gbmV3IEFkZE1hcmtTdGVwKHN0YXJ0LCBlbmQsIG1hcmspKTtcbiAgICB9XG4gIH0pO1xuICByZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gdHIuc3RlcChzKTtcbiAgfSk7XG4gIGFkZGVkLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gdHIuc3RlcChzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIF9yZW1vdmVNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICB2YXIgbWF0Y2hlZCA9IFtdLFxuICAgICAgc3RlcCA9IDA7XG4gIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGZ1bmN0aW9uIChub2RlLCBwb3MpIHtcbiAgICBpZiAoIW5vZGUuaXNJbmxpbmUpIHJldHVybjtcbiAgICBzdGVwKys7XG4gICAgdmFyIHRvUmVtb3ZlID0gbnVsbDtcblxuICAgIGlmIChtYXJrIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JNb2RlbC5NYXJrVHlwZSkge1xuICAgICAgdmFyIHNldCA9IG5vZGUubWFya3MsXG4gICAgICAgICAgZm91bmQ7XG5cbiAgICAgIHdoaWxlIChmb3VuZCA9IG1hcmsuaXNJblNldChzZXQpKSB7XG4gICAgICAgICh0b1JlbW92ZSB8fCAodG9SZW1vdmUgPSBbXSkpLnB1c2goZm91bmQpO1xuICAgICAgICBzZXQgPSBmb3VuZC5yZW1vdmVGcm9tU2V0KHNldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtYXJrKSB7XG4gICAgICBpZiAobWFyay5pc0luU2V0KG5vZGUubWFya3MpKSB0b1JlbW92ZSA9IFttYXJrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9SZW1vdmUgPSBub2RlLm1hcmtzO1xuICAgIH1cblxuICAgIGlmICh0b1JlbW92ZSAmJiB0b1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgIHZhciBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdG9SZW1vdmVbaV0sXG4gICAgICAgICAgICBfZm91bmQgPSB2b2lkIDA7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIG0gPSBtYXRjaGVkW2pdO1xuICAgICAgICAgIGlmIChtLnN0ZXAgPT0gc3RlcCAtIDEgJiYgc3R5bGUuZXEobWF0Y2hlZFtqXS5zdHlsZSkpIF9mb3VuZCA9IG07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2ZvdW5kKSB7XG4gICAgICAgICAgX2ZvdW5kLnRvID0gZW5kO1xuICAgICAgICAgIF9mb3VuZC5zdGVwID0gc3RlcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaGVkLnB1c2goe1xuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgZnJvbTogTWF0aC5tYXgocG9zLCBmcm9tKSxcbiAgICAgICAgICAgIHRvOiBlbmQsXG4gICAgICAgICAgICBzdGVwOiBzdGVwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBtYXRjaGVkLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gdHIuc3RlcChuZXcgUmVtb3ZlTWFya1N0ZXAobS5mcm9tLCBtLnRvLCBtLnN0eWxlKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBfY2xlYXJJbmNvbXBhdGlibGUodHIsIHBvcywgcGFyZW50VHlwZSkge1xuICB2YXIgbWF0Y2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHBhcmVudFR5cGUuY29udGVudE1hdGNoO1xuICB2YXIgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgdmFyIGRlbFN0ZXBzID0gW10sXG4gICAgICBjdXIgPSBwb3MgKyAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZENvdW50OyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkKGkpLFxuICAgICAgICBlbmQgPSBjdXIgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICB2YXIgYWxsb3dlZCA9IG1hdGNoLm1hdGNoVHlwZShjaGlsZC50eXBlKTtcblxuICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgZGVsU3RlcHMucHVzaChuZXcgUmVwbGFjZVN0ZXAoY3VyLCBlbmQsIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSBhbGxvd2VkO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkLm1hcmtzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghcGFyZW50VHlwZS5hbGxvd3NNYXJrVHlwZShjaGlsZC5tYXJrc1tqXS50eXBlKSkgdHIuc3RlcChuZXcgUmVtb3ZlTWFya1N0ZXAoY3VyLCBlbmQsIGNoaWxkLm1hcmtzW2pdKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VyID0gZW5kO1xuICB9XG5cbiAgaWYgKCFtYXRjaC52YWxpZEVuZCkge1xuICAgIHZhciBmaWxsID0gbWF0Y2guZmlsbEJlZm9yZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICB0ci5yZXBsYWNlKGN1ciwgY3VyLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShmaWxsLCAwLCAwKSk7XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IGRlbFN0ZXBzLmxlbmd0aCAtIDE7IF9pID49IDA7IF9pLS0pIHtcbiAgICB0ci5zdGVwKGRlbFN0ZXBzW19pXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuQ3V0KG5vZGUsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChzdGFydCA9PSAwIHx8IG5vZGUuY2FuUmVwbGFjZShzdGFydCwgbm9kZS5jaGlsZENvdW50KSkgJiYgKGVuZCA9PSBub2RlLmNoaWxkQ291bnQgfHwgbm9kZS5jYW5SZXBsYWNlKDAsIGVuZCkpO1xufVxuXG5mdW5jdGlvbiBsaWZ0VGFyZ2V0KHJhbmdlKSB7XG4gIHZhciBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gIHZhciBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQuY3V0QnlJbmRleChyYW5nZS5zdGFydEluZGV4LCByYW5nZS5lbmRJbmRleCk7XG5cbiAgZm9yICh2YXIgZGVwdGggPSByYW5nZS5kZXB0aDs7IC0tZGVwdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJhbmdlLiRmcm9tLm5vZGUoZGVwdGgpO1xuICAgIHZhciBpbmRleCA9IHJhbmdlLiRmcm9tLmluZGV4KGRlcHRoKSxcbiAgICAgICAgZW5kSW5kZXggPSByYW5nZS4kdG8uaW5kZXhBZnRlcihkZXB0aCk7XG4gICAgaWYgKGRlcHRoIDwgcmFuZ2UuZGVwdGggJiYgbm9kZS5jYW5SZXBsYWNlKGluZGV4LCBlbmRJbmRleCwgY29udGVudCkpIHJldHVybiBkZXB0aDtcbiAgICBpZiAoZGVwdGggPT0gMCB8fCBub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgIWNhbkN1dChub2RlLCBpbmRleCwgZW5kSW5kZXgpKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBfbGlmdCh0ciwgcmFuZ2UsIHRhcmdldCkge1xuICB2YXIgJGZyb20gPSByYW5nZS4kZnJvbSxcbiAgICAgICR0byA9IHJhbmdlLiR0byxcbiAgICAgIGRlcHRoID0gcmFuZ2UuZGVwdGg7XG4gIHZhciBnYXBTdGFydCA9ICRmcm9tLmJlZm9yZShkZXB0aCArIDEpLFxuICAgICAgZ2FwRW5kID0gJHRvLmFmdGVyKGRlcHRoICsgMSk7XG4gIHZhciBzdGFydCA9IGdhcFN0YXJ0LFxuICAgICAgZW5kID0gZ2FwRW5kO1xuICB2YXIgYmVmb3JlID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eSxcbiAgICAgIG9wZW5TdGFydCA9IDA7XG5cbiAgZm9yICh2YXIgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKSB7XG4gICAgaWYgKHNwbGl0dGluZyB8fCAkZnJvbS5pbmRleChkKSA+IDApIHtcbiAgICAgIHNwbGl0dGluZyA9IHRydWU7XG4gICAgICBiZWZvcmUgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgb3BlblN0YXJ0Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0LS07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFmdGVyID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eSxcbiAgICAgIG9wZW5FbmQgPSAwO1xuXG4gIGZvciAodmFyIF9kID0gZGVwdGgsIF9zcGxpdHRpbmcgPSBmYWxzZTsgX2QgPiB0YXJnZXQ7IF9kLS0pIHtcbiAgICBpZiAoX3NwbGl0dGluZyB8fCAkdG8uYWZ0ZXIoX2QgKyAxKSA8ICR0by5lbmQoX2QpKSB7XG4gICAgICBfc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgIGFmdGVyID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKCR0by5ub2RlKF9kKS5jb3B5KGFmdGVyKSk7XG4gICAgICBvcGVuRW5kKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCsrO1xuICAgIH1cbiAgfVxuXG4gIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIGdhcFN0YXJ0LCBnYXBFbmQsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBvcGVuU3RhcnQsIG9wZW5FbmQpLCBiZWZvcmUuc2l6ZSAtIG9wZW5TdGFydCwgdHJ1ZSkpO1xufVxuXG5mdW5jdGlvbiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlKSB7XG4gIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgdmFyIGlubmVyUmFuZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHJhbmdlO1xuICB2YXIgYXJvdW5kID0gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgbm9kZVR5cGUpO1xuICB2YXIgaW5uZXIgPSBhcm91bmQgJiYgZmluZFdyYXBwaW5nSW5zaWRlKGlubmVyUmFuZ2UsIG5vZGVUeXBlKTtcbiAgaWYgKCFpbm5lcikgcmV0dXJuIG51bGw7XG4gIHJldHVybiBhcm91bmQubWFwKHdpdGhBdHRycykuY29uY2F0KHtcbiAgICB0eXBlOiBub2RlVHlwZSxcbiAgICBhdHRyczogYXR0cnNcbiAgfSkuY29uY2F0KGlubmVyLm1hcCh3aXRoQXR0cnMpKTtcbn1cblxuZnVuY3Rpb24gd2l0aEF0dHJzKHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGF0dHJzOiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudCxcbiAgICAgIHN0YXJ0SW5kZXggPSByYW5nZS5zdGFydEluZGV4LFxuICAgICAgZW5kSW5kZXggPSByYW5nZS5lbmRJbmRleDtcbiAgdmFyIGFyb3VuZCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChzdGFydEluZGV4KS5maW5kV3JhcHBpbmcodHlwZSk7XG4gIGlmICghYXJvdW5kKSByZXR1cm4gbnVsbDtcbiAgdmFyIG91dGVyID0gYXJvdW5kLmxlbmd0aCA/IGFyb3VuZFswXSA6IHR5cGU7XG4gIHJldHVybiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoc3RhcnRJbmRleCwgZW5kSW5kZXgsIG91dGVyKSA/IGFyb3VuZCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ0luc2lkZShyYW5nZSwgdHlwZSkge1xuICB2YXIgcGFyZW50ID0gcmFuZ2UucGFyZW50LFxuICAgICAgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXgsXG4gICAgICBlbmRJbmRleCA9IHJhbmdlLmVuZEluZGV4O1xuICB2YXIgaW5uZXIgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCk7XG4gIHZhciBpbnNpZGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5maW5kV3JhcHBpbmcoaW5uZXIudHlwZSk7XG4gIGlmICghaW5zaWRlKSByZXR1cm4gbnVsbDtcbiAgdmFyIGxhc3RUeXBlID0gaW5zaWRlLmxlbmd0aCA/IGluc2lkZVtpbnNpZGUubGVuZ3RoIC0gMV0gOiB0eXBlO1xuICB2YXIgaW5uZXJNYXRjaCA9IGxhc3RUeXBlLmNvbnRlbnRNYXRjaDtcblxuICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaW5uZXJNYXRjaCAmJiBpIDwgZW5kSW5kZXg7IGkrKykge1xuICAgIGlubmVyTWF0Y2ggPSBpbm5lck1hdGNoLm1hdGNoVHlwZShwYXJlbnQuY2hpbGQoaSkudHlwZSk7XG4gIH1cblxuICBpZiAoIWlubmVyTWF0Y2ggfHwgIWlubmVyTWF0Y2gudmFsaWRFbmQpIHJldHVybiBudWxsO1xuICByZXR1cm4gaW5zaWRlO1xufVxuXG5mdW5jdGlvbiBfd3JhcDIodHIsIHJhbmdlLCB3cmFwcGVycykge1xuICB2YXIgY29udGVudCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHk7XG5cbiAgZm9yICh2YXIgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgdmFyIG1hdGNoID0gd3JhcHBlcnNbaV0udHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoLnZhbGlkRW5kKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIldyYXBwZXIgdHlwZSBnaXZlbiB0byBUcmFuc2Zvcm0ud3JhcCBkb2VzIG5vdCBmb3JtIHZhbGlkIGNvbnRlbnQgb2YgaXRzIHBhcmVudCB3cmFwcGVyXCIpO1xuICAgIH1cblxuICAgIGNvbnRlbnQgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgfVxuXG4gIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0LFxuICAgICAgZW5kID0gcmFuZ2UuZW5kO1xuICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBzdGFydCwgZW5kLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG59XG5cbmZ1bmN0aW9uIF9zZXRCbG9ja1R5cGUodHIsIGZyb20sIHRvLCB0eXBlLCBhdHRycykge1xuICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHlwZSBnaXZlbiB0byBzZXRCbG9ja1R5cGUgc2hvdWxkIGJlIGEgdGV4dGJsb2NrXCIpO1xuICB2YXIgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aDtcbiAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUsIHBvcykge1xuICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmICFub2RlLmhhc01hcmt1cCh0eXBlLCBhdHRycykgJiYgY2FuQ2hhbmdlVHlwZSh0ci5kb2MsIHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyksIHR5cGUpKSB7XG4gICAgICB0ci5jbGVhckluY29tcGF0aWJsZSh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MsIDEpLCB0eXBlKTtcbiAgICAgIHZhciBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgIHZhciBzdGFydE0gPSBtYXBwaW5nLm1hcChwb3MsIDEpLFxuICAgICAgICAgIGVuZE0gPSBtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplLCAxKTtcbiAgICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0TSwgZW5kTSwgc3RhcnRNICsgMSwgZW5kTSAtIDEsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbm9kZS5tYXJrcykpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhbkNoYW5nZVR5cGUoZG9jLCBwb3MsIHR5cGUpIHtcbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLFxuICAgICAgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gIHJldHVybiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCB0eXBlKTtcbn1cblxuZnVuY3Rpb24gX3NldE5vZGVNYXJrdXAodHIsIHBvcywgdHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gIHZhciBub2RlID0gdHIuZG9jLm5vZGVBdChwb3MpO1xuICBpZiAoIW5vZGUpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhdCBnaXZlbiBwb3NpdGlvblwiKTtcbiAgaWYgKCF0eXBlKSB0eXBlID0gbm9kZS50eXBlO1xuICB2YXIgbmV3Tm9kZSA9IHR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBtYXJrcyB8fCBub2RlLm1hcmtzKTtcbiAgaWYgKG5vZGUuaXNMZWFmKSByZXR1cm4gdHIucmVwbGFjZVdpdGgocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBuZXdOb2RlKTtcbiAgaWYgKCF0eXBlLnZhbGlkQ29udGVudChub2RlLmNvbnRlbnQpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY29udGVudCBmb3Igbm9kZSB0eXBlIFwiICsgdHlwZS5uYW1lKTtcbiAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBwb3MgKyAxLCBwb3MgKyBub2RlLm5vZGVTaXplIC0gMSwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKG5ld05vZGUpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xufVxuXG5mdW5jdGlvbiBjYW5TcGxpdChkb2MsIHBvcykge1xuICB2YXIgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHZhciB0eXBlc0FmdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gIHZhciAkcG9zID0gZG9jLnJlc29sdmUocG9zKSxcbiAgICAgIGJhc2UgPSAkcG9zLmRlcHRoIC0gZGVwdGg7XG4gIHZhciBpbm5lclR5cGUgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbdHlwZXNBZnRlci5sZW5ndGggLSAxXSB8fCAkcG9zLnBhcmVudDtcbiAgaWYgKGJhc2UgPCAwIHx8ICRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgISRwb3MucGFyZW50LmNhblJlcGxhY2UoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSB8fCAhaW5uZXJUeXBlLnR5cGUudmFsaWRDb250ZW50KCRwb3MucGFyZW50LmNvbnRlbnQuY3V0QnlJbmRleCgkcG9zLmluZGV4KCksICRwb3MucGFyZW50LmNoaWxkQ291bnQpKSkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGQgPSAkcG9zLmRlcHRoIC0gMSwgaSA9IGRlcHRoIC0gMjsgZCA+IGJhc2U7IGQtLSwgaS0tKSB7XG4gICAgdmFyIG5vZGUgPSAkcG9zLm5vZGUoZCksXG4gICAgICAgIF9pbmRleCA9ICRwb3MuaW5kZXgoZCk7XG5cbiAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHJlc3QgPSBub2RlLmNvbnRlbnQuY3V0QnlJbmRleChfaW5kZXgsIG5vZGUuY2hpbGRDb3VudCk7XG4gICAgdmFyIGFmdGVyID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldIHx8IG5vZGU7XG4gICAgaWYgKGFmdGVyICE9IG5vZGUpIHJlc3QgPSByZXN0LnJlcGxhY2VDaGlsZCgwLCBhZnRlci50eXBlLmNyZWF0ZShhZnRlci5hdHRycykpO1xuICAgIGlmICghbm9kZS5jYW5SZXBsYWNlKF9pbmRleCArIDEsIG5vZGUuY2hpbGRDb3VudCkgfHwgIWFmdGVyLnR5cGUudmFsaWRDb250ZW50KHJlc3QpKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoYmFzZSk7XG4gIHZhciBiYXNlVHlwZSA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclswXTtcbiAgcmV0dXJuICRwb3Mubm9kZShiYXNlKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIGJhc2VUeXBlID8gYmFzZVR5cGUudHlwZSA6ICRwb3Mubm9kZShiYXNlICsgMSkudHlwZSk7XG59XG5cbmZ1bmN0aW9uIF9zcGxpdCh0ciwgcG9zKSB7XG4gIHZhciBkZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgdmFyIHR5cGVzQWZ0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgdmFyICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpLFxuICAgICAgYmVmb3JlID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eSxcbiAgICAgIGFmdGVyID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcblxuICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aCwgZSA9ICRwb3MuZGVwdGggLSBkZXB0aCwgaSA9IGRlcHRoIC0gMTsgZCA+IGU7IGQtLSwgaS0tKSB7XG4gICAgYmVmb3JlID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKCRwb3Mubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgIHZhciB0eXBlQWZ0ZXIgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV07XG4gICAgYWZ0ZXIgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20odHlwZUFmdGVyID8gdHlwZUFmdGVyLnR5cGUuY3JlYXRlKHR5cGVBZnRlci5hdHRycywgYWZ0ZXIpIDogJHBvcy5ub2RlKGQpLmNvcHkoYWZ0ZXIpKTtcbiAgfVxuXG4gIHRyLnN0ZXAobmV3IFJlcGxhY2VTdGVwKHBvcywgcG9zLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgZGVwdGgsIGRlcHRoKSwgdHJ1ZSkpO1xufVxuXG5mdW5jdGlvbiBjYW5Kb2luKGRvYywgcG9zKSB7XG4gIHZhciAkcG9zID0gZG9jLnJlc29sdmUocG9zKSxcbiAgICAgIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICByZXR1cm4gam9pbmFibGUoJHBvcy5ub2RlQmVmb3JlLCAkcG9zLm5vZGVBZnRlcikgJiYgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKTtcbn1cblxuZnVuY3Rpb24gam9pbmFibGUoYSwgYikge1xuICByZXR1cm4gISEoYSAmJiBiICYmICFhLmlzTGVhZiAmJiBhLmNhbkFwcGVuZChiKSk7XG59XG5cbmZ1bmN0aW9uIGpvaW5Qb2ludChkb2MsIHBvcykge1xuICB2YXIgZGlyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAtMTtcbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuXG4gIGZvciAodmFyIGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgdmFyIGJlZm9yZSA9IHZvaWQgMCxcbiAgICAgICAgYWZ0ZXIgPSB2b2lkIDAsXG4gICAgICAgIGluZGV4ID0gJHBvcy5pbmRleChkKTtcblxuICAgIGlmIChkID09ICRwb3MuZGVwdGgpIHtcbiAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZTtcbiAgICAgIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgfSBlbHNlIGlmIChkaXIgPiAwKSB7XG4gICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgICAgaW5kZXgrKztcbiAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCkubWF5YmVDaGlsZChpbmRleCAtIDEpO1xuICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgIH1cblxuICAgIGlmIChiZWZvcmUgJiYgIWJlZm9yZS5pc1RleHRibG9jayAmJiBqb2luYWJsZShiZWZvcmUsIGFmdGVyKSAmJiAkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSkgcmV0dXJuIHBvcztcbiAgICBpZiAoZCA9PSAwKSBicmVhaztcbiAgICBwb3MgPSBkaXIgPCAwID8gJHBvcy5iZWZvcmUoZCkgOiAkcG9zLmFmdGVyKGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9qb2luKHRyLCBwb3MsIGRlcHRoKSB7XG4gIHZhciBzdGVwID0gbmV3IFJlcGxhY2VTdGVwKHBvcyAtIGRlcHRoLCBwb3MgKyBkZXB0aCwgcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eSwgdHJ1ZSk7XG4gIHRyLnN0ZXAoc3RlcCk7XG59XG5cbmZ1bmN0aW9uIGluc2VydFBvaW50KGRvYywgcG9zLCBub2RlVHlwZSkge1xuICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gIGlmICgkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aCgkcG9zLmluZGV4KCksICRwb3MuaW5kZXgoKSwgbm9kZVR5cGUpKSByZXR1cm4gcG9zO1xuICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT0gMCkgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgIHZhciBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSkgcmV0dXJuICRwb3MuYmVmb3JlKGQgKyAxKTtcbiAgICBpZiAoaW5kZXggPiAwKSByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT0gJHBvcy5wYXJlbnQuY29udGVudC5zaXplKSBmb3IgKHZhciBfZDIgPSAkcG9zLmRlcHRoIC0gMTsgX2QyID49IDA7IF9kMi0tKSB7XG4gICAgdmFyIF9pbmRleDIgPSAkcG9zLmluZGV4QWZ0ZXIoX2QyKTtcblxuICAgIGlmICgkcG9zLm5vZGUoX2QyKS5jYW5SZXBsYWNlV2l0aChfaW5kZXgyLCBfaW5kZXgyLCBub2RlVHlwZSkpIHJldHVybiAkcG9zLmFmdGVyKF9kMiArIDEpO1xuICAgIGlmIChfaW5kZXgyIDwgJHBvcy5ub2RlKF9kMikuY2hpbGRDb3VudCkgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRyb3BQb2ludChkb2MsIHBvcywgc2xpY2UpIHtcbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSkgcmV0dXJuIHBvcztcbiAgdmFyIGNvbnRlbnQgPSBzbGljZS5jb250ZW50O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2Uub3BlblN0YXJ0OyBpKyspIHtcbiAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gIH1cblxuICBmb3IgKHZhciBwYXNzID0gMTsgcGFzcyA8PSAoc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uuc2l6ZSA/IDIgOiAxKTsgcGFzcysrKSB7XG4gICAgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICB2YXIgYmlhcyA9IGQgPT0gJHBvcy5kZXB0aCA/IDAgOiAkcG9zLnBvcyA8PSAoJHBvcy5zdGFydChkICsgMSkgKyAkcG9zLmVuZChkICsgMSkpIC8gMiA/IC0xIDogMTtcbiAgICAgIHZhciBpbnNlcnRQb3MgPSAkcG9zLmluZGV4KGQpICsgKGJpYXMgPiAwID8gMSA6IDApO1xuICAgICAgdmFyIHBhcmVudCA9ICRwb3Mubm9kZShkKSxcbiAgICAgICAgICBmaXRzID0gZmFsc2U7XG5cbiAgICAgIGlmIChwYXNzID09IDEpIHtcbiAgICAgICAgZml0cyA9IHBhcmVudC5jYW5SZXBsYWNlKGluc2VydFBvcywgaW5zZXJ0UG9zLCBjb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB3cmFwcGluZyA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChpbnNlcnRQb3MpLmZpbmRXcmFwcGluZyhjb250ZW50LmZpcnN0Q2hpbGQudHlwZSk7XG4gICAgICAgIGZpdHMgPSB3cmFwcGluZyAmJiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIHdyYXBwaW5nWzBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpdHMpIHJldHVybiBiaWFzID09IDAgPyAkcG9zLnBvcyA6IGJpYXMgPCAwID8gJHBvcy5iZWZvcmUoZCArIDEpIDogJHBvcy5hZnRlcihkICsgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VTdGVwKGRvYywgZnJvbSkge1xuICB2YXIgdG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZyb207XG4gIHZhciBzbGljZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eTtcbiAgaWYgKGZyb20gPT0gdG8gJiYgIXNsaWNlLnNpemUpIHJldHVybiBudWxsO1xuICB2YXIgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSxcbiAgICAgICR0byA9IGRvYy5yZXNvbHZlKHRvKTtcbiAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKSByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSk7XG4gIHJldHVybiBuZXcgRml0dGVyKCRmcm9tLCAkdG8sIHNsaWNlKS5maXQoKTtcbn1cblxuZnVuY3Rpb24gZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICByZXR1cm4gIXNsaWNlLm9wZW5TdGFydCAmJiAhc2xpY2Uub3BlbkVuZCAmJiAkZnJvbS5zdGFydCgpID09ICR0by5zdGFydCgpICYmICRmcm9tLnBhcmVudC5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KCksICR0by5pbmRleCgpLCBzbGljZS5jb250ZW50KTtcbn1cblxudmFyIEZpdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRml0dGVyKCRmcm9tLCAkdG8sIHVucGxhY2VkKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpdHRlcik7XG5cbiAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgdGhpcy4kdG8gPSAkdG87XG4gICAgdGhpcy51bnBsYWNlZCA9IHVucGxhY2VkO1xuICAgIHRoaXMuZnJvbnRpZXIgPSBbXTtcbiAgICB0aGlzLnBsYWNlZCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAkZnJvbS5kZXB0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9ICRmcm9tLm5vZGUoaSk7XG4gICAgICB0aGlzLmZyb250aWVyLnB1c2goe1xuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgIG1hdGNoOiBub2RlLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoaSkpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTIgPSAkZnJvbS5kZXB0aDsgX2kyID4gMDsgX2kyLS0pIHtcbiAgICAgIHRoaXMucGxhY2VkID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoX2kyKS5jb3B5KHRoaXMucGxhY2VkKSk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpdHRlciwgW3tcbiAgICBrZXk6IFwiZGVwdGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyb250aWVyLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXQoKSB7XG4gICAgICB3aGlsZSAodGhpcy51bnBsYWNlZC5zaXplKSB7XG4gICAgICAgIHZhciBmaXQgPSB0aGlzLmZpbmRGaXR0YWJsZSgpO1xuICAgICAgICBpZiAoZml0KSB0aGlzLnBsYWNlTm9kZXMoZml0KTtlbHNlIHRoaXMub3Blbk1vcmUoKSB8fCB0aGlzLmRyb3BOb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtb3ZlSW5saW5lID0gdGhpcy5tdXN0TW92ZUlubGluZSgpLFxuICAgICAgICAgIHBsYWNlZFNpemUgPSB0aGlzLnBsYWNlZC5zaXplIC0gdGhpcy5kZXB0aCAtIHRoaXMuJGZyb20uZGVwdGg7XG4gICAgICB2YXIgJGZyb20gPSB0aGlzLiRmcm9tLFxuICAgICAgICAgICR0byA9IHRoaXMuY2xvc2UobW92ZUlubGluZSA8IDAgPyB0aGlzLiR0byA6ICRmcm9tLmRvYy5yZXNvbHZlKG1vdmVJbmxpbmUpKTtcbiAgICAgIGlmICghJHRvKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy5wbGFjZWQsXG4gICAgICAgICAgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGgsXG4gICAgICAgICAgb3BlbkVuZCA9ICR0by5kZXB0aDtcblxuICAgICAgd2hpbGUgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmIGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxKSB7XG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICAgICAgb3BlblN0YXJ0LS07XG4gICAgICAgIG9wZW5FbmQtLTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNsaWNlID0gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgIGlmIChtb3ZlSW5saW5lID4gLTEpIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGZyb20ucG9zLCBtb3ZlSW5saW5lLCB0aGlzLiR0by5wb3MsIHRoaXMuJHRvLmVuZCgpLCBzbGljZSwgcGxhY2VkU2l6ZSk7XG4gICAgICBpZiAoc2xpY2Uuc2l6ZSB8fCAkZnJvbS5wb3MgIT0gdGhpcy4kdG8ucG9zKSByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKCRmcm9tLnBvcywgJHRvLnBvcywgc2xpY2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRGaXR0YWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kRml0dGFibGUoKSB7XG4gICAgICBmb3IgKHZhciBwYXNzID0gMTsgcGFzcyA8PSAyOyBwYXNzKyspIHtcbiAgICAgICAgZm9yICh2YXIgc2xpY2VEZXB0aCA9IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0OyBzbGljZURlcHRoID49IDA7IHNsaWNlRGVwdGgtLSkge1xuICAgICAgICAgIHZhciBmcmFnbWVudCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgcGFyZW50ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChzbGljZURlcHRoKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBjb250ZW50QXQodGhpcy51bnBsYWNlZC5jb250ZW50LCBzbGljZURlcHRoIC0gMSkuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy51bnBsYWNlZC5jb250ZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBmcm9udGllckRlcHRoID0gdGhpcy5kZXB0aDsgZnJvbnRpZXJEZXB0aCA+PSAwOyBmcm9udGllckRlcHRoLS0pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRmcm9udGllciRmcm9udGkgPSB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLFxuICAgICAgICAgICAgICAgIHR5cGUgPSBfdGhpcyRmcm9udGllciRmcm9udGkudHlwZSxcbiAgICAgICAgICAgICAgICBtYXRjaCA9IF90aGlzJGZyb250aWVyJGZyb250aS5tYXRjaCxcbiAgICAgICAgICAgICAgICBfd3JhcCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBpbmplY3QgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAocGFzcyA9PSAxICYmIChmaXJzdCA/IG1hdGNoLm1hdGNoVHlwZShmaXJzdC50eXBlKSB8fCAoaW5qZWN0ID0gbWF0Y2guZmlsbEJlZm9yZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oZmlyc3QpLCBmYWxzZSkpIDogcGFyZW50ICYmIHR5cGUuY29tcGF0aWJsZUNvbnRlbnQocGFyZW50LnR5cGUpKSkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc2xpY2VEZXB0aDogc2xpY2VEZXB0aCxcbiAgICAgICAgICAgICAgZnJvbnRpZXJEZXB0aDogZnJvbnRpZXJEZXB0aCxcbiAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICAgIGluamVjdDogaW5qZWN0XG4gICAgICAgICAgICB9O2Vsc2UgaWYgKHBhc3MgPT0gMiAmJiBmaXJzdCAmJiAoX3dyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcoZmlyc3QudHlwZSkpKSByZXR1cm4ge1xuICAgICAgICAgICAgICBzbGljZURlcHRoOiBzbGljZURlcHRoLFxuICAgICAgICAgICAgICBmcm9udGllckRlcHRoOiBmcm9udGllckRlcHRoLFxuICAgICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgICAgd3JhcDogX3dyYXBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIG1hdGNoLm1hdGNoVHlwZShwYXJlbnQudHlwZSkpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcGVuTW9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuTW9yZSgpIHtcbiAgICAgIHZhciBfdGhpcyR1bnBsYWNlZCA9IHRoaXMudW5wbGFjZWQsXG4gICAgICAgICAgY29udGVudCA9IF90aGlzJHVucGxhY2VkLmNvbnRlbnQsXG4gICAgICAgICAgb3BlblN0YXJ0ID0gX3RoaXMkdW5wbGFjZWQub3BlblN0YXJ0LFxuICAgICAgICAgIG9wZW5FbmQgPSBfdGhpcyR1bnBsYWNlZC5vcGVuRW5kO1xuICAgICAgdmFyIGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICBpZiAoIWlubmVyLmNoaWxkQ291bnQgfHwgaW5uZXIuZmlyc3RDaGlsZC5pc0xlYWYpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShjb250ZW50LCBvcGVuU3RhcnQgKyAxLCBNYXRoLm1heChvcGVuRW5kLCBpbm5lci5zaXplICsgb3BlblN0YXJ0ID49IGNvbnRlbnQuc2l6ZSAtIG9wZW5FbmQgPyBvcGVuU3RhcnQgKyAxIDogMCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyb3BOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyb3BOb2RlKCkge1xuICAgICAgdmFyIF90aGlzJHVucGxhY2VkMiA9IHRoaXMudW5wbGFjZWQsXG4gICAgICAgICAgY29udGVudCA9IF90aGlzJHVucGxhY2VkMi5jb250ZW50LFxuICAgICAgICAgIG9wZW5TdGFydCA9IF90aGlzJHVucGxhY2VkMi5vcGVuU3RhcnQsXG4gICAgICAgICAgb3BlbkVuZCA9IF90aGlzJHVucGxhY2VkMi5vcGVuRW5kO1xuICAgICAgdmFyIGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG5cbiAgICAgIGlmIChpbm5lci5jaGlsZENvdW50IDw9IDEgJiYgb3BlblN0YXJ0ID4gMCkge1xuICAgICAgICB2YXIgb3BlbkF0RW5kID0gY29udGVudC5zaXplIC0gb3BlblN0YXJ0IDw9IG9wZW5TdGFydCArIGlubmVyLnNpemU7XG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCAtIDEsIDEpLCBvcGVuU3RhcnQgLSAxLCBvcGVuQXRFbmQgPyBvcGVuU3RhcnQgLSAxIDogb3BlbkVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoZHJvcEZyb21GcmFnbWVudChjb250ZW50LCBvcGVuU3RhcnQsIDEpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbGFjZU5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYWNlTm9kZXMoX3JlZikge1xuICAgICAgdmFyIHNsaWNlRGVwdGggPSBfcmVmLnNsaWNlRGVwdGgsXG4gICAgICAgICAgZnJvbnRpZXJEZXB0aCA9IF9yZWYuZnJvbnRpZXJEZXB0aCxcbiAgICAgICAgICBwYXJlbnQgPSBfcmVmLnBhcmVudCxcbiAgICAgICAgICBpbmplY3QgPSBfcmVmLmluamVjdCxcbiAgICAgICAgICB3cmFwID0gX3JlZi53cmFwO1xuXG4gICAgICB3aGlsZSAodGhpcy5kZXB0aCA+IGZyb250aWVyRGVwdGgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAod3JhcCkgZm9yICh2YXIgaSA9IDA7IGkgPCB3cmFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMub3BlbkZyb250aWVyTm9kZSh3cmFwW2ldKTtcbiAgICAgIH1cbiAgICAgIHZhciBzbGljZSA9IHRoaXMudW5wbGFjZWQsXG4gICAgICAgICAgZnJhZ21lbnQgPSBwYXJlbnQgPyBwYXJlbnQuY29udGVudCA6IHNsaWNlLmNvbnRlbnQ7XG4gICAgICB2YXIgb3BlblN0YXJ0ID0gc2xpY2Uub3BlblN0YXJ0IC0gc2xpY2VEZXB0aDtcbiAgICAgIHZhciB0YWtlbiA9IDAsXG4gICAgICAgICAgYWRkID0gW107XG4gICAgICB2YXIgX3RoaXMkZnJvbnRpZXIkZnJvbnRpMiA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0sXG4gICAgICAgICAgbWF0Y2ggPSBfdGhpcyRmcm9udGllciRmcm9udGkyLm1hdGNoLFxuICAgICAgICAgIHR5cGUgPSBfdGhpcyRmcm9udGllciRmcm9udGkyLnR5cGU7XG5cbiAgICAgIGlmIChpbmplY3QpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgYWRkLnB1c2goaW5qZWN0LmNoaWxkKGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hGcmFnbWVudChpbmplY3QpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3BlbkVuZENvdW50ID0gZnJhZ21lbnQuc2l6ZSArIHNsaWNlRGVwdGggLSAoc2xpY2UuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCk7XG5cbiAgICAgIHdoaWxlICh0YWtlbiA8IGZyYWdtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgdmFyIG5leHQgPSBmcmFnbWVudC5jaGlsZCh0YWtlbiksXG4gICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2gubWF0Y2hUeXBlKG5leHQudHlwZSk7XG4gICAgICAgIGlmICghbWF0Y2hlcykgYnJlYWs7XG4gICAgICAgIHRha2VuKys7XG5cbiAgICAgICAgaWYgKHRha2VuID4gMSB8fCBvcGVuU3RhcnQgPT0gMCB8fCBuZXh0LmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgIG1hdGNoID0gbWF0Y2hlcztcbiAgICAgICAgICBhZGQucHVzaChjbG9zZU5vZGVTdGFydChuZXh0Lm1hcmsodHlwZS5hbGxvd2VkTWFya3MobmV4dC5tYXJrcykpLCB0YWtlbiA9PSAxID8gb3BlblN0YXJ0IDogMCwgdGFrZW4gPT0gZnJhZ21lbnQuY2hpbGRDb3VudCA/IG9wZW5FbmRDb3VudCA6IC0xKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRvRW5kID0gdGFrZW4gPT0gZnJhZ21lbnQuY2hpbGRDb3VudDtcbiAgICAgIGlmICghdG9FbmQpIG9wZW5FbmRDb3VudCA9IC0xO1xuICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBmcm9udGllckRlcHRoLCBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oYWRkKSk7XG4gICAgICB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLm1hdGNoID0gbWF0Y2g7XG4gICAgICBpZiAodG9FbmQgJiYgb3BlbkVuZENvdW50IDwgMCAmJiBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXS50eXBlICYmIHRoaXMuZnJvbnRpZXIubGVuZ3RoID4gMSkgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwLCBjdXIgPSBmcmFnbWVudDsgX2kzIDwgb3BlbkVuZENvdW50OyBfaTMrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGN1ci5sYXN0Q2hpbGQ7XG4gICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7XG4gICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgIG1hdGNoOiBub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudClcbiAgICAgICAgfSk7XG4gICAgICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy51bnBsYWNlZCA9ICF0b0VuZCA/IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoc2xpY2UuY29udGVudCwgc2xpY2VEZXB0aCwgdGFrZW4pLCBzbGljZS5vcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpIDogc2xpY2VEZXB0aCA9PSAwID8gcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eSA6IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoc2xpY2UuY29udGVudCwgc2xpY2VEZXB0aCAtIDEsIDEpLCBzbGljZURlcHRoIC0gMSwgb3BlbkVuZENvdW50IDwgMCA/IHNsaWNlLm9wZW5FbmQgOiBzbGljZURlcHRoIC0gMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm11c3RNb3ZlSW5saW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11c3RNb3ZlSW5saW5lKCkge1xuICAgICAgaWYgKCF0aGlzLiR0by5wYXJlbnQuaXNUZXh0YmxvY2spIHJldHVybiAtMTtcbiAgICAgIHZhciB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLFxuICAgICAgICAgIGxldmVsO1xuICAgICAgaWYgKCF0b3AudHlwZS5pc1RleHRibG9jayB8fCAhY29udGVudEFmdGVyRml0cyh0aGlzLiR0bywgdGhpcy4kdG8uZGVwdGgsIHRvcC50eXBlLCB0b3AubWF0Y2gsIGZhbHNlKSB8fCB0aGlzLiR0by5kZXB0aCA9PSB0aGlzLmRlcHRoICYmIChsZXZlbCA9IHRoaXMuZmluZENsb3NlTGV2ZWwodGhpcy4kdG8pKSAmJiBsZXZlbC5kZXB0aCA9PSB0aGlzLmRlcHRoKSByZXR1cm4gLTE7XG4gICAgICB2YXIgZGVwdGggPSB0aGlzLiR0by5kZXB0aCxcbiAgICAgICAgICBhZnRlciA9IHRoaXMuJHRvLmFmdGVyKGRlcHRoKTtcblxuICAgICAgd2hpbGUgKGRlcHRoID4gMSAmJiBhZnRlciA9PSB0aGlzLiR0by5lbmQoLS1kZXB0aCkpIHtcbiAgICAgICAgKythZnRlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFmdGVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQ2xvc2VMZXZlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQ2xvc2VMZXZlbCgkdG8pIHtcbiAgICAgIHNjYW46IGZvciAodmFyIGkgPSBNYXRoLm1pbih0aGlzLmRlcHRoLCAkdG8uZGVwdGgpOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgX3RoaXMkZnJvbnRpZXIkaSA9IHRoaXMuZnJvbnRpZXJbaV0sXG4gICAgICAgICAgICBtYXRjaCA9IF90aGlzJGZyb250aWVyJGkubWF0Y2gsXG4gICAgICAgICAgICB0eXBlID0gX3RoaXMkZnJvbnRpZXIkaS50eXBlO1xuICAgICAgICB2YXIgZHJvcElubmVyID0gaSA8ICR0by5kZXB0aCAmJiAkdG8uZW5kKGkgKyAxKSA9PSAkdG8ucG9zICsgKCR0by5kZXB0aCAtIChpICsgMSkpO1xuICAgICAgICB2YXIgZml0ID0gY29udGVudEFmdGVyRml0cygkdG8sIGksIHR5cGUsIG1hdGNoLCBkcm9wSW5uZXIpO1xuICAgICAgICBpZiAoIWZpdCkgY29udGludWU7XG5cbiAgICAgICAgZm9yICh2YXIgZCA9IGkgLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgIHZhciBfdGhpcyRmcm9udGllciRkID0gdGhpcy5mcm9udGllcltkXSxcbiAgICAgICAgICAgICAgX21hdGNoID0gX3RoaXMkZnJvbnRpZXIkZC5tYXRjaCxcbiAgICAgICAgICAgICAgX3R5cGUgPSBfdGhpcyRmcm9udGllciRkLnR5cGU7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZCwgX3R5cGUsIF9tYXRjaCwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMuY2hpbGRDb3VudCkgY29udGludWUgc2NhbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVwdGg6IGksXG4gICAgICAgICAgZml0OiBmaXQsXG4gICAgICAgICAgbW92ZTogZHJvcElubmVyID8gJHRvLmRvYy5yZXNvbHZlKCR0by5hZnRlcihpICsgMSkpIDogJHRvXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCR0bykge1xuICAgICAgdmFyIGNsb3NlID0gdGhpcy5maW5kQ2xvc2VMZXZlbCgkdG8pO1xuICAgICAgaWYgKCFjbG9zZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgIHdoaWxlICh0aGlzLmRlcHRoID4gY2xvc2UuZGVwdGgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xvc2UuZml0LmNoaWxkQ291bnQpIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgY2xvc2UuZGVwdGgsIGNsb3NlLmZpdCk7XG4gICAgICAkdG8gPSBjbG9zZS5tb3ZlO1xuXG4gICAgICBmb3IgKHZhciBkID0gY2xvc2UuZGVwdGggKyAxOyBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgICAgIHZhciBub2RlID0gJHRvLm5vZGUoZCksXG4gICAgICAgICAgICBhZGQgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCAkdG8uaW5kZXgoZCkpO1xuICAgICAgICB0aGlzLm9wZW5Gcm9udGllck5vZGUobm9kZS50eXBlLCBub2RlLmF0dHJzLCBhZGQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJHRvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcGVuRnJvbnRpZXJOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5Gcm9udGllck5vZGUodHlwZSkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIGNvbnRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdO1xuICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5kZXB0aCwgcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBjb250ZW50KSkpO1xuICAgICAgdGhpcy5mcm9udGllci5wdXNoKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgbWF0Y2g6IHR5cGUuY29udGVudE1hdGNoXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VGcm9udGllck5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VGcm9udGllck5vZGUoKSB7XG4gICAgICB2YXIgb3BlbiA9IHRoaXMuZnJvbnRpZXIucG9wKCk7XG4gICAgICB2YXIgYWRkID0gb3Blbi5tYXRjaC5maWxsQmVmb3JlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgaWYgKGFkZC5jaGlsZENvdW50KSB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZnJvbnRpZXIubGVuZ3RoLCBhZGQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaXR0ZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBjb3VudCkge1xuICBpZiAoZGVwdGggPT0gMCkgcmV0dXJuIGZyYWdtZW50LmN1dEJ5SW5kZXgoY291bnQsIGZyYWdtZW50LmNoaWxkQ291bnQpO1xuICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZyYWdtZW50LmZpcnN0Q2hpbGQuY29weShkcm9wRnJvbUZyYWdtZW50KGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudCwgZGVwdGggLSAxLCBjb3VudCkpKTtcbn1cblxuZnVuY3Rpb24gYWRkVG9GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvbnRlbnQpIHtcbiAgaWYgKGRlcHRoID09IDApIHJldHVybiBmcmFnbWVudC5hcHBlbmQoY29udGVudCk7XG4gIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIGZyYWdtZW50Lmxhc3RDaGlsZC5jb3B5KGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQubGFzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY29udGVudCkpKTtcbn1cblxuZnVuY3Rpb24gY29udGVudEF0KGZyYWdtZW50LCBkZXB0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcHRoOyBpKyspIHtcbiAgICBmcmFnbWVudCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gY2xvc2VOb2RlU3RhcnQobm9kZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gIGlmIChvcGVuU3RhcnQgPD0gMCkgcmV0dXJuIG5vZGU7XG4gIHZhciBmcmFnID0gbm9kZS5jb250ZW50O1xuICBpZiAob3BlblN0YXJ0ID4gMSkgZnJhZyA9IGZyYWcucmVwbGFjZUNoaWxkKDAsIGNsb3NlTm9kZVN0YXJ0KGZyYWcuZmlyc3RDaGlsZCwgb3BlblN0YXJ0IC0gMSwgZnJhZy5jaGlsZENvdW50ID09IDEgPyBvcGVuRW5kIC0gMSA6IDApKTtcblxuICBpZiAob3BlblN0YXJ0ID4gMCkge1xuICAgIGZyYWcgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoZnJhZykuYXBwZW5kKGZyYWcpO1xuICAgIGlmIChvcGVuRW5kIDw9IDApIGZyYWcgPSBmcmFnLmFwcGVuZChub2RlLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZnJhZykuZmlsbEJlZm9yZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gIH1cblxuICByZXR1cm4gbm9kZS5jb3B5KGZyYWcpO1xufVxuXG5mdW5jdGlvbiBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZGVwdGgsIHR5cGUsIG1hdGNoLCBvcGVuKSB7XG4gIHZhciBub2RlID0gJHRvLm5vZGUoZGVwdGgpLFxuICAgICAgaW5kZXggPSBvcGVuID8gJHRvLmluZGV4QWZ0ZXIoZGVwdGgpIDogJHRvLmluZGV4KGRlcHRoKTtcbiAgaWYgKGluZGV4ID09IG5vZGUuY2hpbGRDb3VudCAmJiAhdHlwZS5jb21wYXRpYmxlQ29udGVudChub2RlLnR5cGUpKSByZXR1cm4gbnVsbDtcbiAgdmFyIGZpdCA9IG1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCBpbmRleCk7XG4gIHJldHVybiBmaXQgJiYgIWludmFsaWRNYXJrcyh0eXBlLCBub2RlLmNvbnRlbnQsIGluZGV4KSA/IGZpdCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRNYXJrcyh0eXBlLCBmcmFnbWVudCwgc3RhcnQpIHtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgaWYgKCF0eXBlLmFsbG93c01hcmtzKGZyYWdtZW50LmNoaWxkKGkpLm1hcmtzKSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRlZmluZXNDb250ZW50KHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuc3BlYy5kZWZpbmluZyB8fCB0eXBlLnNwZWMuZGVmaW5pbmdGb3JDb250ZW50O1xufVxuXG5mdW5jdGlvbiBfcmVwbGFjZVJhbmdlKHRyLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgaWYgKCFzbGljZS5zaXplKSByZXR1cm4gdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICB2YXIgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSxcbiAgICAgICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKSByZXR1cm4gdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKSk7XG4gIHZhciB0YXJnZXREZXB0aHMgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCB0ci5kb2MucmVzb2x2ZSh0bykpO1xuICBpZiAodGFyZ2V0RGVwdGhzW3RhcmdldERlcHRocy5sZW5ndGggLSAxXSA9PSAwKSB0YXJnZXREZXB0aHMucG9wKCk7XG4gIHZhciBwcmVmZXJyZWRUYXJnZXQgPSAtKCRmcm9tLmRlcHRoICsgMSk7XG4gIHRhcmdldERlcHRocy51bnNoaWZ0KHByZWZlcnJlZFRhcmdldCk7XG5cbiAgZm9yICh2YXIgZCA9ICRmcm9tLmRlcHRoLCBwb3MgPSAkZnJvbS5wb3MgLSAxOyBkID4gMDsgZC0tLCBwb3MtLSkge1xuICAgIHZhciBzcGVjID0gJGZyb20ubm9kZShkKS50eXBlLnNwZWM7XG4gICAgaWYgKHNwZWMuZGVmaW5pbmcgfHwgc3BlYy5kZWZpbmluZ0FzQ29udGV4dCB8fCBzcGVjLmlzb2xhdGluZykgYnJlYWs7XG4gICAgaWYgKHRhcmdldERlcHRocy5pbmRleE9mKGQpID4gLTEpIHByZWZlcnJlZFRhcmdldCA9IGQ7ZWxzZSBpZiAoJGZyb20uYmVmb3JlKGQpID09IHBvcykgdGFyZ2V0RGVwdGhzLnNwbGljZSgxLCAwLCAtZCk7XG4gIH1cblxuICB2YXIgcHJlZmVycmVkVGFyZ2V0SW5kZXggPSB0YXJnZXREZXB0aHMuaW5kZXhPZihwcmVmZXJyZWRUYXJnZXQpO1xuICB2YXIgbGVmdE5vZGVzID0gW10sXG4gICAgICBwcmVmZXJyZWREZXB0aCA9IHNsaWNlLm9wZW5TdGFydDtcblxuICBmb3IgKHZhciBjb250ZW50ID0gc2xpY2UuY29udGVudCwgaSA9IDA7OyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICBsZWZ0Tm9kZXMucHVzaChub2RlKTtcbiAgICBpZiAoaSA9PSBzbGljZS5vcGVuU3RhcnQpIGJyZWFrO1xuICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQ7XG4gIH1cblxuICBmb3IgKHZhciBfZDMgPSBwcmVmZXJyZWREZXB0aCAtIDE7IF9kMyA+PSAwOyBfZDMtLSkge1xuICAgIHZhciB0eXBlID0gbGVmdE5vZGVzW19kM10udHlwZSxcbiAgICAgICAgZGVmID0gZGVmaW5lc0NvbnRlbnQodHlwZSk7XG4gICAgaWYgKGRlZiAmJiAkZnJvbS5ub2RlKHByZWZlcnJlZFRhcmdldEluZGV4KS50eXBlICE9IHR5cGUpIHByZWZlcnJlZERlcHRoID0gX2QzO2Vsc2UgaWYgKGRlZiB8fCAhdHlwZS5pc1RleHRibG9jaykgYnJlYWs7XG4gIH1cblxuICBmb3IgKHZhciBqID0gc2xpY2Uub3BlblN0YXJ0OyBqID49IDA7IGotLSkge1xuICAgIHZhciBvcGVuRGVwdGggPSAoaiArIHByZWZlcnJlZERlcHRoICsgMSkgJSAoc2xpY2Uub3BlblN0YXJ0ICsgMSk7XG4gICAgdmFyIGluc2VydCA9IGxlZnROb2Rlc1tvcGVuRGVwdGhdO1xuICAgIGlmICghaW5zZXJ0KSBjb250aW51ZTtcblxuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHRhcmdldERlcHRocy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgdGFyZ2V0RGVwdGggPSB0YXJnZXREZXB0aHNbKF9pNCArIHByZWZlcnJlZFRhcmdldEluZGV4KSAlIHRhcmdldERlcHRocy5sZW5ndGhdLFxuICAgICAgICAgIGV4cGFuZCA9IHRydWU7XG5cbiAgICAgIGlmICh0YXJnZXREZXB0aCA8IDApIHtcbiAgICAgICAgZXhwYW5kID0gZmFsc2U7XG4gICAgICAgIHRhcmdldERlcHRoID0gLXRhcmdldERlcHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gJGZyb20ubm9kZSh0YXJnZXREZXB0aCAtIDEpLFxuICAgICAgICAgIGluZGV4ID0gJGZyb20uaW5kZXgodGFyZ2V0RGVwdGggLSAxKTtcbiAgICAgIGlmIChwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBpbnNlcnQudHlwZSwgaW5zZXJ0Lm1hcmtzKSkgcmV0dXJuIHRyLnJlcGxhY2UoJGZyb20uYmVmb3JlKHRhcmdldERlcHRoKSwgZXhwYW5kID8gJHRvLmFmdGVyKHRhcmdldERlcHRoKSA6IHRvLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShjbG9zZUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIDAsIHNsaWNlLm9wZW5TdGFydCwgb3BlbkRlcHRoKSwgb3BlbkRlcHRoLCBzbGljZS5vcGVuRW5kKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXJ0U3RlcHMgPSB0ci5zdGVwcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgX2k1ID0gdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDE7IF9pNSA+PSAwOyBfaTUtLSkge1xuICAgIHRyLnJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKTtcbiAgICBpZiAodHIuc3RlcHMubGVuZ3RoID4gc3RhcnRTdGVwcykgYnJlYWs7XG4gICAgdmFyIGRlcHRoID0gdGFyZ2V0RGVwdGhzW19pNV07XG4gICAgaWYgKGRlcHRoIDwgMCkgY29udGludWU7XG4gICAgZnJvbSA9ICRmcm9tLmJlZm9yZShkZXB0aCk7XG4gICAgdG8gPSAkdG8uYWZ0ZXIoZGVwdGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb3NlRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBvbGRPcGVuLCBuZXdPcGVuLCBwYXJlbnQpIHtcbiAgaWYgKGRlcHRoIDwgb2xkT3Blbikge1xuICAgIHZhciBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZmlyc3QuY29weShjbG9zZUZyYWdtZW50KGZpcnN0LmNvbnRlbnQsIGRlcHRoICsgMSwgb2xkT3BlbiwgbmV3T3BlbiwgZmlyc3QpKSk7XG4gIH1cblxuICBpZiAoZGVwdGggPiBuZXdPcGVuKSB7XG4gICAgdmFyIG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KDApO1xuICAgIHZhciBzdGFydCA9IG1hdGNoLmZpbGxCZWZvcmUoZnJhZ21lbnQpLmFwcGVuZChmcmFnbWVudCk7XG4gICAgZnJhZ21lbnQgPSBzdGFydC5hcHBlbmQobWF0Y2gubWF0Y2hGcmFnbWVudChzdGFydCkuZmlsbEJlZm9yZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gIH1cblxuICByZXR1cm4gZnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIF9yZXBsYWNlUmFuZ2VXaXRoKHRyLCBmcm9tLCB0bywgbm9kZSkge1xuICBpZiAoIW5vZGUuaXNJbmxpbmUgJiYgZnJvbSA9PSB0byAmJiB0ci5kb2MucmVzb2x2ZShmcm9tKS5wYXJlbnQuY29udGVudC5zaXplKSB7XG4gICAgdmFyIHBvaW50ID0gaW5zZXJ0UG9pbnQodHIuZG9jLCBmcm9tLCBub2RlLnR5cGUpO1xuICAgIGlmIChwb2ludCAhPSBudWxsKSBmcm9tID0gdG8gPSBwb2ludDtcbiAgfVxuXG4gIHRyLnJlcGxhY2VSYW5nZShmcm9tLCB0bywgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG59XG5cbmZ1bmN0aW9uIF9kZWxldGVSYW5nZSh0ciwgZnJvbSwgdG8pIHtcbiAgdmFyICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksXG4gICAgICAkdG8gPSB0ci5kb2MucmVzb2x2ZSh0byk7XG4gIHZhciBjb3ZlcmVkID0gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwdGggPSBjb3ZlcmVkW2ldLFxuICAgICAgICBsYXN0ID0gaSA9PSBjb3ZlcmVkLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgJiYgZGVwdGggPT0gMCB8fCAkZnJvbS5ub2RlKGRlcHRoKS50eXBlLmNvbnRlbnRNYXRjaC52YWxpZEVuZCkgcmV0dXJuIHRyW1wiZGVsZXRlXCJdKCRmcm9tLnN0YXJ0KGRlcHRoKSwgJHRvLmVuZChkZXB0aCkpO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgKGxhc3QgfHwgJGZyb20ubm9kZShkZXB0aCAtIDEpLmNhblJlcGxhY2UoJGZyb20uaW5kZXgoZGVwdGggLSAxKSwgJHRvLmluZGV4QWZ0ZXIoZGVwdGggLSAxKSkpKSByZXR1cm4gdHJbXCJkZWxldGVcIl0oJGZyb20uYmVmb3JlKGRlcHRoKSwgJHRvLmFmdGVyKGRlcHRoKSk7XG4gIH1cblxuICBmb3IgKHZhciBkID0gMTsgZCA8PSAkZnJvbS5kZXB0aCAmJiBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgaWYgKGZyb20gLSAkZnJvbS5zdGFydChkKSA9PSAkZnJvbS5kZXB0aCAtIGQgJiYgdG8gPiAkZnJvbS5lbmQoZCkgJiYgJHRvLmVuZChkKSAtIHRvICE9ICR0by5kZXB0aCAtIGQpIHJldHVybiB0cltcImRlbGV0ZVwiXSgkZnJvbS5iZWZvcmUoZCksIHRvKTtcbiAgfVxuXG4gIHRyW1wiZGVsZXRlXCJdKGZyb20sIHRvKTtcbn1cblxuZnVuY3Rpb24gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIG1pbkRlcHRoID0gTWF0aC5taW4oJGZyb20uZGVwdGgsICR0by5kZXB0aCk7XG5cbiAgZm9yICh2YXIgZCA9IG1pbkRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgIHZhciBzdGFydCA9ICRmcm9tLnN0YXJ0KGQpO1xuICAgIGlmIChzdGFydCA8ICRmcm9tLnBvcyAtICgkZnJvbS5kZXB0aCAtIGQpIHx8ICR0by5lbmQoZCkgPiAkdG8ucG9zICsgKCR0by5kZXB0aCAtIGQpIHx8ICRmcm9tLm5vZGUoZCkudHlwZS5zcGVjLmlzb2xhdGluZyB8fCAkdG8ubm9kZShkKS50eXBlLnNwZWMuaXNvbGF0aW5nKSBicmVhaztcbiAgICBpZiAoc3RhcnQgPT0gJHRvLnN0YXJ0KGQpIHx8IGQgPT0gJGZyb20uZGVwdGggJiYgZCA9PSAkdG8uZGVwdGggJiYgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50ICYmIGQgJiYgJHRvLnN0YXJ0KGQgLSAxKSA9PSBzdGFydCAtIDEpIHJlc3VsdC5wdXNoKGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0cy5UcmFuc2Zvcm1FcnJvciA9IGZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKF9jbGFzcywgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihfY2xhc3MpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblxuICAgIHJldHVybiBfc3VwZXI1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKF9jbGFzcyk7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxuZXhwb3J0cy5UcmFuc2Zvcm1FcnJvciA9IGZ1bmN0aW9uIFRyYW5zZm9ybUVycm9yKG1lc3NhZ2UpIHtcbiAgdmFyIGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gIGVyci5fX3Byb3RvX18gPSBUcmFuc2Zvcm1FcnJvci5wcm90b3R5cGU7XG4gIHJldHVybiBlcnI7XG59O1xuXG5leHBvcnRzLlRyYW5zZm9ybUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbmV4cG9ydHMuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZXhwb3J0cy5UcmFuc2Zvcm1FcnJvcjtcbmV4cG9ydHMuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlRyYW5zZm9ybUVycm9yXCI7XG5cbnZhciBUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyYW5zZm9ybShkb2MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNmb3JtKTtcblxuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMuc3RlcHMgPSBbXTtcbiAgICB0aGlzLmRvY3MgPSBbXTtcbiAgICB0aGlzLm1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRyYW5zZm9ybSwgW3tcbiAgICBrZXk6IFwiYmVmb3JlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2NzLmxlbmd0aCA/IHRoaXMuZG9jc1swXSA6IHRoaXMuZG9jO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0ZXAoX3N0ZXApIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLm1heWJlU3RlcChfc3RlcCk7XG4gICAgICBpZiAocmVzdWx0LmZhaWxlZCkgdGhyb3cgbmV3IGV4cG9ydHMuVHJhbnNmb3JtRXJyb3IocmVzdWx0LmZhaWxlZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF5YmVTdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heWJlU3RlcChzdGVwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gc3RlcC5hcHBseSh0aGlzLmRvYyk7XG4gICAgICBpZiAoIXJlc3VsdC5mYWlsZWQpIHRoaXMuYWRkU3RlcChzdGVwLCByZXN1bHQuZG9jKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvY0NoYW5nZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0ZXBzLmxlbmd0aCA+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU3RlcChzdGVwLCBkb2MpIHtcbiAgICAgIHRoaXMuZG9jcy5wdXNoKHRoaXMuZG9jKTtcbiAgICAgIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgICAgIHRoaXMubWFwcGluZy5hcHBlbmRNYXAoc3RlcC5nZXRNYXAoKSk7XG4gICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKGZyb20pIHtcbiAgICAgIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZnJvbTtcbiAgICAgIHZhciBzbGljZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eTtcbiAgICAgIHZhciBzdGVwID0gcmVwbGFjZVN0ZXAodGhpcy5kb2MsIGZyb20sIHRvLCBzbGljZSk7XG4gICAgICBpZiAoc3RlcCkgdGhpcy5zdGVwKHN0ZXApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VXaXRoKGZyb20sIHRvLCBjb250ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oY29udGVudCksIDAsIDApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0KHBvcywgY29udGVudCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgocG9zLCBwb3MsIGNvbnRlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVJhbmdlKGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgX3JlcGxhY2VSYW5nZSh0aGlzLCBmcm9tLCB0bywgc2xpY2UpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVJhbmdlV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBub2RlKSB7XG4gICAgICBfcmVwbGFjZVJhbmdlV2l0aCh0aGlzLCBmcm9tLCB0bywgbm9kZSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVSYW5nZShmcm9tLCB0bykge1xuICAgICAgX2RlbGV0ZVJhbmdlKHRoaXMsIGZyb20sIHRvKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlmdChyYW5nZSwgdGFyZ2V0KSB7XG4gICAgICBfbGlmdCh0aGlzLCByYW5nZSwgdGFyZ2V0KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpvaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gam9pbihwb3MpIHtcbiAgICAgIHZhciBkZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcblxuICAgICAgX2pvaW4odGhpcywgcG9zLCBkZXB0aCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3cmFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyYXAocmFuZ2UsIHdyYXBwZXJzKSB7XG4gICAgICBfd3JhcDIodGhpcywgcmFuZ2UsIHdyYXBwZXJzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEJsb2NrVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRCbG9ja1R5cGUoZnJvbSkge1xuICAgICAgdmFyIHRvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmcm9tO1xuICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICAgICAgX3NldEJsb2NrVHlwZSh0aGlzLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Tm9kZU1hcmt1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXROb2RlTWFya3VwKHBvcywgdHlwZSkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBbXTtcblxuICAgICAgX3NldE5vZGVNYXJrdXAodGhpcywgcG9zLCB0eXBlLCBhdHRycywgbWFya3MpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3BsaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXQocG9zKSB7XG4gICAgICB2YXIgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICB2YXIgdHlwZXNBZnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBfc3BsaXQodGhpcywgcG9zLCBkZXB0aCwgdHlwZXNBZnRlcik7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRNYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1hcmsoZnJvbSwgdG8sIG1hcmspIHtcbiAgICAgIF9hZGRNYXJrKHRoaXMsIGZyb20sIHRvLCBtYXJrKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZU1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgX3JlbW92ZU1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJJbmNvbXBhdGlibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJJbmNvbXBhdGlibGUocG9zLCBwYXJlbnRUeXBlLCBtYXRjaCkge1xuICAgICAgX2NsZWFySW5jb21wYXRpYmxlKHRoaXMsIHBvcywgcGFyZW50VHlwZSwgbWF0Y2gpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhbnNmb3JtO1xufSgpO1xuXG5leHBvcnRzLkFkZE1hcmtTdGVwID0gQWRkTWFya1N0ZXA7XG5leHBvcnRzLk1hcFJlc3VsdCA9IE1hcFJlc3VsdDtcbmV4cG9ydHMuTWFwcGluZyA9IE1hcHBpbmc7XG5leHBvcnRzLlJlbW92ZU1hcmtTdGVwID0gUmVtb3ZlTWFya1N0ZXA7XG5leHBvcnRzLlJlcGxhY2VBcm91bmRTdGVwID0gUmVwbGFjZUFyb3VuZFN0ZXA7XG5leHBvcnRzLlJlcGxhY2VTdGVwID0gUmVwbGFjZVN0ZXA7XG5leHBvcnRzLlN0ZXAgPSBTdGVwO1xuZXhwb3J0cy5TdGVwTWFwID0gU3RlcE1hcDtcbmV4cG9ydHMuU3RlcFJlc3VsdCA9IFN0ZXBSZXN1bHQ7XG5leHBvcnRzLlRyYW5zZm9ybSA9IFRyYW5zZm9ybTtcbmV4cG9ydHMuY2FuSm9pbiA9IGNhbkpvaW47XG5leHBvcnRzLmNhblNwbGl0ID0gY2FuU3BsaXQ7XG5leHBvcnRzLmRyb3BQb2ludCA9IGRyb3BQb2ludDtcbmV4cG9ydHMuZmluZFdyYXBwaW5nID0gZmluZFdyYXBwaW5nO1xuZXhwb3J0cy5pbnNlcnRQb2ludCA9IGluc2VydFBvaW50O1xuZXhwb3J0cy5qb2luUG9pbnQgPSBqb2luUG9pbnQ7XG5leHBvcnRzLmxpZnRUYXJnZXQgPSBsaWZ0VGFyZ2V0O1xuZXhwb3J0cy5yZXBsYWNlU3RlcCA9IHJlcGxhY2VTdGVwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIHByb3NlbWlycm9yU3RhdGUgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1zdGF0ZScpO1xuXG52YXIgcHJvc2VtaXJyb3JNb2RlbCA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLW1vZGVsJyk7XG5cbnZhciBwcm9zZW1pcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXRyYW5zZm9ybScpO1xuXG52YXIgbmF2ID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yIDogbnVsbDtcbnZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogbnVsbDtcbnZhciBhZ2VudCA9IG5hdiAmJiBuYXYudXNlckFnZW50IHx8IFwiXCI7XG52YXIgaWVfZWRnZSA9IC9FZGdlXFwvKFxcZCspLy5leGVjKGFnZW50KTtcbnZhciBpZV91cHRvMTAgPSAvTVNJRSBcXGQvLmV4ZWMoYWdlbnQpO1xudmFyIGllXzExdXAgPSAvVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMoYWdlbnQpO1xudmFyIGllID0gISEoaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgaWVfZWRnZSk7XG52YXIgaWVfdmVyc2lvbiA9IGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IGllXzExdXAgPyAraWVfMTF1cFsxXSA6IGllX2VkZ2UgPyAraWVfZWRnZVsxXSA6IDA7XG52YXIgZ2Vja28gPSAhaWUgJiYgL2dlY2tvXFwvKFxcZCspL2kudGVzdChhZ2VudCk7XG5nZWNrbyAmJiArKC9GaXJlZm94XFwvKFxcZCspLy5leGVjKGFnZW50KSB8fCBbMCwgMF0pWzFdO1xuXG52YXIgX2Nocm9tZSA9ICFpZSAmJiAvQ2hyb21lXFwvKFxcZCspLy5leGVjKGFnZW50KTtcblxudmFyIGNocm9tZSA9ICEhX2Nocm9tZTtcbnZhciBjaHJvbWVfdmVyc2lvbiA9IF9jaHJvbWUgPyArX2Nocm9tZVsxXSA6IDA7XG52YXIgc2FmYXJpID0gIWllICYmICEhbmF2ICYmIC9BcHBsZSBDb21wdXRlci8udGVzdChuYXYudmVuZG9yKTtcbnZhciBpb3MgPSBzYWZhcmkgJiYgKC9Nb2JpbGVcXC9cXHcrLy50ZXN0KGFnZW50KSB8fCAhIW5hdiAmJiBuYXYubWF4VG91Y2hQb2ludHMgPiAyKTtcbnZhciBtYWMgPSBpb3MgfHwgKG5hdiA/IC9NYWMvLnRlc3QobmF2LnBsYXRmb3JtKSA6IGZhbHNlKTtcbnZhciBhbmRyb2lkID0gL0FuZHJvaWQgXFxkLy50ZXN0KGFnZW50KTtcbnZhciB3ZWJraXQgPSAhIWRvYyAmJiBcIndlYmtpdEZvbnRTbW9vdGhpbmdcIiBpbiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xudmFyIHdlYmtpdF92ZXJzaW9uID0gd2Via2l0ID8gKygvXFxiQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDA7XG5cbnZhciBkb21JbmRleCA9IGZ1bmN0aW9uIGRvbUluZGV4KG5vZGUpIHtcbiAgZm9yICh2YXIgaW5kZXggPSAwOzsgaW5kZXgrKykge1xuICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICBpZiAoIW5vZGUpIHJldHVybiBpbmRleDtcbiAgfVxufTtcblxudmFyIHBhcmVudE5vZGUgPSBmdW5jdGlvbiBwYXJlbnROb2RlKG5vZGUpIHtcbiAgdmFyIHBhcmVudCA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMTEgPyBwYXJlbnQuaG9zdCA6IHBhcmVudDtcbn07XG5cbnZhciByZXVzZWRSYW5nZSA9IG51bGw7XG5cbnZhciB0ZXh0UmFuZ2UgPSBmdW5jdGlvbiB0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8pIHtcbiAgdmFyIHJhbmdlID0gcmV1c2VkUmFuZ2UgfHwgKHJldXNlZFJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSk7XG4gIHJhbmdlLnNldEVuZChub2RlLCB0byA9PSBudWxsID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogdG8pO1xuICByYW5nZS5zZXRTdGFydChub2RlLCBmcm9tIHx8IDApO1xuICByZXR1cm4gcmFuZ2U7XG59O1xuXG52YXIgaXNFcXVpdmFsZW50UG9zaXRpb24gPSBmdW5jdGlvbiBpc0VxdWl2YWxlbnRQb3NpdGlvbihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZikge1xuICByZXR1cm4gdGFyZ2V0Tm9kZSAmJiAoc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgLTEpIHx8IHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKTtcbn07XG5cbnZhciBhdG9tRWxlbWVudHMgPSAvXihpbWd8YnJ8aW5wdXR8dGV4dGFyZWF8aHIpJC9pO1xuXG5mdW5jdGlvbiBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCBkaXIpIHtcbiAgZm9yICg7Oykge1xuICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZikgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IGhhc0Jsb2NrRGVzYyhub2RlKSB8fCBhdG9tRWxlbWVudHMudGVzdChub2RlLm5vZGVOYW1lKSB8fCBub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XG4gICAgICBub2RlID0gcGFyZW50O1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZiArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICBvZmYgPSBkaXIgPCAwID8gbm9kZVNpemUobm9kZSkgOiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vZGVTaXplKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGlzT25FZGdlKG5vZGUsIG9mZnNldCwgcGFyZW50KSB7XG4gIGZvciAodmFyIGF0U3RhcnQgPSBvZmZzZXQgPT0gMCwgYXRFbmQgPSBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSk7IGF0U3RhcnQgfHwgYXRFbmQ7KSB7XG4gICAgaWYgKG5vZGUgPT0gcGFyZW50KSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgaW5kZXggPSBkb21JbmRleChub2RlKTtcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICAgIGF0U3RhcnQgPSBhdFN0YXJ0ICYmIGluZGV4ID09IDA7XG4gICAgYXRFbmQgPSBhdEVuZCAmJiBpbmRleCA9PSBub2RlU2l6ZShub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNCbG9ja0Rlc2MoZG9tKSB7XG4gIHZhciBkZXNjO1xuXG4gIGZvciAodmFyIGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgIGlmIChkZXNjID0gY3VyLnBtVmlld0Rlc2MpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrICYmIChkZXNjLmRvbSA9PSBkb20gfHwgZGVzYy5jb250ZW50RE9NID09IGRvbSk7XG59XG5cbnZhciBzZWxlY3Rpb25Db2xsYXBzZWQgPSBmdW5jdGlvbiBzZWxlY3Rpb25Db2xsYXBzZWQoZG9tU2VsKSB7XG4gIHZhciBjb2xsYXBzZWQgPSBkb21TZWwuaXNDb2xsYXBzZWQ7XG4gIGlmIChjb2xsYXBzZWQgJiYgY2hyb21lICYmIGRvbVNlbC5yYW5nZUNvdW50ICYmICFkb21TZWwuZ2V0UmFuZ2VBdCgwKS5jb2xsYXBzZWQpIGNvbGxhcHNlZCA9IGZhbHNlO1xuICByZXR1cm4gY29sbGFwc2VkO1xufTtcblxuZnVuY3Rpb24ga2V5RXZlbnQoa2V5Q29kZSwga2V5KSB7XG4gIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gIGV2ZW50LmluaXRFdmVudChcImtleWRvd25cIiwgdHJ1ZSwgdHJ1ZSk7XG4gIGV2ZW50LmtleUNvZGUgPSBrZXlDb2RlO1xuICBldmVudC5rZXkgPSBldmVudC5jb2RlID0ga2V5O1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbmZ1bmN0aW9uIHdpbmRvd1JlY3QoZG9jKSB7XG4gIHJldHVybiB7XG4gICAgbGVmdDogMCxcbiAgICByaWdodDogZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTaWRlKHZhbHVlLCBzaWRlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IHZhbHVlIDogdmFsdWVbc2lkZV07XG59XG5cbmZ1bmN0aW9uIGNsaWVudFJlY3Qobm9kZSkge1xuICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByZWN0LndpZHRoIC8gbm9kZS5vZmZzZXRXaWR0aCB8fCAxO1xuICB2YXIgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyBub2RlLm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICByaWdodDogcmVjdC5sZWZ0ICsgbm9kZS5jbGllbnRXaWR0aCAqIHNjYWxlWCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIGJvdHRvbTogcmVjdC50b3AgKyBub2RlLmNsaWVudEhlaWdodCAqIHNjYWxlWVxuICB9O1xufVxuXG5mdW5jdGlvbiBzY3JvbGxSZWN0SW50b1ZpZXcodmlldywgcmVjdCwgc3RhcnRET00pIHtcbiAgdmFyIHNjcm9sbFRocmVzaG9sZCA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxUaHJlc2hvbGRcIikgfHwgMCxcbiAgICAgIHNjcm9sbE1hcmdpbiA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxNYXJnaW5cIikgfHwgNTtcbiAgdmFyIGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG5cbiAgZm9yICh2YXIgcGFyZW50ID0gc3RhcnRET00gfHwgdmlldy5kb207OyBwYXJlbnQgPSBwYXJlbnROb2RlKHBhcmVudCkpIHtcbiAgICBpZiAoIXBhcmVudCkgYnJlYWs7XG4gICAgaWYgKHBhcmVudC5ub2RlVHlwZSAhPSAxKSBjb250aW51ZTtcbiAgICB2YXIgZWx0ID0gcGFyZW50O1xuICAgIHZhciBhdFRvcCA9IGVsdCA9PSBkb2MuYm9keTtcbiAgICB2YXIgYm91bmRpbmcgPSBhdFRvcCA/IHdpbmRvd1JlY3QoZG9jKSA6IGNsaWVudFJlY3QoZWx0KTtcbiAgICB2YXIgbW92ZVggPSAwLFxuICAgICAgICBtb3ZlWSA9IDA7XG4gICAgaWYgKHJlY3QudG9wIDwgYm91bmRpbmcudG9wICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwidG9wXCIpKSBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikpO2Vsc2UgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tIC0gZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwiYm90dG9tXCIpKSBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwiYm90dG9tXCIpO1xuICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwibGVmdFwiKSkgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgLSByZWN0LmxlZnQgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJsZWZ0XCIpKTtlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJyaWdodFwiKSkgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJyaWdodFwiKTtcblxuICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgaWYgKGF0VG9wKSB7XG4gICAgICAgIGRvYy5kZWZhdWx0Vmlldy5zY3JvbGxCeShtb3ZlWCwgbW92ZVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXJ0WCA9IGVsdC5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgc3RhcnRZID0gZWx0LnNjcm9sbFRvcDtcbiAgICAgICAgaWYgKG1vdmVZKSBlbHQuc2Nyb2xsVG9wICs9IG1vdmVZO1xuICAgICAgICBpZiAobW92ZVgpIGVsdC5zY3JvbGxMZWZ0ICs9IG1vdmVYO1xuICAgICAgICB2YXIgZFggPSBlbHQuc2Nyb2xsTGVmdCAtIHN0YXJ0WCxcbiAgICAgICAgICAgIGRZID0gZWx0LnNjcm9sbFRvcCAtIHN0YXJ0WTtcbiAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBkWCxcbiAgICAgICAgICB0b3A6IHJlY3QudG9wIC0gZFksXG4gICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgLSBkWCxcbiAgICAgICAgICBib3R0b206IHJlY3QuYm90dG9tIC0gZFlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXRUb3ApIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlU2Nyb2xsUG9zKHZpZXcpIHtcbiAgdmFyIHJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHN0YXJ0WSA9IE1hdGgubWF4KDAsIHJlY3QudG9wKTtcbiAgdmFyIHJlZkRPTSwgcmVmVG9wO1xuXG4gIGZvciAodmFyIHggPSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCB5ID0gc3RhcnRZICsgMTsgeSA8IE1hdGgubWluKGlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7IHkgKz0gNSkge1xuICAgIHZhciBkb20gPSB2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAoIWRvbSB8fCBkb20gPT0gdmlldy5kb20gfHwgIXZpZXcuZG9tLmNvbnRhaW5zKGRvbSkpIGNvbnRpbnVlO1xuICAgIHZhciBsb2NhbFJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBpZiAobG9jYWxSZWN0LnRvcCA+PSBzdGFydFkgLSAyMCkge1xuICAgICAgcmVmRE9NID0gZG9tO1xuICAgICAgcmVmVG9wID0gbG9jYWxSZWN0LnRvcDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVmRE9NOiByZWZET00sXG4gICAgcmVmVG9wOiByZWZUb3AsXG4gICAgc3RhY2s6IHNjcm9sbFN0YWNrKHZpZXcuZG9tKVxuICB9O1xufVxuXG5mdW5jdGlvbiBzY3JvbGxTdGFjayhkb20pIHtcbiAgdmFyIHN0YWNrID0gW10sXG4gICAgICBkb2MgPSBkb20ub3duZXJEb2N1bWVudDtcblxuICBmb3IgKHZhciBjdXIgPSBkb207IGN1cjsgY3VyID0gcGFyZW50Tm9kZShjdXIpKSB7XG4gICAgc3RhY2sucHVzaCh7XG4gICAgICBkb206IGN1cixcbiAgICAgIHRvcDogY3VyLnNjcm9sbFRvcCxcbiAgICAgIGxlZnQ6IGN1ci5zY3JvbGxMZWZ0XG4gICAgfSk7XG4gICAgaWYgKGRvbSA9PSBkb2MpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrO1xufVxuXG5mdW5jdGlvbiByZXNldFNjcm9sbFBvcyhfcmVmKSB7XG4gIHZhciByZWZET00gPSBfcmVmLnJlZkRPTSxcbiAgICAgIHJlZlRvcCA9IF9yZWYucmVmVG9wLFxuICAgICAgc3RhY2sgPSBfcmVmLnN0YWNrO1xuICB2YXIgbmV3UmVmVG9wID0gcmVmRE9NID8gcmVmRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IDA7XG4gIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgbmV3UmVmVG9wID09IDAgPyAwIDogbmV3UmVmVG9wIC0gcmVmVG9wKTtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZVNjcm9sbFN0YWNrKHN0YWNrLCBkVG9wKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX3N0YWNrJGkgPSBzdGFja1tpXSxcbiAgICAgICAgZG9tID0gX3N0YWNrJGkuZG9tLFxuICAgICAgICB0b3AgPSBfc3RhY2skaS50b3AsXG4gICAgICAgIGxlZnQgPSBfc3RhY2skaS5sZWZ0O1xuICAgIGlmIChkb20uc2Nyb2xsVG9wICE9IHRvcCArIGRUb3ApIGRvbS5zY3JvbGxUb3AgPSB0b3AgKyBkVG9wO1xuICAgIGlmIChkb20uc2Nyb2xsTGVmdCAhPSBsZWZ0KSBkb20uc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gIH1cbn1cblxudmFyIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuXG5mdW5jdGlvbiBmb2N1c1ByZXZlbnRTY3JvbGwoZG9tKSB7XG4gIGlmIChkb20uc2V0QWN0aXZlKSByZXR1cm4gZG9tLnNldEFjdGl2ZSgpO1xuICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZCkgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgdmFyIHN0b3JlZCA9IHNjcm9sbFN0YWNrKGRvbSk7XG4gIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0ge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIH0gOiB1bmRlZmluZWQpO1xuXG4gIGlmICghcHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xuICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICByZXN0b3JlU2Nyb2xsU3RhY2soc3RvcmVkLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kT2Zmc2V0SW5Ob2RlKG5vZGUsIGNvb3Jkcykge1xuICB2YXIgY2xvc2VzdCxcbiAgICAgIGR4Q2xvc2VzdCA9IDJlOCxcbiAgICAgIGNvb3Jkc0Nsb3Nlc3QsXG4gICAgICBvZmZzZXQgPSAwO1xuICB2YXIgcm93Qm90ID0gY29vcmRzLnRvcCxcbiAgICAgIHJvd1RvcCA9IGNvb3Jkcy50b3A7XG5cbiAgZm9yICh2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQsIGNoaWxkSW5kZXggPSAwOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZywgY2hpbGRJbmRleCsrKSB7XG4gICAgdmFyIHJlY3RzID0gdm9pZCAwO1xuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKSByZWN0cyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7ZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMykgcmVjdHMgPSB0ZXh0UmFuZ2UoY2hpbGQpLmdldENsaWVudFJlY3RzKCk7ZWxzZSBjb250aW51ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZWN0ID0gcmVjdHNbaV07XG5cbiAgICAgIGlmIChyZWN0LnRvcCA8PSByb3dCb3QgJiYgcmVjdC5ib3R0b20gPj0gcm93VG9wKSB7XG4gICAgICAgIHJvd0JvdCA9IE1hdGgubWF4KHJlY3QuYm90dG9tLCByb3dCb3QpO1xuICAgICAgICByb3dUb3AgPSBNYXRoLm1pbihyZWN0LnRvcCwgcm93VG9wKTtcbiAgICAgICAgdmFyIGR4ID0gcmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgPyByZWN0LmxlZnQgLSBjb29yZHMubGVmdCA6IHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCA/IGNvb3Jkcy5sZWZ0IC0gcmVjdC5yaWdodCA6IDA7XG5cbiAgICAgICAgaWYgKGR4IDwgZHhDbG9zZXN0KSB7XG4gICAgICAgICAgY2xvc2VzdCA9IGNoaWxkO1xuICAgICAgICAgIGR4Q2xvc2VzdCA9IGR4O1xuICAgICAgICAgIGNvb3Jkc0Nsb3Nlc3QgPSBkeCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDMgPyB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBjb29yZHMudG9wXG4gICAgICAgICAgfSA6IGNvb3JkcztcbiAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSAmJiBkeCkgb2Zmc2V0ID0gY2hpbGRJbmRleCArIChjb29yZHMubGVmdCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY2xvc2VzdCAmJiAoY29vcmRzLmxlZnQgPj0gcmVjdC5yaWdodCAmJiBjb29yZHMudG9wID49IHJlY3QudG9wIHx8IGNvb3Jkcy5sZWZ0ID49IHJlY3QubGVmdCAmJiBjb29yZHMudG9wID49IHJlY3QuYm90dG9tKSkgb2Zmc2V0ID0gY2hpbGRJbmRleCArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzKSByZXR1cm4gZmluZE9mZnNldEluVGV4dChjbG9zZXN0LCBjb29yZHNDbG9zZXN0KTtcbiAgaWYgKCFjbG9zZXN0IHx8IGR4Q2xvc2VzdCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDEpIHJldHVybiB7XG4gICAgbm9kZTogbm9kZSxcbiAgICBvZmZzZXQ6IG9mZnNldFxuICB9O1xuICByZXR1cm4gZmluZE9mZnNldEluTm9kZShjbG9zZXN0LCBjb29yZHNDbG9zZXN0KTtcbn1cblxuZnVuY3Rpb24gZmluZE9mZnNldEluVGV4dChub2RlLCBjb29yZHMpIHtcbiAgdmFyIGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIGkgKyAxKTtcbiAgICByYW5nZS5zZXRTdGFydChub2RlLCBpKTtcbiAgICB2YXIgcmVjdCA9IHNpbmdsZVJlY3QocmFuZ2UsIDEpO1xuICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSkgY29udGludWU7XG4gICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKSByZXR1cm4ge1xuICAgICAgbm9kZTogbm9kZSxcbiAgICAgIG9mZnNldDogaSArIChjb29yZHMubGVmdCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IDApXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9kZTogbm9kZSxcbiAgICBvZmZzZXQ6IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5SZWN0KGNvb3JkcywgcmVjdCkge1xuICByZXR1cm4gY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0IC0gMSAmJiBjb29yZHMubGVmdCA8PSByZWN0LnJpZ2h0ICsgMSAmJiBjb29yZHMudG9wID49IHJlY3QudG9wIC0gMSAmJiBjb29yZHMudG9wIDw9IHJlY3QuYm90dG9tICsgMTtcbn1cblxuZnVuY3Rpb24gdGFyZ2V0S2x1ZGdlKGRvbSwgY29vcmRzKSB7XG4gIHZhciBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiAvXmxpJC9pLnRlc3QocGFyZW50Lm5vZGVOYW1lKSAmJiBjb29yZHMubGVmdCA8IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSByZXR1cm4gcGFyZW50O1xuICByZXR1cm4gZG9tO1xufVxuXG5mdW5jdGlvbiBwb3NGcm9tRWxlbWVudCh2aWV3LCBlbHQsIGNvb3Jkcykge1xuICB2YXIgX2ZpbmRPZmZzZXRJbk5vZGUgPSBmaW5kT2Zmc2V0SW5Ob2RlKGVsdCwgY29vcmRzKSxcbiAgICAgIG5vZGUgPSBfZmluZE9mZnNldEluTm9kZS5ub2RlLFxuICAgICAgb2Zmc2V0ID0gX2ZpbmRPZmZzZXRJbk5vZGUub2Zmc2V0LFxuICAgICAgYmlhcyA9IC0xO1xuXG4gIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgIW5vZGUuZmlyc3RDaGlsZCkge1xuICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBiaWFzID0gcmVjdC5sZWZ0ICE9IHJlY3QucmlnaHQgJiYgY29vcmRzLmxlZnQgPiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IC0xO1xuICB9XG5cbiAgcmV0dXJuIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcyk7XG59XG5cbmZ1bmN0aW9uIHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcykge1xuICB2YXIgb3V0c2lkZSA9IC0xO1xuXG4gIGZvciAodmFyIGN1ciA9IG5vZGU7Oykge1xuICAgIGlmIChjdXIgPT0gdmlldy5kb20pIGJyZWFrO1xuICAgIHZhciBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGN1ciwgdHJ1ZSk7XG4gICAgaWYgKCFkZXNjKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChkZXNjLm5vZGUuaXNCbG9jayAmJiBkZXNjLnBhcmVudCkge1xuICAgICAgdmFyIHJlY3QgPSBkZXNjLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmIChyZWN0LmxlZnQgPiBjb29yZHMubGVmdCB8fCByZWN0LnRvcCA+IGNvb3Jkcy50b3ApIG91dHNpZGUgPSBkZXNjLnBvc0JlZm9yZTtlbHNlIGlmIChyZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgfHwgcmVjdC5ib3R0b20gPCBjb29yZHMudG9wKSBvdXRzaWRlID0gZGVzYy5wb3NBZnRlcjtlbHNlIGJyZWFrO1xuICAgIH1cblxuICAgIGN1ciA9IGRlc2MuZG9tLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gb3V0c2lkZSA+IC0xID8gb3V0c2lkZSA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgMSk7XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRGcm9tUG9pbnQoZWxlbWVudCwgY29vcmRzLCBib3gpIHtcbiAgdmFyIGxlbiA9IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgaWYgKGxlbiAmJiBib3gudG9wIDwgYm94LmJvdHRvbSkge1xuICAgIGZvciAodmFyIHN0YXJ0SSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxlbiAtIDEsIE1hdGguZmxvb3IobGVuICogKGNvb3Jkcy50b3AgLSBib3gudG9wKSAvIChib3guYm90dG9tIC0gYm94LnRvcCkpIC0gMikpLCBpID0gc3RhcnRJOzspIHtcbiAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcblxuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgdmFyIHJlY3RzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpIHJldHVybiBlbGVtZW50RnJvbVBvaW50KGNoaWxkLCBjb29yZHMsIHJlY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoaSA9IChpICsgMSkgJSBsZW4pID09IHN0YXJ0SSkgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIF9wb3NBdENvb3Jkcyh2aWV3LCBjb29yZHMpIHtcbiAgdmFyIGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQsXG4gICAgICBub2RlLFxuICAgICAgb2Zmc2V0ID0gMDtcblxuICBpZiAoZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF9wb3MgPSBkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG5cbiAgICAgIGlmIChfcG9zKSB7XG4gICAgICAgIG5vZGUgPSBfcG9zLm9mZnNldE5vZGU7XG4gICAgICAgIG9mZnNldCA9IF9wb3Mub2Zmc2V0O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHt9XG4gIH1cblxuICBpZiAoIW5vZGUgJiYgZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2MuY2FyZXRSYW5nZUZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG5cbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIG5vZGUgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgIG9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbHQgPSAodmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQgPyB2aWV3LnJvb3QgOiBkb2MpLmVsZW1lbnRGcm9tUG9pbnQoY29vcmRzLmxlZnQsIGNvb3Jkcy50b3AgKyAxKTtcbiAgdmFyIHBvcztcblxuICBpZiAoIWVsdCB8fCAhdmlldy5kb20uY29udGFpbnMoZWx0Lm5vZGVUeXBlICE9IDEgPyBlbHQucGFyZW50Tm9kZSA6IGVsdCkpIHtcbiAgICB2YXIgYm94ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKCFpblJlY3QoY29vcmRzLCBib3gpKSByZXR1cm4gbnVsbDtcbiAgICBlbHQgPSBlbGVtZW50RnJvbVBvaW50KHZpZXcuZG9tLCBjb29yZHMsIGJveCk7XG4gICAgaWYgKCFlbHQpIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHNhZmFyaSkge1xuICAgIGZvciAodmFyIHAgPSBlbHQ7IG5vZGUgJiYgcDsgcCA9IHBhcmVudE5vZGUocCkpIHtcbiAgICAgIGlmIChwLmRyYWdnYWJsZSkgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBlbHQgPSB0YXJnZXRLbHVkZ2UoZWx0LCBjb29yZHMpO1xuXG4gIGlmIChub2RlKSB7XG4gICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcblxuICAgICAgaWYgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSxcbiAgICAgICAgICAgIF9ib3g7XG5cbiAgICAgICAgaWYgKG5leHQubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiAoX2JveCA9IG5leHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLnJpZ2h0IDw9IGNvb3Jkcy5sZWZ0ICYmIF9ib3guYm90dG9tID4gY29vcmRzLnRvcCkgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT0gdmlldy5kb20gJiYgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxICYmIG5vZGUubGFzdENoaWxkLm5vZGVUeXBlID09IDEgJiYgY29vcmRzLnRvcCA+IG5vZGUubGFzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSkgcG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplO2Vsc2UgaWYgKG9mZnNldCA9PSAwIHx8IG5vZGUubm9kZVR5cGUgIT0gMSB8fCBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0ubm9kZU5hbWUgIT0gXCJCUlwiKSBwb3MgPSBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpO1xuICB9XG5cbiAgaWYgKHBvcyA9PSBudWxsKSBwb3MgPSBwb3NGcm9tRWxlbWVudCh2aWV3LCBlbHQsIGNvb3Jkcyk7XG4gIHZhciBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGVsdCwgdHJ1ZSk7XG4gIHJldHVybiB7XG4gICAgcG9zOiBwb3MsXG4gICAgaW5zaWRlOiBkZXNjID8gZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIgOiAtMVxuICB9O1xufVxuXG5mdW5jdGlvbiBzaW5nbGVSZWN0KHRhcmdldCwgYmlhcykge1xuICB2YXIgcmVjdHMgPSB0YXJnZXQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgcmV0dXJuICFyZWN0cy5sZW5ndGggPyB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiByZWN0c1tiaWFzIDwgMCA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbn1cblxudmFyIEJJREkgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY10vO1xuXG5mdW5jdGlvbiBfY29vcmRzQXRQb3ModmlldywgcG9zLCBzaWRlKSB7XG4gIHZhciBfdmlldyRkb2NWaWV3JGRvbUZyb20gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIHNpZGUgPCAwID8gLTEgOiAxKSxcbiAgICAgIG5vZGUgPSBfdmlldyRkb2NWaWV3JGRvbUZyb20ubm9kZSxcbiAgICAgIG9mZnNldCA9IF92aWV3JGRvY1ZpZXckZG9tRnJvbS5vZmZzZXQ7XG5cbiAgdmFyIHN1cHBvcnRFbXB0eVJhbmdlID0gd2Via2l0IHx8IGdlY2tvO1xuXG4gIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICBpZiAoc3VwcG9ydEVtcHR5UmFuZ2UgJiYgKEJJREkudGVzdChub2RlLm5vZGVWYWx1ZSkgfHwgKHNpZGUgPCAwID8gIW9mZnNldCA6IG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKSkge1xuICAgICAgdmFyIHJlY3QgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCksIHNpZGUpO1xuXG4gICAgICBpZiAoZ2Vja28gJiYgb2Zmc2V0ICYmIC9cXHMvLnRlc3Qobm9kZS5ub2RlVmFsdWVbb2Zmc2V0IC0gMV0pICYmIG9mZnNldCA8IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmVjdEJlZm9yZSA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCAtIDEsIG9mZnNldCAtIDEpLCAtMSk7XG5cbiAgICAgICAgaWYgKHJlY3RCZWZvcmUudG9wID09IHJlY3QudG9wKSB7XG4gICAgICAgICAgdmFyIHJlY3RBZnRlciA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0ICsgMSksIC0xKTtcbiAgICAgICAgICBpZiAocmVjdEFmdGVyLnRvcCAhPSByZWN0LnRvcCkgcmV0dXJuIGZsYXR0ZW5WKHJlY3RBZnRlciwgcmVjdEFmdGVyLmxlZnQgPCByZWN0QmVmb3JlLmxlZnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZnJvbSA9IG9mZnNldCxcbiAgICAgICAgICB0byA9IG9mZnNldCxcbiAgICAgICAgICB0YWtlU2lkZSA9IHNpZGUgPCAwID8gMSA6IC0xO1xuXG4gICAgICBpZiAoc2lkZSA8IDAgJiYgIW9mZnNldCkge1xuICAgICAgICB0bysrO1xuICAgICAgICB0YWtlU2lkZSA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChzaWRlID49IDAgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICBmcm9tLS07XG4gICAgICAgIHRha2VTaWRlID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc2lkZSA8IDApIHtcbiAgICAgICAgZnJvbS0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG8rKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIGZyb20sIHRvKSwgdGFrZVNpZGUpLCB0YWtlU2lkZSA8IDApO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgaWYgKG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgdmFyIGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMSkgcmV0dXJuIGZsYXR0ZW5IKGJlZm9yZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgdmFyIGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICBpZiAoYWZ0ZXIubm9kZVR5cGUgPT0gMSkgcmV0dXJuIGZsYXR0ZW5IKGFmdGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmxhdHRlbkgobm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc2lkZSA+PSAwKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgJiYgKHNpZGUgPCAwIHx8IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKSkpIHtcbiAgICB2YXIgX2JlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICB2YXIgdGFyZ2V0ID0gX2JlZm9yZS5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKF9iZWZvcmUsIG5vZGVTaXplKF9iZWZvcmUpIC0gKHN1cHBvcnRFbXB0eVJhbmdlID8gMCA6IDEpKSA6IF9iZWZvcmUubm9kZVR5cGUgPT0gMSAmJiAoX2JlZm9yZS5ub2RlTmFtZSAhPSBcIkJSXCIgfHwgIV9iZWZvcmUubmV4dFNpYmxpbmcpID8gX2JlZm9yZSA6IG51bGw7XG4gICAgaWYgKHRhcmdldCkgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3QodGFyZ2V0LCAxKSwgZmFsc2UpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA8IG5vZGVTaXplKG5vZGUpKSB7XG4gICAgdmFyIF9hZnRlciA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuXG4gICAgd2hpbGUgKF9hZnRlci5wbVZpZXdEZXNjICYmIF9hZnRlci5wbVZpZXdEZXNjLmlnbm9yZUZvckNvb3Jkcykge1xuICAgICAgX2FmdGVyID0gX2FmdGVyLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBfdGFyZ2V0ID0gIV9hZnRlciA/IG51bGwgOiBfYWZ0ZXIubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShfYWZ0ZXIsIDAsIHN1cHBvcnRFbXB0eVJhbmdlID8gMCA6IDEpIDogX2FmdGVyLm5vZGVUeXBlID09IDEgPyBfYWZ0ZXIgOiBudWxsO1xuXG4gICAgaWYgKF90YXJnZXQpIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KF90YXJnZXQsIC0xKSwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdChub2RlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2Uobm9kZSkgOiBub2RlLCAtc2lkZSksIHNpZGUgPj0gMCk7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5WKHJlY3QsIGxlZnQpIHtcbiAgaWYgKHJlY3Qud2lkdGggPT0gMCkgcmV0dXJuIHJlY3Q7XG4gIHZhciB4ID0gbGVmdCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gIHJldHVybiB7XG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICBib3R0b206IHJlY3QuYm90dG9tLFxuICAgIGxlZnQ6IHgsXG4gICAgcmlnaHQ6IHhcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbkgocmVjdCwgdG9wKSB7XG4gIGlmIChyZWN0LmhlaWdodCA9PSAwKSByZXR1cm4gcmVjdDtcbiAgdmFyIHkgPSB0b3AgPyByZWN0LnRvcCA6IHJlY3QuYm90dG9tO1xuICByZXR1cm4ge1xuICAgIHRvcDogeSxcbiAgICBib3R0b206IHksXG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHJpZ2h0OiByZWN0LnJpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsIGYpIHtcbiAgdmFyIHZpZXdTdGF0ZSA9IHZpZXcuc3RhdGUsXG4gICAgICBhY3RpdmUgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgaWYgKHZpZXdTdGF0ZSAhPSBzdGF0ZSkgdmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gIGlmIChhY3RpdmUgIT0gdmlldy5kb20pIHZpZXcuZm9jdXMoKTtcblxuICB0cnkge1xuICAgIHJldHVybiBmKCk7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHZpZXdTdGF0ZSAhPSBzdGF0ZSkgdmlldy51cGRhdGVTdGF0ZSh2aWV3U3RhdGUpO1xuICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20gJiYgYWN0aXZlKSBhY3RpdmUuZm9jdXMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgdmFyIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyICRwb3MgPSBkaXIgPT0gXCJ1cFwiID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZpZXckZG9jVmlldyRkb21Gcm9tMiA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKCRwb3MucG9zLCBkaXIgPT0gXCJ1cFwiID8gLTEgOiAxKSxcbiAgICAgICAgZG9tID0gX3ZpZXckZG9jVmlldyRkb21Gcm9tMi5ub2RlO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIG5lYXJlc3QgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tLCB0cnVlKTtcbiAgICAgIGlmICghbmVhcmVzdCkgYnJlYWs7XG5cbiAgICAgIGlmIChuZWFyZXN0Lm5vZGUuaXNCbG9jaykge1xuICAgICAgICBkb20gPSBuZWFyZXN0LmRvbTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRvbSA9IG5lYXJlc3QuZG9tLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgdmFyIGNvb3JkcyA9IF9jb29yZHNBdFBvcyh2aWV3LCAkcG9zLnBvcywgMSk7XG5cbiAgICBmb3IgKHZhciBjaGlsZCA9IGRvbS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgdmFyIGJveGVzID0gdm9pZCAwO1xuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpIGJveGVzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKSBib3hlcyA9IHRleHRSYW5nZShjaGlsZCwgMCwgY2hpbGQubm9kZVZhbHVlLmxlbmd0aCkuZ2V0Q2xpZW50UmVjdHMoKTtlbHNlIGNvbnRpbnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgaWYgKGJveC5ib3R0b20gPiBib3gudG9wICsgMSAmJiAoZGlyID09IFwidXBcIiA/IGNvb3Jkcy50b3AgLSBib3gudG9wID4gKGJveC5ib3R0b20gLSBjb29yZHMudG9wKSAqIDIgOiBib3guYm90dG9tIC0gY29vcmRzLmJvdHRvbSA+IChjb29yZHMuYm90dG9tIC0gYm94LnRvcCkgKiAyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxudmFyIG1heWJlUlRMID0gL1tcXHUwNTkwLVxcdTA4YWNdLztcblxuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgdmFyICRoZWFkID0gc3RhdGUuc2VsZWN0aW9uLiRoZWFkO1xuICBpZiAoISRoZWFkLnBhcmVudC5pc1RleHRibG9jaykgcmV0dXJuIGZhbHNlO1xuICB2YXIgb2Zmc2V0ID0gJGhlYWQucGFyZW50T2Zmc2V0LFxuICAgICAgYXRTdGFydCA9ICFvZmZzZXQsXG4gICAgICBhdEVuZCA9IG9mZnNldCA9PSAkaGVhZC5wYXJlbnQuY29udGVudC5zaXplO1xuICB2YXIgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgaWYgKCFtYXliZVJUTC50ZXN0KCRoZWFkLnBhcmVudC50ZXh0Q29udGVudCkgfHwgIXNlbC5tb2RpZnkpIHJldHVybiBkaXIgPT0gXCJsZWZ0XCIgfHwgZGlyID09IFwiYmFja3dhcmRcIiA/IGF0U3RhcnQgOiBhdEVuZDtcbiAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2xkUmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKSxcbiAgICAgICAgb2xkTm9kZSA9IHNlbC5mb2N1c05vZGUsXG4gICAgICAgIG9sZE9mZiA9IHNlbC5mb2N1c09mZnNldDtcbiAgICB2YXIgb2xkQmlkaUxldmVsID0gc2VsLmNhcmV0QmlkaUxldmVsO1xuICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGRpciwgXCJjaGFyYWN0ZXJcIik7XG4gICAgdmFyIHBhcmVudERPTSA9ICRoZWFkLmRlcHRoID8gdmlldy5kb2NWaWV3LmRvbUFmdGVyUG9zKCRoZWFkLmJlZm9yZSgpKSA6IHZpZXcuZG9tO1xuICAgIHZhciByZXN1bHQgPSAhcGFyZW50RE9NLmNvbnRhaW5zKHNlbC5mb2N1c05vZGUubm9kZVR5cGUgPT0gMSA/IHNlbC5mb2N1c05vZGUgOiBzZWwuZm9jdXNOb2RlLnBhcmVudE5vZGUpIHx8IG9sZE5vZGUgPT0gc2VsLmZvY3VzTm9kZSAmJiBvbGRPZmYgPT0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBzZWwuYWRkUmFuZ2Uob2xkUmFuZ2UpO1xuICAgIGlmIChvbGRCaWRpTGV2ZWwgIT0gbnVsbCkgc2VsLmNhcmV0QmlkaUxldmVsID0gb2xkQmlkaUxldmVsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuXG52YXIgY2FjaGVkU3RhdGUgPSBudWxsO1xudmFyIGNhY2hlZERpciA9IG51bGw7XG52YXIgY2FjaGVkUmVzdWx0ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIF9lbmRPZlRleHRibG9jayh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gIGlmIChjYWNoZWRTdGF0ZSA9PSBzdGF0ZSAmJiBjYWNoZWREaXIgPT0gZGlyKSByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICBjYWNoZWRTdGF0ZSA9IHN0YXRlO1xuICBjYWNoZWREaXIgPSBkaXI7XG4gIHJldHVybiBjYWNoZWRSZXN1bHQgPSBkaXIgPT0gXCJ1cFwiIHx8IGRpciA9PSBcImRvd25cIiA/IGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcikgOiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcik7XG59XG5cbnZhciBOT1RfRElSVFkgPSAwLFxuICAgIENISUxEX0RJUlRZID0gMSxcbiAgICBDT05URU5UX0RJUlRZID0gMixcbiAgICBOT0RFX0RJUlRZID0gMztcblxudmFyIFZpZXdEZXNjID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaWV3RGVzYyhwYXJlbnQsIGNoaWxkcmVuLCBkb20sIGNvbnRlbnRET00pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlld0Rlc2MpO1xuXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuZG9tID0gZG9tO1xuICAgIHRoaXMuY29udGVudERPTSA9IGNvbnRlbnRET007XG4gICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICBkb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVmlld0Rlc2MsIFt7XG4gICAga2V5OiBcIm1hdGNoZXNXaWRnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlc01hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlc01hcmsobWFyaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXRjaGVzTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXRjaGVzSGFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVzSGFjayhub2RlTmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVJ1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VSdWxlKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0b3BFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHNpemUgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2l6ZSArPSB0aGlzLmNoaWxkcmVuW2ldLnNpemU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJib3JkZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLmRvbS5wbVZpZXdEZXNjID09IHRoaXMpIHRoaXMuZG9tLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zQmVmb3JlQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zQmVmb3JlQ2hpbGQoY2hpbGQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwb3MgPSB0aGlzLnBvc0F0U3RhcnQ7OyBpKyspIHtcbiAgICAgICAgdmFyIGN1ciA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjdXIgPT0gY2hpbGQpIHJldHVybiBwb3M7XG4gICAgICAgIHBvcyArPSBjdXIuc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zQmVmb3JlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zQmVmb3JlQ2hpbGQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc0F0U3RhcnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZUNoaWxkKHRoaXMpICsgdGhpcy5ib3JkZXIgOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3NBZnRlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9zQmVmb3JlICsgdGhpcy5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3NBdEVuZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMuc2l6ZSAtIDIgKiB0aGlzLmJvcmRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9jYWxQb3NGcm9tRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoZG9tLm5vZGVUeXBlID09IDEgPyBkb20gOiBkb20ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgaWYgKGJpYXMgPCAwKSB7XG4gICAgICAgICAgdmFyIGRvbUJlZm9yZSwgZGVzYztcblxuICAgICAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICBkb21CZWZvcmUgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgICBkb20gPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoZG9tQmVmb3JlICYmICEoKGRlc2MgPSBkb21CZWZvcmUucG1WaWV3RGVzYykgJiYgZGVzYy5wYXJlbnQgPT0gdGhpcykpIHtcbiAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbUJlZm9yZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRvbUJlZm9yZSA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgKyBkZXNjLnNpemUgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRvbUFmdGVyLCBfZGVzYztcblxuICAgICAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICBkb21BZnRlciA9IGRvbS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChkb20ucGFyZW50Tm9kZSAhPSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvbUFmdGVyID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChkb21BZnRlciAmJiAhKChfZGVzYyA9IGRvbUFmdGVyLnBtVmlld0Rlc2MpICYmIF9kZXNjLnBhcmVudCA9PSB0aGlzKSkge1xuICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb21BZnRlci5uZXh0U2libGluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZG9tQWZ0ZXIgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKF9kZXNjKSA6IHRoaXMucG9zQXRFbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGF0RW5kO1xuXG4gICAgICBpZiAoZG9tID09IHRoaXMuZG9tICYmIHRoaXMuY29udGVudERPTSkge1xuICAgICAgICBhdEVuZCA9IG9mZnNldCA+IGRvbUluZGV4KHRoaXMuY29udGVudERPTSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKSkge1xuICAgICAgICBhdEVuZCA9IGRvbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzLmNvbnRlbnRET00pICYgMjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kb20uZmlyc3RDaGlsZCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09IDApIGZvciAodmFyIHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgaWYgKHNlYXJjaCA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgYXRFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWFyY2gucHJldmlvdXNTaWJsaW5nKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRFbmQgPT0gbnVsbCAmJiBvZmZzZXQgPT0gZG9tLmNoaWxkTm9kZXMubGVuZ3RoKSBmb3IgKHZhciBfc2VhcmNoID0gZG9tOzsgX3NlYXJjaCA9IF9zZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGlmIChfc2VhcmNoID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBhdEVuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3NlYXJjaC5uZXh0U2libGluZykgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChhdEVuZCA9PSBudWxsID8gYmlhcyA+IDAgOiBhdEVuZCkgPyB0aGlzLnBvc0F0RW5kIDogdGhpcy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZWFyZXN0RGVzY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZWFyZXN0RGVzYyhkb20pIHtcbiAgICAgIHZhciBvbmx5Tm9kZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBmaXJzdCA9IHRydWUsIGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICB2YXIgZGVzYyA9IHRoaXMuZ2V0RGVzYyhjdXIpLFxuICAgICAgICAgICAgbm9kZURPTSA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoZGVzYyAmJiAoIW9ubHlOb2RlcyB8fCBkZXNjLm5vZGUpKSB7XG4gICAgICAgICAgaWYgKGZpcnN0ICYmIChub2RlRE9NID0gZGVzYy5ub2RlRE9NKSAmJiAhKG5vZGVET00ubm9kZVR5cGUgPT0gMSA/IG5vZGVET00uY29udGFpbnMoZG9tLm5vZGVUeXBlID09IDEgPyBkb20gOiBkb20ucGFyZW50Tm9kZSkgOiBub2RlRE9NID09IGRvbSkpIGZpcnN0ID0gZmFsc2U7ZWxzZSByZXR1cm4gZGVzYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREZXNjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlc2MoZG9tKSB7XG4gICAgICB2YXIgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuXG4gICAgICBmb3IgKHZhciBjdXIgPSBkZXNjOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpIHtcbiAgICAgICAgaWYgKGN1ciA9PSB0aGlzKSByZXR1cm4gZGVzYztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zRnJvbURPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICBmb3IgKHZhciBzY2FuID0gZG9tOyBzY2FuOyBzY2FuID0gc2Nhbi5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBkZXNjID0gdGhpcy5nZXREZXNjKHNjYW4pO1xuICAgICAgICBpZiAoZGVzYykgcmV0dXJuIGRlc2MubG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXNjQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzY0F0KHBvcykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPT0gcG9zICYmIGVuZCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICB3aGlsZSAoIWNoaWxkLmJvcmRlciAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvcyA8IGVuZCkgcmV0dXJuIGNoaWxkLmRlc2NBdChwb3MgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIpO1xuICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvbUZyb21Qb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9tRnJvbVBvcyhwb3MsIHNpZGUpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKSByZXR1cm4ge1xuICAgICAgICBub2RlOiB0aGlzLmRvbSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9O1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIG9mZnNldCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGN1clBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBlbmQgPSBjdXJQb3MgKyBjaGlsZC5zaXplO1xuXG4gICAgICAgIGlmIChlbmQgPiBwb3MgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmFpbGluZ0hhY2tWaWV3RGVzYykge1xuICAgICAgICAgIG9mZnNldCA9IHBvcyAtIGN1clBvcztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9mZnNldCkgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV0uZG9tRnJvbVBvcyhvZmZzZXQgLSB0aGlzLmNoaWxkcmVuW2ldLmJvcmRlciwgc2lkZSk7XG5cbiAgICAgIGZvciAodmFyIHByZXY7IGkgJiYgIShwcmV2ID0gdGhpcy5jaGlsZHJlbltpIC0gMV0pLnNpemUgJiYgcHJldiBpbnN0YW5jZW9mIFdpZGdldFZpZXdEZXNjICYmIHByZXYuc2lkZSA+PSAwOyBpLS0pIHt9XG5cbiAgICAgIGlmIChzaWRlIDw9IDApIHtcbiAgICAgICAgdmFyIF9wcmV2LFxuICAgICAgICAgICAgZW50ZXIgPSB0cnVlO1xuXG4gICAgICAgIGZvciAoOzsgaS0tLCBlbnRlciA9IGZhbHNlKSB7XG4gICAgICAgICAgX3ByZXYgPSBpID8gdGhpcy5jaGlsZHJlbltpIC0gMV0gOiBudWxsO1xuICAgICAgICAgIGlmICghX3ByZXYgfHwgX3ByZXYuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfcHJldiAmJiBzaWRlICYmIGVudGVyICYmICFfcHJldi5ib3JkZXIgJiYgIV9wcmV2LmRvbUF0b20pIHJldHVybiBfcHJldi5kb21Gcm9tUG9zKF9wcmV2LnNpemUsIHNpZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IHRoaXMuY29udGVudERPTSxcbiAgICAgICAgICBvZmZzZXQ6IF9wcmV2ID8gZG9tSW5kZXgoX3ByZXYuZG9tKSArIDEgOiAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV4dCxcbiAgICAgICAgICAgIF9lbnRlciA9IHRydWU7XG5cbiAgICAgICAgZm9yICg7OyBpKyssIF9lbnRlciA9IGZhbHNlKSB7XG4gICAgICAgICAgbmV4dCA9IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA/IHRoaXMuY2hpbGRyZW5baV0gOiBudWxsO1xuICAgICAgICAgIGlmICghbmV4dCB8fCBuZXh0LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSkgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dCAmJiBfZW50ZXIgJiYgIW5leHQuYm9yZGVyICYmICFuZXh0LmRvbUF0b20pIHJldHVybiBuZXh0LmRvbUZyb21Qb3MoMCwgc2lkZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogdGhpcy5jb250ZW50RE9NLFxuICAgICAgICAgIG9mZnNldDogbmV4dCA/IGRvbUluZGV4KG5leHQuZG9tKSA6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlUmFuZ2UoZnJvbSwgdG8pIHtcbiAgICAgIHZhciBiYXNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDApIHJldHVybiB7XG4gICAgICAgIG5vZGU6IHRoaXMuY29udGVudERPTSxcbiAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgdG86IHRvLFxuICAgICAgICBmcm9tT2Zmc2V0OiAwLFxuICAgICAgICB0b09mZnNldDogdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoXG4gICAgICB9O1xuICAgICAgdmFyIGZyb21PZmZzZXQgPSAtMSxcbiAgICAgICAgICB0b09mZnNldCA9IC0xO1xuXG4gICAgICBmb3IgKHZhciBvZmZzZXQgPSBiYXNlLCBpID0gMDs7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcblxuICAgICAgICBpZiAoZnJvbU9mZnNldCA9PSAtMSAmJiBmcm9tIDw9IGVuZCkge1xuICAgICAgICAgIHZhciBjaGlsZEJhc2UgPSBvZmZzZXQgKyBjaGlsZC5ib3JkZXI7XG4gICAgICAgICAgaWYgKGZyb20gPj0gY2hpbGRCYXNlICYmIHRvIDw9IGVuZCAtIGNoaWxkLmJvcmRlciAmJiBjaGlsZC5ub2RlICYmIGNoaWxkLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGNoaWxkLmNvbnRlbnRET00pKSByZXR1cm4gY2hpbGQucGFyc2VSYW5nZShmcm9tLCB0bywgY2hpbGRCYXNlKTtcbiAgICAgICAgICBmcm9tID0gb2Zmc2V0O1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5jaGlsZHJlbltqIC0gMV07XG5cbiAgICAgICAgICAgIGlmIChwcmV2LnNpemUgJiYgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIXByZXYuZW1wdHlDaGlsZEF0KDEpKSB7XG4gICAgICAgICAgICAgIGZyb21PZmZzZXQgPSBkb21JbmRleChwcmV2LmRvbSkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJvbSAtPSBwcmV2LnNpemU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZyb21PZmZzZXQgPT0gLTEpIGZyb21PZmZzZXQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb21PZmZzZXQgPiAtMSAmJiAoZW5kID4gdG8gfHwgaSA9PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgdG8gPSBlbmQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaiA9IGkgKyAxOyBfaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuY2hpbGRyZW5bX2pdO1xuXG4gICAgICAgICAgICBpZiAobmV4dC5zaXplICYmIG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFuZXh0LmVtcHR5Q2hpbGRBdCgtMSkpIHtcbiAgICAgICAgICAgICAgdG9PZmZzZXQgPSBkb21JbmRleChuZXh0LmRvbSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0byArPSBuZXh0LnNpemU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRvT2Zmc2V0ID09IC0xKSB0b09mZnNldCA9IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogdGhpcy5jb250ZW50RE9NLFxuICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICB0bzogdG8sXG4gICAgICAgIGZyb21PZmZzZXQ6IGZyb21PZmZzZXQsXG4gICAgICAgIHRvT2Zmc2V0OiB0b09mZnNldFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW1wdHlDaGlsZEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtcHR5Q2hpbGRBdChzaWRlKSB7XG4gICAgICBpZiAodGhpcy5ib3JkZXIgfHwgIXRoaXMuY29udGVudERPTSB8fCAhdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bc2lkZSA8IDAgPyAwIDogdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiBjaGlsZC5zaXplID09IDAgfHwgY2hpbGQuZW1wdHlDaGlsZEF0KHNpZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb21BZnRlclBvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb21BZnRlclBvcyhwb3MpIHtcbiAgICAgIHZhciBfdGhpcyRkb21Gcm9tUG9zID0gdGhpcy5kb21Gcm9tUG9zKHBvcywgMCksXG4gICAgICAgICAgbm9kZSA9IF90aGlzJGRvbUZyb21Qb3Mubm9kZSxcbiAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRkb21Gcm9tUG9zLm9mZnNldDtcblxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSB8fCBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGFmdGVyIHBvcyBcIiArIHBvcyk7XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290KSB7XG4gICAgICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgICAgdmFyIGZyb20gPSBNYXRoLm1pbihhbmNob3IsIGhlYWQpLFxuICAgICAgICAgIHRvID0gTWF0aC5tYXgoYW5jaG9yLCBoZWFkKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICBpZiAoZnJvbSA+IG9mZnNldCAmJiB0byA8IGVuZCkgcmV0dXJuIGNoaWxkLnNldFNlbGVjdGlvbihhbmNob3IgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIGhlYWQgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIHJvb3QsIGZvcmNlKTtcbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5jaG9yRE9NID0gdGhpcy5kb21Gcm9tUG9zKGFuY2hvciwgYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgIHZhciBoZWFkRE9NID0gaGVhZCA9PSBhbmNob3IgPyBhbmNob3JET00gOiB0aGlzLmRvbUZyb21Qb3MoaGVhZCwgaGVhZCA/IC0xIDogMSk7XG4gICAgICB2YXIgZG9tU2VsID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHZhciBicktsdWRnZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoKGdlY2tvIHx8IHNhZmFyaSkgJiYgYW5jaG9yID09IGhlYWQpIHtcbiAgICAgICAgdmFyIF9hbmNob3JET00gPSBhbmNob3JET00sXG4gICAgICAgICAgICBub2RlID0gX2FuY2hvckRPTS5ub2RlLFxuICAgICAgICAgICAgX29mZnNldCA9IF9hbmNob3JET00ub2Zmc2V0O1xuXG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICBicktsdWRnZSA9ICEhKF9vZmZzZXQgJiYgbm9kZS5ub2RlVmFsdWVbX29mZnNldCAtIDFdID09IFwiXFxuXCIpO1xuXG4gICAgICAgICAgaWYgKGJyS2x1ZGdlICYmIF9vZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzY2FuID0gbm9kZSwgYWZ0ZXI7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKGFmdGVyID0gc2Nhbi5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIGlmIChhZnRlci5ub2RlTmFtZSA9PSBcIkJSXCIpIGFuY2hvckRPTSA9IGhlYWRET00gPSB7XG4gICAgICAgICAgICAgICAgICBub2RlOiBhZnRlci5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBkb21JbmRleChhZnRlcikgKyAxXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBkZXNjID0gc2Nhbi5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2spIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldiA9IG5vZGUuY2hpbGROb2Rlc1tfb2Zmc2V0IC0gMV07XG4gICAgICAgICAgYnJLbHVkZ2UgPSBwcmV2ICYmIChwcmV2Lm5vZGVOYW1lID09IFwiQlJcIiB8fCBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChnZWNrbyAmJiBkb21TZWwuZm9jdXNOb2RlICYmIGRvbVNlbC5mb2N1c05vZGUgIT0gaGVhZERPTS5ub2RlICYmIGRvbVNlbC5mb2N1c05vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICB2YXIgX2FmdGVyMiA9IGRvbVNlbC5mb2N1c05vZGUuY2hpbGROb2Rlc1tkb21TZWwuZm9jdXNPZmZzZXRdO1xuICAgICAgICBpZiAoX2FmdGVyMiAmJiBfYWZ0ZXIyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpIGZvcmNlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoZm9yY2UgfHwgYnJLbHVkZ2UgJiYgc2FmYXJpKSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQsIGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCkpIHJldHVybjtcbiAgICAgIHZhciBkb21TZWxFeHRlbmRlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoKGRvbVNlbC5leHRlbmQgfHwgYW5jaG9yID09IGhlYWQpICYmICFicktsdWRnZSkge1xuICAgICAgICBkb21TZWwuY29sbGFwc2UoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGFuY2hvciAhPSBoZWFkKSBkb21TZWwuZXh0ZW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgIGRvbVNlbEV4dGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSkgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZG9tU2VsRXh0ZW5kZWQpIHtcbiAgICAgICAgaWYgKGFuY2hvciA+IGhlYWQpIHtcbiAgICAgICAgICB2YXIgdG1wID0gYW5jaG9yRE9NO1xuICAgICAgICAgIGFuY2hvckRPTSA9IGhlYWRET007XG4gICAgICAgICAgaGVhZERPTSA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNldEVuZChoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuICAgICAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIGRvbVNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlnbm9yZU11dGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICByZXR1cm4gIXRoaXMuY29udGVudERPTSAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRMb3N0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTSAhPSB0aGlzLmRvbSAmJiAhdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya0RpcnR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMCwgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPT0gZW5kID8gZnJvbSA8PSBlbmQgJiYgdG8gPj0gb2Zmc2V0IDogZnJvbSA8IGVuZCAmJiB0byA+IG9mZnNldCkge1xuICAgICAgICAgIHZhciBzdGFydEluc2lkZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlcixcbiAgICAgICAgICAgICAgZW5kSW5zaWRlID0gZW5kIC0gY2hpbGQuYm9yZGVyO1xuXG4gICAgICAgICAgaWYgKGZyb20gPj0gc3RhcnRJbnNpZGUgJiYgdG8gPD0gZW5kSW5zaWRlKSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZnJvbSA9PSBvZmZzZXQgfHwgdG8gPT0gZW5kID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gc3RhcnRJbnNpZGUgJiYgdG8gPT0gZW5kSW5zaWRlICYmIChjaGlsZC5jb250ZW50TG9zdCB8fCBjaGlsZC5kb20ucGFyZW50Tm9kZSAhPSB0aGlzLmNvbnRlbnRET00pKSBjaGlsZC5kaXJ0eSA9IE5PREVfRElSVFk7ZWxzZSBjaGlsZC5tYXJrRGlydHkoZnJvbSAtIHN0YXJ0SW5zaWRlLCB0byAtIHN0YXJ0SW5zaWRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIWNoaWxkLmNoaWxkcmVuLmxlbmd0aCA/IENPTlRFTlRfRElSVFkgOiBOT0RFX0RJUlRZO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kaXJ0eSA9IENPTlRFTlRfRElSVFk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtQYXJlbnRzRGlydHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFya1BhcmVudHNEaXJ0eSgpIHtcbiAgICAgIHZhciBsZXZlbCA9IDE7XG5cbiAgICAgIGZvciAodmFyIG5vZGUgPSB0aGlzLnBhcmVudDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50LCBsZXZlbCsrKSB7XG4gICAgICAgIHZhciBkaXJ0eSA9IGxldmVsID09IDEgPyBDT05URU5UX0RJUlRZIDogQ0hJTERfRElSVFk7XG4gICAgICAgIGlmIChub2RlLmRpcnR5IDwgZGlydHkpIG5vZGUuZGlydHkgPSBkaXJ0eTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG9tQXRvbVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZ25vcmVGb3JDb29yZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmlld0Rlc2M7XG59KCk7XG5cbnZhciBXaWRnZXRWaWV3RGVzYyA9IGZ1bmN0aW9uIChfVmlld0Rlc2MpIHtcbiAgX2luaGVyaXRzKFdpZGdldFZpZXdEZXNjLCBfVmlld0Rlc2MpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoV2lkZ2V0Vmlld0Rlc2MpO1xuXG4gIGZ1bmN0aW9uIFdpZGdldFZpZXdEZXNjKHBhcmVudCwgd2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2lkZ2V0Vmlld0Rlc2MpO1xuXG4gICAgdmFyIHNlbGYsXG4gICAgICAgIGRvbSA9IHdpZGdldC50eXBlLnRvRE9NO1xuICAgIGlmICh0eXBlb2YgZG9tID09IFwiZnVuY3Rpb25cIikgZG9tID0gZG9tKHZpZXcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2VsZikgcmV0dXJuIHBvcztcbiAgICAgIGlmIChzZWxmLnBhcmVudCkgcmV0dXJuIHNlbGYucGFyZW50LnBvc0JlZm9yZUNoaWxkKHNlbGYpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF3aWRnZXQudHlwZS5zcGVjLnJhdykge1xuICAgICAgaWYgKGRvbS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgIHZhciB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgZG9tID0gd3JhcDtcbiAgICAgIH1cblxuICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3Itd2lkZ2V0XCIpO1xuICAgIH1cblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICBfdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgX3RoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgIHNlbGYgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2lkZ2V0Vmlld0Rlc2MsIFt7XG4gICAga2V5OiBcIm1hdGNoZXNXaWRnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB3aWRnZXQudHlwZS5lcSh0aGlzLndpZGdldC50eXBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VSdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlUnVsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlnbm9yZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BFdmVudChldmVudCkge1xuICAgICAgdmFyIHN0b3AgPSB0aGlzLndpZGdldC5zcGVjLnN0b3BFdmVudDtcbiAgICAgIHJldHVybiBzdG9wID8gc3RvcChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWdub3JlTXV0YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCIgfHwgdGhpcy53aWRnZXQuc3BlYy5pZ25vcmVTZWxlY3Rpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMud2lkZ2V0LnR5cGUuZGVzdHJveSh0aGlzLmRvbSk7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFdpZGdldFZpZXdEZXNjLnByb3RvdHlwZSksIFwiZGVzdHJveVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb21BdG9tXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2lkZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LnR5cGUuc2lkZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2lkZ2V0Vmlld0Rlc2M7XG59KFZpZXdEZXNjKTtcblxudmFyIENvbXBvc2l0aW9uVmlld0Rlc2MgPSBmdW5jdGlvbiAoX1ZpZXdEZXNjMikge1xuICBfaW5oZXJpdHMoQ29tcG9zaXRpb25WaWV3RGVzYywgX1ZpZXdEZXNjMik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoQ29tcG9zaXRpb25WaWV3RGVzYyk7XG5cbiAgZnVuY3Rpb24gQ29tcG9zaXRpb25WaWV3RGVzYyhwYXJlbnQsIGRvbSwgdGV4dERPTSwgdGV4dCkge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9zaXRpb25WaWV3RGVzYyk7XG5cbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwodGhpcywgcGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICBfdGhpczIudGV4dERPTSA9IHRleHRET007XG4gICAgX3RoaXMyLnRleHQgPSB0ZXh0O1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29tcG9zaXRpb25WaWV3RGVzYywgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvY2FsUG9zRnJvbURPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQpIHtcbiAgICAgIGlmIChkb20gIT0gdGhpcy50ZXh0RE9NKSByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgKG9mZnNldCA/IHRoaXMuc2l6ZSA6IDApO1xuICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIG9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG9tRnJvbVBvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogdGhpcy50ZXh0RE9NLFxuICAgICAgICBvZmZzZXQ6IHBvc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWdub3JlTXV0YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaWdub3JlTXV0YXRpb24obXV0KSB7XG4gICAgICByZXR1cm4gbXV0LnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbXBvc2l0aW9uVmlld0Rlc2M7XG59KFZpZXdEZXNjKTtcblxudmFyIE1hcmtWaWV3RGVzYyA9IGZ1bmN0aW9uIChfVmlld0Rlc2MzKSB7XG4gIF9pbmhlcml0cyhNYXJrVmlld0Rlc2MsIF9WaWV3RGVzYzMpO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKE1hcmtWaWV3RGVzYyk7XG5cbiAgZnVuY3Rpb24gTWFya1ZpZXdEZXNjKHBhcmVudCwgbWFyaywgZG9tLCBjb250ZW50RE9NKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXJrVmlld0Rlc2MpO1xuXG4gICAgX3RoaXMzID0gX3N1cGVyMy5jYWxsKHRoaXMsIHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgX3RoaXMzLm1hcmsgPSBtYXJrO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFya1ZpZXdEZXNjLCBbe1xuICAgIGtleTogXCJwYXJzZVJ1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VSdWxlKCkge1xuICAgICAgaWYgKHRoaXMuZGlydHkgJiBOT0RFX0RJUlRZIHx8IHRoaXMubWFyay50eXBlLnNwZWMucmVwYXJzZUluVmlldykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXJrOiB0aGlzLm1hcmsudHlwZS5uYW1lLFxuICAgICAgICBhdHRyczogdGhpcy5tYXJrLmF0dHJzLFxuICAgICAgICBjb250ZW50RWxlbWVudDogdGhpcy5jb250ZW50RE9NIHx8IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlc01hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlc01hcmsobWFyaykge1xuICAgICAgcmV0dXJuIHRoaXMuZGlydHkgIT0gTk9ERV9ESVJUWSAmJiB0aGlzLm1hcmsuZXEobWFyayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtEaXJ0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hcmtWaWV3RGVzYy5wcm90b3R5cGUpLCBcIm1hcmtEaXJ0eVwiLCB0aGlzKS5jYWxsKHRoaXMsIGZyb20sIHRvKTtcblxuICAgICAgaWYgKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuICAgICAgICB3aGlsZSAoIXBhcmVudC5ub2RlKSB7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnQuZGlydHkgPCB0aGlzLmRpcnR5KSBwYXJlbnQuZGlydHkgPSB0aGlzLmRpcnR5O1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZShmcm9tLCB0bywgdmlldykge1xuICAgICAgdmFyIGNvcHkgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMucGFyZW50LCB0aGlzLm1hcmssIHRydWUsIHZpZXcpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5jaGlsZHJlbixcbiAgICAgICAgICBzaXplID0gdGhpcy5zaXplO1xuICAgICAgaWYgKHRvIDwgc2l6ZSkgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIHRvLCBzaXplLCB2aWV3KTtcbiAgICAgIGlmIChmcm9tID4gMCkgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIDAsIGZyb20sIHZpZXcpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGVzW2ldLnBhcmVudCA9IGNvcHk7XG4gICAgICB9XG5cbiAgICAgIGNvcHkuY2hpbGRyZW4gPSBub2RlcztcbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUocGFyZW50LCBtYXJrLCBpbmxpbmUsIHZpZXcpIHtcbiAgICAgIHZhciBjdXN0b20gPSB2aWV3Lm5vZGVWaWV3c1ttYXJrLnR5cGUubmFtZV07XG4gICAgICB2YXIgc3BlYyA9IGN1c3RvbSAmJiBjdXN0b20obWFyaywgdmlldywgaW5saW5lKTtcbiAgICAgIGlmICghc3BlYyB8fCAhc3BlYy5kb20pIHNwZWMgPSBwcm9zZW1pcnJvck1vZGVsLkRPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2N1bWVudCwgbWFyay50eXBlLnNwZWMudG9ET00obWFyaywgaW5saW5lKSk7XG4gICAgICByZXR1cm4gbmV3IE1hcmtWaWV3RGVzYyhwYXJlbnQsIG1hcmssIHNwZWMuZG9tLCBzcGVjLmNvbnRlbnRET00gfHwgc3BlYy5kb20pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXJrVmlld0Rlc2M7XG59KFZpZXdEZXNjKTtcblxudmFyIE5vZGVWaWV3RGVzYyA9IGZ1bmN0aW9uIChfVmlld0Rlc2M0KSB7XG4gIF9pbmhlcml0cyhOb2RlVmlld0Rlc2MsIF9WaWV3RGVzYzQpO1xuXG4gIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKE5vZGVWaWV3RGVzYyk7XG5cbiAgZnVuY3Rpb24gTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKSB7XG4gICAgdmFyIF90aGlzNDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlVmlld0Rlc2MpO1xuXG4gICAgX3RoaXM0ID0gX3N1cGVyNC5jYWxsKHRoaXMsIHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgX3RoaXM0Lm5vZGUgPSBub2RlO1xuICAgIF90aGlzNC5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgX3RoaXM0LmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICBfdGhpczQubm9kZURPTSA9IG5vZGVET007XG4gICAgaWYgKGNvbnRlbnRET00pIF90aGlzNC51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MpO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm9kZVZpZXdEZXNjLCBbe1xuICAgIGtleTogXCJwYXJzZVJ1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VSdWxlKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLm5vZGUudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHJ1bGUgPSB7XG4gICAgICAgIG5vZGU6IHRoaXMubm9kZS50eXBlLm5hbWUsXG4gICAgICAgIGF0dHJzOiB0aGlzLm5vZGUuYXR0cnNcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5ub2RlLnR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiKSBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSA9IFwiZnVsbFwiO1xuXG4gICAgICBpZiAoIXRoaXMuY29udGVudERPTSkge1xuICAgICAgICBydWxlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNS5ub2RlLmNvbnRlbnQ7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmNvbnRlbnRMb3N0KSB7XG4gICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSB0aGlzLmNvbnRlbnRET007XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgICAgICBpZiAodGhpcy5kb20uY29udGFpbnMoY2hpbGQuZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBydWxlLmNvbnRlbnRFbGVtZW50ID0gY2hpbGQuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJ1bGUuY29udGVudEVsZW1lbnQpIHJ1bGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoZXNOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgbm9kZS5lcSh0aGlzLm5vZGUpICYmIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm91dGVyRGVjbykgJiYgaW5uZXJEZWNvLmVxKHRoaXMuaW5uZXJEZWNvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYm9yZGVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLmlzTGVhZiA/IDAgOiAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVDaGlsZHJlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgaW5saW5lID0gdGhpcy5ub2RlLmlubGluZUNvbnRlbnQsXG4gICAgICAgICAgb2ZmID0gcG9zO1xuICAgICAgdmFyIGNvbXBvc2l0aW9uID0gdmlldy5jb21wb3NpbmcgPyB0aGlzLmxvY2FsQ29tcG9zaXRpb25JbmZvKHZpZXcsIHBvcykgOiBudWxsO1xuICAgICAgdmFyIGxvY2FsQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPiAtMSA/IGNvbXBvc2l0aW9uIDogbnVsbDtcbiAgICAgIHZhciBjb21wb3NpdGlvbkluQ2hpbGQgPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPCAwO1xuICAgICAgdmFyIHVwZGF0ZXIgPSBuZXcgVmlld1RyZWVVcGRhdGVyKHRoaXMsIGxvY2FsQ29tcG9zaXRpb24gJiYgbG9jYWxDb21wb3NpdGlvbi5ub2RlKTtcbiAgICAgIGl0ZXJEZWNvKHRoaXMubm9kZSwgdGhpcy5pbm5lckRlY28sIGZ1bmN0aW9uICh3aWRnZXQsIGksIGluc2lkZU5vZGUpIHtcbiAgICAgICAgaWYgKHdpZGdldC5zcGVjLm1hcmtzKSB1cGRhdGVyLnN5bmNUb01hcmtzKHdpZGdldC5zcGVjLm1hcmtzLCBpbmxpbmUsIHZpZXcpO2Vsc2UgaWYgKHdpZGdldC50eXBlLnNpZGUgPj0gMCAmJiAhaW5zaWRlTm9kZSkgdXBkYXRlci5zeW5jVG9NYXJrcyhpID09IF90aGlzNi5ub2RlLmNoaWxkQ291bnQgPyBwcm9zZW1pcnJvck1vZGVsLk1hcmsubm9uZSA6IF90aGlzNi5ub2RlLmNoaWxkKGkpLm1hcmtzLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICB1cGRhdGVyLnBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgb2ZmKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpIHtcbiAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhjaGlsZC5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgdmFyIGNvbXBJbmRleDtcbiAgICAgICAgaWYgKHVwZGF0ZXIuZmluZE5vZGVNYXRjaChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpKSA7ZWxzZSBpZiAoY29tcG9zaXRpb25JbkNoaWxkICYmIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPiBvZmYgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gPCBvZmYgKyBjaGlsZC5ub2RlU2l6ZSAmJiAoY29tcEluZGV4ID0gdXBkYXRlci5maW5kSW5kZXhXaXRoQ2hpbGQoY29tcG9zaXRpb24ubm9kZSkpID4gLTEgJiYgdXBkYXRlci51cGRhdGVOb2RlQXQoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBjb21wSW5kZXgsIHZpZXcpKSA7ZWxzZSBpZiAodXBkYXRlci51cGRhdGVOZXh0Tm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGkpKSA7ZWxzZSB7XG4gICAgICAgICAgdXBkYXRlci5hZGROb2RlKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgb2ZmKTtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoW10sIGlubGluZSwgdmlldyk7XG4gICAgICBpZiAodGhpcy5ub2RlLmlzVGV4dGJsb2NrKSB1cGRhdGVyLmFkZFRleHRibG9ja0hhY2tzKCk7XG4gICAgICB1cGRhdGVyLmRlc3Ryb3lSZXN0KCk7XG5cbiAgICAgIGlmICh1cGRhdGVyLmNoYW5nZWQgfHwgdGhpcy5kaXJ0eSA9PSBDT05URU5UX0RJUlRZKSB7XG4gICAgICAgIGlmIChsb2NhbENvbXBvc2l0aW9uKSB0aGlzLnByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIGxvY2FsQ29tcG9zaXRpb24pO1xuICAgICAgICByZW5kZXJEZXNjcyh0aGlzLmNvbnRlbnRET00sIHRoaXMuY2hpbGRyZW4sIHZpZXcpO1xuICAgICAgICBpZiAoaW9zKSBpb3NIYWNrcyh0aGlzLmRvbSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvY2FsQ29tcG9zaXRpb25JbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2FsQ29tcG9zaXRpb25JbmZvKHZpZXcsIHBvcykge1xuICAgICAgdmFyIF92aWV3JHN0YXRlJHNlbGVjdGlvbiA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICAgIGZyb20gPSBfdmlldyRzdGF0ZSRzZWxlY3Rpb24uZnJvbSxcbiAgICAgICAgICB0byA9IF92aWV3JHN0YXRlJHNlbGVjdGlvbi50bztcbiAgICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uKSB8fCBmcm9tIDwgcG9zIHx8IHRvID4gcG9zICsgdGhpcy5ub2RlLmNvbnRlbnQuc2l6ZSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICAgIHZhciB0ZXh0Tm9kZSA9IG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICBpZiAoIXRleHROb2RlIHx8ICF0aGlzLmRvbS5jb250YWlucyh0ZXh0Tm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGlmICh0aGlzLm5vZGUuaW5saW5lQ29udGVudCkge1xuICAgICAgICB2YXIgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgdmFyIHRleHRQb3MgPSBmaW5kVGV4dEluRnJhZ21lbnQodGhpcy5ub2RlLmNvbnRlbnQsIHRleHQsIGZyb20gLSBwb3MsIHRvIC0gcG9zKTtcbiAgICAgICAgcmV0dXJuIHRleHRQb3MgPCAwID8gbnVsbCA6IHtcbiAgICAgICAgICBub2RlOiB0ZXh0Tm9kZSxcbiAgICAgICAgICBwb3M6IHRleHRQb3MsXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiB0ZXh0Tm9kZSxcbiAgICAgICAgICBwb3M6IC0xLFxuICAgICAgICAgIHRleHQ6IFwiXCJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvdGVjdExvY2FsQ29tcG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvdGVjdExvY2FsQ29tcG9zaXRpb24odmlldywgX3JlZjIpIHtcbiAgICAgIHZhciBub2RlID0gX3JlZjIubm9kZSxcbiAgICAgICAgICBwb3MgPSBfcmVmMi5wb3MsXG4gICAgICAgICAgdGV4dCA9IF9yZWYyLnRleHQ7XG4gICAgICBpZiAodGhpcy5nZXREZXNjKG5vZGUpKSByZXR1cm47XG4gICAgICB2YXIgdG9wTm9kZSA9IG5vZGU7XG5cbiAgICAgIGZvciAoOzsgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAodG9wTm9kZS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSkgYnJlYWs7XG5cbiAgICAgICAgd2hpbGUgKHRvcE5vZGUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgICAgdG9wTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvcE5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICh0b3BOb2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgdG9wTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvcE5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvcE5vZGUucG1WaWV3RGVzYykgdG9wTm9kZS5wbVZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVzYyA9IG5ldyBDb21wb3NpdGlvblZpZXdEZXNjKHRoaXMsIHRvcE5vZGUsIG5vZGUsIHRleHQpO1xuICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLnB1c2goZGVzYyk7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gcmVwbGFjZU5vZGVzKHRoaXMuY2hpbGRyZW4sIHBvcywgcG9zICsgdGV4dC5sZW5ndGgsIHZpZXcsIGRlc2MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8ICFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy51cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlSW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgIHRoaXMudXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbyk7XG4gICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgdGhpcy5pbm5lckRlY28gPSBpbm5lckRlY287XG4gICAgICBpZiAodGhpcy5jb250ZW50RE9NKSB0aGlzLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHRoaXMucG9zQXRTdGFydCk7XG4gICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVPdXRlckRlY29cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbykge1xuICAgICAgaWYgKHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm91dGVyRGVjbykpIHJldHVybjtcbiAgICAgIHZhciBuZWVkc1dyYXAgPSB0aGlzLm5vZGVET00ubm9kZVR5cGUgIT0gMTtcbiAgICAgIHZhciBvbGRET00gPSB0aGlzLmRvbTtcbiAgICAgIHRoaXMuZG9tID0gcGF0Y2hPdXRlckRlY28odGhpcy5kb20sIHRoaXMubm9kZURPTSwgY29tcHV0ZU91dGVyRGVjbyh0aGlzLm91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApLCBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApKTtcblxuICAgICAgaWYgKHRoaXMuZG9tICE9IG9sZERPTSkge1xuICAgICAgICBvbGRET00ucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3ROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE5vZGUoKSB7XG4gICAgICBpZiAodGhpcy5ub2RlRE9NLm5vZGVUeXBlID09IDEpIHRoaXMubm9kZURPTS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICAgICAgaWYgKHRoaXMuY29udGVudERPTSB8fCAhdGhpcy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpIHRoaXMuZG9tLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc2VsZWN0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICBpZiAodGhpcy5ub2RlRE9NLm5vZGVUeXBlID09IDEpIHRoaXMubm9kZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICAgICAgaWYgKHRoaXMuY29udGVudERPTSB8fCAhdGhpcy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpIHRoaXMuZG9tLnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG9tQXRvbVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5pc0F0b207XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgIHZhciBjdXN0b20gPSB2aWV3Lm5vZGVWaWV3c1tub2RlLnR5cGUubmFtZV0sXG4gICAgICAgICAgZGVzY09iajtcbiAgICAgIHZhciBzcGVjID0gY3VzdG9tICYmIGN1c3RvbShub2RlLCB2aWV3LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZGVzY09iaikgcmV0dXJuIHBvcztcbiAgICAgICAgaWYgKGRlc2NPYmoucGFyZW50KSByZXR1cm4gZGVzY09iai5wYXJlbnQucG9zQmVmb3JlQ2hpbGQoZGVzY09iaik7XG4gICAgICB9LCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICB2YXIgZG9tID0gc3BlYyAmJiBzcGVjLmRvbSxcbiAgICAgICAgICBjb250ZW50RE9NID0gc3BlYyAmJiBzcGVjLmNvbnRlbnRET007XG5cbiAgICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgICBpZiAoIWRvbSkgZG9tID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS50ZXh0KTtlbHNlIGlmIChkb20ubm9kZVR5cGUgIT0gMykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZXh0IG11c3QgYmUgcmVuZGVyZWQgYXMgYSBET00gdGV4dCBub2RlXCIpO1xuICAgICAgfSBlbHNlIGlmICghZG9tKSB7XG4gICAgICAgIHZhciBfcHJvc2VtaXJyb3JNb2RlbCRET00gPSBwcm9zZW1pcnJvck1vZGVsLkRPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2N1bWVudCwgbm9kZS50eXBlLnNwZWMudG9ET00obm9kZSkpO1xuXG4gICAgICAgIGRvbSA9IF9wcm9zZW1pcnJvck1vZGVsJERPTS5kb207XG4gICAgICAgIGNvbnRlbnRET00gPSBfcHJvc2VtaXJyb3JNb2RlbCRET00uY29udGVudERPTTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb250ZW50RE9NICYmICFub2RlLmlzVGV4dCAmJiBkb20ubm9kZU5hbWUgIT0gXCJCUlwiKSB7XG4gICAgICAgIGlmICghZG9tLmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSkgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSkgZG9tLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlRE9NID0gZG9tO1xuICAgICAgZG9tID0gYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIG5vZGUpO1xuICAgICAgaWYgKHNwZWMpIHJldHVybiBkZXNjT2JqID0gbmV3IEN1c3RvbU5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00gfHwgbnVsbCwgbm9kZURPTSwgc3BlYywgdmlldywgcG9zICsgMSk7ZWxzZSBpZiAobm9kZS5pc1RleHQpIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldyk7ZWxzZSByZXR1cm4gbmV3IE5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00gfHwgbnVsbCwgbm9kZURPTSwgdmlldywgcG9zICsgMSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVWaWV3RGVzYztcbn0oVmlld0Rlc2MpO1xuXG5mdW5jdGlvbiBkb2NWaWV3RGVzYyhkb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIHZpZXcpIHtcbiAgYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIGRvYyk7XG4gIHJldHVybiBuZXcgTm9kZVZpZXdEZXNjKHVuZGVmaW5lZCwgZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBkb20sIGRvbSwgdmlldywgMCk7XG59XG5cbnZhciBUZXh0Vmlld0Rlc2MgPSBmdW5jdGlvbiAoX05vZGVWaWV3RGVzYykge1xuICBfaW5oZXJpdHMoVGV4dFZpZXdEZXNjLCBfTm9kZVZpZXdEZXNjKTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihUZXh0Vmlld0Rlc2MpO1xuXG4gIGZ1bmN0aW9uIFRleHRWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFZpZXdEZXNjKTtcblxuICAgIHJldHVybiBfc3VwZXI1LmNhbGwodGhpcywgcGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBudWxsLCBub2RlRE9NLCB2aWV3LCAwKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUZXh0Vmlld0Rlc2MsIFt7XG4gICAga2V5OiBcInBhcnNlUnVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVJ1bGUoKSB7XG4gICAgICB2YXIgc2tpcCA9IHRoaXMubm9kZURPTS5wYXJlbnROb2RlO1xuXG4gICAgICB3aGlsZSAoc2tpcCAmJiBza2lwICE9IHRoaXMuZG9tICYmICFza2lwLnBtSXNEZWNvKSB7XG4gICAgICAgIHNraXAgPSBza2lwLnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNraXA6IHNraXAgfHwgdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSB8fCB0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSAmJiAhdGhpcy5pblBhcmVudCgpIHx8ICFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy51cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKTtcblxuICAgICAgaWYgKCh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSB8fCBub2RlLnRleHQgIT0gdGhpcy5ub2RlLnRleHQpICYmIG5vZGUudGV4dCAhPSB0aGlzLm5vZGVET00ubm9kZVZhbHVlKSB7XG4gICAgICAgIHRoaXMubm9kZURPTS5ub2RlVmFsdWUgPSBub2RlLnRleHQ7XG4gICAgICAgIGlmICh2aWV3LnRyYWNrV3JpdGVzID09IHRoaXMubm9kZURPTSkgdmlldy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluUGFyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluUGFyZW50KCkge1xuICAgICAgdmFyIHBhcmVudERPTSA9IHRoaXMucGFyZW50LmNvbnRlbnRET007XG5cbiAgICAgIGZvciAodmFyIG4gPSB0aGlzLm5vZGVET007IG47IG4gPSBuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKG4gPT0gcGFyZW50RE9NKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb21Gcm9tUG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvbUZyb21Qb3MocG9zKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiB0aGlzLm5vZGVET00sXG4gICAgICAgIG9mZnNldDogcG9zXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2NhbFBvc0Zyb21ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICBpZiAoZG9tID09IHRoaXMubm9kZURPTSkgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIE1hdGgubWluKG9mZnNldCwgdGhpcy5ub2RlLnRleHQubGVuZ3RoKTtcbiAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihUZXh0Vmlld0Rlc2MucHJvdG90eXBlKSwgXCJsb2NhbFBvc0Zyb21ET01cIiwgdGhpcykuY2FsbCh0aGlzLCBkb20sIG9mZnNldCwgYmlhcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlnbm9yZU11dGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICByZXR1cm4gbXV0YXRpb24udHlwZSAhPSBcImNoYXJhY3RlckRhdGFcIiAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZS5jdXQoZnJvbSwgdG8pLFxuICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICByZXR1cm4gbmV3IFRleHRWaWV3RGVzYyh0aGlzLnBhcmVudCwgbm9kZSwgdGhpcy5vdXRlckRlY28sIHRoaXMuaW5uZXJEZWNvLCBkb20sIGRvbSwgdmlldyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtEaXJ0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFRleHRWaWV3RGVzYy5wcm90b3R5cGUpLCBcIm1hcmtEaXJ0eVwiLCB0aGlzKS5jYWxsKHRoaXMsIGZyb20sIHRvKTtcblxuICAgICAgaWYgKHRoaXMuZG9tICE9IHRoaXMubm9kZURPTSAmJiAoZnJvbSA9PSAwIHx8IHRvID09IHRoaXMubm9kZURPTS5ub2RlVmFsdWUubGVuZ3RoKSkgdGhpcy5kaXJ0eSA9IE5PREVfRElSVFk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvbUF0b21cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dFZpZXdEZXNjO1xufShOb2RlVmlld0Rlc2MpO1xuXG52YXIgVHJhaWxpbmdIYWNrVmlld0Rlc2MgPSBmdW5jdGlvbiAoX1ZpZXdEZXNjNSkge1xuICBfaW5oZXJpdHMoVHJhaWxpbmdIYWNrVmlld0Rlc2MsIF9WaWV3RGVzYzUpO1xuXG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKFRyYWlsaW5nSGFja1ZpZXdEZXNjKTtcblxuICBmdW5jdGlvbiBUcmFpbGluZ0hhY2tWaWV3RGVzYygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhaWxpbmdIYWNrVmlld0Rlc2MpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUcmFpbGluZ0hhY2tWaWV3RGVzYywgW3tcbiAgICBrZXk6IFwicGFyc2VSdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlUnVsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlnbm9yZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlc0hhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlc0hhY2sobm9kZU5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBub2RlTmFtZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG9tQXRvbVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlnbm9yZUZvckNvb3Jkc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZG9tLm5vZGVOYW1lID09IFwiSU1HXCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYWlsaW5nSGFja1ZpZXdEZXNjO1xufShWaWV3RGVzYyk7XG5cbnZhciBDdXN0b21Ob2RlVmlld0Rlc2MgPSBmdW5jdGlvbiAoX05vZGVWaWV3RGVzYzIpIHtcbiAgX2luaGVyaXRzKEN1c3RvbU5vZGVWaWV3RGVzYywgX05vZGVWaWV3RGVzYzIpO1xuXG4gIHZhciBfc3VwZXI3ID0gX2NyZWF0ZVN1cGVyKEN1c3RvbU5vZGVWaWV3RGVzYyk7XG5cbiAgZnVuY3Rpb24gQ3VzdG9tTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgc3BlYywgdmlldywgcG9zKSB7XG4gICAgdmFyIF90aGlzNztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXN0b21Ob2RlVmlld0Rlc2MpO1xuXG4gICAgX3RoaXM3ID0gX3N1cGVyNy5jYWxsKHRoaXMsIHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKTtcbiAgICBfdGhpczcuc3BlYyA9IHNwZWM7XG4gICAgcmV0dXJuIF90aGlzNztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDdXN0b21Ob2RlVmlld0Rlc2MsIFt7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkpIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuc3BlYy51cGRhdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc3BlYy51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICBpZiAocmVzdWx0KSB0aGlzLnVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuY29udGVudERPTSAmJiAhbm9kZS5pc0xlYWYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKEN1c3RvbU5vZGVWaWV3RGVzYy5wcm90b3R5cGUpLCBcInVwZGF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3ROb2RlKCkge1xuICAgICAgdGhpcy5zcGVjLnNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuc2VsZWN0Tm9kZSgpIDogX2dldChfZ2V0UHJvdG90eXBlT2YoQ3VzdG9tTm9kZVZpZXdEZXNjLnByb3RvdHlwZSksIFwic2VsZWN0Tm9kZVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXNlbGVjdE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzZWxlY3ROb2RlKCkge1xuICAgICAgdGhpcy5zcGVjLmRlc2VsZWN0Tm9kZSA/IHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUoKSA6IF9nZXQoX2dldFByb3RvdHlwZU9mKEN1c3RvbU5vZGVWaWV3RGVzYy5wcm90b3R5cGUpLCBcImRlc2VsZWN0Tm9kZVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UpIHtcbiAgICAgIHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24gPyB0aGlzLnNwZWMuc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdCkgOiBfZ2V0KF9nZXRQcm90b3R5cGVPZihDdXN0b21Ob2RlVmlld0Rlc2MucHJvdG90eXBlKSwgXCJzZXRTZWxlY3Rpb25cIiwgdGhpcykuY2FsbCh0aGlzLCBhbmNob3IsIGhlYWQsIHJvb3QsIGZvcmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KSB0aGlzLnNwZWMuZGVzdHJveSgpO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihDdXN0b21Ob2RlVmlld0Rlc2MucHJvdG90eXBlKSwgXCJkZXN0cm95XCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0b3BFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwZWMuc3RvcEV2ZW50ID8gdGhpcy5zcGVjLnN0b3BFdmVudChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWdub3JlTXV0YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnNwZWMuaWdub3JlTXV0YXRpb24gPyB0aGlzLnNwZWMuaWdub3JlTXV0YXRpb24obXV0YXRpb24pIDogX2dldChfZ2V0UHJvdG90eXBlT2YoQ3VzdG9tTm9kZVZpZXdEZXNjLnByb3RvdHlwZSksIFwiaWdub3JlTXV0YXRpb25cIiwgdGhpcykuY2FsbCh0aGlzLCBtdXRhdGlvbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1c3RvbU5vZGVWaWV3RGVzYztcbn0oTm9kZVZpZXdEZXNjKTtcblxuZnVuY3Rpb24gcmVuZGVyRGVzY3MocGFyZW50RE9NLCBkZXNjcywgdmlldykge1xuICB2YXIgZG9tID0gcGFyZW50RE9NLmZpcnN0Q2hpbGQsXG4gICAgICB3cml0dGVuID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXNjcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjID0gZGVzY3NbaV0sXG4gICAgICAgIGNoaWxkRE9NID0gZGVzYy5kb207XG5cbiAgICBpZiAoY2hpbGRET00ucGFyZW50Tm9kZSA9PSBwYXJlbnRET00pIHtcbiAgICAgIHdoaWxlIChjaGlsZERPTSAhPSBkb20pIHtcbiAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgICBwYXJlbnRET00uaW5zZXJ0QmVmb3JlKGNoaWxkRE9NLCBkb20pO1xuICAgIH1cblxuICAgIGlmIChkZXNjIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICB2YXIgcG9zID0gZG9tID8gZG9tLnByZXZpb3VzU2libGluZyA6IHBhcmVudERPTS5sYXN0Q2hpbGQ7XG4gICAgICByZW5kZXJEZXNjcyhkZXNjLmNvbnRlbnRET00sIGRlc2MuY2hpbGRyZW4sIHZpZXcpO1xuICAgICAgZG9tID0gcG9zID8gcG9zLm5leHRTaWJsaW5nIDogcGFyZW50RE9NLmZpcnN0Q2hpbGQ7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGRvbSkge1xuICAgIGRvbSA9IHJtKGRvbSk7XG4gICAgd3JpdHRlbiA9IHRydWU7XG4gIH1cblxuICBpZiAod3JpdHRlbiAmJiB2aWV3LnRyYWNrV3JpdGVzID09IHBhcmVudERPTSkgdmlldy50cmFja1dyaXRlcyA9IG51bGw7XG59XG5cbnZhciBPdXRlckRlY29MZXZlbCA9IGZ1bmN0aW9uIE91dGVyRGVjb0xldmVsKG5vZGVOYW1lKSB7XG4gIGlmIChub2RlTmFtZSkgdGhpcy5ub2RlTmFtZSA9IG5vZGVOYW1lO1xufTtcblxuT3V0ZXJEZWNvTGV2ZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBub0RlY28gPSBbbmV3IE91dGVyRGVjb0xldmVsKCldO1xuXG5mdW5jdGlvbiBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgbm9kZSwgbmVlZHNXcmFwKSB7XG4gIGlmIChvdXRlckRlY28ubGVuZ3RoID09IDApIHJldHVybiBub0RlY287XG4gIHZhciB0b3AgPSBuZWVkc1dyYXAgPyBub0RlY29bMF0gOiBuZXcgT3V0ZXJEZWNvTGV2ZWwoKSxcbiAgICAgIHJlc3VsdCA9IFt0b3BdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0ZXJEZWNvLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHJzID0gb3V0ZXJEZWNvW2ldLnR5cGUuYXR0cnM7XG4gICAgaWYgKCFhdHRycykgY29udGludWU7XG4gICAgaWYgKGF0dHJzLm5vZGVOYW1lKSByZXN1bHQucHVzaCh0b3AgPSBuZXcgT3V0ZXJEZWNvTGV2ZWwoYXR0cnMubm9kZU5hbWUpKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgIHZhciB2YWwgPSBhdHRyc1tuYW1lXTtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkgY29udGludWU7XG4gICAgICBpZiAobmVlZHNXcmFwICYmIHJlc3VsdC5sZW5ndGggPT0gMSkgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKG5vZGUuaXNJbmxpbmUgPyBcInNwYW5cIiA6IFwiZGl2XCIpKTtcbiAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIikgdG9wW1wiY2xhc3NcIl0gPSAodG9wW1wiY2xhc3NcIl0gPyB0b3BbXCJjbGFzc1wiXSArIFwiIFwiIDogXCJcIikgKyB2YWw7ZWxzZSBpZiAobmFtZSA9PSBcInN0eWxlXCIpIHRvcC5zdHlsZSA9ICh0b3Auc3R5bGUgPyB0b3Auc3R5bGUgKyBcIjtcIiA6IFwiXCIpICsgdmFsO2Vsc2UgaWYgKG5hbWUgIT0gXCJub2RlTmFtZVwiKSB0b3BbbmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGF0Y2hPdXRlckRlY28ob3V0ZXJET00sIG5vZGVET00sIHByZXZDb21wdXRlZCwgY3VyQ29tcHV0ZWQpIHtcbiAgaWYgKHByZXZDb21wdXRlZCA9PSBub0RlY28gJiYgY3VyQ29tcHV0ZWQgPT0gbm9EZWNvKSByZXR1cm4gbm9kZURPTTtcbiAgdmFyIGN1ckRPTSA9IG5vZGVET007XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJDb21wdXRlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZWNvID0gY3VyQ29tcHV0ZWRbaV0sXG4gICAgICAgIHByZXYgPSBwcmV2Q29tcHV0ZWRbaV07XG5cbiAgICBpZiAoaSkge1xuICAgICAgdmFyIHBhcmVudCA9IHZvaWQgMDtcblxuICAgICAgaWYgKHByZXYgJiYgcHJldi5ub2RlTmFtZSA9PSBkZWNvLm5vZGVOYW1lICYmIGN1ckRPTSAhPSBvdXRlckRPTSAmJiAocGFyZW50ID0gY3VyRE9NLnBhcmVudE5vZGUpICYmIHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IGRlY28ubm9kZU5hbWUpIHtcbiAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkZWNvLm5vZGVOYW1lKTtcbiAgICAgICAgcGFyZW50LnBtSXNEZWNvID0gdHJ1ZTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGN1ckRPTSk7XG4gICAgICAgIHByZXYgPSBub0RlY29bMF07XG4gICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRjaEF0dHJpYnV0ZXMoY3VyRE9NLCBwcmV2IHx8IG5vRGVjb1swXSwgZGVjbyk7XG4gIH1cblxuICByZXR1cm4gY3VyRE9NO1xufVxuXG5mdW5jdGlvbiBwYXRjaEF0dHJpYnV0ZXMoZG9tLCBwcmV2LCBjdXIpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiBwcmV2KSB7XG4gICAgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmICEobmFtZSBpbiBjdXIpKSBkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG5cbiAgZm9yICh2YXIgX25hbWUgaW4gY3VyKSB7XG4gICAgaWYgKF9uYW1lICE9IFwiY2xhc3NcIiAmJiBfbmFtZSAhPSBcInN0eWxlXCIgJiYgX25hbWUgIT0gXCJub2RlTmFtZVwiICYmIGN1cltfbmFtZV0gIT0gcHJldltfbmFtZV0pIGRvbS5zZXRBdHRyaWJ1dGUoX25hbWUsIGN1cltfbmFtZV0pO1xuICB9XG5cbiAgaWYgKHByZXZbXCJjbGFzc1wiXSAhPSBjdXJbXCJjbGFzc1wiXSkge1xuICAgIHZhciBwcmV2TGlzdCA9IHByZXZbXCJjbGFzc1wiXSA/IHByZXZbXCJjbGFzc1wiXS5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgdmFyIGN1ckxpc3QgPSBjdXJbXCJjbGFzc1wiXSA/IGN1cltcImNsYXNzXCJdLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjdXJMaXN0LmluZGV4T2YocHJldkxpc3RbaV0pID09IC0xKSBkb20uY2xhc3NMaXN0LnJlbW92ZShwcmV2TGlzdFtpXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGN1ckxpc3QubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBpZiAocHJldkxpc3QuaW5kZXhPZihjdXJMaXN0W19pXSkgPT0gLTEpIGRvbS5jbGFzc0xpc3QuYWRkKGN1ckxpc3RbX2ldKTtcbiAgICB9XG5cbiAgICBpZiAoZG9tLmNsYXNzTGlzdC5sZW5ndGggPT0gMCkgZG9tLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICB9XG5cbiAgaWYgKHByZXYuc3R5bGUgIT0gY3VyLnN0eWxlKSB7XG4gICAgaWYgKHByZXYuc3R5bGUpIHtcbiAgICAgIHZhciBwcm9wID0gL1xccyooW1xcd1xcLVxceGExLVxcdWZmZmZdKylcXHMqOig/OlwiKD86XFxcXC58W15cIl0pKlwifCcoPzpcXFxcLnxbXiddKSonfFxcKC4qP1xcKXxbXjtdKSovZyxcbiAgICAgICAgICBtO1xuXG4gICAgICB3aGlsZSAobSA9IHByb3AuZXhlYyhwcmV2LnN0eWxlKSkge1xuICAgICAgICBkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkobVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1ci5zdHlsZSkgZG9tLnN0eWxlLmNzc1RleHQgKz0gY3VyLnN0eWxlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5T3V0ZXJEZWNvKGRvbSwgZGVjbywgbm9kZSkge1xuICByZXR1cm4gcGF0Y2hPdXRlckRlY28oZG9tLCBkb20sIG5vRGVjbywgY29tcHV0ZU91dGVyRGVjbyhkZWNvLCBub2RlLCBkb20ubm9kZVR5cGUgIT0gMSkpO1xufVxuXG5mdW5jdGlvbiBzYW1lT3V0ZXJEZWNvKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFhW2ldLnR5cGUuZXEoYltpXS50eXBlKSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJtKGRvbSkge1xuICB2YXIgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbnZhciBWaWV3VHJlZVVwZGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZpZXdUcmVlVXBkYXRlcih0b3AsIGxvY2spIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlld1RyZWVVcGRhdGVyKTtcblxuICAgIHRoaXMubG9jayA9IGxvY2s7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMucHJlTWF0Y2ggPSBwcmVNYXRjaCh0b3Aubm9kZS5jb250ZW50LCB0b3ApO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFZpZXdUcmVlVXBkYXRlciwgW3tcbiAgICBrZXk6IFwiZGVzdHJveUJldHdlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveUJldHdlZW4oc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKHN0YXJ0ID09IGVuZCkgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVJlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveVJlc3QoKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN5bmNUb01hcmtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN5bmNUb01hcmtzKG1hcmtzLCBpbmxpbmUsIHZpZXcpIHtcbiAgICAgIHZhciBrZWVwID0gMCxcbiAgICAgICAgICBkZXB0aCA9IHRoaXMuc3RhY2subGVuZ3RoID4+IDE7XG4gICAgICB2YXIgbWF4S2VlcCA9IE1hdGgubWluKGRlcHRoLCBtYXJrcy5sZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoa2VlcCA8IG1heEtlZXAgJiYgKGtlZXAgPT0gZGVwdGggLSAxID8gdGhpcy50b3AgOiB0aGlzLnN0YWNrW2tlZXAgKyAxIDw8IDFdKS5tYXRjaGVzTWFyayhtYXJrc1trZWVwXSkgJiYgbWFya3Nba2VlcF0udHlwZS5zcGVjLnNwYW5uaW5nICE9PSBmYWxzZSkge1xuICAgICAgICBrZWVwKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChrZWVwIDwgZGVwdGgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95UmVzdCgpO1xuICAgICAgICB0aGlzLnRvcC5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgZGVwdGgtLTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGRlcHRoIDwgbWFya3MubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnRvcCwgdGhpcy5pbmRleCArIDEpO1xuICAgICAgICB2YXIgZm91bmQgPSAtMTtcblxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5pbmRleDsgaSA8IE1hdGgubWluKHRoaXMuaW5kZXggKyAzLCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy50b3AuY2hpbGRyZW5baV0ubWF0Y2hlc01hcmsobWFya3NbZGVwdGhdKSkge1xuICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICBpZiAoZm91bmQgPiB0aGlzLmluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWFya0Rlc2MgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBtYXJrc1tkZXB0aF0sIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgsIDAsIG1hcmtEZXNjKTtcbiAgICAgICAgICB0aGlzLnRvcCA9IG1hcmtEZXNjO1xuICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZE5vZGVNYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTm9kZU1hdGNoKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCkge1xuICAgICAgdmFyIGZvdW5kID0gLTEsXG4gICAgICAgICAgdGFyZ2V0RGVzYztcblxuICAgICAgaWYgKGluZGV4ID49IHRoaXMucHJlTWF0Y2guaW5kZXggJiYgKHRhcmdldERlc2MgPSB0aGlzLnByZU1hdGNoLm1hdGNoZXNbaW5kZXggLSB0aGlzLnByZU1hdGNoLmluZGV4XSkucGFyZW50ID09IHRoaXMudG9wICYmIHRhcmdldERlc2MubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pKSB7XG4gICAgICAgIGZvdW5kID0gdGhpcy50b3AuY2hpbGRyZW4uaW5kZXhPZih0YXJnZXREZXNjLCB0aGlzLmluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmluZGV4LCBlID0gTWF0aC5taW4odGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoLCBpICsgNSk7IGkgPCBlOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcblxuICAgICAgICAgIGlmIChjaGlsZC5tYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykgJiYgIXRoaXMucHJlTWF0Y2gubWF0Y2hlZC5oYXMoY2hpbGQpKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kIDwgMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICB0aGlzLmluZGV4Kys7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlTm9kZUF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU5vZGVBdChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgsIHZpZXcpIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMudG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgIGlmIChjaGlsZC5kaXJ0eSA9PSBOT0RFX0RJUlRZICYmIGNoaWxkLmRvbSA9PSBjaGlsZC5jb250ZW50RE9NKSBjaGlsZC5kaXJ0eSA9IENPTlRFTlRfRElSVFk7XG4gICAgICBpZiAoIWNoaWxkLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaW5kZXgpO1xuICAgICAgdGhpcy5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kSW5kZXhXaXRoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEluZGV4V2l0aENoaWxkKGRvbU5vZGUpIHtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHJldHVybiAtMTtcblxuICAgICAgICBpZiAocGFyZW50ID09IHRoaXMudG9wLmNvbnRlbnRET00pIHtcbiAgICAgICAgICB2YXIgZGVzYyA9IGRvbU5vZGUucG1WaWV3RGVzYztcbiAgICAgICAgICBpZiAoZGVzYykgZm9yICh2YXIgaSA9IHRoaXMuaW5kZXg7IGkgPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMudG9wLmNoaWxkcmVuW2ldID09IGRlc2MpIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBkb21Ob2RlID0gcGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVOZXh0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVOZXh0Tm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgaW5kZXgpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLmluZGV4OyBpIDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcblxuICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIE5vZGVWaWV3RGVzYykge1xuICAgICAgICAgIHZhciBfcHJlTWF0Y2ggPSB0aGlzLnByZU1hdGNoLm1hdGNoZWQuZ2V0KG5leHQpO1xuXG4gICAgICAgICAgaWYgKF9wcmVNYXRjaCAhPSBudWxsICYmIF9wcmVNYXRjaCAhPSBpbmRleCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHZhciBuZXh0RE9NID0gbmV4dC5kb207XG4gICAgICAgICAgdmFyIGxvY2tlZCA9IHRoaXMubG9jayAmJiAobmV4dERPTSA9PSB0aGlzLmxvY2sgfHwgbmV4dERPTS5ub2RlVHlwZSA9PSAxICYmIG5leHRET00uY29udGFpbnModGhpcy5sb2NrLnBhcmVudE5vZGUpKSAmJiAhKG5vZGUuaXNUZXh0ICYmIG5leHQubm9kZSAmJiBuZXh0Lm5vZGUuaXNUZXh0ICYmIG5leHQubm9kZURPTS5ub2RlVmFsdWUgPT0gbm9kZS50ZXh0ICYmIG5leHQuZGlydHkgIT0gTk9ERV9ESVJUWSAmJiBzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgbmV4dC5vdXRlckRlY28pKTtcblxuICAgICAgICAgIGlmICghbG9ja2VkICYmIG5leHQudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBpKTtcbiAgICAgICAgICAgIGlmIChuZXh0LmRvbSAhPSBuZXh0RE9NKSB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgTm9kZVZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykpO1xuICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGxhY2VXaWRnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxhY2VXaWRnZXQod2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5pbmRleCA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCA/IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXhdIDogbnVsbDtcblxuICAgICAgaWYgKG5leHQgJiYgbmV4dC5tYXRjaGVzV2lkZ2V0KHdpZGdldCkgJiYgKHdpZGdldCA9PSBuZXh0LndpZGdldCB8fCAhbmV4dC53aWRnZXQudHlwZS50b0RPTS5wYXJlbnROb2RlKSkge1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVzYyA9IG5ldyBXaWRnZXRWaWV3RGVzYyh0aGlzLnRvcCwgd2lkZ2V0LCB2aWV3LCBwb3MpO1xuICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBkZXNjKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVGV4dGJsb2NrSGFja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVGV4dGJsb2NrSGFja3MoKSB7XG4gICAgICB2YXIgbGFzdENoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleCAtIDFdLFxuICAgICAgICAgIHBhcmVudCA9IHRoaXMudG9wO1xuXG4gICAgICB3aGlsZSAobGFzdENoaWxkIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgIHBhcmVudCA9IGxhc3RDaGlsZDtcbiAgICAgICAgbGFzdENoaWxkID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFsYXN0Q2hpbGQgfHwgIShsYXN0Q2hpbGQgaW5zdGFuY2VvZiBUZXh0Vmlld0Rlc2MpIHx8IC9cXG4kLy50ZXN0KGxhc3RDaGlsZC5ub2RlLnRleHQpKSB7XG4gICAgICAgIGlmICgoc2FmYXJpIHx8IGNocm9tZSkgJiYgbGFzdENoaWxkICYmIGxhc3RDaGlsZC5kb20uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgdGhpcy5hZGRIYWNrTm9kZShcIklNR1wiLCBwYXJlbnQpO1xuICAgICAgICB0aGlzLmFkZEhhY2tOb2RlKFwiQlJcIiwgdGhpcy50b3ApO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRIYWNrTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRIYWNrTm9kZShub2RlTmFtZSwgcGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50ID09IHRoaXMudG9wICYmIHRoaXMuaW5kZXggPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoICYmIHBhcmVudC5jaGlsZHJlblt0aGlzLmluZGV4XS5tYXRjaGVzSGFjayhub2RlTmFtZSkpIHtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuXG4gICAgICAgIGlmIChub2RlTmFtZSA9PSBcIklNR1wiKSB7XG4gICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3Itc2VwYXJhdG9yXCI7XG4gICAgICAgICAgZG9tLmFsdCA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZU5hbWUgPT0gXCJCUlwiKSBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci10cmFpbGluZ0JyZWFrXCI7XG4gICAgICAgIHZhciBoYWNrID0gbmV3IFRyYWlsaW5nSGFja1ZpZXdEZXNjKHRoaXMudG9wLCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgaWYgKHBhcmVudCAhPSB0aGlzLnRvcCkgcGFyZW50LmNoaWxkcmVuLnB1c2goaGFjayk7ZWxzZSBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgaGFjayk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpZXdUcmVlVXBkYXRlcjtcbn0oKTtcblxuZnVuY3Rpb24gcHJlTWF0Y2goZnJhZywgcGFyZW50RGVzYykge1xuICB2YXIgY3VyRGVzYyA9IHBhcmVudERlc2MsXG4gICAgICBkZXNjSSA9IGN1ckRlc2MuY2hpbGRyZW4ubGVuZ3RoO1xuICB2YXIgZkkgPSBmcmFnLmNoaWxkQ291bnQsXG4gICAgICBtYXRjaGVkID0gbmV3IE1hcCgpLFxuICAgICAgbWF0Y2hlcyA9IFtdO1xuXG4gIG91dGVyOiB3aGlsZSAoZkkgPiAwKSB7XG4gICAgdmFyIGRlc2MgPSB2b2lkIDA7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAoZGVzY0kpIHtcbiAgICAgICAgdmFyIG5leHQgPSBjdXJEZXNjLmNoaWxkcmVuW2Rlc2NJIC0gMV07XG5cbiAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgICBjdXJEZXNjID0gbmV4dDtcbiAgICAgICAgICBkZXNjSSA9IG5leHQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlc2MgPSBuZXh0O1xuICAgICAgICAgIGRlc2NJLS07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VyRGVzYyA9PSBwYXJlbnREZXNjKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzY0kgPSBjdXJEZXNjLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGN1ckRlc2MpO1xuICAgICAgICBjdXJEZXNjID0gY3VyRGVzYy5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBkZXNjLm5vZGU7XG4gICAgaWYgKCFub2RlKSBjb250aW51ZTtcbiAgICBpZiAobm9kZSAhPSBmcmFnLmNoaWxkKGZJIC0gMSkpIGJyZWFrO1xuICAgIC0tZkk7XG4gICAgbWF0Y2hlZC5zZXQoZGVzYywgZkkpO1xuICAgIG1hdGNoZXMucHVzaChkZXNjKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaW5kZXg6IGZJLFxuICAgIG1hdGNoZWQ6IG1hdGNoZWQsXG4gICAgbWF0Y2hlczogbWF0Y2hlcy5yZXZlcnNlKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVNpZGUoYSwgYikge1xuICByZXR1cm4gYS50eXBlLnNpZGUgLSBiLnR5cGUuc2lkZTtcbn1cblxuZnVuY3Rpb24gaXRlckRlY28ocGFyZW50LCBkZWNvLCBvbldpZGdldCwgb25Ob2RlKSB7XG4gIHZhciBsb2NhbHMgPSBkZWNvLmxvY2FscyhwYXJlbnQpLFxuICAgICAgb2Zmc2V0ID0gMDtcblxuICBpZiAobG9jYWxzLmxlbmd0aCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaSk7XG4gICAgICBvbk5vZGUoY2hpbGQsIGxvY2FscywgZGVjby5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKSwgaSk7XG4gICAgICBvZmZzZXQgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRlY29JbmRleCA9IDAsXG4gICAgICBhY3RpdmUgPSBbXSxcbiAgICAgIHJlc3ROb2RlID0gbnVsbDtcblxuICBmb3IgKHZhciBwYXJlbnRJbmRleCA9IDA7Oykge1xuICAgIGlmIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID09IG9mZnNldCkge1xuICAgICAgdmFyIHdpZGdldCA9IGxvY2Fsc1tkZWNvSW5kZXgrK10sXG4gICAgICAgICAgd2lkZ2V0cyA9IHZvaWQgMDtcblxuICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPT0gb2Zmc2V0KSB7XG4gICAgICAgICh3aWRnZXRzIHx8ICh3aWRnZXRzID0gW3dpZGdldF0pKS5wdXNoKGxvY2Fsc1tkZWNvSW5kZXgrK10pO1xuICAgICAgfVxuXG4gICAgICBpZiAod2lkZ2V0cykge1xuICAgICAgICB3aWRnZXRzLnNvcnQoY29tcGFyZVNpZGUpO1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHdpZGdldHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIG9uV2lkZ2V0KHdpZGdldHNbX2kyXSwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbldpZGdldCh3aWRnZXQsIHBhcmVudEluZGV4LCAhIXJlc3ROb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2NoaWxkID0gdm9pZCAwLFxuICAgICAgICBpbmRleCA9IHZvaWQgMDtcblxuICAgIGlmIChyZXN0Tm9kZSkge1xuICAgICAgaW5kZXggPSAtMTtcbiAgICAgIF9jaGlsZCA9IHJlc3ROb2RlO1xuICAgICAgcmVzdE5vZGUgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocGFyZW50SW5kZXggPCBwYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgIF9jaGlsZCA9IHBhcmVudC5jaGlsZChwYXJlbnRJbmRleCsrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgYWN0aXZlLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgIGlmIChhY3RpdmVbX2kzXS50byA8PSBvZmZzZXQpIGFjdGl2ZS5zcGxpY2UoX2kzLS0sIDEpO1xuICAgIH1cblxuICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPD0gb2Zmc2V0ICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID4gb2Zmc2V0KSB7XG4gICAgICBhY3RpdmUucHVzaChsb2NhbHNbZGVjb0luZGV4KytdKTtcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gb2Zmc2V0ICsgX2NoaWxkLm5vZGVTaXplO1xuXG4gICAgaWYgKF9jaGlsZC5pc1RleHQpIHtcbiAgICAgIHZhciBjdXRBdCA9IGVuZDtcbiAgICAgIGlmIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPCBjdXRBdCkgY3V0QXQgPSBsb2NhbHNbZGVjb0luZGV4XS5mcm9tO1xuXG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBhY3RpdmUubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICBpZiAoYWN0aXZlW19pNF0udG8gPCBjdXRBdCkgY3V0QXQgPSBhY3RpdmVbX2k0XS50bztcbiAgICAgIH1cblxuICAgICAgaWYgKGN1dEF0IDwgZW5kKSB7XG4gICAgICAgIHJlc3ROb2RlID0gX2NoaWxkLmN1dChjdXRBdCAtIG9mZnNldCk7XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5jdXQoMCwgY3V0QXQgLSBvZmZzZXQpO1xuICAgICAgICBlbmQgPSBjdXRBdDtcbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb3V0ZXJEZWNvID0gX2NoaWxkLmlzSW5saW5lICYmICFfY2hpbGQuaXNMZWFmID8gYWN0aXZlLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuICFkLmlubGluZTtcbiAgICB9KSA6IGFjdGl2ZS5zbGljZSgpO1xuICAgIG9uTm9kZShfY2hpbGQsIG91dGVyRGVjbywgZGVjby5mb3JDaGlsZChvZmZzZXQsIF9jaGlsZCksIGluZGV4KTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW9zSGFja3MoZG9tKSB7XG4gIGlmIChkb20ubm9kZU5hbWUgPT0gXCJVTFwiIHx8IGRvbS5ub2RlTmFtZSA9PSBcIk9MXCIpIHtcbiAgICB2YXIgb2xkQ1NTID0gZG9tLnN0eWxlLmNzc1RleHQ7XG4gICAgZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRDU1MgKyBcIjsgbGlzdC1zdHlsZTogc3F1YXJlICFpbXBvcnRhbnRcIjtcbiAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pLmxpc3RTdHlsZTtcbiAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgfVxufVxuXG5mdW5jdGlvbiBuZWFyYnlUZXh0Tm9kZShub2RlLCBvZmZzZXQpIHtcbiAgZm9yICg7Oykge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHJldHVybiBub2RlO1xuXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IG9mZnNldCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XS5ub2RlVHlwZSA9PSAzKSByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgb2Zmc2V0ID0gbm9kZVNpemUobm9kZSk7XG4gICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRUZXh0SW5GcmFnbWVudChmcmFnLCB0ZXh0LCBmcm9tLCB0bykge1xuICBmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgaSA8IGZyYWcuY2hpbGRDb3VudCAmJiBwb3MgPD0gdG87KSB7XG4gICAgdmFyIGNoaWxkID0gZnJhZy5jaGlsZChpKyspLFxuICAgICAgICBjaGlsZFN0YXJ0ID0gcG9zO1xuICAgIHBvcyArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICBpZiAoIWNoaWxkLmlzVGV4dCkgY29udGludWU7XG4gICAgdmFyIHN0ciA9IGNoaWxkLnRleHQ7XG5cbiAgICB3aGlsZSAoaSA8IGZyYWcuY2hpbGRDb3VudCkge1xuICAgICAgdmFyIG5leHQgPSBmcmFnLmNoaWxkKGkrKyk7XG4gICAgICBwb3MgKz0gbmV4dC5ub2RlU2l6ZTtcbiAgICAgIGlmICghbmV4dC5pc1RleHQpIGJyZWFrO1xuICAgICAgc3RyICs9IG5leHQudGV4dDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgIHZhciBmb3VuZCA9IGNoaWxkU3RhcnQgPCB0byA/IHN0ci5sYXN0SW5kZXhPZih0ZXh0LCB0byAtIGNoaWxkU3RhcnQgLSAxKSA6IC0xO1xuICAgICAgaWYgKGZvdW5kID49IDAgJiYgZm91bmQgKyB0ZXh0Lmxlbmd0aCArIGNoaWxkU3RhcnQgPj0gZnJvbSkgcmV0dXJuIGNoaWxkU3RhcnQgKyBmb3VuZDtcbiAgICAgIGlmIChmcm9tID09IHRvICYmIHN0ci5sZW5ndGggPj0gdG8gKyB0ZXh0Lmxlbmd0aCAtIGNoaWxkU3RhcnQgJiYgc3RyLnNsaWNlKHRvIC0gY2hpbGRTdGFydCwgdG8gLSBjaGlsZFN0YXJ0ICsgdGV4dC5sZW5ndGgpID09IHRleHQpIHJldHVybiB0bztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VOb2Rlcyhub2RlcywgZnJvbSwgdG8sIHZpZXcsIHJlcGxhY2VtZW50KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgb2ZmID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZXNbaV0sXG4gICAgICAgIHN0YXJ0ID0gb2ZmLFxuICAgICAgICBlbmQgPSBvZmYgKz0gY2hpbGQuc2l6ZTtcblxuICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSkge1xuICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhcnQgPCBmcm9tKSByZXN1bHQucHVzaChjaGlsZC5zbGljZSgwLCBmcm9tIC0gc3RhcnQsIHZpZXcpKTtcblxuICAgICAgaWYgKHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJlcGxhY2VtZW50KTtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPiB0bykgcmVzdWx0LnB1c2goY2hpbGQuc2xpY2UodG8gLSBzdGFydCwgY2hpbGQuc2l6ZSwgdmlldykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbkZyb21ET00odmlldykge1xuICB2YXIgb3JpZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICB2YXIgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb24oKSxcbiAgICAgIGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICBpZiAoIWRvbVNlbC5mb2N1c05vZGUpIHJldHVybiBudWxsO1xuICB2YXIgbmVhcmVzdERlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tU2VsLmZvY3VzTm9kZSksXG4gICAgICBpbldpZGdldCA9IG5lYXJlc3REZXNjICYmIG5lYXJlc3REZXNjLnNpemUgPT0gMDtcbiAgdmFyIGhlYWQgPSB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIDEpO1xuICBpZiAoaGVhZCA8IDApIHJldHVybiBudWxsO1xuICB2YXIgJGhlYWQgPSBkb2MucmVzb2x2ZShoZWFkKSxcbiAgICAgICRhbmNob3IsXG4gICAgICBzZWxlY3Rpb247XG5cbiAgaWYgKHNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKSB7XG4gICAgJGFuY2hvciA9ICRoZWFkO1xuXG4gICAgd2hpbGUgKG5lYXJlc3REZXNjICYmICFuZWFyZXN0RGVzYy5ub2RlKSB7XG4gICAgICBuZWFyZXN0RGVzYyA9IG5lYXJlc3REZXNjLnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgbmVhcmVzdERlc2NOb2RlID0gbmVhcmVzdERlc2Mubm9kZTtcblxuICAgIGlmIChuZWFyZXN0RGVzYyAmJiBuZWFyZXN0RGVzY05vZGUuaXNBdG9tICYmIHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobmVhcmVzdERlc2NOb2RlKSAmJiBuZWFyZXN0RGVzYy5wYXJlbnQgJiYgIShuZWFyZXN0RGVzY05vZGUuaXNJbmxpbmUgJiYgaXNPbkVkZ2UoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCBuZWFyZXN0RGVzYy5kb20pKSkge1xuICAgICAgdmFyIHBvcyA9IG5lYXJlc3REZXNjLnBvc0JlZm9yZTtcbiAgICAgIHNlbGVjdGlvbiA9IG5ldyBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24oaGVhZCA9PSBwb3MgPyAkaGVhZCA6IGRvYy5yZXNvbHZlKHBvcykpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5jaG9yID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQsIDEpO1xuICAgIGlmIChhbmNob3IgPCAwKSByZXR1cm4gbnVsbDtcbiAgICAkYW5jaG9yID0gZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgfVxuXG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgdmFyIGJpYXMgPSBvcmlnaW4gPT0gXCJwb2ludGVyXCIgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCA8ICRoZWFkLnBvcyAmJiAhaW5XaWRnZXQgPyAxIDogLTE7XG4gICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHtcbiAgcmV0dXJuIHZpZXcuZWRpdGFibGUgPyB2aWV3Lmhhc0ZvY3VzKCkgOiBoYXNTZWxlY3Rpb24odmlldykgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNvbnRhaW5zKHZpZXcuZG9tKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uVG9ET00odmlldykge1xuICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gIHN5bmNOb2RlU2VsZWN0aW9uKHZpZXcsIHNlbCk7XG4gIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSkgcmV0dXJuO1xuXG4gIGlmICghZm9yY2UgJiYgdmlldy5pbnB1dC5tb3VzZURvd24gJiYgdmlldy5pbnB1dC5tb3VzZURvd24uYWxsb3dEZWZhdWx0ICYmIGNocm9tZSkge1xuICAgIHZhciBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpLFxuICAgICAgICBjdXJTZWwgPSB2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICBpZiAoZG9tU2VsLmFuY2hvck5vZGUgJiYgY3VyU2VsLmFuY2hvck5vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQsIGN1clNlbC5hbmNob3JOb2RlLCBjdXJTZWwuYW5jaG9yT2Zmc2V0KSkge1xuICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24uZGVsYXllZFNlbGVjdGlvblN5bmMgPSB0cnVlO1xuICAgICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICB2aWV3LmRvbU9ic2VydmVyLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcblxuICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKSB7XG4gICAgc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5jaG9yID0gc2VsLmFuY2hvcixcbiAgICAgICAgaGVhZCA9IHNlbC5oZWFkLFxuICAgICAgICByZXNldEVkaXRhYmxlRnJvbSxcbiAgICAgICAgcmVzZXRFZGl0YWJsZVRvO1xuXG4gICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlICYmICEoc2VsIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uKSkge1xuICAgICAgaWYgKCFzZWwuJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpIHJlc2V0RWRpdGFibGVGcm9tID0gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgc2VsLmZyb20pO1xuICAgICAgaWYgKCFzZWwuZW1wdHkgJiYgIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCkgcmVzZXRFZGl0YWJsZVRvID0gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgc2VsLnRvKTtcbiAgICB9XG5cbiAgICB2aWV3LmRvY1ZpZXcuc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldy5yb290LCBmb3JjZSk7XG5cbiAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUpIHtcbiAgICAgIGlmIChyZXNldEVkaXRhYmxlRnJvbSkgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlRnJvbSk7XG4gICAgICBpZiAocmVzZXRFZGl0YWJsZVRvKSByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVUbyk7XG4gICAgfVxuXG4gICAgaWYgKHNlbC52aXNpYmxlKSB7XG4gICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICBpZiAoXCJvbnNlbGVjdGlvbmNoYW5nZVwiIGluIGRvY3VtZW50KSByZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlKHZpZXcpO1xuICAgIH1cbiAgfVxuXG4gIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuY29ubmVjdFNlbGVjdGlvbigpO1xufVxuXG52YXIgYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgPSBzYWZhcmkgfHwgY2hyb21lICYmIGNocm9tZV92ZXJzaW9uIDwgNjM7XG5cbmZ1bmN0aW9uIHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHBvcykge1xuICB2YXIgX3ZpZXckZG9jVmlldyRkb21Gcm9tMyA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgMCksXG4gICAgICBub2RlID0gX3ZpZXckZG9jVmlldyRkb21Gcm9tMy5ub2RlLFxuICAgICAgb2Zmc2V0ID0gX3ZpZXckZG9jVmlldyRkb21Gcm9tMy5vZmZzZXQ7XG5cbiAgdmFyIGFmdGVyID0gb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdIDogbnVsbDtcbiAgdmFyIGJlZm9yZSA9IG9mZnNldCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXSA6IG51bGw7XG4gIGlmIChzYWZhcmkgJiYgYWZ0ZXIgJiYgYWZ0ZXIuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgcmV0dXJuIHNldEVkaXRhYmxlKGFmdGVyKTtcblxuICBpZiAoKCFhZnRlciB8fCBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSAmJiAoIWJlZm9yZSB8fCBiZWZvcmUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikpIHtcbiAgICBpZiAoYWZ0ZXIpIHJldHVybiBzZXRFZGl0YWJsZShhZnRlcik7ZWxzZSBpZiAoYmVmb3JlKSByZXR1cm4gc2V0RWRpdGFibGUoYmVmb3JlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7XG5cbiAgaWYgKHNhZmFyaSAmJiBlbGVtZW50LmRyYWdnYWJsZSkge1xuICAgIGVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgZWxlbWVudC53YXNEcmFnZ2FibGUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHJlc2V0RWRpdGFibGUoZWxlbWVudCkge1xuICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcblxuICBpZiAoZWxlbWVudC53YXNEcmFnZ2FibGUpIHtcbiAgICBlbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgZWxlbWVudC53YXNEcmFnZ2FibGUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldykge1xuICB2YXIgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICB2YXIgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgdmFyIG5vZGUgPSBkb21TZWwuYW5jaG9yTm9kZSxcbiAgICAgIG9mZnNldCA9IGRvbVNlbC5hbmNob3JPZmZzZXQ7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChkb21TZWwuYW5jaG9yTm9kZSAhPSBub2RlIHx8IGRvbVNlbC5hbmNob3JPZmZzZXQgIT0gb2Zmc2V0KSB7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUpIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgfSwgMjApO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdEN1cnNvcldyYXBwZXIodmlldykge1xuICB2YXIgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb24oKSxcbiAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIG5vZGUgPSB2aWV3LmN1cnNvcldyYXBwZXIuZG9tLFxuICAgICAgaW1nID0gbm9kZS5ub2RlTmFtZSA9PSBcIklNR1wiO1xuICBpZiAoaW1nKSByYW5nZS5zZXRFbmQobm9kZS5wYXJlbnROb2RlLCBkb21JbmRleChub2RlKSArIDEpO2Vsc2UgcmFuZ2Uuc2V0RW5kKG5vZGUsIDApO1xuICByYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gIGRvbVNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcblxuICBpZiAoIWltZyAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJiBpZSAmJiBpZV92ZXJzaW9uIDw9IDExKSB7XG4gICAgbm9kZS5kaXNhYmxlZCA9IHRydWU7XG4gICAgbm9kZS5kaXNhYmxlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN5bmNOb2RlU2VsZWN0aW9uKHZpZXcsIHNlbCkge1xuICBpZiAoc2VsIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uKSB7XG4gICAgdmFyIGRlc2MgPSB2aWV3LmRvY1ZpZXcuZGVzY0F0KHNlbC5mcm9tKTtcblxuICAgIGlmIChkZXNjICE9IHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MpIHtcbiAgICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgICAgIGlmIChkZXNjKSBkZXNjLnNlbGVjdE5vZGUoKTtcbiAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSBkZXNjO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjbGVhck5vZGVTZWxlY3Rpb24odmlldyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpIHtcbiAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MpIHtcbiAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5wYXJlbnQpIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MuZGVzZWxlY3ROb2RlKCk7XG4gICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKSB7XG4gIHJldHVybiB2aWV3LnNvbWVQcm9wKFwiY3JlYXRlU2VsZWN0aW9uQmV0d2VlblwiLCBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKHZpZXcsICRhbmNob3IsICRoZWFkKTtcbiAgfSkgfHwgcHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uLmJldHdlZW4oJGFuY2hvciwgJGhlYWQsIGJpYXMpO1xufVxuXG5mdW5jdGlvbiBoYXNGb2N1c0FuZFNlbGVjdGlvbih2aWV3KSB7XG4gIGlmICh2aWV3LmVkaXRhYmxlICYmIHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ICE9IHZpZXcuZG9tKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBoYXNTZWxlY3Rpb24odmlldyk7XG59XG5cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbih2aWV3KSB7XG4gIHZhciBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICBpZiAoIXNlbC5hbmNob3JOb2RlKSByZXR1cm4gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdmlldy5kb20uY29udGFpbnMoc2VsLmFuY2hvck5vZGUubm9kZVR5cGUgPT0gMyA/IHNlbC5hbmNob3JOb2RlLnBhcmVudE5vZGUgOiBzZWwuYW5jaG9yTm9kZSkgJiYgKHZpZXcuZWRpdGFibGUgfHwgdmlldy5kb20uY29udGFpbnMoc2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmZvY3VzTm9kZS5wYXJlbnROb2RlIDogc2VsLmZvY3VzTm9kZSkpO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFuY2hvckluUmlnaHRQbGFjZSh2aWV3KSB7XG4gIHZhciBhbmNob3JET00gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IsIDApO1xuICB2YXIgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgcmV0dXJuIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIG1vdmVTZWxlY3Rpb25CbG9jayhzdGF0ZSwgZGlyKSB7XG4gIHZhciBfc3RhdGUkc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJGFuY2hvciA9IF9zdGF0ZSRzZWxlY3Rpb24uJGFuY2hvcixcbiAgICAgICRoZWFkID0gX3N0YXRlJHNlbGVjdGlvbi4kaGVhZDtcbiAgdmFyICRzaWRlID0gZGlyID4gMCA/ICRhbmNob3IubWF4KCRoZWFkKSA6ICRhbmNob3IubWluKCRoZWFkKTtcbiAgdmFyICRzdGFydCA9ICEkc2lkZS5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRzaWRlIDogJHNpZGUuZGVwdGggPyBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHNpZGUuYWZ0ZXIoKSA6ICRzaWRlLmJlZm9yZSgpKSA6IG51bGw7XG4gIHJldHVybiAkc3RhcnQgJiYgcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24uZmluZEZyb20oJHN0YXJ0LCBkaXIpO1xufVxuXG5mdW5jdGlvbiBhcHBseSh2aWV3LCBzZWwpIHtcbiAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICB2YXIgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG5cbiAgaWYgKHNlbCBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbikge1xuICAgIGlmICghc2VsLmVtcHR5IHx8IG1vZHMuaW5kZXhPZihcInNcIikgPiAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXIgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpKSB7XG4gICAgICB2YXIgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgaWYgKG5leHQgJiYgbmV4dCBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbikgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIShtYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKSkge1xuICAgICAgdmFyICRoZWFkID0gc2VsLiRoZWFkLFxuICAgICAgICAgIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyLFxuICAgICAgICAgIGRlc2M7XG4gICAgICBpZiAoIW5vZGUgfHwgbm9kZS5pc1RleHQpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBub2RlUG9zID0gZGlyIDwgMCA/ICRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUgOiAkaGVhZC5wb3M7XG4gICAgICBpZiAoIShub2RlLmlzQXRvbSB8fCAoZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQobm9kZVBvcykpICYmICFkZXNjLmNvbnRlbnRET00pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGlmIChwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uKGRpciA8IDAgPyB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKCRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUpIDogJGhlYWQpKTtcbiAgICAgIH0gZWxzZSBpZiAod2Via2l0KSB7XG4gICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgcHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uKHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZGlyIDwgMCA/IG5vZGVQb3MgOiBub2RlUG9zICsgbm9kZS5ub2RlU2l6ZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc2VsIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uICYmIHNlbC5ub2RlLmlzSW5saW5lKSB7XG4gICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24oZGlyID4gMCA/IHNlbC4kdG8gOiBzZWwuJGZyb20pKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX25leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcblxuICAgIGlmIChfbmV4dCkgcmV0dXJuIGFwcGx5KHZpZXcsIF9uZXh0KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9kZUxlbihub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBpc0lnbm9yYWJsZShkb20pIHtcbiAgdmFyIGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgcmV0dXJuIGRlc2MgJiYgZGVzYy5zaXplID09IDAgJiYgKGRvbS5uZXh0U2libGluZyB8fCBkb20ubm9kZU5hbWUgIT0gXCJCUlwiKTtcbn1cblxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlc0xlZnQodmlldykge1xuICB2YXIgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgdmFyIG5vZGUgPSBzZWwuZm9jdXNOb2RlLFxuICAgICAgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgdmFyIG1vdmVOb2RlLFxuICAgICAgbW92ZU9mZnNldCxcbiAgICAgIGZvcmNlID0gZmFsc2U7XG4gIGlmIChnZWNrbyAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZUxlbihub2RlKSAmJiBpc0lnbm9yYWJsZShub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSkpIGZvcmNlID0gdHJ1ZTtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuXG4gICAgICAgIGlmIChpc0lnbm9yYWJsZShiZWZvcmUpKSB7XG4gICAgICAgICAgbW92ZU5vZGUgPSBub2RlO1xuICAgICAgICAgIG1vdmVPZmZzZXQgPSAtLW9mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgb2Zmc2V0ID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Jsb2NrTm9kZShub2RlKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmV2ID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG5cbiAgICAgIHdoaWxlIChwcmV2ICYmIGlzSWdub3JhYmxlKHByZXYpKSB7XG4gICAgICAgIG1vdmVOb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBtb3ZlT2Zmc2V0ID0gZG9tSW5kZXgocHJldik7XG4gICAgICAgIHByZXYgPSBwcmV2LnByZXZpb3VzU2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKSBicmVhaztcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICBvZmZzZXQgPSBub2RlTGVuKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmb3JjZSkgc2V0U2VsRm9jdXModmlldywgc2VsLCBub2RlLCBvZmZzZXQpO2Vsc2UgaWYgKG1vdmVOb2RlKSBzZXRTZWxGb2N1cyh2aWV3LCBzZWwsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlc1JpZ2h0KHZpZXcpIHtcbiAgdmFyIHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gIHZhciBub2RlID0gc2VsLmZvY3VzTm9kZSxcbiAgICAgIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgaWYgKCFub2RlKSByZXR1cm47XG4gIHZhciBsZW4gPSBub2RlTGVuKG5vZGUpO1xuICB2YXIgbW92ZU5vZGUsIG1vdmVPZmZzZXQ7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpIGJyZWFrO1xuICAgICAgdmFyIGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG5cbiAgICAgIGlmIChpc0lnbm9yYWJsZShhZnRlcikpIHtcbiAgICAgICAgbW92ZU5vZGUgPSBub2RlO1xuICAgICAgICBtb3ZlT2Zmc2V0ID0gKytvZmZzZXQ7XG4gICAgICB9IGVsc2UgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2NrTm9kZShub2RlKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcblxuICAgICAgd2hpbGUgKG5leHQgJiYgaXNJZ25vcmFibGUobmV4dCkpIHtcbiAgICAgICAgbW92ZU5vZGUgPSBuZXh0LnBhcmVudE5vZGU7XG4gICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChuZXh0KSArIDE7XG4gICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pIGJyZWFrO1xuICAgICAgICBvZmZzZXQgPSBsZW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG1vdmVOb2RlKSBzZXRTZWxGb2N1cyh2aWV3LCBzZWwsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gaXNCbG9ja05vZGUoZG9tKSB7XG4gIHZhciBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gIHJldHVybiBkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jaztcbn1cblxuZnVuY3Rpb24gc2V0U2VsRm9jdXModmlldywgc2VsLCBub2RlLCBvZmZzZXQpIHtcbiAgaWYgKHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICByYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICB9IGVsc2UgaWYgKHNlbC5leHRlbmQpIHtcbiAgICBzZWwuZXh0ZW5kKG5vZGUsIG9mZnNldCk7XG4gIH1cblxuICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICB2YXIgc3RhdGUgPSB2aWV3LnN0YXRlO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodmlldy5zdGF0ZSA9PSBzdGF0ZSkgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gIH0sIDUwKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0VmVydGljYWxseSh2aWV3LCBkaXIsIG1vZHMpIHtcbiAgdmFyIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICBpZiAoc2VsIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgfHwgbW9kcy5pbmRleE9mKFwic1wiKSA+IC0xKSByZXR1cm4gZmFsc2U7XG4gIGlmIChtYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKSByZXR1cm4gZmFsc2U7XG4gIHZhciAkZnJvbSA9IHNlbC4kZnJvbSxcbiAgICAgICR0byA9IHNlbC4kdG87XG5cbiAgaWYgKCEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA8IDAgPyBcInVwXCIgOiBcImRvd25cIikpIHtcbiAgICB2YXIgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgIGlmIChuZXh0ICYmIG5leHQgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24pIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgfVxuXG4gIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICB2YXIgc2lkZSA9IGRpciA8IDAgPyAkZnJvbSA6ICR0bztcbiAgICB2YXIgYmV5b25kID0gc2VsIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5BbGxTZWxlY3Rpb24gPyBwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbi5uZWFyKHNpZGUsIGRpcikgOiBwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbi5maW5kRnJvbShzaWRlLCBkaXIpO1xuICAgIHJldHVybiBiZXlvbmQgPyBhcHBseSh2aWV3LCBiZXlvbmQpIDogZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIGRpcikge1xuICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbikpIHJldHVybiB0cnVlO1xuICB2YXIgX3ZpZXckc3RhdGUkc2VsZWN0aW9uMiA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJGhlYWQgPSBfdmlldyRzdGF0ZSRzZWxlY3Rpb24yLiRoZWFkLFxuICAgICAgJGFuY2hvciA9IF92aWV3JHN0YXRlJHNlbGVjdGlvbjIuJGFuY2hvcixcbiAgICAgIGVtcHR5ID0gX3ZpZXckc3RhdGUkc2VsZWN0aW9uMi5lbXB0eTtcbiAgaWYgKCEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCFlbXB0eSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXIgPiAwID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIpKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIG5leHROb2RlID0gISRoZWFkLnRleHRPZmZzZXQgJiYgKGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyKTtcblxuICBpZiAobmV4dE5vZGUgJiYgIW5leHROb2RlLmlzVGV4dCkge1xuICAgIHZhciB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgaWYgKGRpciA8IDApIHRyW1wiZGVsZXRlXCJdKCRoZWFkLnBvcyAtIG5leHROb2RlLm5vZGVTaXplLCAkaGVhZC5wb3MpO2Vsc2UgdHJbXCJkZWxldGVcIl0oJGhlYWQucG9zLCAkaGVhZC5wb3MgKyBuZXh0Tm9kZS5ub2RlU2l6ZSk7XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHN3aXRjaEVkaXRhYmxlKHZpZXcsIG5vZGUsIHN0YXRlKSB7XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IHN0YXRlO1xuICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG59XG5cbmZ1bmN0aW9uIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB7XG4gIGlmICghc2FmYXJpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRoZWFkLnBhcmVudE9mZnNldCA+IDApIHJldHVybiBmYWxzZTtcblxuICB2YXIgX3ZpZXckZG9tU2VsZWN0aW9uID0gdmlldy5kb21TZWxlY3Rpb24oKSxcbiAgICAgIGZvY3VzTm9kZSA9IF92aWV3JGRvbVNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldCA9IF92aWV3JGRvbVNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICBpZiAoZm9jdXNOb2RlICYmIGZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxICYmIGZvY3VzT2Zmc2V0ID09IDAgJiYgZm9jdXNOb2RlLmZpcnN0Q2hpbGQgJiYgZm9jdXNOb2RlLmZpcnN0Q2hpbGQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikge1xuICAgIHZhciBjaGlsZCA9IGZvY3VzTm9kZS5maXJzdENoaWxkO1xuICAgIHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBcInRydWVcIik7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwiZmFsc2VcIik7XG4gICAgfSwgMjApO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRNb2RzKGV2ZW50KSB7XG4gIHZhciByZXN1bHQgPSBcIlwiO1xuICBpZiAoZXZlbnQuY3RybEtleSkgcmVzdWx0ICs9IFwiY1wiO1xuICBpZiAoZXZlbnQubWV0YUtleSkgcmVzdWx0ICs9IFwibVwiO1xuICBpZiAoZXZlbnQuYWx0S2V5KSByZXN1bHQgKz0gXCJhXCI7XG4gIGlmIChldmVudC5zaGlmdEtleSkgcmVzdWx0ICs9IFwic1wiO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjYXB0dXJlS2V5RG93bih2aWV3LCBldmVudCkge1xuICB2YXIgY29kZSA9IGV2ZW50LmtleUNvZGUsXG4gICAgICBtb2RzID0gZ2V0TW9kcyhldmVudCk7XG5cbiAgaWYgKGNvZGUgPT0gOCB8fCBtYWMgJiYgY29kZSA9PSA3MiAmJiBtb2RzID09IFwiY1wiKSB7XG4gICAgcmV0dXJuIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIC0xKSB8fCBza2lwSWdub3JlZE5vZGVzTGVmdCh2aWV3KTtcbiAgfSBlbHNlIGlmIChjb2RlID09IDQ2IHx8IG1hYyAmJiBjb2RlID09IDY4ICYmIG1vZHMgPT0gXCJjXCIpIHtcbiAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgMSkgfHwgc2tpcElnbm9yZWROb2Rlc1JpZ2h0KHZpZXcpO1xuICB9IGVsc2UgaWYgKGNvZGUgPT0gMTMgfHwgY29kZSA9PSAyNykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGNvZGUgPT0gMzcgfHwgbWFjICYmIGNvZGUgPT0gNjYgJiYgbW9kcyA9PSBcImNcIikge1xuICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgLTEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXNMZWZ0KHZpZXcpO1xuICB9IGVsc2UgaWYgKGNvZGUgPT0gMzkgfHwgbWFjICYmIGNvZGUgPT0gNzAgJiYgbW9kcyA9PSBcImNcIikge1xuICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlc1JpZ2h0KHZpZXcpO1xuICB9IGVsc2UgaWYgKGNvZGUgPT0gMzggfHwgbWFjICYmIGNvZGUgPT0gODAgJiYgbW9kcyA9PSBcImNcIikge1xuICAgIHJldHVybiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIC0xLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzTGVmdCh2aWV3KTtcbiAgfSBlbHNlIGlmIChjb2RlID09IDQwIHx8IG1hYyAmJiBjb2RlID09IDc4ICYmIG1vZHMgPT0gXCJjXCIpIHtcbiAgICByZXR1cm4gc2FmYXJpRG93bkFycm93QnVnKHZpZXcpIHx8IHNlbGVjdFZlcnRpY2FsbHkodmlldywgMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlc1JpZ2h0KHZpZXcpO1xuICB9IGVsc2UgaWYgKG1vZHMgPT0gKG1hYyA/IFwibVwiIDogXCJjXCIpICYmIChjb2RlID09IDY2IHx8IGNvZGUgPT0gNzMgfHwgY29kZSA9PSA4OSB8fCBjb2RlID09IDkwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpIHtcbiAgdmFyIGNvbnRleHQgPSBbXSxcbiAgICAgIGNvbnRlbnQgPSBzbGljZS5jb250ZW50LFxuICAgICAgb3BlblN0YXJ0ID0gc2xpY2Uub3BlblN0YXJ0LFxuICAgICAgb3BlbkVuZCA9IHNsaWNlLm9wZW5FbmQ7XG5cbiAgd2hpbGUgKG9wZW5TdGFydCA+IDEgJiYgb3BlbkVuZCA+IDEgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEgJiYgY29udGVudC5maXJzdENoaWxkLmNoaWxkQ291bnQgPT0gMSkge1xuICAgIG9wZW5TdGFydC0tO1xuICAgIG9wZW5FbmQtLTtcbiAgICB2YXIgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICBjb250ZXh0LnB1c2gobm9kZS50eXBlLm5hbWUsIG5vZGUuYXR0cnMgIT0gbm9kZS50eXBlLmRlZmF1bHRBdHRycyA/IG5vZGUuYXR0cnMgOiBudWxsKTtcbiAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkU2VyaWFsaXplclwiKSB8fCBwcm9zZW1pcnJvck1vZGVsLkRPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gIHZhciBkb2MgPSBkZXRhY2hlZERvYygpLFxuICAgICAgd3JhcCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB3cmFwLmFwcGVuZENoaWxkKHNlcmlhbGl6ZXIuc2VyaWFsaXplRnJhZ21lbnQoY29udGVudCwge1xuICAgIGRvY3VtZW50OiBkb2NcbiAgfSkpO1xuICB2YXIgZmlyc3RDaGlsZCA9IHdyYXAuZmlyc3RDaGlsZCxcbiAgICAgIG5lZWRzV3JhcCxcbiAgICAgIHdyYXBwZXJzID0gMDtcblxuICB3aGlsZSAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09IDEgJiYgKG5lZWRzV3JhcCA9IHdyYXBNYXBbZmlyc3RDaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICBmb3IgKHZhciBpID0gbmVlZHNXcmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KG5lZWRzV3JhcFtpXSk7XG5cbiAgICAgIHdoaWxlICh3cmFwLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh3cmFwLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB3cmFwLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgd3JhcHBlcnMrKztcbiAgICB9XG5cbiAgICBmaXJzdENoaWxkID0gd3JhcC5maXJzdENoaWxkO1xuICB9XG5cbiAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxKSBmaXJzdENoaWxkLnNldEF0dHJpYnV0ZShcImRhdGEtcG0tc2xpY2VcIiwgXCJcIi5jb25jYXQob3BlblN0YXJ0LCBcIiBcIikuY29uY2F0KG9wZW5FbmQpLmNvbmNhdCh3cmFwcGVycyA/IFwiIC1cIi5jb25jYXQod3JhcHBlcnMpIDogXCJcIiwgXCIgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShjb250ZXh0KSkpO1xuICB2YXIgdGV4dCA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRUZXh0U2VyaWFsaXplclwiLCBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKHNsaWNlKTtcbiAgfSkgfHwgc2xpY2UuY29udGVudC50ZXh0QmV0d2VlbigwLCBzbGljZS5jb250ZW50LnNpemUsIFwiXFxuXFxuXCIpO1xuICByZXR1cm4ge1xuICAgIGRvbTogd3JhcCxcbiAgICB0ZXh0OiB0ZXh0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwbGFpblRleHQsICRjb250ZXh0KSB7XG4gIHZhciBpbkNvZGUgPSAkY29udGV4dC5wYXJlbnQudHlwZS5zcGVjLmNvZGU7XG4gIHZhciBkb20sIHNsaWNlO1xuICBpZiAoIWh0bWwgJiYgIXRleHQpIHJldHVybiBudWxsO1xuICB2YXIgYXNUZXh0ID0gdGV4dCAmJiAocGxhaW5UZXh0IHx8IGluQ29kZSB8fCAhaHRtbCk7XG5cbiAgaWYgKGFzVGV4dCkge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRUZXh0XCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgICB0ZXh0ID0gZih0ZXh0LCBpbkNvZGUgfHwgcGxhaW5UZXh0KTtcbiAgICB9KTtcbiAgICBpZiAoaW5Db2RlKSByZXR1cm4gdGV4dCA/IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSh2aWV3LnN0YXRlLnNjaGVtYS50ZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSkpLCAwLCAwKSA6IHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHk7XG4gICAgdmFyIHBhcnNlZCA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRUZXh0UGFyc2VyXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gZih0ZXh0LCAkY29udGV4dCwgcGxhaW5UZXh0KTtcbiAgICB9KTtcblxuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHNsaWNlID0gcGFyc2VkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFya3MgPSAkY29udGV4dC5tYXJrcygpO1xuICAgICAgdmFyIHNjaGVtYSA9IHZpZXcuc3RhdGUuc2NoZW1hLFxuICAgICAgICAgIHNlcmlhbGl6ZXIgPSBwcm9zZW1pcnJvck1vZGVsLkRPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYShzY2hlbWEpO1xuICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRleHQuc3BsaXQoLyg/Olxcclxcbj98XFxuKSsvKS5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgcCA9IGRvbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKSk7XG4gICAgICAgIGlmIChibG9jaykgcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZU5vZGUoc2NoZW1hLnRleHQoYmxvY2ssIG1hcmtzKSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRIVE1MXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgICBodG1sID0gZihodG1sKTtcbiAgICB9KTtcbiAgICBkb20gPSByZWFkSFRNTChodG1sKTtcbiAgICBpZiAod2Via2l0KSByZXN0b3JlUmVwbGFjZWRTcGFjZXMoZG9tKTtcbiAgfVxuXG4gIHZhciBjb250ZXh0Tm9kZSA9IGRvbSAmJiBkb20ucXVlcnlTZWxlY3RvcihcIltkYXRhLXBtLXNsaWNlXVwiKTtcbiAgdmFyIHNsaWNlRGF0YSA9IGNvbnRleHROb2RlICYmIC9eKFxcZCspIChcXGQrKSg/OiAtKFxcZCspKT8gKC4qKS8uZXhlYyhjb250ZXh0Tm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIpIHx8IFwiXCIpO1xuICBpZiAoc2xpY2VEYXRhICYmIHNsaWNlRGF0YVszXSkgZm9yICh2YXIgaSA9ICtzbGljZURhdGFbM107IGkgPiAwICYmIGRvbS5maXJzdENoaWxkOyBpLS0pIHtcbiAgICBkb20gPSBkb20uZmlyc3RDaGlsZDtcbiAgfVxuXG4gIGlmICghc2xpY2UpIHtcbiAgICB2YXIgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFBhcnNlclwiKSB8fCB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IHByb3NlbWlycm9yTW9kZWwuRE9NUGFyc2VyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgIHNsaWNlID0gcGFyc2VyLnBhcnNlU2xpY2UoZG9tLCB7XG4gICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICEhKGFzVGV4dCB8fCBzbGljZURhdGEpLFxuICAgICAgY29udGV4dDogJGNvbnRleHQsXG4gICAgICBydWxlRnJvbU5vZGU6IGZ1bmN0aW9uIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgIWRvbS5uZXh0U2libGluZyAmJiBkb20ucGFyZW50Tm9kZSAmJiAhaW5saW5lUGFyZW50cy50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkgcmV0dXJuIHtcbiAgICAgICAgICBpZ25vcmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoc2xpY2VEYXRhKSB7XG4gICAgc2xpY2UgPSBhZGRDb250ZXh0KGNsb3NlU2xpY2Uoc2xpY2UsICtzbGljZURhdGFbMV0sICtzbGljZURhdGFbMl0pLCBzbGljZURhdGFbNF0pO1xuICB9IGVsc2Uge1xuICAgIHNsaWNlID0gcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5tYXhPcGVuKG5vcm1hbGl6ZVNpYmxpbmdzKHNsaWNlLmNvbnRlbnQsICRjb250ZXh0KSwgdHJ1ZSk7XG5cbiAgICBpZiAoc2xpY2Uub3BlblN0YXJ0IHx8IHNsaWNlLm9wZW5FbmQpIHtcbiAgICAgIHZhciBvcGVuU3RhcnQgPSAwLFxuICAgICAgICAgIG9wZW5FbmQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBub2RlID0gc2xpY2UuY29udGVudC5maXJzdENoaWxkOyBvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQgJiYgIW5vZGUudHlwZS5zcGVjLmlzb2xhdGluZzsgb3BlblN0YXJ0KyssIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQpIHt9XG5cbiAgICAgIGZvciAodmFyIF9ub2RlID0gc2xpY2UuY29udGVudC5sYXN0Q2hpbGQ7IG9wZW5FbmQgPCBzbGljZS5vcGVuRW5kICYmICFfbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nOyBvcGVuRW5kKyssIF9ub2RlID0gX25vZGUubGFzdENoaWxkKSB7fVxuXG4gICAgICBzbGljZSA9IGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxuICB9XG5cbiAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmdW5jdGlvbiAoZikge1xuICAgIHNsaWNlID0gZihzbGljZSk7XG4gIH0pO1xuICByZXR1cm4gc2xpY2U7XG59XG5cbnZhciBpbmxpbmVQYXJlbnRzID0gL14oYXxhYmJyfGFjcm9ueW18YnxjaXRlfGNvZGV8ZGVsfGVtfGl8aW5zfGtiZHxsYWJlbHxvdXRwdXR8cXxydWJ5fHN8c2FtcHxzcGFufHN0cm9uZ3xzdWJ8c3VwfHRpbWV8dXx0dHx2YXIpJC9pO1xuXG5mdW5jdGlvbiBub3JtYWxpemVTaWJsaW5ncyhmcmFnbWVudCwgJGNvbnRleHQpIHtcbiAgaWYgKGZyYWdtZW50LmNoaWxkQ291bnQgPCAyKSByZXR1cm4gZnJhZ21lbnQ7XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoZCkge1xuICAgIHZhciBwYXJlbnQgPSAkY29udGV4dC5ub2RlKGQpO1xuICAgIHZhciBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleChkKSk7XG4gICAgdmFyIGxhc3RXcmFwID0gdm9pZCAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICBmcmFnbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xuICAgICAgdmFyIHdyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKSxcbiAgICAgICAgICBpbkxhc3Q7XG4gICAgICBpZiAoIXdyYXApIHJldHVybiByZXN1bHQgPSBudWxsO1xuXG4gICAgICBpZiAoaW5MYXN0ID0gcmVzdWx0Lmxlbmd0aCAmJiBsYXN0V3JhcC5sZW5ndGggJiYgYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCAwKSkge1xuICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gaW5MYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBjbG9zZVJpZ2h0KHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIGxhc3RXcmFwLmxlbmd0aCk7XG4gICAgICAgIHZhciB3cmFwcGVkID0gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXApO1xuICAgICAgICByZXN1bHQucHVzaCh3cmFwcGVkKTtcbiAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaFR5cGUod3JhcHBlZC50eXBlKTtcbiAgICAgICAgbGFzdFdyYXAgPSB3cmFwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQpIHJldHVybiB7XG4gICAgICB2OiBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20ocmVzdWx0KVxuICAgIH07XG4gIH07XG5cbiAgZm9yICh2YXIgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgIHZhciBfcmV0ID0gX2xvb3AoZCk7XG5cbiAgICBpZiAoX3R5cGVvZihfcmV0KSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXApIHtcbiAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG5cbiAgZm9yICh2YXIgaSA9IHdyYXAubGVuZ3RoIC0gMTsgaSA+PSBmcm9tOyBpLS0pIHtcbiAgICBub2RlID0gd3JhcFtpXS5jcmVhdGUobnVsbCwgcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHNpYmxpbmcsIGRlcHRoKSB7XG4gIGlmIChkZXB0aCA8IHdyYXAubGVuZ3RoICYmIGRlcHRoIDwgbGFzdFdyYXAubGVuZ3RoICYmIHdyYXBbZGVwdGhdID09IGxhc3RXcmFwW2RlcHRoXSkge1xuICAgIHZhciBpbm5lciA9IGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZy5sYXN0Q2hpbGQsIGRlcHRoICsgMSk7XG4gICAgaWYgKGlubmVyKSByZXR1cm4gc2libGluZy5jb3B5KHNpYmxpbmcuY29udGVudC5yZXBsYWNlQ2hpbGQoc2libGluZy5jaGlsZENvdW50IC0gMSwgaW5uZXIpKTtcbiAgICB2YXIgbWF0Y2ggPSBzaWJsaW5nLmNvbnRlbnRNYXRjaEF0KHNpYmxpbmcuY2hpbGRDb3VudCk7XG4gICAgaWYgKG1hdGNoLm1hdGNoVHlwZShkZXB0aCA9PSB3cmFwLmxlbmd0aCAtIDEgPyBub2RlLnR5cGUgOiB3cmFwW2RlcHRoICsgMV0pKSByZXR1cm4gc2libGluZy5jb3B5KHNpYmxpbmcuY29udGVudC5hcHBlbmQocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBkZXB0aCArIDEpKSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb3NlUmlnaHQobm9kZSwgZGVwdGgpIHtcbiAgaWYgKGRlcHRoID09IDApIHJldHVybiBub2RlO1xuICB2YXIgZnJhZ21lbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKG5vZGUuY2hpbGRDb3VudCAtIDEsIGNsb3NlUmlnaHQobm9kZS5sYXN0Q2hpbGQsIGRlcHRoIC0gMSkpO1xuICB2YXIgZmlsbCA9IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICByZXR1cm4gbm9kZS5jb3B5KGZyYWdtZW50LmFwcGVuZChmaWxsKSk7XG59XG5cbmZ1bmN0aW9uIGNsb3NlUmFuZ2UoZnJhZ21lbnQsIHNpZGUsIGZyb20sIHRvLCBkZXB0aCwgb3BlbkVuZCkge1xuICB2YXIgbm9kZSA9IHNpZGUgPCAwID8gZnJhZ21lbnQuZmlyc3RDaGlsZCA6IGZyYWdtZW50Lmxhc3RDaGlsZCxcbiAgICAgIGlubmVyID0gbm9kZS5jb250ZW50O1xuICBpZiAoZGVwdGggPCB0byAtIDEpIGlubmVyID0gY2xvc2VSYW5nZShpbm5lciwgc2lkZSwgZnJvbSwgdG8sIGRlcHRoICsgMSwgb3BlbkVuZCk7XG4gIGlmIChkZXB0aCA+PSBmcm9tKSBpbm5lciA9IHNpZGUgPCAwID8gbm9kZS5jb250ZW50TWF0Y2hBdCgwKS5maWxsQmVmb3JlKGlubmVyLCBmcmFnbWVudC5jaGlsZENvdW50ID4gMSB8fCBvcGVuRW5kIDw9IGRlcHRoKS5hcHBlbmQoaW5uZXIpIDogaW5uZXIuYXBwZW5kKG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZChzaWRlIDwgMCA/IDAgOiBmcmFnbWVudC5jaGlsZENvdW50IC0gMSwgbm9kZS5jb3B5KGlubmVyKSk7XG59XG5cbmZ1bmN0aW9uIGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICBpZiAob3BlblN0YXJ0IDwgc2xpY2Uub3BlblN0YXJ0KSBzbGljZSA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgLTEsIG9wZW5TdGFydCwgc2xpY2Uub3BlblN0YXJ0LCAwLCBzbGljZS5vcGVuRW5kKSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKTtcbiAgaWYgKG9wZW5FbmQgPCBzbGljZS5vcGVuRW5kKSBzbGljZSA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgMSwgb3BlbkVuZCwgc2xpY2Uub3BlbkVuZCwgMCwgMCksIHNsaWNlLm9wZW5TdGFydCwgb3BlbkVuZCk7XG4gIHJldHVybiBzbGljZTtcbn1cblxudmFyIHdyYXBNYXAgPSB7XG4gIHRoZWFkOiBbXCJ0YWJsZVwiXSxcbiAgdGJvZHk6IFtcInRhYmxlXCJdLFxuICB0Zm9vdDogW1widGFibGVcIl0sXG4gIGNhcHRpb246IFtcInRhYmxlXCJdLFxuICBjb2xncm91cDogW1widGFibGVcIl0sXG4gIGNvbDogW1widGFibGVcIiwgXCJjb2xncm91cFwiXSxcbiAgdHI6IFtcInRhYmxlXCIsIFwidGJvZHlcIl0sXG4gIHRkOiBbXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidHJcIl0sXG4gIHRoOiBbXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidHJcIl1cbn07XG52YXIgX2RldGFjaGVkRG9jID0gbnVsbDtcblxuZnVuY3Rpb24gZGV0YWNoZWREb2MoKSB7XG4gIHJldHVybiBfZGV0YWNoZWREb2MgfHwgKF9kZXRhY2hlZERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcInRpdGxlXCIpKTtcbn1cblxuZnVuY3Rpb24gcmVhZEhUTUwoaHRtbCkge1xuICB2YXIgbWV0YXMgPSAvXihcXHMqPG1ldGEgW14+XSo+KSovLmV4ZWMoaHRtbCk7XG4gIGlmIChtZXRhcykgaHRtbCA9IGh0bWwuc2xpY2UobWV0YXNbMF0ubGVuZ3RoKTtcbiAgdmFyIGVsdCA9IGRldGFjaGVkRG9jKCkuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgdmFyIGZpcnN0VGFnID0gLzwoW2Etel1bXj5cXHNdKykvaS5leGVjKGh0bWwpLFxuICAgICAgd3JhcDtcbiAgaWYgKHdyYXAgPSBmaXJzdFRhZyAmJiB3cmFwTWFwW2ZpcnN0VGFnWzFdLnRvTG93ZXJDYXNlKCldKSBodG1sID0gd3JhcC5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCI8XCIgKyBuICsgXCI+XCI7XG4gIH0pLmpvaW4oXCJcIikgKyBodG1sICsgd3JhcC5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gXCI8L1wiICsgbiArIFwiPlwiO1xuICB9KS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgZWx0LmlubmVySFRNTCA9IGh0bWw7XG4gIGlmICh3cmFwKSBmb3IgKHZhciBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspIHtcbiAgICBlbHQgPSBlbHQucXVlcnlTZWxlY3Rvcih3cmFwW2ldKSB8fCBlbHQ7XG4gIH1cbiAgcmV0dXJuIGVsdDtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSkge1xuICB2YXIgbm9kZXMgPSBkb20ucXVlcnlTZWxlY3RvckFsbChjaHJvbWUgPyBcInNwYW46bm90KFtjbGFzc10pOm5vdChbc3R5bGVdKVwiIDogXCJzcGFuLkFwcGxlLWNvbnZlcnRlZC1zcGFjZVwiKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGUudGV4dENvbnRlbnQgPT0gXCJcXHhBMFwiICYmIG5vZGUucGFyZW50Tm9kZSkgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChkb20ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIiBcIiksIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZENvbnRleHQoc2xpY2UsIGNvbnRleHQpIHtcbiAgaWYgKCFzbGljZS5zaXplKSByZXR1cm4gc2xpY2U7XG4gIHZhciBzY2hlbWEgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQudHlwZS5zY2hlbWEsXG4gICAgICBhcnJheTtcblxuICB0cnkge1xuICAgIGFycmF5ID0gSlNPTi5wYXJzZShjb250ZXh0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBzbGljZTtcbiAgfVxuXG4gIHZhciBjb250ZW50ID0gc2xpY2UuY29udGVudCxcbiAgICAgIG9wZW5TdGFydCA9IHNsaWNlLm9wZW5TdGFydCxcbiAgICAgIG9wZW5FbmQgPSBzbGljZS5vcGVuRW5kO1xuXG4gIGZvciAodmFyIGkgPSBhcnJheS5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgIHZhciB0eXBlID0gc2NoZW1hLm5vZGVzW2FycmF5W2ldXTtcbiAgICBpZiAoIXR5cGUgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpIGJyZWFrO1xuICAgIGNvbnRlbnQgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXJyYXlbaSArIDFdLCBjb250ZW50KSk7XG4gICAgb3BlblN0YXJ0Kys7XG4gICAgb3BlbkVuZCsrO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbnZhciBoYW5kbGVycyA9IHt9O1xudmFyIGVkaXRIYW5kbGVycyA9IHt9O1xuXG52YXIgSW5wdXRTdGF0ZSA9IF9jcmVhdGVDbGFzcyhmdW5jdGlvbiBJbnB1dFN0YXRlKCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5wdXRTdGF0ZSk7XG5cbiAgdGhpcy5zaGlmdEtleSA9IGZhbHNlO1xuICB0aGlzLm1vdXNlRG93biA9IG51bGw7XG4gIHRoaXMubGFzdEtleUNvZGUgPSBudWxsO1xuICB0aGlzLmxhc3RLZXlDb2RlVGltZSA9IDA7XG4gIHRoaXMubGFzdENsaWNrID0ge1xuICAgIHRpbWU6IDAsXG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHR5cGU6IFwiXCJcbiAgfTtcbiAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gIHRoaXMubGFzdElPU0VudGVyID0gMDtcbiAgdGhpcy5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQgPSAtMTtcbiAgdGhpcy5sYXN0QW5kcm9pZERlbGV0ZSA9IDA7XG4gIHRoaXMuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRoaXMuY29tcG9zaW5nVGltZW91dCA9IC0xO1xuICB0aGlzLmNvbXBvc2l0aW9uTm9kZXMgPSBbXTtcbiAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICB0aGlzLmRvbUNoYW5nZUNvdW50ID0gMDtcbiAgdGhpcy5ldmVudEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5oaWRlU2VsZWN0aW9uR3VhcmQgPSBudWxsO1xufSk7XG5cbmZ1bmN0aW9uIGluaXRJbnB1dCh2aWV3KSB7XG4gIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoZXZlbnQpIHtcbiAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50XTtcbiAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbZXZlbnRdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSAmJiAhcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiYgKHZpZXcuZWRpdGFibGUgfHwgIShldmVudC50eXBlIGluIGVkaXRIYW5kbGVycykpKSBoYW5kbGVyKHZpZXcsIGV2ZW50KTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBldmVudCBpbiBoYW5kbGVycykge1xuICAgIF9sb29wMihldmVudCk7XG4gIH1cblxuICBpZiAoc2FmYXJpKSB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9KTtcbiAgZW5zdXJlTGlzdGVuZXJzKHZpZXcpO1xufVxuXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgb3JpZ2luKSB7XG4gIHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG9yaWdpbjtcbiAgdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uVGltZSA9IERhdGUubm93KCk7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lJbnB1dCh2aWV3KSB7XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuXG4gIGZvciAodmFyIHR5cGUgaW4gdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzKSB7XG4gICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0pO1xuICB9XG5cbiAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCk7XG4gIGNsZWFyVGltZW91dCh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCk7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUxpc3RlbmVycyh2aWV3KSB7XG4gIHZpZXcuc29tZVByb3AoXCJoYW5kbGVET01FdmVudHNcIiwgZnVuY3Rpb24gKGN1cnJlbnRIYW5kbGVycykge1xuICAgIGZvciAodmFyIHR5cGUgaW4gY3VycmVudEhhbmRsZXJzKSB7XG4gICAgICBpZiAoIXZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSkgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkge1xuICByZXR1cm4gdmlldy5zb21lUHJvcChcImhhbmRsZURPTUV2ZW50c1wiLCBmdW5jdGlvbiAoaGFuZGxlcnMpIHtcbiAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50LnR5cGVdO1xuICAgIHJldHVybiBoYW5kbGVyID8gaGFuZGxlcih2aWV3LCBldmVudCkgfHwgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IGZhbHNlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSB7XG4gIGlmICghZXZlbnQuYnViYmxlcykgcmV0dXJuIHRydWU7XG4gIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgbm9kZSA9IGV2ZW50LnRhcmdldDsgbm9kZSAhPSB2aWV3LmRvbTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09IDExIHx8IG5vZGUucG1WaWV3RGVzYyAmJiBub2RlLnBtVmlld0Rlc2Muc3RvcEV2ZW50KGV2ZW50KSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIF9kaXNwYXRjaEV2ZW50KHZpZXcsIGV2ZW50KSB7XG4gIGlmICghcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiYgaGFuZGxlcnNbZXZlbnQudHlwZV0gJiYgKHZpZXcuZWRpdGFibGUgfHwgIShldmVudC50eXBlIGluIGVkaXRIYW5kbGVycykpKSBoYW5kbGVyc1tldmVudC50eXBlXSh2aWV3LCBldmVudCk7XG59XG5cbmVkaXRIYW5kbGVycy5rZXlkb3duID0gZnVuY3Rpb24gKHZpZXcsIF9ldmVudCkge1xuICB2YXIgZXZlbnQgPSBfZXZlbnQ7XG4gIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5rZXlDb2RlID09IDE2IHx8IGV2ZW50LnNoaWZ0S2V5O1xuICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkpIHJldHVybjtcbiAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gIHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgaWYgKGFuZHJvaWQgJiYgY2hyb21lICYmIGV2ZW50LmtleUNvZGUgPT0gMTMpIHJldHVybjtcbiAgaWYgKGV2ZW50LmtleUNvZGUgIT0gMjI5KSB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcblxuICBpZiAoaW9zICYmIGV2ZW50LmtleUNvZGUgPT0gMTMgJiYgIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQubWV0YUtleSkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gbm93O1xuICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPT0gbm93KSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgfVxuICAgIH0sIDIwMCk7XG4gIH0gZWxzZSBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZih2aWV3LCBldmVudCk7XG4gIH0pIHx8IGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwia2V5XCIpO1xuICB9XG59O1xuXG5lZGl0SGFuZGxlcnMua2V5dXAgPSBmdW5jdGlvbiAodmlldywgZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTYpIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBmYWxzZTtcbn07XG5cbmVkaXRIYW5kbGVycy5rZXlwcmVzcyA9IGZ1bmN0aW9uICh2aWV3LCBfZXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gX2V2ZW50O1xuICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkgfHwgIWV2ZW50LmNoYXJDb2RlIHx8IGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSB8fCBtYWMgJiYgZXZlbnQubWV0YUtleSkgcmV0dXJuO1xuXG4gIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5UHJlc3NcIiwgZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZih2aWV3LCBldmVudCk7XG4gIH0pKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG5cbiAgaWYgKCEoc2VsIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uKSB8fCAhc2VsLiRmcm9tLnNhbWVQYXJlbnQoc2VsLiR0bykpIHtcbiAgICB2YXIgdGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgIGlmICghdmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIGYodmlldywgc2VsLiRmcm9tLnBvcywgc2VsLiR0by5wb3MsIHRleHQpO1xuICAgIH0pKSB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBldmVudENvb3JkcyhldmVudCkge1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGV2ZW50LmNsaWVudFgsXG4gICAgdG9wOiBldmVudC5jbGllbnRZXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzTmVhcihldmVudCwgY2xpY2spIHtcbiAgdmFyIGR4ID0gY2xpY2sueCAtIGV2ZW50LmNsaWVudFgsXG4gICAgICBkeSA9IGNsaWNrLnkgLSBldmVudC5jbGllbnRZO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPCAxMDA7XG59XG5cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgcHJvcE5hbWUsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICBpZiAoaW5zaWRlID09IC0xKSByZXR1cm4gZmFsc2U7XG4gIHZhciAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpO1xuXG4gIHZhciBfbG9vcDMgPSBmdW5jdGlvbiBfbG9vcDMoaSkge1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKHByb3BOYW1lLCBmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIGkgPiAkcG9zLmRlcHRoID8gZih2aWV3LCBwb3MsICRwb3Mubm9kZUFmdGVyLCAkcG9zLmJlZm9yZShpKSwgZXZlbnQsIHRydWUpIDogZih2aWV3LCBwb3MsICRwb3Mubm9kZShpKSwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCBmYWxzZSk7XG4gICAgfSkpIHJldHVybiB7XG4gICAgICB2OiB0cnVlXG4gICAgfTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgX3JldDIgPSBfbG9vcDMoaSk7XG5cbiAgICBpZiAoX3R5cGVvZihfcmV0MikgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0Mi52O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24odmlldywgc2VsZWN0aW9uLCBvcmlnaW4pIHtcbiAgaWYgKCF2aWV3LmZvY3VzZWQpIHZpZXcuZm9jdXMoKTtcbiAgdmFyIHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgaWYgKG9yaWdpbiA9PSBcInBvaW50ZXJcIikgdHIuc2V0TWV0YShcInBvaW50ZXJcIiwgdHJ1ZSk7XG4gIHZpZXcuZGlzcGF0Y2godHIpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpIHtcbiAgaWYgKGluc2lkZSA9PSAtMSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKSxcbiAgICAgIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcblxuICBpZiAobm9kZSAmJiBub2RlLmlzQXRvbSAmJiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIG5ldyBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24oJHBvcyksIFwicG9pbnRlclwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZE5vZGUodmlldywgaW5zaWRlKSB7XG4gIGlmIChpbnNpZGUgPT0gLTEpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgc2VsZWN0ZWROb2RlLFxuICAgICAgc2VsZWN0QXQ7XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24pIHNlbGVjdGVkTm9kZSA9IHNlbC5ub2RlO1xuICB2YXIgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcblxuICBmb3IgKHZhciBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgbm9kZSA9IGkgPiAkcG9zLmRlcHRoID8gJHBvcy5ub2RlQWZ0ZXIgOiAkcG9zLm5vZGUoaSk7XG5cbiAgICBpZiAocHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBzZWwuJGZyb20uZGVwdGggPiAwICYmIGkgPj0gc2VsLiRmcm9tLmRlcHRoICYmICRwb3MuYmVmb3JlKHNlbC4kZnJvbS5kZXB0aCArIDEpID09IHNlbC4kZnJvbS5wb3MpIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoKTtlbHNlIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoaSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZWN0QXQgIT0gbnVsbCkge1xuICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBzZWxlY3RBdCksIFwicG9pbnRlclwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50LCBzZWxlY3ROb2RlKSB7XG4gIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8IHZpZXcuc29tZVByb3AoXCJoYW5kbGVDbGlja1wiLCBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKHZpZXcsIHBvcywgZXZlbnQpO1xuICB9KSB8fCAoc2VsZWN0Tm9kZSA/IHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkgOiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRG91YmxlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlRG91YmxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8IHZpZXcuc29tZVByb3AoXCJoYW5kbGVEb3VibGVDbGlja1wiLCBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKHZpZXcsIHBvcywgZXZlbnQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlVHJpcGxlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlVHJpcGxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8IHZpZXcuc29tZVByb3AoXCJoYW5kbGVUcmlwbGVDbGlja1wiLCBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKHZpZXcsIHBvcywgZXZlbnQpO1xuICB9KSB8fCBkZWZhdWx0VHJpcGxlQ2xpY2sodmlldywgaW5zaWRlLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KSB7XG4gIGlmIChldmVudC5idXR0b24gIT0gMCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG5cbiAgaWYgKGluc2lkZSA9PSAtMSkge1xuICAgIGlmIChkb2MuaW5saW5lQ29udGVudCkge1xuICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCAwLCBkb2MuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShpbnNpZGUpO1xuXG4gIGZvciAodmFyIGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgIHZhciBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICB2YXIgbm9kZVBvcyA9ICRwb3MuYmVmb3JlKGkpO1xuICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQpIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyArIDEsIG5vZGVQb3MgKyAxICsgbm9kZS5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7ZWxzZSBpZiAocHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBub2RlUG9zKSwgXCJwb2ludGVyXCIpO2Vsc2UgY29udGludWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VET01GbHVzaCh2aWV3KSB7XG4gIHJldHVybiBlbmRDb21wb3NpdGlvbih2aWV3KTtcbn1cblxudmFyIHNlbGVjdE5vZGVNb2RpZmllciA9IG1hYyA/IFwibWV0YUtleVwiIDogXCJjdHJsS2V5XCI7XG5cbmhhbmRsZXJzLm1vdXNlZG93biA9IGZ1bmN0aW9uICh2aWV3LCBfZXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gX2V2ZW50O1xuICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gIHZhciBmbHVzaGVkID0gZm9yY2VET01GbHVzaCh2aWV3KTtcbiAgdmFyIG5vdyA9IERhdGUubm93KCksXG4gICAgICB0eXBlID0gXCJzaW5nbGVDbGlja1wiO1xuXG4gIGlmIChub3cgLSB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lIDwgNTAwICYmIGlzTmVhcihldmVudCwgdmlldy5pbnB1dC5sYXN0Q2xpY2spICYmICFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdKSB7XG4gICAgaWYgKHZpZXcuaW5wdXQubGFzdENsaWNrLnR5cGUgPT0gXCJzaW5nbGVDbGlja1wiKSB0eXBlID0gXCJkb3VibGVDbGlja1wiO2Vsc2UgaWYgKHZpZXcuaW5wdXQubGFzdENsaWNrLnR5cGUgPT0gXCJkb3VibGVDbGlja1wiKSB0eXBlID0gXCJ0cmlwbGVDbGlja1wiO1xuICB9XG5cbiAgdmlldy5pbnB1dC5sYXN0Q2xpY2sgPSB7XG4gICAgdGltZTogbm93LFxuICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG4gIHZhciBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gIGlmICghcG9zKSByZXR1cm47XG5cbiAgaWYgKHR5cGUgPT0gXCJzaW5nbGVDbGlja1wiKSB7XG4gICAgaWYgKHZpZXcuaW5wdXQubW91c2VEb3duKSB2aWV3LmlucHV0Lm1vdXNlRG93bi5kb25lKCk7XG4gICAgdmlldy5pbnB1dC5tb3VzZURvd24gPSBuZXcgTW91c2VEb3duKHZpZXcsIHBvcywgZXZlbnQsICEhZmx1c2hlZCk7XG4gIH0gZWxzZSBpZiAoKHR5cGUgPT0gXCJkb3VibGVDbGlja1wiID8gaGFuZGxlRG91YmxlQ2xpY2sgOiBoYW5kbGVUcmlwbGVDbGljaykodmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xuICB9XG59O1xuXG52YXIgTW91c2VEb3duID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNb3VzZURvd24odmlldywgcG9zLCBldmVudCwgZmx1c2hlZCkge1xuICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vdXNlRG93bik7XG5cbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIHRoaXMucG9zID0gcG9zO1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICB0aGlzLmZsdXNoZWQgPSBmbHVzaGVkO1xuICAgIHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMgPSBmYWxzZTtcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IG51bGw7XG4gICAgdGhpcy5zdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIHRoaXMuc2VsZWN0Tm9kZSA9ICEhZXZlbnRbc2VsZWN0Tm9kZU1vZGlmaWVyXTtcbiAgICB0aGlzLmFsbG93RGVmYXVsdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgIHZhciB0YXJnZXROb2RlLCB0YXJnZXRQb3M7XG5cbiAgICBpZiAocG9zLmluc2lkZSA+IC0xKSB7XG4gICAgICB0YXJnZXROb2RlID0gdmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcy5pbnNpZGUpO1xuICAgICAgdGFyZ2V0UG9zID0gcG9zLmluc2lkZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcy5wb3MpO1xuICAgICAgdGFyZ2V0Tm9kZSA9ICRwb3MucGFyZW50O1xuICAgICAgdGFyZ2V0UG9zID0gJHBvcy5kZXB0aCA/ICRwb3MuYmVmb3JlKCkgOiAwO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBmbHVzaGVkID8gbnVsbCA6IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgdGFyZ2V0RGVzYyA9IHRhcmdldCA/IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyh0YXJnZXQsIHRydWUpIDogbnVsbDtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldERlc2MgPyB0YXJnZXREZXNjLmRvbSA6IG51bGw7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChldmVudC5idXR0b24gPT0gMCAmJiB0YXJnZXROb2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUgJiYgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuc2VsZWN0YWJsZSAhPT0gZmFsc2UgfHwgc2VsZWN0aW9uIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5mcm9tIDw9IHRhcmdldFBvcyAmJiBzZWxlY3Rpb24udG8gPiB0YXJnZXRQb3MpIHRoaXMubWlnaHREcmFnID0ge1xuICAgICAgbm9kZTogdGFyZ2V0Tm9kZSxcbiAgICAgIHBvczogdGFyZ2V0UG9zLFxuICAgICAgYWRkQXR0cjogISEodGhpcy50YXJnZXQgJiYgIXRoaXMudGFyZ2V0LmRyYWdnYWJsZSksXG4gICAgICBzZXRVbmVkaXRhYmxlOiAhISh0aGlzLnRhcmdldCAmJiBnZWNrbyAmJiAhdGhpcy50YXJnZXQuaGFzQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpKVxuICAgIH07XG5cbiAgICBpZiAodGhpcy50YXJnZXQgJiYgdGhpcy5taWdodERyYWcgJiYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIgfHwgdGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSkpIHtcbiAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cikgdGhpcy50YXJnZXQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzOC52aWV3LmlucHV0Lm1vdXNlRG93biA9PSBfdGhpczgpIF90aGlzOC50YXJnZXQuc2V0QXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIsIFwiZmFsc2VcIik7XG4gICAgICB9LCAyMCk7XG4gICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG5cbiAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCA9IHRoaXMudXAuYmluZCh0aGlzKSk7XG4gICAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcykpO1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTW91c2VEb3duLCBbe1xuICAgIGtleTogXCJkb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCk7XG4gICAgICB0aGlzLnZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XG5cbiAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZyAmJiB0aGlzLnRhcmdldCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cikgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xuICAgICAgICBpZiAodGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSkgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMpIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uVG9ET00oX3RoaXM5LnZpZXcpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXAoZXZlbnQpIHtcbiAgICAgIHRoaXMuZG9uZSgpO1xuICAgICAgaWYgKCF0aGlzLnZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZG9jICE9IHRoaXMuc3RhcnREb2MpIHBvcyA9IHRoaXMudmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuXG4gICAgICBpZiAodGhpcy5hbGxvd0RlZmF1bHQgfHwgIXBvcykge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICB9IGVsc2UgaWYgKGhhbmRsZVNpbmdsZUNsaWNrKHRoaXMudmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQsIHRoaXMuc2VsZWN0Tm9kZSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiYgKHRoaXMuZmx1c2hlZCB8fCBzYWZhcmkgJiYgdGhpcy5taWdodERyYWcgJiYgIXRoaXMubWlnaHREcmFnLm5vZGUuaXNBdG9tIHx8IGNocm9tZSAmJiAhKHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24pICYmIE1hdGgubWluKE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pLCBNYXRoLmFicyhwb3MucG9zIC0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi50bykpIDw9IDIpKSB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbih0aGlzLnZpZXcsIHByb3NlbWlycm9yU3RhdGUuU2VsZWN0aW9uLm5lYXIodGhpcy52aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcy5wb3MpKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5hbGxvd0RlZmF1bHQgJiYgKE1hdGguYWJzKHRoaXMuZXZlbnQueCAtIGV2ZW50LmNsaWVudFgpID4gNCB8fCBNYXRoLmFicyh0aGlzLmV2ZW50LnkgLSBldmVudC5jbGllbnRZKSA+IDQpKSB0aGlzLmFsbG93RGVmYXVsdCA9IHRydWU7XG4gICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKSB0aGlzLmRvbmUoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTW91c2VEb3duO1xufSgpO1xuXG5oYW5kbGVycy50b3VjaGRvd24gPSBmdW5jdGlvbiAodmlldykge1xuICBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcblxuaGFuZGxlcnMuY29udGV4dG1lbnUgPSBmdW5jdGlvbiAodmlldykge1xuICByZXR1cm4gZm9yY2VET01GbHVzaCh2aWV3KTtcbn07XG5cbmZ1bmN0aW9uIGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHtcbiAgaWYgKHZpZXcuY29tcG9zaW5nKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoc2FmYXJpICYmIE1hdGguYWJzKGV2ZW50LnRpbWVTdGFtcCAtIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0KSA8IDUwMCkge1xuICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gLTJlODtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIHRpbWVvdXRDb21wb3NpdGlvbiA9IGFuZHJvaWQgPyA1MDAwIDogLTE7XG5cbmVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgaWYgKCF2aWV3LmNvbXBvc2luZykge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2goKTtcbiAgICB2YXIgc3RhdGUgPSB2aWV3LnN0YXRlLFxuICAgICAgICAkcG9zID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuXG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJiAoc3RhdGUuc3RvcmVkTWFya3MgfHwgISRwb3MudGV4dE9mZnNldCAmJiAkcG9zLnBhcmVudE9mZnNldCAmJiAkcG9zLm5vZGVCZWZvcmUubWFya3Muc29tZShmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2U7XG4gICAgfSkpKSB7XG4gICAgICB2aWV3Lm1hcmtDdXJzb3IgPSB2aWV3LnN0YXRlLnN0b3JlZE1hcmtzIHx8ICRwb3MubWFya3MoKTtcbiAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsIHRydWUpO1xuICAgICAgdmlldy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kQ29tcG9zaXRpb24odmlldyk7XG5cbiAgICAgIGlmIChnZWNrbyAmJiBzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgJHBvcy5wYXJlbnRPZmZzZXQgJiYgISRwb3MudGV4dE9mZnNldCAmJiAkcG9zLm5vZGVCZWZvcmUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuXG4gICAgICAgIGZvciAodmFyIG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7IG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCAhPSAwOykge1xuICAgICAgICAgIHZhciBiZWZvcmUgPSBvZmZzZXQgPCAwID8gbm9kZS5sYXN0Q2hpbGQgOiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgaWYgKCFiZWZvcmUpIGJyZWFrO1xuXG4gICAgICAgICAgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICBzZWwuY29sbGFwc2UoYmVmb3JlLCBiZWZvcmUubm9kZVZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgIG9mZnNldCA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCB0aW1lb3V0Q29tcG9zaXRpb24pO1xufTtcblxuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSBldmVudC50aW1lU3RhbXA7XG4gICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIDIwKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIGRlbGF5KSB7XG4gIGNsZWFyVGltZW91dCh2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQpO1xuICBpZiAoZGVsYXkgPiAtMSkgdmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVuZENvbXBvc2l0aW9uKHZpZXcpO1xuICB9LCBkZWxheSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyQ29tcG9zaXRpb24odmlldykge1xuICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCk7XG4gIH1cblxuICB3aGlsZSAodmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucG9wKCkubWFya1BhcmVudHNEaXJ0eSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRpbWVzdGFtcEZyb21DdXN0b21FdmVudCgpIHtcbiAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgZXZlbnQuaW5pdEV2ZW50KFwiZXZlbnRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gIHJldHVybiBldmVudC50aW1lU3RhbXA7XG59XG5cbmZ1bmN0aW9uIGVuZENvbXBvc2l0aW9uKHZpZXcpIHtcbiAgdmFyIGZvcmNlVXBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgaWYgKGFuZHJvaWQgJiYgdmlldy5kb21PYnNlcnZlci5mbHVzaGluZ1Nvb24gPj0gMCkgcmV0dXJuO1xuICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgY2xlYXJDb21wb3NpdGlvbih2aWV3KTtcblxuICBpZiAoZm9yY2VVcGRhdGUgfHwgdmlldy5kb2NWaWV3ICYmIHZpZXcuZG9jVmlldy5kaXJ0eSkge1xuICAgIHZhciBzZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcpO1xuICAgIGlmIChzZWwgJiYgIXNlbC5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKSk7ZWxzZSB2aWV3LnVwZGF0ZVN0YXRlKHZpZXcuc3RhdGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29weSh2aWV3LCBkb20pIHtcbiAgaWYgKCF2aWV3LmRvbS5wYXJlbnROb2RlKSByZXR1cm47XG4gIHZhciB3cmFwID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICB3cmFwLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICB2YXIgc2VsID0gZ2V0U2VsZWN0aW9uKCksXG4gICAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhkb20pO1xuICB2aWV3LmRvbS5ibHVyKCk7XG4gIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdyYXAucGFyZW50Tm9kZSkgd3JhcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHdyYXApO1xuICAgIHZpZXcuZm9jdXMoKTtcbiAgfSwgNTApO1xufVxuXG52YXIgYnJva2VuQ2xpcGJvYXJkQVBJID0gaWUgJiYgaWVfdmVyc2lvbiA8IDE1IHx8IGlvcyAmJiB3ZWJraXRfdmVyc2lvbiA8IDYwNDtcblxuaGFuZGxlcnMuY29weSA9IGVkaXRIYW5kbGVycy5jdXQgPSBmdW5jdGlvbiAodmlldywgX2V2ZW50KSB7XG4gIHZhciBldmVudCA9IF9ldmVudDtcbiAgdmFyIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgY3V0ID0gZXZlbnQudHlwZSA9PSBcImN1dFwiO1xuICBpZiAoc2VsLmVtcHR5KSByZXR1cm47XG4gIHZhciBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG5cbiAgdmFyIHNsaWNlID0gc2VsLmNvbnRlbnQoKSxcbiAgICAgIF9zZXJpYWxpemVGb3JDbGlwYm9hciA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSksXG4gICAgICBkb20gPSBfc2VyaWFsaXplRm9yQ2xpcGJvYXIuZG9tLFxuICAgICAgdGV4dCA9IF9zZXJpYWxpemVGb3JDbGlwYm9hci50ZXh0O1xuXG4gIGlmIChkYXRhKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkYXRhLmNsZWFyRGF0YSgpO1xuICAgIGRhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICB9IGVsc2Uge1xuICAgIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSk7XG4gIH1cblxuICBpZiAoY3V0KSB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuZGVsZXRlU2VsZWN0aW9uKCkuc2Nyb2xsSW50b1ZpZXcoKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcImN1dFwiKSk7XG59O1xuXG5mdW5jdGlvbiBzbGljZVNpbmdsZU5vZGUoc2xpY2UpIHtcbiAgcmV0dXJuIHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLm9wZW5FbmQgPT0gMCAmJiBzbGljZS5jb250ZW50LmNoaWxkQ291bnQgPT0gMSA/IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCkge1xuICBpZiAoIXZpZXcuZG9tLnBhcmVudE5vZGUpIHJldHVybjtcbiAgdmFyIHBsYWluVGV4dCA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlO1xuICB2YXIgdGFyZ2V0ID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KHBsYWluVGV4dCA/IFwidGV4dGFyZWFcIiA6IFwiZGl2XCIpKTtcbiAgaWYgKCFwbGFpblRleHQpIHRhcmdldC5jb250ZW50RWRpdGFibGUgPSBcInRydWVcIjtcbiAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICB0YXJnZXQuZm9jdXMoKTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdmlldy5mb2N1cygpO1xuICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZSkgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICBpZiAocGxhaW5UZXh0KSBkb1Bhc3RlKHZpZXcsIHRhcmdldC52YWx1ZSwgbnVsbCwgZXZlbnQpO2Vsc2UgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudGV4dENvbnRlbnQsIHRhcmdldC5pbm5lckhUTUwsIGV2ZW50KTtcbiAgfSwgNTApO1xufVxuXG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIHRleHQsIGh0bWwsIGV2ZW50KSB7XG4gIHZhciBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCB2aWV3LmlucHV0LnNoaWZ0S2V5LCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbSk7XG4gIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlUGFzdGVcIiwgZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZih2aWV3LCBldmVudCwgc2xpY2UgfHwgcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eSk7XG4gIH0pKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCFzbGljZSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2luZ2xlTm9kZSA9IHNsaWNlU2luZ2xlTm9kZShzbGljZSk7XG4gIHZhciB0ciA9IHNpbmdsZU5vZGUgPyB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNpbmdsZU5vZGUsIHZpZXcuaW5wdXQuc2hpZnRLZXkpIDogdmlldy5zdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uKHNsaWNlKTtcbiAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJwYXN0ZVwiLCB0cnVlKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcInBhc3RlXCIpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmVkaXRIYW5kbGVycy5wYXN0ZSA9IGZ1bmN0aW9uICh2aWV3LCBfZXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gX2V2ZW50O1xuICBpZiAodmlldy5jb21wb3NpbmcgJiYgIWFuZHJvaWQpIHJldHVybjtcbiAgdmFyIGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgaWYgKGRhdGEgJiYgZG9QYXN0ZSh2aWV3LCBkYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpLCBkYXRhLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIGV2ZW50KSkgZXZlbnQucHJldmVudERlZmF1bHQoKTtlbHNlIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCk7XG59O1xuXG52YXIgRHJhZ2dpbmcgPSBfY3JlYXRlQ2xhc3MoZnVuY3Rpb24gRHJhZ2dpbmcoc2xpY2UsIG1vdmUpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyYWdnaW5nKTtcblxuICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gIHRoaXMubW92ZSA9IG1vdmU7XG59KTtcblxudmFyIGRyYWdDb3B5TW9kaWZpZXIgPSBtYWMgPyBcImFsdEtleVwiIDogXCJjdHJsS2V5XCI7XG5cbmhhbmRsZXJzLmRyYWdzdGFydCA9IGZ1bmN0aW9uICh2aWV3LCBfZXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gX2V2ZW50O1xuICB2YXIgbW91c2VEb3duID0gdmlldy5pbnB1dC5tb3VzZURvd247XG4gIGlmIChtb3VzZURvd24pIG1vdXNlRG93bi5kb25lKCk7XG4gIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKSByZXR1cm47XG4gIHZhciBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyIHBvcyA9IHNlbC5lbXB0eSA/IG51bGwgOiB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gIGlmIChwb3MgJiYgcG9zLnBvcyA+PSBzZWwuZnJvbSAmJiBwb3MucG9zIDw9IChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24gPyBzZWwudG8gLSAxIDogc2VsLnRvKSkgO2Vsc2UgaWYgKG1vdXNlRG93biAmJiBtb3VzZURvd24ubWlnaHREcmFnKSB7XG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBtb3VzZURvd24ubWlnaHREcmFnLnBvcykpKTtcbiAgfSBlbHNlIGlmIChldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09IDEpIHtcbiAgICB2YXIgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhldmVudC50YXJnZXQsIHRydWUpO1xuICAgIGlmIChkZXNjICYmIGRlc2Mubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIGRlc2MgIT0gdmlldy5kb2NWaWV3KSB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIGRlc2MucG9zQmVmb3JlKSkpO1xuICB9XG5cbiAgdmFyIHNsaWNlID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uY29udGVudCgpLFxuICAgICAgX3NlcmlhbGl6ZUZvckNsaXBib2FyMiA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSksXG4gICAgICBkb20gPSBfc2VyaWFsaXplRm9yQ2xpcGJvYXIyLmRvbSxcbiAgICAgIHRleHQgPSBfc2VyaWFsaXplRm9yQ2xpcGJvYXIyLnRleHQ7XG5cbiAgZXZlbnQuZGF0YVRyYW5zZmVyLmNsZWFyRGF0YSgpO1xuICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShicm9rZW5DbGlwYm9hcmRBUEkgPyBcIlRleHRcIiA6IFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgaWYgKCFicm9rZW5DbGlwYm9hcmRBUEkpIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgdmlldy5kcmFnZ2luZyA9IG5ldyBEcmFnZ2luZyhzbGljZSwgIWV2ZW50W2RyYWdDb3B5TW9kaWZpZXJdKTtcbn07XG5cbmhhbmRsZXJzLmRyYWdlbmQgPSBmdW5jdGlvbiAodmlldykge1xuICB2YXIgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZpZXcuZHJhZ2dpbmcgPT0gZHJhZ2dpbmcpIHZpZXcuZHJhZ2dpbmcgPSBudWxsO1xuICB9LCA1MCk7XG59O1xuXG5lZGl0SGFuZGxlcnMuZHJhZ292ZXIgPSBlZGl0SGFuZGxlcnMuZHJhZ2VudGVyID0gZnVuY3Rpb24gKF8sIGUpIHtcbiAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbn07XG5cbmVkaXRIYW5kbGVycy5kcm9wID0gZnVuY3Rpb24gKHZpZXcsIF9ldmVudCkge1xuICB2YXIgZXZlbnQgPSBfZXZlbnQ7XG4gIHZhciBkcmFnZ2luZyA9IHZpZXcuZHJhZ2dpbmc7XG4gIHZpZXcuZHJhZ2dpbmcgPSBudWxsO1xuICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcikgcmV0dXJuO1xuICB2YXIgZXZlbnRQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gIGlmICghZXZlbnRQb3MpIHJldHVybjtcbiAgdmFyICRtb3VzZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZXZlbnRQb3MucG9zKTtcbiAgaWYgKCEkbW91c2UpIHJldHVybjtcbiAgdmFyIHNsaWNlID0gZHJhZ2dpbmcgJiYgZHJhZ2dpbmcuc2xpY2U7XG5cbiAgaWYgKHNsaWNlKSB7XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmdW5jdGlvbiAoZikge1xuICAgICAgc2xpY2UgPSBmKHNsaWNlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShicm9rZW5DbGlwYm9hcmRBUEkgPyBcIlRleHRcIiA6IFwidGV4dC9wbGFpblwiKSwgYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9odG1sXCIpLCBmYWxzZSwgJG1vdXNlKTtcbiAgfVxuXG4gIHZhciBtb3ZlID0gISEoZHJhZ2dpbmcgJiYgIWV2ZW50W2RyYWdDb3B5TW9kaWZpZXJdKTtcblxuICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZURyb3BcIiwgZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZih2aWV3LCBldmVudCwgc2xpY2UgfHwgcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eSwgbW92ZSk7XG4gIH0pKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXNsaWNlKSByZXR1cm47XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIHZhciBpbnNlcnRQb3MgPSBzbGljZSA/IHByb3NlbWlycm9yVHJhbnNmb3JtLmRyb3BQb2ludCh2aWV3LnN0YXRlLmRvYywgJG1vdXNlLnBvcywgc2xpY2UpIDogJG1vdXNlLnBvcztcbiAgaWYgKGluc2VydFBvcyA9PSBudWxsKSBpbnNlcnRQb3MgPSAkbW91c2UucG9zO1xuICB2YXIgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICBpZiAobW92ZSkgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gIHZhciBwb3MgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICB2YXIgaXNOb2RlID0gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxO1xuICB2YXIgYmVmb3JlSW5zZXJ0ID0gdHIuZG9jO1xuICBpZiAoaXNOb2RlKSB0ci5yZXBsYWNlUmFuZ2VXaXRoKHBvcywgcG9zLCBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpO2Vsc2UgdHIucmVwbGFjZVJhbmdlKHBvcywgcG9zLCBzbGljZSk7XG4gIGlmICh0ci5kb2MuZXEoYmVmb3JlSW5zZXJ0KSkgcmV0dXJuO1xuICB2YXIgJHBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcyk7XG5cbiAgaWYgKGlzTm9kZSAmJiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkgJiYgJHBvcy5ub2RlQWZ0ZXIgJiYgJHBvcy5ub2RlQWZ0ZXIuc2FtZU1hcmt1cChzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24oJHBvcykpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbmQgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgIHRyLm1hcHBpbmcubWFwc1t0ci5tYXBwaW5nLm1hcHMubGVuZ3RoIC0gMV0uZm9yRWFjaChmdW5jdGlvbiAoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSB7XG4gICAgICByZXR1cm4gZW5kID0gbmV3VG87XG4gICAgfSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbkJldHdlZW4odmlldywgJHBvcywgdHIuZG9jLnJlc29sdmUoZW5kKSkpO1xuICB9XG5cbiAgdmlldy5mb2N1cygpO1xuICB2aWV3LmRpc3BhdGNoKHRyLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiZHJvcFwiKSk7XG59O1xuXG5oYW5kbGVycy5mb2N1cyA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gIGlmICghdmlldy5mb2N1c2VkKSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgIHZpZXcuZm9jdXNlZCA9IHRydWU7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodmlldy5kb2NWaWV3ICYmIHZpZXcuaGFzRm9jdXMoKSAmJiAhdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmVxKHZpZXcuZG9tU2VsZWN0aW9uKCkpKSBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICB9LCAyMCk7XG4gIH1cbn07XG5cbmhhbmRsZXJzLmJsdXIgPSBmdW5jdGlvbiAodmlldywgX2V2ZW50KSB7XG4gIHZhciBldmVudCA9IF9ldmVudDtcblxuICBpZiAodmlldy5mb2N1c2VkKSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ICYmIHZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICB2aWV3LmZvY3VzZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuaGFuZGxlcnMuYmVmb3JlaW5wdXQgPSBmdW5jdGlvbiAodmlldywgX2V2ZW50KSB7XG4gIHZhciBldmVudCA9IF9ldmVudDtcblxuICBpZiAoY2hyb21lICYmIGFuZHJvaWQgJiYgZXZlbnQuaW5wdXRUeXBlID09IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgIHZhciBkb21DaGFuZ2VDb3VudCA9IHZpZXcuaW5wdXQuZG9tQ2hhbmdlQ291bnQ7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodmlldy5pbnB1dC5kb21DaGFuZ2VDb3VudCAhPSBkb21DaGFuZ2VDb3VudCkgcmV0dXJuO1xuICAgICAgdmlldy5kb20uYmx1cigpO1xuICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKTtcbiAgICAgIH0pKSByZXR1cm47XG4gICAgICB2YXIgJGN1cnNvciA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRjdXJzb3I7XG4gICAgICBpZiAoJGN1cnNvciAmJiAkY3Vyc29yLnBvcyA+IDApIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50cltcImRlbGV0ZVwiXSgkY3Vyc29yLnBvcyAtIDEsICRjdXJzb3IucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9LCA1MCk7XG4gIH1cbn07XG5cbmZvciAodmFyIHByb3AgaW4gZWRpdEhhbmRsZXJzKSB7XG4gIGhhbmRsZXJzW3Byb3BdID0gZWRpdEhhbmRsZXJzW3Byb3BdO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlT2JqcyhhLCBiKSB7XG4gIGlmIChhID09IGIpIHJldHVybiB0cnVlO1xuXG4gIGZvciAodmFyIHAgaW4gYSkge1xuICAgIGlmIChhW3BdICE9PSBiW3BdKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBfcCBpbiBiKSB7XG4gICAgaWYgKCEoX3AgaW4gYSkpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgV2lkZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV2lkZ2V0VHlwZSh0b0RPTSwgc3BlYykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXaWRnZXRUeXBlKTtcblxuICAgIHRoaXMudG9ET00gPSB0b0RPTTtcbiAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICB0aGlzLnNpZGUgPSB0aGlzLnNwZWMuc2lkZSB8fCAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFdpZGdldFR5cGUsIFt7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgIHZhciBfbWFwcGluZyRtYXBSZXN1bHQgPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIHRoaXMuc2lkZSA8IDAgPyAtMSA6IDEpLFxuICAgICAgICAgIHBvcyA9IF9tYXBwaW5nJG1hcFJlc3VsdC5wb3MsXG4gICAgICAgICAgZGVsZXRlZCA9IF9tYXBwaW5nJG1hcFJlc3VsdC5kZWxldGVkO1xuXG4gICAgICByZXR1cm4gZGVsZXRlZCA/IG51bGwgOiBuZXcgRGVjb3JhdGlvbihwb3MgLSBvZmZzZXQsIHBvcyAtIG9mZnNldCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCBvdGhlciBpbnN0YW5jZW9mIFdpZGdldFR5cGUgJiYgKHRoaXMuc3BlYy5rZXkgJiYgdGhpcy5zcGVjLmtleSA9PSBvdGhlci5zcGVjLmtleSB8fCB0aGlzLnRvRE9NID09IG90aGVyLnRvRE9NICYmIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3kobm9kZSkge1xuICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KSB0aGlzLnNwZWMuZGVzdHJveShub2RlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2lkZ2V0VHlwZTtcbn0oKTtcblxudmFyIElubGluZVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIElubGluZVR5cGUoYXR0cnMsIHNwZWMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5saW5lVHlwZSk7XG5cbiAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW5saW5lVHlwZSwgW3tcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgdmFyIGZyb20gPSBtYXBwaW5nLm1hcChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIHRoaXMuc3BlYy5pbmNsdXNpdmVTdGFydCA/IC0xIDogMSkgLSBvZmZzZXQ7XG4gICAgICB2YXIgdG8gPSBtYXBwaW5nLm1hcChzcGFuLnRvICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlRW5kID8gMSA6IC0xKSAtIG9mZnNldDtcbiAgICAgIHJldHVybiBmcm9tID49IHRvID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWQoXywgc3Bhbikge1xuICAgICAgcmV0dXJuIHNwYW4uZnJvbSA8IHNwYW4udG87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCBvdGhlciBpbnN0YW5jZW9mIElubGluZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHt9XG4gIH1dLCBbe1xuICAgIGtleTogXCJpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpcyhzcGFuKSB7XG4gICAgICByZXR1cm4gc3Bhbi50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW5saW5lVHlwZTtcbn0oKTtcblxudmFyIE5vZGVUeXBlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlVHlwZShhdHRycywgc3BlYykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlVHlwZSk7XG5cbiAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm9kZVR5cGUsIFt7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCAxKTtcbiAgICAgIGlmIChmcm9tLmRlbGV0ZWQpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHRvID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi50byArIG9sZE9mZnNldCwgLTEpO1xuICAgICAgaWYgKHRvLmRlbGV0ZWQgfHwgdG8ucG9zIDw9IGZyb20ucG9zKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLnBvcyAtIG9mZnNldCwgdG8ucG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWQobm9kZSwgc3Bhbikge1xuICAgICAgdmFyIF9ub2RlJGNvbnRlbnQkZmluZEluZCA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoc3Bhbi5mcm9tKSxcbiAgICAgICAgICBpbmRleCA9IF9ub2RlJGNvbnRlbnQkZmluZEluZC5pbmRleCxcbiAgICAgICAgICBvZmZzZXQgPSBfbm9kZSRjb250ZW50JGZpbmRJbmQub2Zmc2V0LFxuICAgICAgICAgIGNoaWxkO1xuXG4gICAgICByZXR1cm4gb2Zmc2V0ID09IHNwYW4uZnJvbSAmJiAhKGNoaWxkID0gbm9kZS5jaGlsZChpbmRleCkpLmlzVGV4dCAmJiBvZmZzZXQgKyBjaGlsZC5ub2RlU2l6ZSA9PSBzcGFuLnRvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgb3RoZXIgaW5zdGFuY2VvZiBOb2RlVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiYgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBOb2RlVHlwZTtcbn0oKTtcblxudmFyIERlY29yYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERlY29yYXRpb24oZnJvbSwgdG8sIHR5cGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVjb3JhdGlvbik7XG5cbiAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIHRoaXMudG8gPSB0bztcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERlY29yYXRpb24sIFt7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShmcm9tLCB0bykge1xuICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuZXEob3RoZXIudHlwZSkgJiYgdGhpcy5mcm9tICsgb2Zmc2V0ID09IG90aGVyLmZyb20gJiYgdGhpcy50byArIG9mZnNldCA9PSBvdGhlci50bztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5tYXAobWFwcGluZywgdGhpcywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzcGVjXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLnNwZWM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlubGluZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwid2lkZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpZGdldChwb3MsIHRvRE9NLCBzcGVjKSB7XG4gICAgICByZXR1cm4gbmV3IERlY29yYXRpb24ocG9zLCBwb3MsIG5ldyBXaWRnZXRUeXBlKHRvRE9NLCBzcGVjKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlubGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmxpbmUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIG5ldyBJbmxpbmVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IE5vZGVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERlY29yYXRpb247XG59KCk7XG5cbnZhciBub25lID0gW10sXG4gICAgbm9TcGVjID0ge307XG5cbnZhciBEZWNvcmF0aW9uU2V0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEZWNvcmF0aW9uU2V0KGxvY2FsLCBjaGlsZHJlbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZWNvcmF0aW9uU2V0KTtcblxuICAgIHRoaXMubG9jYWwgPSBsb2NhbC5sZW5ndGggPyBsb2NhbCA6IG5vbmU7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuIDogbm9uZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEZWNvcmF0aW9uU2V0LCBbe1xuICAgIGtleTogXCJmaW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmQoc3RhcnQsIGVuZCwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB0aGlzLmZpbmRJbm5lcihzdGFydCA9PSBudWxsID8gMCA6IHN0YXJ0LCBlbmQgPT0gbnVsbCA/IDFlOSA6IGVuZCwgcmVzdWx0LCAwLCBwcmVkaWNhdGUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZElubmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRJbm5lcihzdGFydCwgZW5kLCByZXN1bHQsIG9mZnNldCwgcHJlZGljYXRlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNwYW4gPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICBpZiAoc3Bhbi5mcm9tIDw9IGVuZCAmJiBzcGFuLnRvID49IHN0YXJ0ICYmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZShzcGFuLnNwZWMpKSkgcmVzdWx0LnB1c2goc3Bhbi5jb3B5KHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgX2k1ICs9IDMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5bX2k1XSA8IGVuZCAmJiB0aGlzLmNoaWxkcmVuW19pNSArIDFdID4gc3RhcnQpIHtcbiAgICAgICAgICB2YXIgY2hpbGRPZmYgPSB0aGlzLmNoaWxkcmVuW19pNV0gKyAxO1xuXG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltfaTUgKyAyXS5maW5kSW5uZXIoc3RhcnQgLSBjaGlsZE9mZiwgZW5kIC0gY2hpbGRPZmYsIHJlc3VsdCwgb2Zmc2V0ICsgY2hpbGRPZmYsIHByZWRpY2F0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBwaW5nLCBkb2MsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzID09IGVtcHR5IHx8IG1hcHBpbmcubWFwcy5sZW5ndGggPT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5tYXBJbm5lcihtYXBwaW5nLCBkb2MsIDAsIDAsIG9wdGlvbnMgfHwgbm9TcGVjKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwSW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwSW5uZXIobWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBuZXdMb2NhbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSB0aGlzLmxvY2FsW2ldLm1hcChtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCk7XG4gICAgICAgIGlmIChtYXBwZWQgJiYgbWFwcGVkLnR5cGUudmFsaWQobm9kZSwgbWFwcGVkKSkgKG5ld0xvY2FsIHx8IChuZXdMb2NhbCA9IFtdKSkucHVzaChtYXBwZWQpO2Vsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpIG9wdGlvbnMub25SZW1vdmUodGhpcy5sb2NhbFtpXS5zcGVjKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSByZXR1cm4gbWFwQ2hpbGRyZW4odGhpcy5jaGlsZHJlbiwgbmV3TG9jYWwgfHwgW10sIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKTtlbHNlIHJldHVybiBuZXdMb2NhbCA/IG5ldyBEZWNvcmF0aW9uU2V0KG5ld0xvY2FsLnNvcnQoYnlQb3MpLCBub25lKSA6IGVtcHR5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGRvYywgZGVjb3JhdGlvbnMpIHtcbiAgICAgIGlmICghZGVjb3JhdGlvbnMubGVuZ3RoKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICh0aGlzID09IGVtcHR5KSByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoZG9jLCBkZWNvcmF0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5hZGRJbm5lcihkb2MsIGRlY29yYXRpb25zLCAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkSW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5uZXIoZG9jLCBkZWNvcmF0aW9ucywgb2Zmc2V0KSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGlsZHJlbixcbiAgICAgICAgICBjaGlsZEluZGV4ID0gMDtcbiAgICAgIGRvYy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZE5vZGUsIGNoaWxkT2Zmc2V0KSB7XG4gICAgICAgIHZhciBiYXNlT2Zmc2V0ID0gY2hpbGRPZmZzZXQgKyBvZmZzZXQsXG4gICAgICAgICAgICBmb3VuZDtcbiAgICAgICAgaWYgKCEoZm91bmQgPSB0YWtlU3BhbnNGb3JOb2RlKGRlY29yYXRpb25zLCBjaGlsZE5vZGUsIGJhc2VPZmZzZXQpKSkgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoaWxkcmVuKSBjaGlsZHJlbiA9IF90aGlzMTAuY2hpbGRyZW4uc2xpY2UoKTtcblxuICAgICAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltjaGlsZEluZGV4XSA8IGNoaWxkT2Zmc2V0KSB7XG4gICAgICAgICAgY2hpbGRJbmRleCArPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuW2NoaWxkSW5kZXhdID09IGNoaWxkT2Zmc2V0KSBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0gPSBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0uYWRkSW5uZXIoY2hpbGROb2RlLCBmb3VuZCwgYmFzZU9mZnNldCArIDEpO2Vsc2UgY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDAsIGNoaWxkT2Zmc2V0LCBjaGlsZE9mZnNldCArIGNoaWxkTm9kZS5ub2RlU2l6ZSwgYnVpbGRUcmVlKGZvdW5kLCBjaGlsZE5vZGUsIGJhc2VPZmZzZXQgKyAxLCBub1NwZWMpKTtcbiAgICAgICAgY2hpbGRJbmRleCArPSAzO1xuICAgICAgfSk7XG4gICAgICB2YXIgbG9jYWwgPSBtb3ZlU3BhbnMoY2hpbGRJbmRleCA/IHdpdGhvdXROdWxscyhkZWNvcmF0aW9ucykgOiBkZWNvcmF0aW9ucywgLW9mZnNldCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFsb2NhbFtpXS50eXBlLnZhbGlkKGRvYywgbG9jYWxbaV0pKSBsb2NhbC5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLmxlbmd0aCA/IHRoaXMubG9jYWwuY29uY2F0KGxvY2FsKS5zb3J0KGJ5UG9zKSA6IHRoaXMubG9jYWwsIGNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGRlY29yYXRpb25zKSB7XG4gICAgICBpZiAoZGVjb3JhdGlvbnMubGVuZ3RoID09IDAgfHwgdGhpcyA9PSBlbXB0eSkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUlubmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUlubmVyKGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sXG4gICAgICAgICAgbG9jYWwgPSB0aGlzLmxvY2FsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGZyb20gPSBjaGlsZHJlbltpXSArIG9mZnNldCxcbiAgICAgICAgICAgIHRvID0gY2hpbGRyZW5baSArIDFdICsgb2Zmc2V0O1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBzcGFuOyBqIDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoc3BhbiA9IGRlY29yYXRpb25zW2pdKSB7XG4gICAgICAgICAgICBpZiAoc3Bhbi5mcm9tID4gZnJvbSAmJiBzcGFuLnRvIDwgdG8pIHtcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnNbal0gPSBudWxsO1xuICAgICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZm91bmQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbikgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgIHZhciByZW1vdmVkID0gY2hpbGRyZW5baSArIDJdLnJlbW92ZUlubmVyKGZvdW5kLCBmcm9tICsgMSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZWQgIT0gZW1wdHkpIHtcbiAgICAgICAgICBjaGlsZHJlbltpICsgMl0gPSByZW1vdmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAzKTtcbiAgICAgICAgICBpIC09IDM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxvY2FsLmxlbmd0aCkgZm9yICh2YXIgX2k2ID0gMCwgX3NwYW47IF9pNiA8IGRlY29yYXRpb25zLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgaWYgKF9zcGFuID0gZGVjb3JhdGlvbnNbX2k2XSkge1xuICAgICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IGxvY2FsLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgICAgICAgIGlmIChsb2NhbFtfajJdLmVxKF9zcGFuLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgIGlmIChsb2NhbCA9PSB0aGlzLmxvY2FsKSBsb2NhbCA9IHRoaXMubG9jYWwuc2xpY2UoKTtcbiAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKF9qMi0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuICYmIGxvY2FsID09IHRoaXMubG9jYWwpIHJldHVybiB0aGlzO1xuICAgICAgcmV0dXJuIGxvY2FsLmxlbmd0aCB8fCBjaGlsZHJlbi5sZW5ndGggPyBuZXcgRGVjb3JhdGlvblNldChsb2NhbCwgY2hpbGRyZW4pIDogZW1wdHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvckNoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckNoaWxkKG9mZnNldCwgbm9kZSkge1xuICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKG5vZGUuaXNMZWFmKSByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eTtcbiAgICAgIHZhciBjaGlsZCwgbG9jYWw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA+PSBvZmZzZXQpIHtcbiAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA9PSBvZmZzZXQpIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpICsgMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0ICsgMSxcbiAgICAgICAgICBlbmQgPSBzdGFydCArIG5vZGUuY29udGVudC5zaXplO1xuXG4gICAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCB0aGlzLmxvY2FsLmxlbmd0aDsgX2k3KyspIHtcbiAgICAgICAgdmFyIGRlYyA9IHRoaXMubG9jYWxbX2k3XTtcblxuICAgICAgICBpZiAoZGVjLmZyb20gPCBlbmQgJiYgZGVjLnRvID4gc3RhcnQgJiYgZGVjLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlKSB7XG4gICAgICAgICAgdmFyIGZyb20gPSBNYXRoLm1heChzdGFydCwgZGVjLmZyb20pIC0gc3RhcnQsXG4gICAgICAgICAgICAgIHRvID0gTWF0aC5taW4oZW5kLCBkZWMudG8pIC0gc3RhcnQ7XG4gICAgICAgICAgaWYgKGZyb20gPCB0bykgKGxvY2FsIHx8IChsb2NhbCA9IFtdKSkucHVzaChkZWMuY29weShmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICB2YXIgbG9jYWxTZXQgPSBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSk7XG4gICAgICAgIHJldHVybiBjaGlsZCA/IG5ldyBEZWNvcmF0aW9uR3JvdXAoW2xvY2FsU2V0LCBjaGlsZF0pIDogbG9jYWxTZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGlsZCB8fCBlbXB0eTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIGlmICh0aGlzID09IG90aGVyKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgfHwgdGhpcy5sb2NhbC5sZW5ndGggIT0gb3RoZXIubG9jYWwubGVuZ3RoIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9IG90aGVyLmNoaWxkcmVuLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2FsW2ldLmVxKG90aGVyLmxvY2FsW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgX2k4ICs9IDMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5bX2k4XSAhPSBvdGhlci5jaGlsZHJlbltfaThdIHx8IHRoaXMuY2hpbGRyZW5bX2k4ICsgMV0gIT0gb3RoZXIuY2hpbGRyZW5bX2k4ICsgMV0gfHwgIXRoaXMuY2hpbGRyZW5bX2k4ICsgMl0uZXEob3RoZXIuY2hpbGRyZW5bX2k4ICsgMl0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2NhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9jYWxzKG5vZGUpIHtcbiAgICAgIHJldHVybiByZW1vdmVPdmVybGFwKHRoaXMubG9jYWxzSW5uZXIobm9kZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2NhbHNJbm5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2NhbHNJbm5lcihub2RlKSB7XG4gICAgICBpZiAodGhpcyA9PSBlbXB0eSkgcmV0dXJuIG5vbmU7XG4gICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50IHx8ICF0aGlzLmxvY2FsLnNvbWUoSW5saW5lVHlwZS5pcykpIHJldHVybiB0aGlzLmxvY2FsO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCEodGhpcy5sb2NhbFtpXS50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZSkpIHJlc3VsdC5wdXNoKHRoaXMubG9jYWxbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgcmV0dXJuIGRlY29yYXRpb25zLmxlbmd0aCA/IGJ1aWxkVHJlZShkZWNvcmF0aW9ucywgZG9jLCAwLCBub1NwZWMpIDogZW1wdHk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERlY29yYXRpb25TZXQ7XG59KCk7XG5cbkRlY29yYXRpb25TZXQuZW1wdHkgPSBuZXcgRGVjb3JhdGlvblNldChbXSwgW10pO1xuRGVjb3JhdGlvblNldC5yZW1vdmVPdmVybGFwID0gcmVtb3ZlT3ZlcmxhcDtcbnZhciBlbXB0eSA9IERlY29yYXRpb25TZXQuZW1wdHk7XG5cbnZhciBEZWNvcmF0aW9uR3JvdXAgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERlY29yYXRpb25Hcm91cChtZW1iZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlY29yYXRpb25Hcm91cCk7XG5cbiAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERlY29yYXRpb25Hcm91cCwgW3tcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBwaW5nLCBkb2MpIHtcbiAgICAgIHZhciBtYXBwZWREZWNvcyA9IHRoaXMubWVtYmVycy5tYXAoZnVuY3Rpb24gKG1lbWJlcikge1xuICAgICAgICByZXR1cm4gbWVtYmVyLm1hcChtYXBwaW5nLCBkb2MsIG5vU3BlYyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShtYXBwZWREZWNvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvckNoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckNoaWxkKG9mZnNldCwgY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5pc0xlYWYpIHJldHVybiBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuICAgICAgdmFyIGZvdW5kID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLm1lbWJlcnNbaV0uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gZW1wdHkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKSBmb3VuZCA9IGZvdW5kLmNvbmNhdChyZXN1bHQubWVtYmVycyk7ZWxzZSBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERlY29yYXRpb25Hcm91cCkgfHwgb3RoZXIubWVtYmVycy5sZW5ndGggIT0gdGhpcy5tZW1iZXJzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMubWVtYmVyc1tpXS5lcShvdGhlci5tZW1iZXJzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9jYWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2Fscyhub2RlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHNvcnRlZCA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsb2NhbHMgPSB0aGlzLm1lbWJlcnNbaV0ubG9jYWxzSW5uZXIobm9kZSk7XG4gICAgICAgIGlmICghbG9jYWxzLmxlbmd0aCkgY29udGludWU7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSBsb2NhbHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKCk7XG4gICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxvY2Fscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobG9jYWxzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlbW92ZU92ZXJsYXAoc29ydGVkID8gcmVzdWx0IDogcmVzdWx0LnNvcnQoYnlQb3MpKSA6IG5vbmU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKG1lbWJlcnMpIHtcbiAgICAgIHN3aXRjaCAobWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBlbXB0eTtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIG1lbWJlcnNbMF07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb25Hcm91cChtZW1iZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGVjb3JhdGlvbkdyb3VwO1xufSgpO1xuXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gIHZhciBjaGlsZHJlbiA9IG9sZENoaWxkcmVuLnNsaWNlKCk7XG5cbiAgdmFyIHNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQob2xkU3RhcnQsIG9sZEVuZCwgbmV3U3RhcnQsIG5ld0VuZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIHZhciBlbmQgPSBjaGlsZHJlbltpICsgMV0sXG4gICAgICAgICAgZFNpemUgPSB2b2lkIDA7XG4gICAgICBpZiAoZW5kIDwgMCB8fCBvbGRTdGFydCA+IGVuZCArIG9sZE9mZnNldCkgY29udGludWU7XG4gICAgICB2YXIgc3RhcnQgPSBjaGlsZHJlbltpXSArIG9sZE9mZnNldDtcblxuICAgICAgaWYgKG9sZEVuZCA+PSBzdGFydCkge1xuICAgICAgICBjaGlsZHJlbltpICsgMV0gPSBvbGRTdGFydCA8PSBzdGFydCA/IC0yIDogLTE7XG4gICAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0ID49IG9mZnNldCAmJiAoZFNpemUgPSBuZXdFbmQgLSBuZXdTdGFydCAtIChvbGRFbmQgLSBvbGRTdGFydCkpKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldICs9IGRTaXplO1xuICAgICAgICBjaGlsZHJlbltpICsgMV0gKz0gZFNpemU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwcGluZy5tYXBzW2ldLmZvckVhY2goc2hpZnQpO1xuICB9XG5cbiAgdmFyIG11c3RSZWJ1aWxkID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgY2hpbGRyZW4ubGVuZ3RoOyBfaTkgKz0gMykge1xuICAgIGlmIChjaGlsZHJlbltfaTkgKyAxXSA8IDApIHtcbiAgICAgIGlmIChjaGlsZHJlbltfaTkgKyAxXSA9PSAtMikge1xuICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgIGNoaWxkcmVuW19pOSArIDFdID0gLTE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJvbSA9IG1hcHBpbmcubWFwKG9sZENoaWxkcmVuW19pOV0gKyBvbGRPZmZzZXQpLFxuICAgICAgICAgIGZyb21Mb2NhbCA9IGZyb20gLSBvZmZzZXQ7XG5cbiAgICAgIGlmIChmcm9tTG9jYWwgPCAwIHx8IGZyb21Mb2NhbCA+PSBub2RlLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG8gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltfaTkgKyAxXSArIG9sZE9mZnNldCwgLTEpLFxuICAgICAgICAgIHRvTG9jYWwgPSB0byAtIG9mZnNldDtcblxuICAgICAgdmFyIF9ub2RlJGNvbnRlbnQkZmluZEluZDIgPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KGZyb21Mb2NhbCksXG4gICAgICAgICAgaW5kZXggPSBfbm9kZSRjb250ZW50JGZpbmRJbmQyLmluZGV4LFxuICAgICAgICAgIGNoaWxkT2Zmc2V0ID0gX25vZGUkY29udGVudCRmaW5kSW5kMi5vZmZzZXQ7XG5cbiAgICAgIHZhciBjaGlsZE5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuXG4gICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkT2Zmc2V0ID09IGZyb21Mb2NhbCAmJiBjaGlsZE9mZnNldCArIGNoaWxkTm9kZS5ub2RlU2l6ZSA9PSB0b0xvY2FsKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBjaGlsZHJlbltfaTkgKyAyXS5tYXBJbm5lcihtYXBwaW5nLCBjaGlsZE5vZGUsIGZyb20gKyAxLCBvbGRDaGlsZHJlbltfaTldICsgb2xkT2Zmc2V0ICsgMSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG1hcHBlZCAhPSBlbXB0eSkge1xuICAgICAgICAgIGNoaWxkcmVuW19pOV0gPSBmcm9tTG9jYWw7XG4gICAgICAgICAgY2hpbGRyZW5bX2k5ICsgMV0gPSB0b0xvY2FsO1xuICAgICAgICAgIGNoaWxkcmVuW19pOSArIDJdID0gbWFwcGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkcmVuW19pOSArIDFdID0gLTI7XG4gICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RSZWJ1aWxkKSB7XG4gICAgdmFyIGRlY29yYXRpb25zID0gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgIHZhciBidWlsdCA9IGJ1aWxkVHJlZShkZWNvcmF0aW9ucywgbm9kZSwgMCwgb3B0aW9ucyk7XG4gICAgbmV3TG9jYWwgPSBidWlsdC5sb2NhbDtcblxuICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgY2hpbGRyZW4ubGVuZ3RoOyBfaTEwICs9IDMpIHtcbiAgICAgIGlmIChjaGlsZHJlbltfaTEwICsgMV0gPCAwKSB7XG4gICAgICAgIGNoaWxkcmVuLnNwbGljZShfaTEwLCAzKTtcbiAgICAgICAgX2kxMCAtPSAzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pMTEgPSAwLCBqID0gMDsgX2kxMSA8IGJ1aWx0LmNoaWxkcmVuLmxlbmd0aDsgX2kxMSArPSAzKSB7XG4gICAgICB2YXIgX2Zyb20yID0gYnVpbHQuY2hpbGRyZW5bX2kxMV07XG5cbiAgICAgIHdoaWxlIChqIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2pdIDwgX2Zyb20yKSB7XG4gICAgICAgIGogKz0gMztcbiAgICAgIH1cblxuICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDAsIGJ1aWx0LmNoaWxkcmVuW19pMTFdLCBidWlsdC5jaGlsZHJlbltfaTExICsgMV0sIGJ1aWx0LmNoaWxkcmVuW19pMTEgKyAyXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uU2V0KG5ld0xvY2FsLnNvcnQoYnlQb3MpLCBjaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIG1vdmVTcGFucyhzcGFucywgb2Zmc2V0KSB7XG4gIGlmICghb2Zmc2V0IHx8ICFzcGFucy5sZW5ndGgpIHJldHVybiBzcGFucztcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgIHJlc3VsdC5wdXNoKG5ldyBEZWNvcmF0aW9uKHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCwgc3Bhbi50eXBlKSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyhjaGlsZHJlbiwgb2xkQ2hpbGRyZW4sIGRlY29yYXRpb25zLCBtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICBmdW5jdGlvbiBnYXRoZXIoc2V0LCBvbGRPZmZzZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1hcHBlZCA9IHNldC5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgaWYgKG1hcHBlZCkgZGVjb3JhdGlvbnMucHVzaChtYXBwZWQpO2Vsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpIG9wdGlvbnMub25SZW1vdmUoc2V0LmxvY2FsW2ldLnNwZWMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgc2V0LmNoaWxkcmVuLmxlbmd0aDsgX2kxMiArPSAzKSB7XG4gICAgICBnYXRoZXIoc2V0LmNoaWxkcmVuW19pMTIgKyAyXSwgc2V0LmNoaWxkcmVuW19pMTJdICsgb2xkT2Zmc2V0ICsgMSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgIGlmIChjaGlsZHJlbltpICsgMV0gPT0gLTEpIGdhdGhlcihjaGlsZHJlbltpICsgMl0sIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSk7XG4gIH1cblxuICByZXR1cm4gZGVjb3JhdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHRha2VTcGFuc0Zvck5vZGUoc3BhbnMsIG5vZGUsIG9mZnNldCkge1xuICBpZiAobm9kZS5pc0xlYWYpIHJldHVybiBudWxsO1xuICB2YXIgZW5kID0gb2Zmc2V0ICsgbm9kZS5ub2RlU2l6ZSxcbiAgICAgIGZvdW5kID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gMCwgc3BhbjsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChzcGFuID0gc3BhbnNbaV0pICYmIHNwYW4uZnJvbSA+IG9mZnNldCAmJiBzcGFuLnRvIDwgZW5kKSB7XG4gICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgc3BhbnNbaV0gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gd2l0aG91dE51bGxzKGFycmF5KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycmF5W2ldICE9IG51bGwpIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShzcGFucywgbm9kZSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gIHZhciBjaGlsZHJlbiA9IFtdLFxuICAgICAgaGFzTnVsbHMgPSBmYWxzZTtcbiAgbm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZE5vZGUsIGxvY2FsU3RhcnQpIHtcbiAgICB2YXIgZm91bmQgPSB0YWtlU3BhbnNGb3JOb2RlKHNwYW5zLCBjaGlsZE5vZGUsIGxvY2FsU3RhcnQgKyBvZmZzZXQpO1xuXG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICBoYXNOdWxscyA9IHRydWU7XG4gICAgICB2YXIgc3VidHJlZSA9IGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBvZmZzZXQgKyBsb2NhbFN0YXJ0ICsgMSwgb3B0aW9ucyk7XG4gICAgICBpZiAoc3VidHJlZSAhPSBlbXB0eSkgY2hpbGRyZW4ucHVzaChsb2NhbFN0YXJ0LCBsb2NhbFN0YXJ0ICsgY2hpbGROb2RlLm5vZGVTaXplLCBzdWJ0cmVlKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgbG9jYWxzID0gbW92ZVNwYW5zKGhhc051bGxzID8gd2l0aG91dE51bGxzKHNwYW5zKSA6IHNwYW5zLCAtb2Zmc2V0KS5zb3J0KGJ5UG9zKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2Fscy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghbG9jYWxzW2ldLnR5cGUudmFsaWQobm9kZSwgbG9jYWxzW2ldKSkge1xuICAgICAgaWYgKG9wdGlvbnMub25SZW1vdmUpIG9wdGlvbnMub25SZW1vdmUobG9jYWxzW2ldLnNwZWMpO1xuICAgICAgbG9jYWxzLnNwbGljZShpLS0sIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhbHMubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FscywgY2hpbGRyZW4pIDogZW1wdHk7XG59XG5cbmZ1bmN0aW9uIGJ5UG9zKGEsIGIpIHtcbiAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnRvIC0gYi50bztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlT3ZlcmxhcChzcGFucykge1xuICB2YXIgd29ya2luZyA9IHNwYW5zO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd29ya2luZy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB2YXIgc3BhbiA9IHdvcmtpbmdbaV07XG4gICAgaWYgKHNwYW4uZnJvbSAhPSBzcGFuLnRvKSBmb3IgKHZhciBqID0gaSArIDE7IGogPCB3b3JraW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbmV4dCA9IHdvcmtpbmdbal07XG5cbiAgICAgIGlmIChuZXh0LmZyb20gPT0gc3Bhbi5mcm9tKSB7XG4gICAgICAgIGlmIChuZXh0LnRvICE9IHNwYW4udG8pIHtcbiAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucykgd29ya2luZyA9IHNwYW5zLnNsaWNlKCk7XG4gICAgICAgICAgd29ya2luZ1tqXSA9IG5leHQuY29weShuZXh0LmZyb20sIHNwYW4udG8pO1xuICAgICAgICAgIGluc2VydEFoZWFkKHdvcmtpbmcsIGogKyAxLCBuZXh0LmNvcHkoc3Bhbi50bywgbmV4dC50bykpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmV4dC5mcm9tIDwgc3Bhbi50bykge1xuICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKSB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTtcbiAgICAgICAgICB3b3JraW5nW2ldID0gc3Bhbi5jb3B5KHNwYW4uZnJvbSwgbmV4dC5mcm9tKTtcbiAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqLCBzcGFuLmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya2luZztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QWhlYWQoYXJyYXksIGksIGRlY28pIHtcbiAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGggJiYgYnlQb3MoZGVjbywgYXJyYXlbaV0pID4gMCkge1xuICAgIGkrKztcbiAgfVxuXG4gIGFycmF5LnNwbGljZShpLCAwLCBkZWNvKTtcbn1cblxuZnVuY3Rpb24gdmlld0RlY29yYXRpb25zKHZpZXcpIHtcbiAgdmFyIGZvdW5kID0gW107XG4gIHZpZXcuc29tZVByb3AoXCJkZWNvcmF0aW9uc1wiLCBmdW5jdGlvbiAoZikge1xuICAgIHZhciByZXN1bHQgPSBmKHZpZXcuc3RhdGUpO1xuICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0ICE9IGVtcHR5KSBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gIH0pO1xuICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKSBmb3VuZC5wdXNoKERlY29yYXRpb25TZXQuY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBbdmlldy5jdXJzb3JXcmFwcGVyLmRlY29dKSk7XG4gIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG59XG5cbnZhciBvYnNlcnZlT3B0aW9ucyA9IHtcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXG4gIGF0dHJpYnV0ZXM6IHRydWUsXG4gIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICBzdWJ0cmVlOiB0cnVlXG59O1xudmFyIHVzZUNoYXJEYXRhID0gaWUgJiYgaWVfdmVyc2lvbiA8PSAxMTtcblxudmFyIFNlbGVjdGlvblN0YXRlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZWxlY3Rpb25TdGF0ZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uU3RhdGUpO1xuXG4gICAgdGhpcy5hbmNob3JOb2RlID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNPZmZzZXQgPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNlbGVjdGlvblN0YXRlLCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KHNlbCkge1xuICAgICAgdGhpcy5hbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7XG4gICAgICB0aGlzLmFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gICAgICB0aGlzLmZvY3VzTm9kZSA9IHNlbC5mb2N1c05vZGU7XG4gICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEoc2VsKSB7XG4gICAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgPT0gdGhpcy5hbmNob3JOb2RlICYmIHNlbC5hbmNob3JPZmZzZXQgPT0gdGhpcy5hbmNob3JPZmZzZXQgJiYgc2VsLmZvY3VzTm9kZSA9PSB0aGlzLmZvY3VzTm9kZSAmJiBzZWwuZm9jdXNPZmZzZXQgPT0gdGhpcy5mb2N1c09mZnNldDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2VsZWN0aW9uU3RhdGU7XG59KCk7XG5cbnZhciBET01PYnNlcnZlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRE9NT2JzZXJ2ZXIodmlldywgaGFuZGxlRE9NQ2hhbmdlKSB7XG4gICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERPTU9ic2VydmVyKTtcblxuICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgdGhpcy5oYW5kbGVET01DaGFuZ2UgPSBoYW5kbGVET01DaGFuZ2U7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvblN0YXRlKCk7XG4gICAgdGhpcy5vbkNoYXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciAmJiBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX3RoaXMxMS5xdWV1ZS5wdXNoKG11dGF0aW9uc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIG11dGF0aW9ucy5zb21lKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnJlbW92ZWROb2Rlcy5sZW5ndGggfHwgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgIH0pKSBfdGhpczExLmZsdXNoU29vbigpO2Vsc2UgX3RoaXMxMS5mbHVzaCgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHVzZUNoYXJEYXRhKSB7XG4gICAgICB0aGlzLm9uQ2hhckRhdGEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpczExLnF1ZXVlLnB1c2goe1xuICAgICAgICAgIHRhcmdldDogZS50YXJnZXQsXG4gICAgICAgICAgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsXG4gICAgICAgICAgb2xkVmFsdWU6IGUucHJldlZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzMTEuZmx1c2hTb29uKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRE9NT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiBcImZsdXNoU29vblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbHVzaFNvb24oKSB7XG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA8IDApIHRoaXMuZmx1c2hpbmdTb29uID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczEyLmZsdXNoaW5nU29vbiA9IC0xO1xuXG4gICAgICAgIF90aGlzMTIuZmx1c2goKTtcbiAgICAgIH0sIDIwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yY2VGbHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JjZUZsdXNoKCkge1xuICAgICAgaWYgKHRoaXMuZmx1c2hpbmdTb29uID4gLTEpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmZsdXNoaW5nU29vbik7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBpZiAodGhpcy5vYnNlcnZlcikgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMudmlldy5kb20sIG9ic2VydmVPcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLm9uQ2hhckRhdGEpIHRoaXMudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgdGhpcy5jb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHZhciBfdGhpczEzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIHRha2UgPSB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG5cbiAgICAgICAgaWYgKHRha2UubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWtlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2godGFrZVtpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMTMuZmx1c2goKTtcbiAgICAgICAgICB9LCAyMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSkgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29ubmVjdFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0U2VsZWN0aW9uKCkge1xuICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc2Nvbm5lY3RTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdFNlbGVjdGlvbigpIHtcbiAgICAgIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCkge1xuICAgICAgdmFyIF90aGlzMTQgPSB0aGlzO1xuXG4gICAgICB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTQuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gZmFsc2U7XG4gICAgICB9LCA1MCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uU2VsZWN0aW9uQ2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU2VsZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgaWYgKCFoYXNGb2N1c0FuZFNlbGVjdGlvbih0aGlzLnZpZXcpKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMpIHJldHVybiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpO1xuXG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiAhdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICB2YXIgc2VsID0gdGhpcy52aWV3LmRvbVNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoc2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSkgcmV0dXJuIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q3VyU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1clNlbGVjdGlvbigpIHtcbiAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQodGhpcy52aWV3LmRvbVNlbGVjdGlvbigpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWdub3JlU2VsZWN0aW9uQ2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlnbm9yZVNlbGVjdGlvbkNoYW5nZShzZWwpIHtcbiAgICAgIGlmIChzZWwucmFuZ2VDb3VudCA9PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHZhciBjb250YWluZXIgPSBzZWwuZ2V0UmFuZ2VBdCgwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICAgIHZhciBkZXNjID0gdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY29udGFpbmVyKTtcblxuICAgICAgaWYgKGRlc2MgJiYgZGVzYy5pZ25vcmVNdXRhdGlvbih7XG4gICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgIHRhcmdldDogY29udGFpbmVyLm5vZGVUeXBlID09IDMgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lclxuICAgICAgfSkpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZsdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgaWYgKCF0aGlzLnZpZXcuZG9jVmlldyB8fCB0aGlzLmZsdXNoaW5nU29vbiA+IC0xKSByZXR1cm47XG4gICAgICB2YXIgbXV0YXRpb25zID0gdGhpcy5vYnNlcnZlciA/IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSA6IFtdO1xuXG4gICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgbXV0YXRpb25zID0gdGhpcy5xdWV1ZS5jb25jYXQobXV0YXRpb25zKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsID0gdGhpcy52aWV3LmRvbVNlbGVjdGlvbigpO1xuICAgICAgdmFyIG5ld1NlbCA9ICF0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyAmJiAhdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkgJiYgaGFzRm9jdXNBbmRTZWxlY3Rpb24odGhpcy52aWV3KSAmJiAhdGhpcy5pZ25vcmVTZWxlY3Rpb25DaGFuZ2Uoc2VsKTtcbiAgICAgIHZhciBmcm9tID0gLTEsXG4gICAgICAgICAgdG8gPSAtMSxcbiAgICAgICAgICB0eXBlT3ZlciA9IGZhbHNlLFxuICAgICAgICAgIGFkZGVkID0gW107XG5cbiAgICAgIGlmICh0aGlzLnZpZXcuZWRpdGFibGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWdpc3Rlck11dGF0aW9uKG11dGF0aW9uc1tpXSwgYWRkZWQpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgZnJvbSA9IGZyb20gPCAwID8gcmVzdWx0LmZyb20gOiBNYXRoLm1pbihyZXN1bHQuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICB0byA9IHRvIDwgMCA/IHJlc3VsdC50byA6IE1hdGgubWF4KHJlc3VsdC50bywgdG8pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlT3ZlcikgdHlwZU92ZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ2Vja28gJiYgYWRkZWQubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgYnJzID0gYWRkZWQuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIG4ubm9kZU5hbWUgPT0gXCJCUlwiO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYnJzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgdmFyIGEgPSBicnNbMF0sXG4gICAgICAgICAgICAgIGIgPSBicnNbMV07XG4gICAgICAgICAgaWYgKGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PSBiLnBhcmVudE5vZGUpIGIucmVtb3ZlKCk7ZWxzZSBhLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmcm9tID4gLTEgfHwgbmV3U2VsKSB7XG4gICAgICAgIGlmIChmcm9tID4gLTEpIHtcbiAgICAgICAgICB0aGlzLnZpZXcuZG9jVmlldy5tYXJrRGlydHkoZnJvbSwgdG8pO1xuICAgICAgICAgIGNoZWNrQ1NTKHRoaXMudmlldyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZShmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTtcbiAgICAgICAgaWYgKHRoaXMudmlldy5kb2NWaWV3ICYmIHRoaXMudmlldy5kb2NWaWV3LmRpcnR5KSB0aGlzLnZpZXcudXBkYXRlU3RhdGUodGhpcy52aWV3LnN0YXRlKTtlbHNlIGlmICghdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkpIHNlbGVjdGlvblRvRE9NKHRoaXMudmlldyk7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJNdXRhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlck11dGF0aW9uKG11dCwgYWRkZWQpIHtcbiAgICAgIGlmIChhZGRlZC5pbmRleE9mKG11dC50YXJnZXQpID4gLTEpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGRlc2MgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhtdXQudGFyZ2V0KTtcbiAgICAgIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIiAmJiAoZGVzYyA9PSB0aGlzLnZpZXcuZG9jVmlldyB8fCBtdXQuYXR0cmlidXRlTmFtZSA9PSBcImNvbnRlbnRlZGl0YWJsZVwiIHx8IG11dC5hdHRyaWJ1dGVOYW1lID09IFwic3R5bGVcIiAmJiAhbXV0Lm9sZFZhbHVlICYmICFtdXQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpKSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoIWRlc2MgfHwgZGVzYy5pZ25vcmVNdXRhdGlvbihtdXQpKSByZXR1cm4gbnVsbDtcblxuICAgICAgaWYgKG11dC50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXQuYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFkZGVkLnB1c2gobXV0LmFkZGVkTm9kZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MuY29udGVudERPTSAmJiBkZXNjLmNvbnRlbnRET00gIT0gZGVzYy5kb20gJiYgIWRlc2MuY29udGVudERPTS5jb250YWlucyhtdXQudGFyZ2V0KSkgcmV0dXJuIHtcbiAgICAgICAgICBmcm9tOiBkZXNjLnBvc0JlZm9yZSxcbiAgICAgICAgICB0bzogZGVzYy5wb3NBZnRlclxuICAgICAgICB9O1xuICAgICAgICB2YXIgcHJldiA9IG11dC5wcmV2aW91c1NpYmxpbmcsXG4gICAgICAgICAgICBuZXh0ID0gbXV0Lm5leHRTaWJsaW5nO1xuXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIG11dC5hZGRlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIF9pMTMgPSAwOyBfaTEzIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBfaTEzKyspIHtcbiAgICAgICAgICAgIHZhciBfbXV0JGFkZGVkTm9kZXMkX2kgPSBtdXQuYWRkZWROb2Rlc1tfaTEzXSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcgPSBfbXV0JGFkZGVkTm9kZXMkX2kucHJldmlvdXNTaWJsaW5nLFxuICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nID0gX211dCRhZGRlZE5vZGVzJF9pLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKCFwcmV2aW91c1NpYmxpbmcgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChtdXQuYWRkZWROb2RlcywgcHJldmlvdXNTaWJsaW5nKSA8IDApIHByZXYgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICBpZiAoIW5leHRTaWJsaW5nIHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0LmFkZGVkTm9kZXMsIG5leHRTaWJsaW5nKSA8IDApIG5leHQgPSBuZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnJvbU9mZnNldCA9IHByZXYgJiYgcHJldi5wYXJlbnROb2RlID09IG11dC50YXJnZXQgPyBkb21JbmRleChwcmV2KSArIDEgOiAwO1xuICAgICAgICB2YXIgZnJvbSA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIGZyb21PZmZzZXQsIC0xKTtcbiAgICAgICAgdmFyIHRvT2Zmc2V0ID0gbmV4dCAmJiBuZXh0LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldCA/IGRvbUluZGV4KG5leHQpIDogbXV0LnRhcmdldC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHRvID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgdG9PZmZzZXQsIDEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgdG86IHRvXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnJvbTogZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIsXG4gICAgICAgICAgdG86IGRlc2MucG9zQXRFbmQgKyBkZXNjLmJvcmRlclxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmcm9tOiBkZXNjLnBvc0F0U3RhcnQsXG4gICAgICAgICAgdG86IGRlc2MucG9zQXRFbmQsXG4gICAgICAgICAgdHlwZU92ZXI6IG11dC50YXJnZXQubm9kZVZhbHVlID09IG11dC5vbGRWYWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBET01PYnNlcnZlcjtcbn0oKTtcblxudmFyIGNzc0NoZWNrZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2hlY2tDU1Modmlldykge1xuICBpZiAoY3NzQ2hlY2tlZCkgcmV0dXJuO1xuICBjc3NDaGVja2VkID0gdHJ1ZTtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUodmlldy5kb20pLndoaXRlU3BhY2UgPT0gXCJub3JtYWxcIikgY29uc29sZVtcIndhcm5cIl0oXCJQcm9zZU1pcnJvciBleHBlY3RzIHRoZSBDU1Mgd2hpdGUtc3BhY2UgcHJvcGVydHkgdG8gYmUgc2V0LCBwcmVmZXJhYmx5IHRvICdwcmUtd3JhcCcuIEl0IGlzIHJlY29tbWVuZGVkIHRvIGxvYWQgc3R5bGUvcHJvc2VtaXJyb3IuY3NzIGZyb20gdGhlIHByb3NlbWlycm9yLXZpZXcgcGFja2FnZS5cIik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQmV0d2Vlbih2aWV3LCBmcm9tXywgdG9fKSB7XG4gIHZhciBfdmlldyRkb2NWaWV3JHBhcnNlUmEgPSB2aWV3LmRvY1ZpZXcucGFyc2VSYW5nZShmcm9tXywgdG9fKSxcbiAgICAgIHBhcmVudCA9IF92aWV3JGRvY1ZpZXckcGFyc2VSYS5ub2RlLFxuICAgICAgZnJvbU9mZnNldCA9IF92aWV3JGRvY1ZpZXckcGFyc2VSYS5mcm9tT2Zmc2V0LFxuICAgICAgdG9PZmZzZXQgPSBfdmlldyRkb2NWaWV3JHBhcnNlUmEudG9PZmZzZXQsXG4gICAgICBmcm9tID0gX3ZpZXckZG9jVmlldyRwYXJzZVJhLmZyb20sXG4gICAgICB0byA9IF92aWV3JGRvY1ZpZXckcGFyc2VSYS50bztcblxuICB2YXIgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgdmFyIGZpbmQ7XG4gIHZhciBhbmNob3IgPSBkb21TZWwuYW5jaG9yTm9kZTtcblxuICBpZiAoYW5jaG9yICYmIHZpZXcuZG9tLmNvbnRhaW5zKGFuY2hvci5ub2RlVHlwZSA9PSAxID8gYW5jaG9yIDogYW5jaG9yLnBhcmVudE5vZGUpKSB7XG4gICAgZmluZCA9IFt7XG4gICAgICBub2RlOiBhbmNob3IsXG4gICAgICBvZmZzZXQ6IGRvbVNlbC5hbmNob3JPZmZzZXRcbiAgICB9XTtcbiAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKSBmaW5kLnB1c2goe1xuICAgICAgbm9kZTogZG9tU2VsLmZvY3VzTm9kZSxcbiAgICAgIG9mZnNldDogZG9tU2VsLmZvY3VzT2Zmc2V0XG4gICAgfSk7XG4gIH1cblxuICBpZiAoY2hyb21lICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDgpIHtcbiAgICBmb3IgKHZhciBvZmYgPSB0b09mZnNldDsgb2ZmID4gZnJvbU9mZnNldDsgb2ZmLS0pIHtcbiAgICAgIHZhciBub2RlID0gcGFyZW50LmNoaWxkTm9kZXNbb2ZmIC0gMV0sXG4gICAgICAgICAgZGVzYyA9IG5vZGUucG1WaWV3RGVzYztcblxuICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiICYmICFkZXNjKSB7XG4gICAgICAgIHRvT2Zmc2V0ID0gb2ZmO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKCFkZXNjIHx8IGRlc2Muc2l6ZSkgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXJ0RG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gIHZhciBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IHByb3NlbWlycm9yTW9kZWwuRE9NUGFyc2VyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICB2YXIgJGZyb20gPSBzdGFydERvYy5yZXNvbHZlKGZyb20pO1xuICB2YXIgc2VsID0gbnVsbCxcbiAgICAgIGRvYyA9IHBhcnNlci5wYXJzZShwYXJlbnQsIHtcbiAgICB0b3BOb2RlOiAkZnJvbS5wYXJlbnQsXG4gICAgdG9wTWF0Y2g6ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKSxcbiAgICB0b3BPcGVuOiB0cnVlLFxuICAgIGZyb206IGZyb21PZmZzZXQsXG4gICAgdG86IHRvT2Zmc2V0LFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJGZyb20ucGFyZW50LnR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiID8gXCJmdWxsXCIgOiB0cnVlLFxuICAgIGZpbmRQb3NpdGlvbnM6IGZpbmQsXG4gICAgcnVsZUZyb21Ob2RlOiBydWxlRnJvbU5vZGUsXG4gICAgY29udGV4dDogJGZyb21cbiAgfSk7XG5cbiAgaWYgKGZpbmQgJiYgZmluZFswXS5wb3MgIT0gbnVsbCkge1xuICAgIHZhciBfYW5jaG9yID0gZmluZFswXS5wb3MsXG4gICAgICAgIGhlYWQgPSBmaW5kWzFdICYmIGZpbmRbMV0ucG9zO1xuICAgIGlmIChoZWFkID09IG51bGwpIGhlYWQgPSBfYW5jaG9yO1xuICAgIHNlbCA9IHtcbiAgICAgIGFuY2hvcjogX2FuY2hvciArIGZyb20sXG4gICAgICBoZWFkOiBoZWFkICsgZnJvbVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRvYzogZG9jLFxuICAgIHNlbDogc2VsLFxuICAgIGZyb206IGZyb20sXG4gICAgdG86IHRvXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgdmFyIGRlc2MgPSBkb20ucG1WaWV3RGVzYztcblxuICBpZiAoZGVzYykge1xuICAgIHJldHVybiBkZXNjLnBhcnNlUnVsZSgpO1xuICB9IGVsc2UgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgZG9tLnBhcmVudE5vZGUpIHtcbiAgICBpZiAoc2FmYXJpICYmIC9eKHVsfG9sKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgdmFyIHNraXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgc2tpcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIikpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2tpcDogc2tpcFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvbS5wYXJlbnROb2RlLmxhc3RDaGlsZCA9PSBkb20gfHwgc2FmYXJpICYmIC9eKHRyfHRhYmxlKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWdub3JlOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChkb20ubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiBkb20uZ2V0QXR0cmlidXRlKFwibWFyay1wbGFjZWhvbGRlclwiKSkge1xuICAgIHJldHVybiB7XG4gICAgICBpZ25vcmU6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlYWRET01DaGFuZ2UodmlldywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZE5vZGVzKSB7XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIHZhciBvcmlnaW4gPSB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwID8gdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luIDogbnVsbDtcbiAgICB2YXIgbmV3U2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4pO1xuXG4gICAgaWYgKG5ld1NlbCAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24uZXEobmV3U2VsKSkge1xuICAgICAgdmFyIF90ciA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ld1NlbCk7XG5cbiAgICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpIF90ci5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTtlbHNlIGlmIChvcmlnaW4gPT0gXCJrZXlcIikgX3RyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICB2aWV3LmRpc3BhdGNoKF90cik7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyICRiZWZvcmUgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGZyb20pO1xuICB2YXIgc2hhcmVkID0gJGJlZm9yZS5zaGFyZWREZXB0aCh0byk7XG4gIGZyb20gPSAkYmVmb3JlLmJlZm9yZShzaGFyZWQgKyAxKTtcbiAgdG8gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHRvKS5hZnRlcihzaGFyZWQgKyAxKTtcbiAgdmFyIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgcGFyc2UgPSBwYXJzZUJldHdlZW4odmlldywgZnJvbSwgdG8pO1xuXG4gIGlmIChjaHJvbWUgJiYgdmlldy5jdXJzb3JXcmFwcGVyICYmIHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yID09IHZpZXcuY3Vyc29yV3JhcHBlci5kZWNvLmZyb20pIHtcbiAgICB2YXIgdGV4dCA9IHZpZXcuY3Vyc29yV3JhcHBlci5kZWNvLnR5cGUudG9ET00ubmV4dFNpYmxpbmc7XG4gICAgdmFyIHNpemUgPSB0ZXh0ICYmIHRleHQubm9kZVZhbHVlID8gdGV4dC5ub2RlVmFsdWUubGVuZ3RoIDogMTtcbiAgICBwYXJzZS5zZWwgPSB7XG4gICAgICBhbmNob3I6IHBhcnNlLnNlbC5hbmNob3IgKyBzaXplLFxuICAgICAgaGVhZDogcGFyc2Uuc2VsLmFuY2hvciArIHNpemVcbiAgICB9O1xuICB9XG5cbiAgdmFyIGRvYyA9IHZpZXcuc3RhdGUuZG9jLFxuICAgICAgY29tcGFyZSA9IGRvYy5zbGljZShwYXJzZS5mcm9tLCBwYXJzZS50byk7XG4gIHZhciBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGU7XG5cbiAgaWYgKHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDggJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lKSB7XG4gICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgcHJlZmVycmVkU2lkZSA9IFwiZW5kXCI7XG4gIH0gZWxzZSB7XG4gICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbTtcbiAgICBwcmVmZXJyZWRTaWRlID0gXCJzdGFydFwiO1xuICB9XG5cbiAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9IG51bGw7XG4gIHZhciBjaGFuZ2UgPSBmaW5kRGlmZihjb21wYXJlLmNvbnRlbnQsIHBhcnNlLmRvYy5jb250ZW50LCBwYXJzZS5mcm9tLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpO1xuXG4gIGlmICgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSB8fCBhbmRyb2lkKSAmJiBhZGRlZE5vZGVzLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5ub2RlTmFtZSA9PSBcIkRJVlwiIHx8IG4ubm9kZU5hbWUgPT0gXCJQXCI7XG4gIH0pICYmICghY2hhbmdlIHx8IGNoYW5nZS5lbmRBID49IGNoYW5nZS5lbmRCKSAmJiB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKTtcbiAgfSkpIHtcbiAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFjaGFuZ2UpIHtcbiAgICBpZiAodHlwZU92ZXIgJiYgc2VsIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgJiYgc2VsLiRoZWFkLnNhbWVQYXJlbnQoc2VsLiRhbmNob3IpICYmICF2aWV3LmNvbXBvc2luZyAmJiAhKHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yICE9IHBhcnNlLnNlbC5oZWFkKSkge1xuICAgICAgY2hhbmdlID0ge1xuICAgICAgICBzdGFydDogc2VsLmZyb20sXG4gICAgICAgIGVuZEE6IHNlbC50byxcbiAgICAgICAgZW5kQjogc2VsLnRvXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgIHZhciBfc2VsID0gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCB2aWV3LnN0YXRlLmRvYywgcGFyc2Uuc2VsKTtcblxuICAgICAgICBpZiAoX3NlbCAmJiAhX3NlbC5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oX3NlbCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgdmlldy5pbnB1dC5kb21DaGFuZ2VDb3VudCsrO1xuXG4gIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiYgY2hhbmdlLnN0YXJ0ID09IGNoYW5nZS5lbmRCICYmIHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5UZXh0U2VsZWN0aW9uKSB7XG4gICAgaWYgKGNoYW5nZS5zdGFydCA+IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gJiYgY2hhbmdlLnN0YXJ0IDw9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gKyAyICYmIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPj0gcGFyc2UuZnJvbSkge1xuICAgICAgY2hhbmdlLnN0YXJ0ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5lbmRBIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiYgY2hhbmdlLmVuZEEgPj0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSAyICYmIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDw9IHBhcnNlLnRvKSB7XG4gICAgICBjaGFuZ2UuZW5kQiArPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIGNoYW5nZS5lbmRBO1xuICAgICAgY2hhbmdlLmVuZEEgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICB9XG4gIH1cblxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQgKyAxICYmIGNoYW5nZS5lbmRBID09IGNoYW5nZS5zdGFydCAmJiBjaGFuZ2Uuc3RhcnQgPiBwYXJzZS5mcm9tICYmIHBhcnNlLmRvYy50ZXh0QmV0d2VlbihjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tIC0gMSwgY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSArIDEpID09IFwiIFxceEEwXCIpIHtcbiAgICBjaGFuZ2Uuc3RhcnQtLTtcbiAgICBjaGFuZ2UuZW5kQS0tO1xuICAgIGNoYW5nZS5lbmRCLS07XG4gIH1cblxuICB2YXIgJGZyb20gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSk7XG4gIHZhciAkdG8gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKTtcbiAgdmFyICRmcm9tQSA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCk7XG4gIHZhciBpbmxpbmVDaGFuZ2UgPSAkZnJvbS5zYW1lUGFyZW50KCR0bykgJiYgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgJGZyb21BLmVuZCgpID49IGNoYW5nZS5lbmRBO1xuICB2YXIgbmV4dFNlbDtcblxuICBpZiAoKGlvcyAmJiB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA+IERhdGUubm93KCkgLSAyMjUgJiYgKCFpbmxpbmVDaGFuZ2UgfHwgYWRkZWROb2Rlcy5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4ubm9kZU5hbWUgPT0gXCJESVZcIiB8fCBuLm5vZGVOYW1lID09IFwiUFwiO1xuICB9KSkgfHwgIWlubGluZUNoYW5nZSAmJiAkZnJvbS5wb3MgPCBwYXJzZS5kb2MuY29udGVudC5zaXplICYmIChuZXh0U2VsID0gcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24uZmluZEZyb20ocGFyc2UuZG9jLnJlc29sdmUoJGZyb20ucG9zICsgMSksIDEsIHRydWUpKSAmJiBuZXh0U2VsLmhlYWQgPT0gJHRvLnBvcykgJiYgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSk7XG4gIH0pKSB7XG4gICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPiBjaGFuZ2Uuc3RhcnQgJiYgbG9va3NMaWtlSm9pbihkb2MsIGNoYW5nZS5zdGFydCwgY2hhbmdlLmVuZEEsICRmcm9tLCAkdG8pICYmIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYodmlldywga2V5RXZlbnQoOCwgXCJCYWNrc3BhY2VcIikpO1xuICB9KSkge1xuICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSkgdmlldy5kb21PYnNlcnZlci5zdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hyb21lICYmIGFuZHJvaWQgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0KSB2aWV3LmlucHV0Lmxhc3RBbmRyb2lkRGVsZXRlID0gRGF0ZS5ub3coKTtcblxuICBpZiAoYW5kcm9pZCAmJiAhaW5saW5lQ2hhbmdlICYmICRmcm9tLnN0YXJ0KCkgIT0gJHRvLnN0YXJ0KCkgJiYgJHRvLnBhcmVudE9mZnNldCA9PSAwICYmICRmcm9tLmRlcHRoID09ICR0by5kZXB0aCAmJiBwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciA9PSBwYXJzZS5zZWwuaGVhZCAmJiBwYXJzZS5zZWwuaGVhZCA9PSBjaGFuZ2UuZW5kQSkge1xuICAgIGNoYW5nZS5lbmRCIC09IDI7XG4gICAgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSk7XG4gICAgICB9KTtcbiAgICB9LCAyMCk7XG4gIH1cblxuICB2YXIgY2hGcm9tID0gY2hhbmdlLnN0YXJ0LFxuICAgICAgY2hUbyA9IGNoYW5nZS5lbmRBO1xuICB2YXIgdHIsIHN0b3JlZE1hcmtzLCBtYXJrQ2hhbmdlO1xuXG4gIGlmIChpbmxpbmVDaGFuZ2UpIHtcbiAgICBpZiAoJGZyb20ucG9zID09ICR0by5wb3MpIHtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmICRmcm9tLnBhcmVudE9mZnNldCA9PSAwKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgfSwgMjApO1xuICAgICAgfVxuXG4gICAgICB0ciA9IHZpZXcuc3RhdGUudHJbXCJkZWxldGVcIl0oY2hGcm9tLCBjaFRvKTtcbiAgICAgIHN0b3JlZE1hcmtzID0gZG9jLnJlc29sdmUoY2hhbmdlLnN0YXJ0KS5tYXJrc0Fjcm9zcyhkb2MucmVzb2x2ZShjaGFuZ2UuZW5kQSkpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLmVuZEEgPT0gY2hhbmdlLmVuZEIgJiYgKG1hcmtDaGFuZ2UgPSBpc01hcmtDaGFuZ2UoJGZyb20ucGFyZW50LmNvbnRlbnQuY3V0KCRmcm9tLnBhcmVudE9mZnNldCwgJHRvLnBhcmVudE9mZnNldCksICRmcm9tQS5wYXJlbnQuY29udGVudC5jdXQoJGZyb21BLnBhcmVudE9mZnNldCwgY2hhbmdlLmVuZEEgLSAkZnJvbUEuc3RhcnQoKSkpKSkge1xuICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgICAgaWYgKG1hcmtDaGFuZ2UudHlwZSA9PSBcImFkZFwiKSB0ci5hZGRNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtlbHNlIHRyLnJlbW92ZU1hcmsoY2hGcm9tLCBjaFRvLCBtYXJrQ2hhbmdlLm1hcmspO1xuICAgIH0gZWxzZSBpZiAoJGZyb20ucGFyZW50LmNoaWxkKCRmcm9tLmluZGV4KCkpLmlzVGV4dCAmJiAkZnJvbS5pbmRleCgpID09ICR0by5pbmRleCgpIC0gKCR0by50ZXh0T2Zmc2V0ID8gMCA6IDEpKSB7XG4gICAgICB2YXIgX3RleHQgPSAkZnJvbS5wYXJlbnQudGV4dEJldHdlZW4oJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KTtcblxuICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYodmlldywgY2hGcm9tLCBjaFRvLCBfdGV4dCk7XG4gICAgICB9KSkgcmV0dXJuO1xuICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLmluc2VydFRleHQoX3RleHQsIGNoRnJvbSwgY2hUbyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0cikgdHIgPSB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoY2hGcm9tLCBjaFRvLCBwYXJzZS5kb2Muc2xpY2UoY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSwgY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKSk7XG5cbiAgaWYgKHBhcnNlLnNlbCkge1xuICAgIHZhciBfc2VsMiA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdHIuZG9jLCBwYXJzZS5zZWwpO1xuXG4gICAgaWYgKF9zZWwyICYmICEoY2hyb21lICYmIGFuZHJvaWQgJiYgdmlldy5jb21wb3NpbmcgJiYgX3NlbDIuZW1wdHkgJiYgKGNoYW5nZS5zdGFydCAhPSBjaGFuZ2UuZW5kQiB8fCB2aWV3LmlucHV0Lmxhc3RBbmRyb2lkRGVsZXRlIDwgRGF0ZS5ub3coKSAtIDEwMCkgJiYgKF9zZWwyLmhlYWQgPT0gY2hGcm9tIHx8IF9zZWwyLmhlYWQgPT0gdHIubWFwcGluZy5tYXAoY2hUbykgLSAxKSB8fCBpZSAmJiBfc2VsMi5lbXB0eSAmJiBfc2VsMi5oZWFkID09IGNoRnJvbSkpIHRyLnNldFNlbGVjdGlvbihfc2VsMik7XG4gIH1cblxuICBpZiAoc3RvcmVkTWFya3MpIHRyLmVuc3VyZU1hcmtzKHN0b3JlZE1hcmtzKTtcbiAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCBkb2MsIHBhcnNlZFNlbCkge1xuICBpZiAoTWF0aC5tYXgocGFyc2VkU2VsLmFuY2hvciwgcGFyc2VkU2VsLmhlYWQpID4gZG9jLmNvbnRlbnQuc2l6ZSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5hbmNob3IpLCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuaGVhZCkpO1xufVxuXG5mdW5jdGlvbiBpc01hcmtDaGFuZ2UoY3VyLCBwcmV2KSB7XG4gIHZhciBjdXJNYXJrcyA9IGN1ci5maXJzdENoaWxkLm1hcmtzLFxuICAgICAgcHJldk1hcmtzID0gcHJldi5maXJzdENoaWxkLm1hcmtzO1xuICB2YXIgYWRkZWQgPSBjdXJNYXJrcyxcbiAgICAgIHJlbW92ZWQgPSBwcmV2TWFya3MsXG4gICAgICB0eXBlLFxuICAgICAgbWFyayxcbiAgICAgIHVwZGF0ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZNYXJrcy5sZW5ndGg7IGkrKykge1xuICAgIGFkZGVkID0gcHJldk1hcmtzW2ldLnJlbW92ZUZyb21TZXQoYWRkZWQpO1xuICB9XG5cbiAgZm9yICh2YXIgX2kxNCA9IDA7IF9pMTQgPCBjdXJNYXJrcy5sZW5ndGg7IF9pMTQrKykge1xuICAgIHJlbW92ZWQgPSBjdXJNYXJrc1tfaTE0XS5yZW1vdmVGcm9tU2V0KHJlbW92ZWQpO1xuICB9XG5cbiAgaWYgKGFkZGVkLmxlbmd0aCA9PSAxICYmIHJlbW92ZWQubGVuZ3RoID09IDApIHtcbiAgICBtYXJrID0gYWRkZWRbMF07XG4gICAgdHlwZSA9IFwiYWRkXCI7XG5cbiAgICB1cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUubWFyayhtYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGFkZGVkLmxlbmd0aCA9PSAwICYmIHJlbW92ZWQubGVuZ3RoID09IDEpIHtcbiAgICBtYXJrID0gcmVtb3ZlZFswXTtcbiAgICB0eXBlID0gXCJyZW1vdmVcIjtcblxuICAgIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5tYXJrKG1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB1cGRhdGVkID0gW107XG5cbiAgZm9yICh2YXIgX2kxNSA9IDA7IF9pMTUgPCBwcmV2LmNoaWxkQ291bnQ7IF9pMTUrKykge1xuICAgIHVwZGF0ZWQucHVzaCh1cGRhdGUocHJldi5jaGlsZChfaTE1KSkpO1xuICB9XG5cbiAgaWYgKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSh1cGRhdGVkKS5lcShjdXIpKSByZXR1cm4ge1xuICAgIG1hcms6IG1hcmssXG4gICAgdHlwZTogdHlwZVxuICB9O1xufVxuXG5mdW5jdGlvbiBsb29rc0xpa2VKb2luKG9sZCwgc3RhcnQsIGVuZCwgJG5ld1N0YXJ0LCAkbmV3RW5kKSB7XG4gIGlmICghJG5ld1N0YXJ0LnBhcmVudC5pc1RleHRibG9jayB8fCBlbmQgLSBzdGFydCA8PSAkbmV3RW5kLnBvcyAtICRuZXdTdGFydC5wb3MgfHwgc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRuZXdTdGFydCwgdHJ1ZSwgZmFsc2UpIDwgJG5ld0VuZC5wb3MpIHJldHVybiBmYWxzZTtcbiAgdmFyICRzdGFydCA9IG9sZC5yZXNvbHZlKHN0YXJ0KTtcbiAgaWYgKCRzdGFydC5wYXJlbnRPZmZzZXQgPCAkc3RhcnQucGFyZW50LmNvbnRlbnQuc2l6ZSB8fCAhJHN0YXJ0LnBhcmVudC5pc1RleHRibG9jaykgcmV0dXJuIGZhbHNlO1xuICB2YXIgJG5leHQgPSBvbGQucmVzb2x2ZShza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJHN0YXJ0LCB0cnVlLCB0cnVlKSk7XG4gIGlmICghJG5leHQucGFyZW50LmlzVGV4dGJsb2NrIHx8ICRuZXh0LnBvcyA+IGVuZCB8fCBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJG5leHQsIHRydWUsIGZhbHNlKSA8IGVuZCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gJG5ld1N0YXJ0LnBhcmVudC5jb250ZW50LmN1dCgkbmV3U3RhcnQucGFyZW50T2Zmc2V0KS5lcSgkbmV4dC5wYXJlbnQuY29udGVudCk7XG59XG5cbmZ1bmN0aW9uIHNraXBDbG9zaW5nQW5kT3BlbmluZygkcG9zLCBmcm9tRW5kLCBtYXlPcGVuKSB7XG4gIHZhciBkZXB0aCA9ICRwb3MuZGVwdGgsXG4gICAgICBlbmQgPSBmcm9tRW5kID8gJHBvcy5lbmQoKSA6ICRwb3MucG9zO1xuXG4gIHdoaWxlIChkZXB0aCA+IDAgJiYgKGZyb21FbmQgfHwgJHBvcy5pbmRleEFmdGVyKGRlcHRoKSA9PSAkcG9zLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpKSB7XG4gICAgZGVwdGgtLTtcbiAgICBlbmQrKztcbiAgICBmcm9tRW5kID0gZmFsc2U7XG4gIH1cblxuICBpZiAobWF5T3Blbikge1xuICAgIHZhciBuZXh0ID0gJHBvcy5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRwb3MuaW5kZXhBZnRlcihkZXB0aCkpO1xuXG4gICAgd2hpbGUgKG5leHQgJiYgIW5leHQuaXNMZWFmKSB7XG4gICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgZW5kKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVuZDtcbn1cblxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcG9zLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpIHtcbiAgdmFyIHN0YXJ0ID0gYS5maW5kRGlmZlN0YXJ0KGIsIHBvcyk7XG4gIGlmIChzdGFydCA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICB2YXIgX2EkZmluZERpZmZFbmQgPSBhLmZpbmREaWZmRW5kKGIsIHBvcyArIGEuc2l6ZSwgcG9zICsgYi5zaXplKSxcbiAgICAgIGVuZEEgPSBfYSRmaW5kRGlmZkVuZC5hLFxuICAgICAgZW5kQiA9IF9hJGZpbmREaWZmRW5kLmI7XG5cbiAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgIHZhciBhZGp1c3QgPSBNYXRoLm1heCgwLCBzdGFydCAtIE1hdGgubWluKGVuZEEsIGVuZEIpKTtcbiAgICBwcmVmZXJyZWRQb3MgLT0gZW5kQSArIGFkanVzdCAtIHN0YXJ0O1xuICB9XG5cbiAgaWYgKGVuZEEgPCBzdGFydCAmJiBhLnNpemUgPCBiLnNpemUpIHtcbiAgICB2YXIgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQSA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICBzdGFydCAtPSBtb3ZlO1xuICAgIGVuZEIgPSBzdGFydCArIChlbmRCIC0gZW5kQSk7XG4gICAgZW5kQSA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKGVuZEIgPCBzdGFydCkge1xuICAgIHZhciBfbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQiA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcblxuICAgIHN0YXJ0IC09IF9tb3ZlO1xuICAgIGVuZEEgPSBzdGFydCArIChlbmRBIC0gZW5kQik7XG4gICAgZW5kQiA9IHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kQTogZW5kQSxcbiAgICBlbmRCOiBlbmRCXG4gIH07XG59XG5cbnZhciBfX3NlcmlhbGl6ZUZvckNsaXBib2FyZCA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZDtcbnZhciBfX3BhcnNlRnJvbUNsaXBib2FyZCA9IHBhcnNlRnJvbUNsaXBib2FyZDtcbnZhciBfX2VuZENvbXBvc2l0aW9uID0gZW5kQ29tcG9zaXRpb247XG5cbnZhciBFZGl0b3JWaWV3ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFZGl0b3JWaWV3KHBsYWNlLCBwcm9wcykge1xuICAgIHZhciBfdGhpczE1ID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGl0b3JWaWV3KTtcblxuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMudHJhY2tXcml0ZXMgPSBudWxsO1xuICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgIHRoaXMubWFya0N1cnNvciA9IG51bGw7XG4gICAgdGhpcy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICB0aGlzLmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5wdXQgPSBuZXcgSW5wdXRTdGF0ZSgpO1xuICAgIHRoaXMucHJldkRpcmVjdFBsdWdpbnMgPSBbXTtcbiAgICB0aGlzLnBsdWdpblZpZXdzID0gW107XG4gICAgdGhpcy5kcmFnZ2luZyA9IG51bGw7XG4gICAgdGhpcy5fcHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLnN0YXRlID0gcHJvcHMuc3RhdGU7XG4gICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgICB0aGlzLmRpcmVjdFBsdWdpbnMuZm9yRWFjaChjaGVja1N0YXRlQ29tcG9uZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZG9tID0gcGxhY2UgJiYgcGxhY2UubW91bnQgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgIGlmIChwbGFjZSkge1xuICAgICAgaWYgKHBsYWNlLmFwcGVuZENoaWxkKSBwbGFjZS5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7ZWxzZSBpZiAodHlwZW9mIHBsYWNlID09IFwiZnVuY3Rpb25cIikgcGxhY2UodGhpcy5kb20pO2Vsc2UgaWYgKHBsYWNlLm1vdW50KSB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuZWRpdGFibGUgPSBnZXRFZGl0YWJsZSh0aGlzKTtcbiAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgIHRoaXMubm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgdGhpcy5kb2NWaWV3ID0gZG9jVmlld0Rlc2ModGhpcy5zdGF0ZS5kb2MsIGNvbXB1dGVEb2NEZWNvKHRoaXMpLCB2aWV3RGVjb3JhdGlvbnModGhpcyksIHRoaXMuZG9tLCB0aGlzKTtcbiAgICB0aGlzLmRvbU9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMsIGZ1bmN0aW9uIChmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKSB7XG4gICAgICByZXR1cm4gcmVhZERPTUNoYW5nZShfdGhpczE1LCBmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTtcbiAgICB9KTtcbiAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgaW5pdElucHV0KHRoaXMpO1xuICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFZGl0b3JWaWV3LCBbe1xuICAgIGtleTogXCJjb21wb3NpbmdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0LmNvbXBvc2luZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvcHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLl9wcm9wcy5zdGF0ZSAhPSB0aGlzLnN0YXRlKSB7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5fcHJvcHM7XG4gICAgICAgIHRoaXMuX3Byb3BzID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2KSB7XG4gICAgICAgICAgdGhpcy5fcHJvcHNbbmFtZV0gPSBwcmV2W25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHJvcHMuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcHJvcHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUocHJvcHMpIHtcbiAgICAgIGlmIChwcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKSBlbnN1cmVMaXN0ZW5lcnModGhpcyk7XG4gICAgICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuXG4gICAgICBpZiAocHJvcHMucGx1Z2lucykge1xuICAgICAgICBwcm9wcy5wbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuZGlyZWN0UGx1Z2lucyA9IHByb3BzLnBsdWdpbnM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihwcm9wcy5zdGF0ZSwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFByb3BzKHByb3BzKSB7XG4gICAgICB2YXIgdXBkYXRlZCA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuX3Byb3BzKSB7XG4gICAgICAgIHVwZGF0ZWRbbmFtZV0gPSB0aGlzLl9wcm9wc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlZC5zdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIGZvciAodmFyIF9uYW1lMiBpbiBwcm9wcykge1xuICAgICAgICB1cGRhdGVkW19uYW1lMl0gPSBwcm9wc1tfbmFtZTJdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZSh1cGRhdGVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU3RhdGUoc3RhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihzdGF0ZSwgdGhpcy5zdGF0ZS5wbHVnaW5zICE9IHN0YXRlLnBsdWdpbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTdGF0ZUlubmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlSW5uZXIoc3RhdGUsIHJlY29uZmlndXJlZCkge1xuICAgICAgdmFyIF90aGlzMTYgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJldiA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgcmVkcmF3ID0gZmFsc2UsXG4gICAgICAgICAgdXBkYXRlU2VsID0gZmFsc2U7XG5cbiAgICAgIGlmIChzdGF0ZS5zdG9yZWRNYXJrcyAmJiB0aGlzLmNvbXBvc2luZykge1xuICAgICAgICBjbGVhckNvbXBvc2l0aW9uKHRoaXMpO1xuICAgICAgICB1cGRhdGVTZWwgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgICAgIGlmIChyZWNvbmZpZ3VyZWQpIHtcbiAgICAgICAgdmFyIG5vZGVWaWV3cyA9IGJ1aWxkTm9kZVZpZXdzKHRoaXMpO1xuXG4gICAgICAgIGlmIChjaGFuZ2VkTm9kZVZpZXdzKG5vZGVWaWV3cywgdGhpcy5ub2RlVmlld3MpKSB7XG4gICAgICAgICAgdGhpcy5ub2RlVmlld3MgPSBub2RlVmlld3M7XG4gICAgICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuc3VyZUxpc3RlbmVycyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgdXBkYXRlQ3Vyc29yV3JhcHBlcih0aGlzKTtcbiAgICAgIHZhciBpbm5lckRlY28gPSB2aWV3RGVjb3JhdGlvbnModGhpcyksXG4gICAgICAgICAgb3V0ZXJEZWNvID0gY29tcHV0ZURvY0RlY28odGhpcyk7XG4gICAgICB2YXIgc2Nyb2xsID0gcmVjb25maWd1cmVkID8gXCJyZXNldFwiIDogc3RhdGUuc2Nyb2xsVG9TZWxlY3Rpb24gPiBwcmV2LnNjcm9sbFRvU2VsZWN0aW9uID8gXCJ0byBzZWxlY3Rpb25cIiA6IFwicHJlc2VydmVcIjtcbiAgICAgIHZhciB1cGRhdGVEb2MgPSByZWRyYXcgfHwgIXRoaXMuZG9jVmlldy5tYXRjaGVzTm9kZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgIGlmICh1cGRhdGVEb2MgfHwgIXN0YXRlLnNlbGVjdGlvbi5lcShwcmV2LnNlbGVjdGlvbikpIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICB2YXIgb2xkU2Nyb2xsUG9zID0gc2Nyb2xsID09IFwicHJlc2VydmVcIiAmJiB1cGRhdGVTZWwgJiYgdGhpcy5kb20uc3R5bGUub3ZlcmZsb3dBbmNob3IgPT0gbnVsbCAmJiBzdG9yZVNjcm9sbFBvcyh0aGlzKTtcblxuICAgICAgaWYgKHVwZGF0ZVNlbCkge1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgdmFyIGZvcmNlU2VsVXBkYXRlID0gdXBkYXRlRG9jICYmIChpZSB8fCBjaHJvbWUpICYmICF0aGlzLmNvbXBvc2luZyAmJiAhcHJldi5zZWxlY3Rpb24uZW1wdHkgJiYgIXN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJiBzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZChwcmV2LnNlbGVjdGlvbiwgc3RhdGUuc2VsZWN0aW9uKTtcblxuICAgICAgICBpZiAodXBkYXRlRG9jKSB7XG4gICAgICAgICAgdmFyIGNocm9tZUtsdWRnZSA9IGNocm9tZSA/IHRoaXMudHJhY2tXcml0ZXMgPSB0aGlzLmRvbVNlbGVjdGlvbigpLmZvY3VzTm9kZSA6IG51bGw7XG5cbiAgICAgICAgICBpZiAocmVkcmF3IHx8ICF0aGlzLmRvY1ZpZXcudXBkYXRlKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlT3V0ZXJEZWNvKFtdKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyhzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzLmRvbSwgdGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNocm9tZUtsdWRnZSAmJiAhdGhpcy50cmFja1dyaXRlcykgZm9yY2VTZWxVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlU2VsVXBkYXRlIHx8ICEodGhpcy5pbnB1dC5tb3VzZURvd24gJiYgdGhpcy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmVxKHRoaXMuZG9tU2VsZWN0aW9uKCkpICYmIGFuY2hvckluUmlnaHRQbGFjZSh0aGlzKSkpIHtcbiAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh0aGlzLCBmb3JjZVNlbFVwZGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3luY05vZGVTZWxlY3Rpb24odGhpcywgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVBsdWdpblZpZXdzKHByZXYpO1xuXG4gICAgICBpZiAoc2Nyb2xsID09IFwicmVzZXRcIikge1xuICAgICAgICB0aGlzLmRvbS5zY3JvbGxUb3AgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGwgPT0gXCJ0byBzZWxlY3Rpb25cIikge1xuICAgICAgICB2YXIgc3RhcnRET00gPSB0aGlzLmRvbVNlbGVjdGlvbigpLmZvY3VzTm9kZTtcbiAgICAgICAgaWYgKHRoaXMuc29tZVByb3AoXCJoYW5kbGVTY3JvbGxUb1NlbGVjdGlvblwiLCBmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBmKF90aGlzMTYpO1xuICAgICAgICB9KSkgO2Vsc2UgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmRvY1ZpZXcuZG9tQWZ0ZXJQb3Moc3RhdGUuc2VsZWN0aW9uLmZyb20pO1xuICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMSkgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRET00pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0aGlzLmNvb3Jkc0F0UG9zKHN0YXRlLnNlbGVjdGlvbi5oZWFkLCAxKSwgc3RhcnRET00pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9sZFNjcm9sbFBvcykge1xuICAgICAgICByZXNldFNjcm9sbFBvcyhvbGRTY3JvbGxQb3MpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95UGx1Z2luVmlld3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveVBsdWdpblZpZXdzKCkge1xuICAgICAgdmFyIHZpZXc7XG5cbiAgICAgIHdoaWxlICh2aWV3ID0gdGhpcy5wbHVnaW5WaWV3cy5wb3AoKSkge1xuICAgICAgICBpZiAodmlldy5kZXN0cm95KSB2aWV3LmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlUGx1Z2luVmlld3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUGx1Z2luVmlld3MocHJldlN0YXRlKSB7XG4gICAgICBpZiAoIXByZXZTdGF0ZSB8fCBwcmV2U3RhdGUucGx1Z2lucyAhPSB0aGlzLnN0YXRlLnBsdWdpbnMgfHwgdGhpcy5kaXJlY3RQbHVnaW5zICE9IHRoaXMucHJldkRpcmVjdFBsdWdpbnMpIHtcbiAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IHRoaXMuZGlyZWN0UGx1Z2lucztcbiAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV07XG4gICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnZpZXcpIHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pMTYgPSAwOyBfaTE2IDwgdGhpcy5zdGF0ZS5wbHVnaW5zLmxlbmd0aDsgX2kxNisrKSB7XG4gICAgICAgICAgdmFyIF9wbHVnaW4gPSB0aGlzLnN0YXRlLnBsdWdpbnNbX2kxNl07XG4gICAgICAgICAgaWYgKF9wbHVnaW4uc3BlYy52aWV3KSB0aGlzLnBsdWdpblZpZXdzLnB1c2goX3BsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBfaTE3ID0gMDsgX2kxNyA8IHRoaXMucGx1Z2luVmlld3MubGVuZ3RoOyBfaTE3KyspIHtcbiAgICAgICAgICB2YXIgcGx1Z2luVmlldyA9IHRoaXMucGx1Z2luVmlld3NbX2kxN107XG4gICAgICAgICAgaWYgKHBsdWdpblZpZXcudXBkYXRlKSBwbHVnaW5WaWV3LnVwZGF0ZSh0aGlzLCBwcmV2U3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNvbWVQcm9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbWVQcm9wKHByb3BOYW1lLCBmKSB7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuX3Byb3BzICYmIHRoaXMuX3Byb3BzW3Byb3BOYW1lXSxcbiAgICAgICAgICB2YWx1ZTtcbiAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX3Byb3AgPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAoX3Byb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihfcHJvcCkgOiBfcHJvcCkpIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBsdWdpbnMgPSB0aGlzLnN0YXRlLnBsdWdpbnM7XG4gICAgICBpZiAocGx1Z2lucykgZm9yICh2YXIgX2kxOCA9IDA7IF9pMTggPCBwbHVnaW5zLmxlbmd0aDsgX2kxOCsrKSB7XG4gICAgICAgIHZhciBfcHJvcDIgPSBwbHVnaW5zW19pMThdLnByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgaWYgKF9wcm9wMiAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKF9wcm9wMikgOiBfcHJvcDIpKSByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0ZvY3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0ZvY3VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgaWYgKHRoaXMuZWRpdGFibGUpIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmRvbSk7XG4gICAgICBzZWxlY3Rpb25Ub0RPTSh0aGlzKTtcbiAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm9vdFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzMTcgPSB0aGlzO1xuXG4gICAgICB2YXIgY2FjaGVkID0gdGhpcy5fcm9vdDtcblxuICAgICAgaWYgKGNhY2hlZCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBfbG9vcDQgPSBmdW5jdGlvbiBfbG9vcDQoc2VhcmNoKSB7XG4gICAgICAgICAgaWYgKHNlYXJjaC5ub2RlVHlwZSA9PSA5IHx8IHNlYXJjaC5ub2RlVHlwZSA9PSAxMSAmJiBzZWFyY2guaG9zdCkge1xuICAgICAgICAgICAgaWYgKCFzZWFyY2guZ2V0U2VsZWN0aW9uKSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VhcmNoKS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWFyY2gub3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2OiBfdGhpczE3Ll9yb290ID0gc2VhcmNoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBzZWFyY2ggPSB0aGlzLmRvbS5wYXJlbnROb2RlOyBzZWFyY2g7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdmFyIF9yZXQzID0gX2xvb3A0KHNlYXJjaCk7XG5cbiAgICAgICAgICBpZiAoX3R5cGVvZihfcmV0MykgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0My52O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZWQgfHwgZG9jdW1lbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc0F0Q29vcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc0F0Q29vcmRzKGNvb3Jkcykge1xuICAgICAgcmV0dXJuIF9wb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb29yZHNBdFBvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb29yZHNBdFBvcyhwb3MpIHtcbiAgICAgIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgcmV0dXJuIF9jb29yZHNBdFBvcyh0aGlzLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb21BdFBvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb21BdFBvcyhwb3MpIHtcbiAgICAgIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vZGVET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZURPTShwb3MpIHtcbiAgICAgIHZhciBkZXNjID0gdGhpcy5kb2NWaWV3LmRlc2NBdChwb3MpO1xuICAgICAgcmV0dXJuIGRlc2MgPyBkZXNjLm5vZGVET00gOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3NBdERPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NBdERPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgIHZhciBiaWFzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAtMTtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgaWYgKHBvcyA9PSBudWxsKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRPTSBwb3NpdGlvbiBub3QgaW5zaWRlIHRoZSBlZGl0b3JcIik7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRPZlRleHRibG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRPZlRleHRibG9jayhkaXIsIHN0YXRlKSB7XG4gICAgICByZXR1cm4gX2VuZE9mVGV4dGJsb2NrKHRoaXMsIHN0YXRlIHx8IHRoaXMuc3RhdGUsIGRpcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICghdGhpcy5kb2NWaWV3KSByZXR1cm47XG4gICAgICBkZXN0cm95SW5wdXQodGhpcyk7XG4gICAgICB0aGlzLmRlc3Ryb3lQbHVnaW5WaWV3cygpO1xuXG4gICAgICBpZiAodGhpcy5tb3VudGVkKSB7XG4gICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGUodGhpcy5zdGF0ZS5kb2MsIFtdLCB2aWV3RGVjb3JhdGlvbnModGhpcyksIHRoaXMpO1xuICAgICAgICB0aGlzLmRvbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5kb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRvY1ZpZXcgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0Rlc3Ryb3llZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldyA9PSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwYXRjaEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgIHJldHVybiBfZGlzcGF0Y2hFdmVudCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3BhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoKHRyKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hUcmFuc2FjdGlvbiA9IHRoaXMuX3Byb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb247XG4gICAgICBpZiAoZGlzcGF0Y2hUcmFuc2FjdGlvbikgZGlzcGF0Y2hUcmFuc2FjdGlvbi5jYWxsKHRoaXMsIHRyKTtlbHNlIHRoaXMudXBkYXRlU3RhdGUodGhpcy5zdGF0ZS5hcHBseSh0cikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb21TZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9tU2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRWRpdG9yVmlldztcbn0oKTtcblxuZnVuY3Rpb24gY29tcHV0ZURvY0RlY28odmlldykge1xuICB2YXIgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBhdHRyc1tcImNsYXNzXCJdID0gXCJQcm9zZU1pcnJvclwiO1xuICBhdHRycy5jb250ZW50ZWRpdGFibGUgPSBTdHJpbmcodmlldy5lZGl0YWJsZSk7XG4gIGF0dHJzLnRyYW5zbGF0ZSA9IFwibm9cIjtcbiAgdmlldy5zb21lUHJvcChcImF0dHJpYnV0ZXNcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHZhbHVlID0gdmFsdWUodmlldy5zdGF0ZSk7XG4gICAgaWYgKHZhbHVlKSBmb3IgKHZhciBhdHRyIGluIHZhbHVlKSB7XG4gICAgICBpZiAoYXR0ciA9PSBcImNsYXNzXCIpIGF0dHJzW1wiY2xhc3NcIl0gKz0gXCIgXCIgKyB2YWx1ZVthdHRyXTtcblxuICAgICAgaWYgKGF0dHIgPT0gXCJzdHlsZVwiKSB7XG4gICAgICAgIGF0dHJzLnN0eWxlID0gKGF0dHJzLnN0eWxlID8gYXR0cnMuc3R5bGUgKyBcIjtcIiA6IFwiXCIpICsgdmFsdWVbYXR0cl07XG4gICAgICB9IGVsc2UgaWYgKCFhdHRyc1thdHRyXSAmJiBhdHRyICE9IFwiY29udGVudGVkaXRhYmxlXCIgJiYgYXR0ciAhPSBcIm5vZGVOYW1lXCIpIGF0dHJzW2F0dHJdID0gU3RyaW5nKHZhbHVlW2F0dHJdKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gW0RlY29yYXRpb24ubm9kZSgwLCB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsIGF0dHJzKV07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUN1cnNvcldyYXBwZXIodmlldykge1xuICBpZiAodmlldy5tYXJrQ3Vyc29yKSB7XG4gICAgdmFyIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3Itc2VwYXJhdG9yXCI7XG4gICAgZG9tLnNldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIiwgXCJ0cnVlXCIpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJhbHRcIiwgXCJcIik7XG4gICAgdmlldy5jdXJzb3JXcmFwcGVyID0ge1xuICAgICAgZG9tOiBkb20sXG4gICAgICBkZWNvOiBEZWNvcmF0aW9uLndpZGdldCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5oZWFkLCBkb20sIHtcbiAgICAgICAgcmF3OiB0cnVlLFxuICAgICAgICBtYXJrczogdmlldy5tYXJrQ3Vyc29yXG4gICAgICB9KVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmlldy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFZGl0YWJsZSh2aWV3KSB7XG4gIHJldHVybiAhdmlldy5zb21lUHJvcChcImVkaXRhYmxlXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSh2aWV3LnN0YXRlKSA9PT0gZmFsc2U7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZChzZWwxLCBzZWwyKSB7XG4gIHZhciBkZXB0aCA9IE1hdGgubWluKHNlbDEuJGFuY2hvci5zaGFyZWREZXB0aChzZWwxLmhlYWQpLCBzZWwyLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMi5oZWFkKSk7XG4gIHJldHVybiBzZWwxLiRhbmNob3Iuc3RhcnQoZGVwdGgpICE9IHNlbDIuJGFuY2hvci5zdGFydChkZXB0aCk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTm9kZVZpZXdzKHZpZXcpIHtcbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZnVuY3Rpb24gYWRkKG9iaikge1xuICAgIGZvciAodmFyIF9wcm9wMyBpbiBvYmopIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgX3Byb3AzKSkgcmVzdWx0W19wcm9wM10gPSBvYmpbX3Byb3AzXTtcbiAgICB9XG4gIH1cblxuICB2aWV3LnNvbWVQcm9wKFwibm9kZVZpZXdzXCIsIGFkZCk7XG4gIHZpZXcuc29tZVByb3AoXCJtYXJrVmlld3NcIiwgYWRkKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2hhbmdlZE5vZGVWaWV3cyhhLCBiKSB7XG4gIHZhciBuQSA9IDAsXG4gICAgICBuQiA9IDA7XG5cbiAgZm9yICh2YXIgX3Byb3A0IGluIGEpIHtcbiAgICBpZiAoYVtfcHJvcDRdICE9IGJbX3Byb3A0XSkgcmV0dXJuIHRydWU7XG4gICAgbkErKztcbiAgfVxuXG4gIGZvciAodmFyIF8gaW4gYikge1xuICAgIG5CKys7XG4gIH1cblxuICByZXR1cm4gbkEgIT0gbkI7XG59XG5cbmZ1bmN0aW9uIGNoZWNrU3RhdGVDb21wb25lbnQocGx1Z2luKSB7XG4gIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSB8fCBwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiB8fCBwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQbHVnaW5zIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgdmlldyBtdXN0IG5vdCBoYXZlIGEgc3RhdGUgY29tcG9uZW50XCIpO1xufVxuXG5leHBvcnRzLkRlY29yYXRpb24gPSBEZWNvcmF0aW9uO1xuZXhwb3J0cy5EZWNvcmF0aW9uU2V0ID0gRGVjb3JhdGlvblNldDtcbmV4cG9ydHMuRWRpdG9yVmlldyA9IEVkaXRvclZpZXc7XG5leHBvcnRzLl9fZW5kQ29tcG9zaXRpb24gPSBfX2VuZENvbXBvc2l0aW9uO1xuZXhwb3J0cy5fX3BhcnNlRnJvbUNsaXBib2FyZCA9IF9fcGFyc2VGcm9tQ2xpcGJvYXJkO1xuZXhwb3J0cy5fX3NlcmlhbGl6ZUZvckNsaXBib2FyZCA9IF9fc2VyaWFsaXplRm9yQ2xpcGJvYXJkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYmFzZSA9IHtcbiAgODogXCJCYWNrc3BhY2VcIixcbiAgOTogXCJUYWJcIixcbiAgMTA6IFwiRW50ZXJcIixcbiAgMTI6IFwiTnVtTG9ja1wiLFxuICAxMzogXCJFbnRlclwiLFxuICAxNjogXCJTaGlmdFwiLFxuICAxNzogXCJDb250cm9sXCIsXG4gIDE4OiBcIkFsdFwiLFxuICAyMDogXCJDYXBzTG9ja1wiLFxuICAyNzogXCJFc2NhcGVcIixcbiAgMzI6IFwiIFwiLFxuICAzMzogXCJQYWdlVXBcIixcbiAgMzQ6IFwiUGFnZURvd25cIixcbiAgMzU6IFwiRW5kXCIsXG4gIDM2OiBcIkhvbWVcIixcbiAgMzc6IFwiQXJyb3dMZWZ0XCIsXG4gIDM4OiBcIkFycm93VXBcIixcbiAgMzk6IFwiQXJyb3dSaWdodFwiLFxuICA0MDogXCJBcnJvd0Rvd25cIixcbiAgNDQ6IFwiUHJpbnRTY3JlZW5cIixcbiAgNDU6IFwiSW5zZXJ0XCIsXG4gIDQ2OiBcIkRlbGV0ZVwiLFxuICA1OTogXCI7XCIsXG4gIDYxOiBcIj1cIixcbiAgOTE6IFwiTWV0YVwiLFxuICA5MjogXCJNZXRhXCIsXG4gIDEwNjogXCIqXCIsXG4gIDEwNzogXCIrXCIsXG4gIDEwODogXCIsXCIsXG4gIDEwOTogXCItXCIsXG4gIDExMDogXCIuXCIsXG4gIDExMTogXCIvXCIsXG4gIDE0NDogXCJOdW1Mb2NrXCIsXG4gIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gIDE2MDogXCJTaGlmdFwiLFxuICAxNjE6IFwiU2hpZnRcIixcbiAgMTYyOiBcIkNvbnRyb2xcIixcbiAgMTYzOiBcIkNvbnRyb2xcIixcbiAgMTY0OiBcIkFsdFwiLFxuICAxNjU6IFwiQWx0XCIsXG4gIDE3MzogXCItXCIsXG4gIDE4NjogXCI7XCIsXG4gIDE4NzogXCI9XCIsXG4gIDE4ODogXCIsXCIsXG4gIDE4OTogXCItXCIsXG4gIDE5MDogXCIuXCIsXG4gIDE5MTogXCIvXCIsXG4gIDE5MjogXCJgXCIsXG4gIDIxOTogXCJbXCIsXG4gIDIyMDogXCJcXFxcXCIsXG4gIDIyMTogXCJdXCIsXG4gIDIyMjogXCInXCIsXG4gIDIyOTogXCJxXCJcbn07XG5cbnZhciBzaGlmdCA9IHtcbiAgNDg6IFwiKVwiLFxuICA0OTogXCIhXCIsXG4gIDUwOiBcIkBcIixcbiAgNTE6IFwiI1wiLFxuICA1MjogXCIkXCIsXG4gIDUzOiBcIiVcIixcbiAgNTQ6IFwiXlwiLFxuICA1NTogXCImXCIsXG4gIDU2OiBcIipcIixcbiAgNTc6IFwiKFwiLFxuICA1OTogXCI6XCIsXG4gIDYxOiBcIitcIixcbiAgMTczOiBcIl9cIixcbiAgMTg2OiBcIjpcIixcbiAgMTg3OiBcIitcIixcbiAgMTg4OiBcIjxcIixcbiAgMTg5OiBcIl9cIixcbiAgMTkwOiBcIj5cIixcbiAgMTkxOiBcIj9cIixcbiAgMTkyOiBcIn5cIixcbiAgMjE5OiBcIntcIixcbiAgMjIwOiBcInxcIixcbiAgMjIxOiBcIn1cIixcbiAgMjIyOiBcIlxcXCJcIixcbiAgMjI5OiBcIlFcIlxufTtcblxudmFyIGNocm9tZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIHNhZmFyaSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XG52YXIgZ2Vja28gPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0dlY2tvXFwvXFxkKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xudmFyIGllID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NU0lFIFxcZHxUcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBicm9rZW5Nb2RpZmllck5hbWVzID0gY2hyb21lICYmIChtYWMgfHwgK2Nocm9tZVsxXSA8IDU3KSB8fCBnZWNrbyAmJiBtYWM7XG5cbi8vIEZpbGwgaW4gdGhlIGRpZ2l0IGtleXNcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykgYmFzZVs0OCArIGldID0gYmFzZVs5NiArIGldID0gU3RyaW5nKGkpO1xuXG4vLyBUaGUgZnVuY3Rpb24ga2V5c1xuZm9yICh2YXIgaSA9IDE7IGkgPD0gMjQ7IGkrKykgYmFzZVtpICsgMTExXSA9IFwiRlwiICsgaTtcblxuLy8gQW5kIHRoZSBhbHBoYWJldGljIGtleXNcbmZvciAodmFyIGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7XG4gIGJhc2VbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAzMik7XG4gIHNoaWZ0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbn1cblxuLy8gRm9yIGVhY2ggY29kZSB0aGF0IGRvZXNuJ3QgaGF2ZSBhIHNoaWZ0LWVxdWl2YWxlbnQsIGNvcHkgdGhlIGJhc2UgbmFtZVxuZm9yICh2YXIgY29kZSBpbiBiYXNlKSBpZiAoIXNoaWZ0Lmhhc093blByb3BlcnR5KGNvZGUpKSBzaGlmdFtjb2RlXSA9IGJhc2VbY29kZV07XG5cbmZ1bmN0aW9uIGtleU5hbWUoZXZlbnQpIHtcbiAgLy8gRG9uJ3QgdHJ1c3QgZXZlbnQua2V5IGluIENocm9tZSB3aGVuIHRoZXJlIGFyZSBtb2RpZmllcnMgdW50aWxcbiAgLy8gdGhleSBmaXggaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjMzODM4XG4gIHZhciBpZ25vcmVLZXkgPSBicm9rZW5Nb2RpZmllck5hbWVzICYmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5KSB8fFxuICAgIChzYWZhcmkgfHwgaWUpICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSAmJiBldmVudC5rZXkubGVuZ3RoID09IDE7XG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIjtcbiAgLy8gRWRnZSBzb21ldGltZXMgcHJvZHVjZXMgd3JvbmcgbmFtZXMgKElzc3VlICMzKVxuICBpZiAobmFtZSA9PSBcIkVzY1wiKSBuYW1lID0gXCJFc2NhcGVcIjtcbiAgaWYgKG5hbWUgPT0gXCJEZWxcIikgbmFtZSA9IFwiRGVsZXRlXCI7XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIjtcbiAgaWYgKG5hbWUgPT0gXCJVcFwiKSBuYW1lID0gXCJBcnJvd1VwXCI7XG4gIGlmIChuYW1lID09IFwiUmlnaHRcIikgbmFtZSA9IFwiQXJyb3dSaWdodFwiO1xuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCI7XG4gIHJldHVybiBuYW1lXG59XG5cbmV4cG9ydHMuYmFzZSA9IGJhc2U7XG5leHBvcnRzLmtleU5hbWUgPSBrZXlOYW1lO1xuZXhwb3J0cy5zaGlmdCA9IHNoaWZ0O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubmMgPSB1bmRlZmluZWQ7IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9kZW1vL2luZGV4LnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9